(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/a/snake/index.js":[function(require,module,exports){
/*jslint node:true*/
/*global window*/
var domready = require('domready'),
    ex = require('./lib/excalibur'),
    Snake = require('./lib/snake'),
    mobile = require('./lib/mobile');

domready(function () {
    'use strict';
    var game = new ex.Engine(),
        snake = new Snake({
            ex: ex,
            game: game,
            color: {
                head: ex.Color.Red,
                body: ex.Color.Yellow,
                food: ex.Color.Green
            }
        }),
        replay = function () {
            game.rootScene.children.forEach(function (actor) {
                actor.kill();
            });
            document.title = '';
            setTimeout(function () {
                snake = new Snake({
                    ex: ex,
                    game: game,
                    color: {
                        head: ex.Color.Red,
                        body: ex.Color.Yellow,
                        food: ex.Color.Green
                    }
                });
                snake.onLose = replay;
                snake.run({x: 1});
            }, 500);
        },
        paused = false;
    game.input.keyboard.on('down', function (k) {
        k = k.key;
        if (k === 37) {
            snake.left();
        } else if (k === 38) {
            snake.up();
        } else if (k === 39) {
            snake.right();
        } else if (k === 40) {
            snake.down();
        } else if (k === 32) {
            if (paused) {
                game.start();
                paused = false;
            } else {
                game.stop();
                paused = true;
            }
        }
    });
    document.addEventListener('click', function () {
        replay();
    });
    mobile(snake);
    game.start();
    snake.onLose = replay;
    snake.run({x: 1});
});

},{"./lib/excalibur":"/home/a/snake/lib/excalibur.js","./lib/mobile":"/home/a/snake/lib/mobile.js","./lib/snake":"/home/a/snake/lib/snake.js","domready":"/home/a/snake/node_modules/domready/ready.js"}],"/home/a/snake/lib/excalibur.js":[function(require,module,exports){
/*! excalibur - v0.2.5 - 2015-02-04
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2015 ; Licensed BSD*/
if (typeof window == 'undefined') {
    window = { audioContext: function () {
    } };
}
if (typeof window != 'undefined' && !window.requestAnimationFrame) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
        window.setInterval(callback, 1000 / 60);
    };
}
if (typeof window != 'undefined' && !window.AudioContext) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError(' this is null or not defined');
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg */) {
        'use strict';
        if (this === void 0 || this === null)
            throw new TypeError();
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function')
            throw new TypeError();
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t))
                return true;
        }
        return false;
    };
}
// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {
        }, fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
var ex;
(function (ex) {
    var Effects;
    (function (Effects) {
        /**
         * Applies the "Grayscale" effect to a sprite, removing color information.
         * @class Effects.Grayscale
         * @constructor
         * @extends ISpriteEffect
         */
        var Grayscale = (function () {
            function Grayscale() {
            }
            Grayscale.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
                pixel[firstPixel + 0] = avg;
                pixel[firstPixel + 1] = avg;
                pixel[firstPixel + 2] = avg;
            };
            return Grayscale;
        })();
        Effects.Grayscale = Grayscale;
        /**
         * Applies the "Invert" effect to a sprite, inverting the pixel colors.
         * @class Effects.Invert
         * @constructor
         * @extends ISpriteEffect
         */
        var Invert = (function () {
            function Invert() {
            }
            Invert.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
                pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
                pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
            };
            return Invert;
        })();
        Effects.Invert = Invert;
        /**
         * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
         * @class Effects.Opacity
         * @extends ISpriteEffect
         * @constructor
         * @param opacity {number} The new opacity of the sprite from 0-1.0
         */
        var Opacity = (function () {
            function Opacity(opacity) {
                this.opacity = opacity;
            }
            Opacity.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 3] = Math.round(this.opacity * 255);
                }
            };
            return Opacity;
        })();
        Effects.Opacity = Opacity;
        /**
         * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
         * average of the original color and the provided color
         * @class Effects.Colorize
         * @extends ISpriteEffect
         * @constructor
         * @param color {Color} The color to apply to the sprite
         */
        var Colorize = (function () {
            function Colorize(color) {
                this.color = color;
            }
            Colorize.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
                    pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
                    pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
                }
            };
            return Colorize;
        })();
        Effects.Colorize = Colorize;
        /**
         * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
         * a given color
         * @class Effects.Fill
         * @extends ISpriteEffect
         * @constructor
         * @param color {Color} The color to apply to the sprite
         */
        var Fill = (function () {
            function Fill(color) {
                this.color = color;
            }
            Fill.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 0] = this.color.r;
                    pixel[firstPixel + 1] = this.color.g;
                    pixel[firstPixel + 2] = this.color.b;
                }
            };
            return Fill;
        })();
        Effects.Fill = Fill;
    })(Effects = ex.Effects || (ex.Effects = {}));
})(ex || (ex = {}));
/// <reference path="../SpriteEffects.ts" />
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var MovementModule = (function () {
        function MovementModule() {
        }
        MovementModule.prototype.update = function (actor, engine, delta) {
            // Update placements based on linear algebra
            actor.x += actor.dx * delta / 1000;
            actor.y += actor.dy * delta / 1000;
            actor.dx += actor.ax * delta / 1000;
            actor.dy += actor.ay * delta / 1000;
            actor.rotation += actor.rx * delta / 1000;
            actor.scale.x += actor.sx * delta / 1000;
            actor.scale.y += actor.sy * delta / 1000;
        };
        return MovementModule;
    })();
    ex.MovementModule = MovementModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var OffscreenCullingModule = (function () {
        function OffscreenCullingModule() {
        }
        OffscreenCullingModule.prototype.update = function (actor, engine, delta) {
            var eventDispatcher = actor.eventDispatcher;
            var anchor = actor.anchor;
            var globalScale = actor.getGlobalScale();
            var width = globalScale.x * actor.getWidth() / actor.scale.x;
            var height = globalScale.y * actor.getHeight() / actor.scale.y;
            var actorScreenCoords = engine.worldToScreenCoordinates(new ex.Point(actor.getGlobalX() - anchor.x * width, actor.getGlobalY() - anchor.y * height));
            var zoom = 1.0;
            if (actor.scene && actor.scene.camera) {
                zoom = actor.scene.camera.getZoom();
            }
            if (!actor.isOffScreen) {
                if (actorScreenCoords.x + width * zoom < 0 || actorScreenCoords.y + height * zoom < 0 || actorScreenCoords.x > engine.width || actorScreenCoords.y > engine.height) {
                    eventDispatcher.publish('exitviewport', new ex.ExitViewPortEvent());
                    actor.isOffScreen = true;
                }
            }
            else {
                if (actorScreenCoords.x + width * zoom > 0 && actorScreenCoords.y + height * zoom > 0 && actorScreenCoords.x < engine.width && actorScreenCoords.y < engine.height) {
                    eventDispatcher.publish('enterviewport', new ex.EnterViewPortEvent());
                    actor.isOffScreen = false;
                }
            }
        };
        return OffscreenCullingModule;
    })();
    ex.OffscreenCullingModule = OffscreenCullingModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    /**
     * Propogates pointer events to the actor
     */
    var CapturePointerModule = (function () {
        function CapturePointerModule() {
        }
        CapturePointerModule.prototype.update = function (actor, engine, delta) {
            if (!actor.enableCapturePointer)
                return;
            if (actor.isKilled())
                return;
            engine.input.pointers.propogate(actor);
        };
        return CapturePointerModule;
    })();
    ex.CapturePointerModule = CapturePointerModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var CollisionDetectionModule = (function () {
        function CollisionDetectionModule() {
        }
        CollisionDetectionModule.prototype.update = function (actor, engine, delta) {
            var eventDispatcher = actor.eventDispatcher;
            if (actor.collisionType !== 0 /* PreventCollision */) {
                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {
                    var map = engine.currentScene.tileMaps[j];
                    var intersectMap;
                    var side = 0 /* None */;
                    var max = 2;
                    var hasBounced = false;
                    while (intersectMap = map.collides(actor)) {
                        if (max-- < 0) {
                            break;
                        }
                        side = actor.getSideFromIntersect(intersectMap);
                        eventDispatcher.publish('collision', new ex.CollisionEvent(actor, null, side, intersectMap));
                        if ((actor.collisionType === 2 /* Active */ || actor.collisionType === 3 /* Elastic */)) {
                            actor.y += intersectMap.y;
                            actor.x += intersectMap.x;
                            // Naive elastic bounce
                            if (actor.collisionType === 3 /* Elastic */ && !hasBounced) {
                                hasBounced = true;
                                if (side === 3 /* Left */) {
                                    actor.dx = Math.abs(actor.dx);
                                }
                                else if (side === 4 /* Right */) {
                                    actor.dx = -Math.abs(actor.dx);
                                }
                                else if (side === 1 /* Top */) {
                                    actor.dy = Math.abs(actor.dy);
                                }
                                else if (side === 2 /* Bottom */) {
                                    actor.dy = -Math.abs(actor.dy);
                                }
                            }
                        }
                    }
                }
            }
        };
        return CollisionDetectionModule;
    })();
    ex.CollisionDetectionModule = CollisionDetectionModule;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * An enum that describes the sides of an Actor for collision
     * @class Side
     */
    (function (Side) {
        /**
        @property None {Side}
        @static
        @final
        */
        Side[Side["None"] = 0] = "None";
        /**
        @property Top {Side}
        @static
        @final
        */
        Side[Side["Top"] = 1] = "Top";
        /**
        @property Bottom {Side}
        @static
        @final
        */
        Side[Side["Bottom"] = 2] = "Bottom";
        /**
        @property Left {Side}
        @static
        @final
        */
        Side[Side["Left"] = 3] = "Left";
        /**
        @property Right {Side}
        @static
        @final
        */
        Side[Side["Right"] = 4] = "Right";
    })(ex.Side || (ex.Side = {}));
    var Side = ex.Side;
})(ex || (ex = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ex;
(function (ex) {
    /**
     * A simple 2D point on a plane
     * @class Point
     * @constructor
     * @param x {number} X coordinate of the point
     * @param y {number} Y coordinate of the point
     *
     */
    var Point = (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * X Coordinate of the point
         * @property x {number}
         */
        /**
         * Y Coordinate of the point
         * @property y {number}
         */
        /**
         * Convert this point to a vector
         * @method toVector
         * @returns Vector
         */
        Point.prototype.toVector = function () {
            return new Vector(this.x, this.y);
        };
        /**
         * Rotates the current point around another by a certain number of
         * degrees in radians
         * @method rotate
         * @returns Point
         */
        Point.prototype.rotate = function (angle, anchor) {
            if (!anchor) {
                anchor = new ex.Point(0, 0);
            }
            var sinAngle = Math.sin(angle);
            var cosAngle = Math.cos(angle);
            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
            return new Point(x, y);
        };
        /**
         * Translates the current point by a vector
         * @method add
         * @returns Point
         */
        Point.prototype.add = function (vector) {
            return new Point(this.x + vector.x, this.y + vector.y);
        };
        /**
         * Sets the x and y components at once
         * @method setTo
         * @param x {number}
         * @param y {number}
         */
        Point.prototype.setTo = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Clones a new point that is a copy of this one.
         * @method clone
         * @returns Point
         */
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };
        return Point;
    })();
    ex.Point = Point;
    /**
     * A 2D vector on a plane.
     * @class Vector
     * @extends Point
     * @constructor
     * @param x {number} X component of the Vector
     * @param y {number} Y component of the Vector
     */
    var Vector = (function (_super) {
        __extends(Vector, _super);
        function Vector(x, y) {
            _super.call(this, x, y);
            this.x = x;
            this.y = y;
        }
        /**
         * Returns a vector of unit length in the direction of the specified angle.
         * @method fromAngle
         * @static
         * @param angle {number} The angle to generate the vector
         * @returns Vector
         */
        Vector.fromAngle = function (angle) {
            return new Vector(Math.cos(angle), Math.sin(angle));
        };
        /**
         * The distance to another vector
         * @method distance
         * @param v {Vector} The other vector
         * @returns number
         */
        Vector.prototype.distance = function (v) {
            if (!v) {
                v = new Vector(0.0, 0.0);
            }
            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
        };
        /**
         * Normalizes a vector to have a magnitude of 1.
         * @method normalize
         * @return Vector
         */
        Vector.prototype.normalize = function () {
            var d = this.distance();
            if (d > 0) {
                return new Vector(this.x / d, this.y / d);
            }
            else {
                return new Vector(0, 1);
            }
        };
        /**
         * Scales a vector's by a factor of size
         * @method scale
         * @param size {number} The factor to scale the magnitude by
         * @returns Vector
         */
        Vector.prototype.scale = function (size) {
            return new Vector(this.x * size, this.y * size);
        };
        /**
         * Adds one vector to another
         * @method add
         * @param v {Vector} The vector to add
         * @returns Vector
         */
        Vector.prototype.add = function (v) {
            return new Vector(this.x + v.x, this.y + v.y);
        };
        /**
         * Subtracts a vector from the current vector
         * @method minus
         * @param v {Vector} The vector to subtract
         * @returns Vector
         */
        Vector.prototype.minus = function (v) {
            return new Vector(this.x - v.x, this.y - v.y);
        };
        /**
         * Performs a dot product with another vector
         * @method dot
         * @param v {Vector} The vector to dot
         * @returns number
         */
        Vector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        /**
         * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.
         * @method cross
         * @param v {Vector} The vector to cross
         * @returns number
         */
        Vector.prototype.cross = function (v) {
            return this.x * v.y - this.y * v.x;
        };
        /**
         * Returns the perpendicular vector to this one
         * @method perpendicular
         * @return Vector
         */
        Vector.prototype.perpendicular = function () {
            return new Vector(this.y, -this.x);
        };
        /**
         * Returns the normal vector to this one
         * @method normal
         * @return Vector
         */
        Vector.prototype.normal = function () {
            return this.perpendicular().normalize();
        };
        /**
         * Returns the angle of this vector.
         * @method toAngle
         * @returns number
         */
        Vector.prototype.toAngle = function () {
            return Math.atan2(this.y, this.x);
        };
        /**
         * Returns the point represention of this vector
         * @method toPoint
         * @returns Point
         */
        Vector.prototype.toPoint = function () {
            return new Point(this.x, this.y);
        };
        /**
         * Rotates the current vector around a point by a certain number of
         * degrees in radians
         * @method rotate
         * @returns Vector
         */
        Vector.prototype.rotate = function (angle, anchor) {
            return _super.prototype.rotate.call(this, angle, anchor).toVector();
        };
        return Vector;
    })(Point);
    ex.Vector = Vector;
    /**
     * A 2D ray that can be cast into the scene to do collision detection
     * @class Ray
     * @constructor
     * @param pos {Point} The starting position for the ray
     * @param dir {Vector} The vector indicating the direction of the ray
     */
    var Ray = (function () {
        function Ray(pos, dir) {
            this.pos = pos;
            this.dir = dir.normalize();
        }
        /**
         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
         * This number indicates the mathematical intersection time.
         * @method intersect
         * @param line {Line} The line to test
         * @returns number
         */
        Ray.prototype.intersect = function (line) {
            var numerator = line.begin.toVector().minus(this.pos.toVector());
            // Test is line and ray are parallel and non intersecting
            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
                return -1;
            }
            // Lines are parallel
            var divisor = (this.dir.cross(line.getSlope()));
            if (divisor === 0) {
                return -1;
            }
            var t = numerator.cross(line.getSlope()) / divisor;
            if (t >= 0) {
                var u = (numerator.cross(this.dir) / divisor) / line.getLength();
                if (u >= 0 && u <= 1) {
                    return t;
                }
            }
            return -1;
        };
        /**
         * Returns the point of intersection given the intersection time
         * @method getPoint
         * @returns Point
         */
        Ray.prototype.getPoint = function (time) {
            return this.pos.toVector().add(this.dir.scale(time)).toPoint();
        };
        return Ray;
    })();
    ex.Ray = Ray;
    /**
     * A 2D line segment
     * @class Line
     * @constructor
     * @param begin {Point} The starting point of the line segment
     * @param end {Point} The ending point of the line segment
     */
    var Line = (function () {
        function Line(begin, end) {
            this.begin = begin;
            this.end = end;
        }
        /**
         * Returns the slope of the line in the form of a vector
         * @method getSlope
         * @returns Vector
         */
        Line.prototype.getSlope = function () {
            var begin = this.begin.toVector();
            var end = this.end.toVector();
            var distance = begin.distance(end);
            return end.minus(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         * @method getLength
         * @returns number
         */
        Line.prototype.getLength = function () {
            var begin = this.begin.toVector();
            var end = this.end.toVector();
            var distance = begin.distance(end);
            return distance;
        };
        return Line;
    })();
    ex.Line = Line;
    var Projection = (function () {
        function Projection(min, max) {
            this.min = min;
            this.max = max;
        }
        Projection.prototype.overlaps = function (projection) {
            return this.max > projection.min && projection.max > this.min;
        };
        Projection.prototype.getOverlap = function (projection) {
            if (this.overlaps(projection)) {
                if (this.max > projection.max) {
                    return projection.max - this.min;
                }
                else {
                    return this.max - projection.min;
                }
            }
            return 0;
        };
        return Projection;
    })();
    ex.Projection = Projection;
})(ex || (ex = {}));
/// <reference path="Algebra.ts"/>
/// <reference path="Events.ts"/>
var ex;
(function (ex) {
    var Util;
    (function (Util) {
        Util.TwoPI = Math.PI * 2;
        function base64Encode(inputStr) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var outputStr = "";
            var i = 0;
            while (i < inputStr.length) {
                //all three "& 0xff" added below are there to fix a known bug 
                //with bytes returned by xhr.responseText
                var byte1 = inputStr.charCodeAt(i++) & 0xff;
                var byte2 = inputStr.charCodeAt(i++) & 0xff;
                var byte3 = inputStr.charCodeAt(i++) & 0xff;
                var enc1 = byte1 >> 2;
                var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
                var enc3, enc4;
                if (isNaN(byte2)) {
                    enc3 = enc4 = 64;
                }
                else {
                    enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
                    if (isNaN(byte3)) {
                        enc4 = 64;
                    }
                    else {
                        enc4 = byte3 & 63;
                    }
                }
                outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
            }
            return outputStr;
        }
        Util.base64Encode = base64Encode;
        function clamp(val, min, max) {
            return val <= min ? min : (val >= max ? max : val);
        }
        Util.clamp = clamp;
        function drawLine(ctx, color, startx, starty, endx, endy) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.moveTo(startx, starty);
            ctx.lineTo(endx, endy);
            ctx.closePath();
            ctx.stroke();
        }
        Util.drawLine = drawLine;
        function randomInRange(min, max) {
            return min + Math.random() * (max - min);
        }
        Util.randomInRange = randomInRange;
        function randomIntInRange(min, max) {
            return Math.round(randomInRange(min, max));
        }
        Util.randomIntInRange = randomIntInRange;
        function canonicalizeAngle(angle) {
            var tmpAngle = angle;
            if (angle > this.TwoPI) {
                while (tmpAngle > this.TwoPI) {
                    tmpAngle -= this.TwoPI;
                }
            }
            if (angle < 0) {
                while (tmpAngle < 0) {
                    tmpAngle += this.TwoPI;
                }
            }
            return tmpAngle;
        }
        Util.canonicalizeAngle = canonicalizeAngle;
        function toDegrees(radians) {
            return 180 / Math.PI * radians;
        }
        Util.toDegrees = toDegrees;
        function toRadians(degrees) {
            return degrees / 180 * Math.PI;
        }
        Util.toRadians = toRadians;
        function getPosition(el) {
            var oLeft = 0, oTop = 0;
            var calcOffsetLeft = function (parent) {
                oLeft += parent.offsetLeft;
                if (parent.offsetParent) {
                    calcOffsetLeft(parent.offsetParent);
                }
            };
            var calcOffsetTop = function (parent) {
                oTop += parent.offsetTop;
                if (parent.offsetParent) {
                    calcOffsetTop(parent.offsetParent);
                }
            };
            calcOffsetLeft(el);
            calcOffsetTop(el);
            return new ex.Point(oLeft, oTop);
        }
        Util.getPosition = getPosition;
        function getOppositeSide(side) {
            if (side === 1 /* Top */)
                return 2 /* Bottom */;
            if (side === 2 /* Bottom */)
                return 1 /* Top */;
            if (side === 3 /* Left */)
                return 4 /* Right */;
            if (side === 4 /* Right */)
                return 3 /* Left */;
            return 0 /* None */;
        }
        Util.getOppositeSide = getOppositeSide;
        /**
         * Excaliburs dynamically resizing collection
         * @class Collection
         * @constructor
         * @param [initialSize=200] {number} Initial size of the internal backing array
         */
        var Collection = (function () {
            function Collection(initialSize) {
                this.internalArray = null;
                this.endPointer = 0;
                var size = initialSize || Collection.DefaultSize;
                this.internalArray = new Array(size);
            }
            Collection.prototype.resize = function () {
                var newSize = this.internalArray.length * 2;
                var newArray = new Array(newSize);
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    newArray[i] = this.internalArray[i];
                }
                delete this.internalArray;
                this.internalArray = newArray;
            };
            /**
             * Push elements to the end of the collection
             * @method push
             * @param element {T}
             * @returns T
             */
            Collection.prototype.push = function (element) {
                if (this.endPointer === this.internalArray.length) {
                    this.resize();
                }
                return this.internalArray[this.endPointer++] = element;
            };
            /**
             * Removes elements from the end of the collection
             * @method pop
             * @returns T
             */
            Collection.prototype.pop = function () {
                this.endPointer = this.endPointer - 1 < 0 ? 0 : this.endPointer - 1;
                return this.internalArray[this.endPointer];
            };
            /**
             * Returns the count of the collection
             * @method count
             * @returns number
             */
            Collection.prototype.count = function () {
                return this.endPointer;
            };
            /**
             * Empties the collection
             * @method clear
             */
            Collection.prototype.clear = function () {
                this.endPointer = 0;
            };
            /**
             * Returns the size of the internal backing array
             * @method internalSize
             * @returns number
             */
            Collection.prototype.internalSize = function () {
                return this.internalArray.length;
            };
            /**
             * Returns an element at a specific index
             * @method elementAt
             * @param index {number} Index of element to retreive
             * @returns T
             */
            Collection.prototype.elementAt = function (index) {
                if (index >= this.count()) {
                    return;
                }
                return this.internalArray[index];
            };
            /**
             * Inserts an element at a specific index
             * @method insert
             * @param index {number} Index to insert the element
             * @returns T
             */
            Collection.prototype.insert = function (index, value) {
                if (index >= this.count()) {
                    this.resize();
                }
                return this.internalArray[index] = value;
            };
            /**
             * Removes an element at a specific index
             * @method remove
             * @param index {number} Index of element to remove
             * @returns T
             */
            Collection.prototype.remove = function (index) {
                var count = this.count();
                if (count === 0)
                    return;
                // O(n) Shift 
                var removed = this.internalArray[index];
                for (var i = index; i < count; i++) {
                    this.internalArray[i] = this.internalArray[i + 1];
                }
                this.endPointer--;
                return removed;
            };
            /**
             * Removes an element by reference
             * @method removeElement
             * @param element {T} Index of element to retreive
             */
            Collection.prototype.removeElement = function (element) {
                var index = this.internalArray.indexOf(element);
                this.remove(index);
            };
            /**
             * Returns a array representing the collection
             * @method toArray
             * @returns T[]
             */
            Collection.prototype.toArray = function () {
                return this.internalArray.slice(0, this.endPointer);
            };
            /**
             * Iterate over every element in the collection
             * @method forEach
             * @param func {(T,number)=>any} Callback to call for each element passing a reference to the element and its index, returned values are ignored
             */
            Collection.prototype.forEach = function (func) {
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    func.call(this, this.internalArray[i], i);
                }
            };
            /**
             * Mutate every element in the collection
             * @method map
             * @param func {(T,number)=>any} Callback to call for each element passing a reference to the element and its index, any values returned mutate the collection
             */
            Collection.prototype.map = function (func) {
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    this.internalArray[i] = func.call(this, this.internalArray[i], i);
                }
            };
            /**
             * Default collection size
             * @property DefaultSize {number}
             * @static
             * @final
             */
            Collection.DefaultSize = 200;
            return Collection;
        })();
        Util.Collection = Collection;
    })(Util = ex.Util || (ex.Util = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * A Sprite is one of the main drawing primitives. It is responsible for drawing
     * images or parts of images known as Textures to the screen.
     * @class Sprite
     * @constructor
     * @param image {Texture} The backing image texture to build the Sprite
     * @param sx {number} The x position of the sprite
     * @param sy {number} The y position of the sprite
     * @param swidth {number} The width of the sprite in pixels
     * @param sheight {number} The height of the sprite in pixels
     */
    var Sprite = (function () {
        function Sprite(image, sx, sy, swidth, sheight) {
            var _this = this;
            this.sx = sx;
            this.sy = sy;
            this.swidth = swidth;
            this.sheight = sheight;
            this.scaleX = 1.0;
            this.scaleY = 1.0;
            this.rotation = 0.0;
            this.transformPoint = new ex.Point(0, 0);
            this.logger = ex.Logger.getInstance();
            this.flipVertical = false;
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.effects = [];
            this.internalImage = new Image();
            this.spriteCanvas = null;
            this.spriteCtx = null;
            this.pixelData = null;
            this.pixelsLoaded = false;
            this.dirtyEffect = false;
            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {
                this.logger.error("Sprite cannot have any negative dimensions x:", sx, "y:", sy, "width:", swidth, "height:", sheight);
            }
            this.texture = image;
            this.spriteCanvas = document.createElement('canvas');
            this.spriteCanvas.width = swidth;
            this.spriteCanvas.height = sheight;
            this.spriteCtx = this.spriteCanvas.getContext('2d');
            this.texture.loaded.then(function () {
                _this.spriteCanvas.width = _this.spriteCanvas.width || _this.texture.image.naturalWidth;
                _this.spriteCanvas.height = _this.spriteCanvas.height || _this.texture.image.naturalHeight;
                _this.loadPixels();
                _this.dirtyEffect = true;
            }).error(function (e) {
                _this.logger.error("Error loading texture ", _this.texture.path, e);
            });
            this.width = swidth;
            this.height = sheight;
        }
        Sprite.prototype.loadPixels = function () {
            if (this.texture.isLoaded() && !this.pixelsLoaded) {
                var clamp = ex.Util.clamp;
                var naturalWidth = this.texture.image.naturalWidth || 0;
                var naturalHeight = this.texture.image.naturalHeight || 0;
                if (this.swidth > naturalWidth) {
                    this.logger.warn("The sprite width", this.swidth, "exceeds the width", naturalWidth, "of the backing texture", this.texture.path);
                }
                if (this.sheight > naturalHeight) {
                    this.logger.warn("The sprite height", this.sheight, "exceeds the height", naturalHeight, "of the backing texture", this.texture.path);
                }
                this.spriteCtx.drawImage(this.texture.image, clamp(this.sx, 0, naturalWidth), clamp(this.sy, 0, naturalHeight), clamp(this.swidth, 0, naturalWidth), clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
                //this.pixelData = this.spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
                this.internalImage.src = this.spriteCanvas.toDataURL("image/png");
                this.pixelsLoaded = true;
            }
        };
        /**
         * Adds a new {{#crossLink Effects.ISpriteEffect}}{{/crossLink}} to this drawing.
         * @method addEffect
         * @param effect {Effects.ISpriteEffect} Effect to add to the this drawing
         */
        Sprite.prototype.addEffect = function (effect) {
            this.effects.push(effect);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this.texture.isLoaded() || !this.pixelsLoaded) {
                this.dirtyEffect = true;
            }
            else {
                this.applyEffects();
            }
        };
        Sprite.prototype.removeEffect = function (param) {
            var indexToRemove = null;
            if (typeof param === 'number') {
                indexToRemove = param;
            }
            else {
                indexToRemove = this.effects.indexOf(param);
            }
            this.effects.splice(indexToRemove, 1);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this.texture.isLoaded() || !this.pixelsLoaded) {
                this.dirtyEffect = true;
            }
            else {
                this.applyEffects();
            }
        };
        Sprite.prototype.applyEffects = function () {
            var _this = this;
            var clamp = ex.Util.clamp;
            var naturalWidth = this.texture.image.naturalWidth || 0;
            var naturalHeight = this.texture.image.naturalHeight || 0;
            this.spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this.spriteCtx.drawImage(this.texture.image, clamp(this.sx, 0, naturalWidth), clamp(this.sy, 0, naturalHeight), clamp(this.swidth, 0, naturalWidth), clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
            this.pixelData = this.spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
            this.effects.forEach(function (effect) {
                for (var y = 0; y < _this.sheight; y++) {
                    for (var x = 0; x < _this.swidth; x++) {
                        effect.updatePixel(x, y, _this.pixelData);
                    }
                }
            });
            this.spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this.spriteCtx.putImageData(this.pixelData, 0, 0);
            this.internalImage.src = this.spriteCanvas.toDataURL("image/png");
        };
        /**
         * Clears all effects from the drawing and return it to its original state.
         * @method clearEffects
         */
        Sprite.prototype.clearEffects = function () {
            this.effects.length = 0;
            this.applyEffects();
        };
        /**
         * Sets the point about which to apply transformations to the drawing relative to the
         * top left corner of the drawing.
         * @method transformAbotPoint
         * @param point {Point} The point about which to apply transformations
         */
        Sprite.prototype.transformAboutPoint = function (point) {
            this.transformPoint = point;
        };
        /**
         * Sets the current rotation transformation for the drawing.
         * @method setRotation
         * @param radians {number} The rotation to apply to the drawing.
         */
        Sprite.prototype.setRotation = function (radians) {
            this.rotation = radians;
        };
        /**
         * Returns the current rotation for the drawing in radians.
         * @method getRotation
         * @returns number
         */
        Sprite.prototype.getRotation = function () {
            return this.rotation;
        };
        /**
         * Sets the scale trasformation in the x direction
         * @method setScale
         * @param scale {number} The magnitude to scale the drawing in the x direction
         */
        Sprite.prototype.setScaleX = function (scaleX) {
            this.scaleX = scaleX;
        };
        /**
         * Sets the scale trasformation in the x direction
         * @method setScale
         * @param scale {number} The magnitude to scale the drawing in the x direction
         */
        Sprite.prototype.setScaleY = function (scaleY) {
            this.scaleY = scaleY;
        };
        /**
         * Returns the current magnitude of the drawing's scale in the x direction
         * @method getScale
         * @returns number
         */
        Sprite.prototype.getScaleX = function () {
            return this.scaleX;
        };
        /**
         * Returns the current magnitude of the drawing's scale in the y direction
         * @method getScale
         * @returns number
         */
        Sprite.prototype.getScaleY = function () {
            return this.scaleY;
        };
        /**
         * Resets the internal state of the drawing (if any)
         * @method reset
         */
        Sprite.prototype.reset = function () {
            // do nothing
        };
        /**
         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The 2D rendering context
         * @param x {number} The x coordinate of where to draw
         * @param y {number} The y coordinate of where to draw
         */
        Sprite.prototype.draw = function (ctx, x, y) {
            if (this.dirtyEffect) {
                this.applyEffects();
                this.dirtyEffect = false;
            }
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            if (this.flipHorizontal) {
                ctx.translate(this.swidth, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, this.sheight);
                ctx.scale(1, -1);
            }
            if (this.internalImage) {
                ctx.drawImage(this.internalImage, 0, 0, this.swidth, this.sheight, -(this.transformPoint.x * this.swidth) * this.scaleX, -(this.transformPoint.y * this.sheight) * this.scaleY, this.swidth * this.scaleX, this.sheight * this.scaleY);
            }
            ctx.restore();
        };
        /**
         * Produces a copy of the current sprite
         * @method clone
         * @returns Sprite
         */
        Sprite.prototype.clone = function () {
            var result = new Sprite(this.texture, this.sx, this.sy, this.swidth, this.sheight);
            result.scaleX = this.scaleX;
            result.scaleY = this.scaleY;
            result.rotation = this.rotation;
            result.flipHorizontal = this.flipHorizontal;
            result.flipVertical = this.flipVertical;
            this.effects.forEach(function (e) {
                result.addEffect(e);
            });
            return result;
        };
        return Sprite;
    })();
    ex.Sprite = Sprite;
})(ex || (ex = {}));
/// <reference path="Sprite.ts" />
var ex;
(function (ex) {
    /**
     * SpriteSheets are a useful mechanism for slicing up image resources into
     * separate sprites or for generating in game animations. Sprites are organized
     * in row major order in the SpriteSheet.
     * @class SpriteSheet
     * @constructor
     * @param image {Texture} The backing image texture to build the SpriteSheet
     * @param columns {number} The number of columns in the image texture
     * @param rows {number} The number of rows in the image texture
     * @param spWidth {number} The width of each individual sprite in pixels
     * @param spHeight {number} The height of each individual sprite in pixels
     */
    var SpriteSheet = (function () {
        function SpriteSheet(image, columns, rows, spWidth, spHeight) {
            this.image = image;
            this.columns = columns;
            this.rows = rows;
            this.sprites = [];
            this.internalImage = image.image;
            this.sprites = new Array(columns * rows);
            // TODO: Inspect actual image dimensions with preloading
            /*if(spWidth * columns > this.internalImage.naturalWidth){
               throw new Error("SpriteSheet specified is wider than image width");
            }
   
            if(spHeight * rows > this.internalImage.naturalHeight){
               throw new Error("SpriteSheet specified is higher than image height");
            }*/
            var i = 0;
            var j = 0;
            for (i = 0; i < rows; i++) {
                for (j = 0; j < columns; j++) {
                    this.sprites[j + i * columns] = new ex.Sprite(this.image, j * spWidth, i * spHeight, spWidth, spHeight);
                }
            }
        }
        /**
         * Create an animation from the this SpriteSheet by listing out the
         * sprite indices. Sprites are organized in row major order in the SpriteSheet.
         * @method getAnimationByIndices
         * @param engine {Engine} Reference to the current game Engine
         * @param indices {number[]} An array of sprite indices to use in the animation
         * @param speed {number} The number in milliseconds to display each frame in the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationByIndices = function (engine, indices, speed) {
            var _this = this;
            var images = indices.map(function (index) {
                return _this.sprites[index];
            });
            images = images.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, images, speed);
        };
        /**
         * Create an animation from the this SpriteSheet by specifing the range of
         * images with the beginning and ending index
         * @method getAnimationBetween
         * @param engine {Engine} Reference to the current game Engine
         * @param beginIndex {number} The index to start taking frames
         * @param endIndex {number} The index to stop taking frames
         * @param speed {number} The number in milliseconds to display each frame in the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {
            var images = this.sprites.slice(beginIndex, endIndex);
            images = images.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, images, speed);
        };
        /**
         * Treat the entire SpriteSheet as one animation, organizing the frames in
         * row major order.
         * @method getAnimationForAll
         * @param engine {Engine} Reference to the current game Engine
         * @param speed {number} The number in milliseconds to display each frame the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationForAll = function (engine, speed) {
            var sprites = this.sprites.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, sprites, speed);
        };
        /**
         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized
         * in row major order in the SpriteSheet.
         * @method getSprite
         * @param index {number} The index of the sprite
         * @returns Sprite
         */
        SpriteSheet.prototype.getSprite = function (index) {
            if (index >= 0 && index < this.sprites.length) {
                return this.sprites[index];
            }
        };
        return SpriteSheet;
    })();
    ex.SpriteSheet = SpriteSheet;
    /**
     * SpriteFonts are a used in conjunction with a {{#crossLink Label}}{{/crossLink}} to specify
     * a particular bitmap as a font.
     * @class SpriteFont
     * @extends SpriteSheet
     * @constructor
     * @param image {Texture} The backing image texture to build the SpriteFont
     * @param alphabet {string} A string representing all the charaters in the image, in row major order.
     * @param caseInsensitve {boolean} Indicate whether this font takes case into account
     * @param columns {number} The number of columns of characters in the image
     * @param rows {number} The number of rows of characters in the image
     * @param spWdith {number} The width of each character in pixels
     * @param spHeight {number} The height of each character in pixels
     */
    var SpriteFont = (function (_super) {
        __extends(SpriteFont, _super);
        function SpriteFont(image, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            _super.call(this, image, columns, rows, spWidth, spHeight);
            this.image = image;
            this.alphabet = alphabet;
            this.caseInsensitive = caseInsensitive;
            this.spriteLookup = {};
            this.colorLookup = {};
            this._currentColor = ex.Color.Black;
        }
        /**
         * Returns a dictionary that maps each character in the alphabet to the appropriate Sprite.
         * @method getTextSprites
         * @returns {Object}
         */
        SpriteFont.prototype.getTextSprites = function () {
            var lookup = {};
            for (var i = 0; i < this.alphabet.length; i++) {
                var char = this.alphabet[i];
                if (this.caseInsensitive) {
                    char = char.toLowerCase();
                }
                lookup[char] = this.sprites[i].clone();
            }
            return lookup;
        };
        return SpriteFont;
    })(SpriteSheet);
    ex.SpriteFont = SpriteFont;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="SpriteSheet.ts" />
var ex;
(function (ex) {
    var TileSprite = (function () {
        function TileSprite(spriteSheetKey, spriteId) {
            this.spriteSheetKey = spriteSheetKey;
            this.spriteId = spriteId;
        }
        return TileSprite;
    })();
    ex.TileSprite = TileSprite;
    /**
     * A light-weight object that occupies a space in a collision map. Generally
     * created by a CollisionMap.
     * @class Cell
     * @constructor
     * @param x {number}
     * @param y {number}
     * @param width {number}
     * @param height {number}
     * @param index {number}
     * @param [solid=false] {boolean}
     * @param [spriteId=-1] {number}
     */
    var Cell = (function () {
        function Cell(
            /**
             * Gets or sets x coordinate of the cell in world coordinates
             * @property x {number}
             */
            x, 
            /**
             * Gets or sets y coordinate of the cell in world coordinates
             * @property y {number}
             */
            y, 
            /**
             * Gets or sets the width of the cell
             * @property width {number}
             */
            width, 
            /**
             * Gets or sets the height of the cell
             * @property height {number}
             */
            height, 
            /**
             * The index of the cell in row major order
             * @property index {number}
             */
            index, 
            /**
             * Gets or sets whether this cell is solid
             * @property solid {boolean}
             */
            solid, 
            /**
             * The index of the sprite to use from the CollisionMap SpriteSheet, if -1 is specified nothing is drawn.
             * @property number {number}
             */
            sprites) {
            if (solid === void 0) { solid = false; }
            if (sprites === void 0) { sprites = []; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.index = index;
            this.solid = solid;
            this.sprites = sprites;
            this._bounds = new ex.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
        }
        /**
         * Returns the bounding box for this cell
         * @method getBounds
         * @returns BoundingBox
         */
        Cell.prototype.getBounds = function () {
            return this._bounds;
        };
        Cell.prototype.getCenter = function () {
            return new ex.Vector(this.x + this.width / 2, this.y + this.height / 2);
        };
        Cell.prototype.pushSprite = function (tileSprite) {
            this.sprites.push(tileSprite);
        };
        Cell.prototype.removeSprite = function (tileSprite) {
            var index = -1;
            if ((index = this.sprites.indexOf(tileSprite)) > -1) {
                this.sprites.splice(index, 1);
            }
        };
        Cell.prototype.clearSprites = function () {
            this.sprites.length = 0;
        };
        return Cell;
    })();
    ex.Cell = Cell;
    /**
     * The CollisionMap object provides a lightweight way to do large complex scenes with collision
     * without the overhead of actors.
     * @class CollisionMap
     * @constructor
     * @param x {number} The x coordinate to anchor the collision map's upper left corner (should not be changed once set)
     * @param y {number} The y coordinate to anchor the collision map's upper left corner (should not be changed once set)
     * @param cellWidth {number} The individual width of each cell (in pixels) (should not be changed once set)
     * @param cellHeight {number} The individual height of each cell (in pixels) (should not be changed once set)
     * @param rows {number} The number of rows in the collision map (should not be changed once set)
     * @param cols {number} The number of cols in the collision map (should not be changed once set)
     * @param spriteSheet {SpriteSheet} The spriteSheet to use for drawing
     */
    var TileMap = (function () {
        function TileMap(x, y, cellWidth, cellHeight, rows, cols) {
            var _this = this;
            this.x = x;
            this.y = y;
            this.cellWidth = cellWidth;
            this.cellHeight = cellHeight;
            this.rows = rows;
            this.cols = cols;
            this._collidingX = -1;
            this._collidingY = -1;
            this._onScreenXStart = 0;
            this._onScreenXEnd = 9999;
            this._onScreenYStart = 0;
            this._onScreenYEnd = 9999;
            this._spriteSheets = {};
            this.logger = ex.Logger.getInstance();
            this.data = [];
            this.data = new Array(rows * cols);
            for (var i = 0; i < cols; i++) {
                for (var j = 0; j < rows; j++) {
                    (function () {
                        var cd = new Cell(i * cellWidth + x, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                        _this.data[i + j * cols] = cd;
                    })();
                }
            }
        }
        TileMap.prototype.registerSpriteSheet = function (key, spriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        };
        /**
         * Returns the intesection vector that can be used to resolve collisions with actors. If there
         * is no collision null is returned.
         * @method collides
         * @param actor {Actor}
         * @returns Vector
         */
        TileMap.prototype.collides = function (actor) {
            var points = [];
            var width = actor.x + actor.getWidth();
            var height = actor.y + actor.getHeight();
            var actorBounds = actor.getBounds();
            var overlaps = [];
            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {
                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {
                    var cell = this.getCellByPoint(x, y);
                    if (cell && cell.solid) {
                        var overlap = actorBounds.collides(cell.getBounds());
                        var dir = actor.getCenter().minus(cell.getCenter());
                        if (overlap && overlap.dot(dir) > 0) {
                            overlaps.push(overlap);
                        }
                    }
                }
            }
            if (overlaps.length === 0) {
                return null;
            }
            // Return the smallest change other than zero
            var result = overlaps.reduce(function (accum, next) {
                var x = accum.x;
                var y = accum.y;
                if (Math.abs(accum.x) < Math.abs(next.x)) {
                    x = next.x;
                }
                if (Math.abs(accum.y) < Math.abs(next.y)) {
                    y = next.y;
                }
                return new ex.Vector(x, y);
            });
            return result;
        };
        /*
        public collidesActor(actor: Actor): boolean{
           
           var points: Point[] = [];
           var width = actor.x + actor.getWidth();
           var height = actor.y + actor.getHeight();
           for(var x = actor.x; x <= width; x += Math.min(actor.getWidth()/2,this.cellWidth/2)){
              for(var y = actor.y; y <= height; y += Math.min(actor.getHeight()/2, this.cellHeight/2)){
                 points.push(new Point(x,y))
              }
           }
  
           var result = points.some((p) => {
              return this.collidesPoint(p.x, p.y);
           });
  
           return result;
  
        }*/
        /*
        public collidesPoint(x: number, y: number): boolean{
           var x = Math.floor(x/this.cellWidth);// - Math.floor(this.x/this.cellWidth);
           var y = Math.floor(y/this.cellHeight);
  
  
           var cell = this.getCell(x, y);
           if(x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell){
              if(cell.solid){
                 this._collidingX = x;
                 this._collidingY = y;
              }
              return cell.solid;
           }
  
  
  
           
           return false;
        }*/
        /**
         * Returns the cell by index (row major order)
         * @method getCellByIndex
         * @param index {number}
         * @returns Cell
         */
        TileMap.prototype.getCellByIndex = function (index) {
            return this.data[index];
        };
        /**
         * Returns the cell by it's x and y coordinates
         * @method getCell
         * @param x {number}
         * @param y {number}
         * @returns Cell
         */
        TileMap.prototype.getCell = function (x, y) {
            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
                return null;
            }
            return this.data[x + y * this.cols];
        };
        /**
         * Returns the cell by testing a point in global coordinates,
         * returns null if no cell was found.
         * @method getCellByPoint
         * @param x {number}
         * @param y {number}
         * @returns Cell
         */
        TileMap.prototype.getCellByPoint = function (x, y) {
            var x = Math.floor((x - this.x) / this.cellWidth); // - Math.floor(this.x/this.cellWidth);
            var y = Math.floor((y - this.y) / this.cellHeight);
            var cell = this.getCell(x, y);
            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
                return cell;
            }
            return null;
        };
        TileMap.prototype.update = function (engine, delta) {
            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new ex.Point(0, 0));
            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new ex.Point(engine.width, engine.height));
            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);
            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);
            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
        };
        /**
         * Draws the collision map to the screen. Called by the Scene.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         * @param delta {number} The number of milliseconds since the last draw
         */
        TileMap.prototype.draw = function (ctx, delta) {
            var _this = this;
            ctx.save();
            ctx.translate(this.x, this.y);
            for (var x = this._onScreenXStart; x < Math.min(this._onScreenXEnd, this.cols); x++) {
                for (var y = this._onScreenYStart; y < Math.min(this._onScreenYEnd, this.rows); y++) {
                    this.getCell(x, y).sprites.filter(function (s) {
                        return s.spriteId > -1;
                    }).forEach(function (ts) {
                        var ss = _this._spriteSheets[ts.spriteSheetKey];
                        if (ss) {
                            var sprite = ss.getSprite(ts.spriteId);
                            if (sprite) {
                                sprite.draw(ctx, x * _this.cellWidth, y * _this.cellHeight);
                            }
                            else {
                                _this.logger.warn("Sprite does not exist for id", ts.spriteId, "in sprite sheet", ts.spriteSheetKey, sprite, ss);
                            }
                        }
                        else {
                            _this.logger.warn("Sprite sheet", ts.spriteSheetKey, "does not exist", ss);
                        }
                    });
                }
            }
            ctx.restore();
        };
        /**
         * Draws all the collision map's debug info. Called by the Scene.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         */
        TileMap.prototype.debugDraw = function (ctx) {
            var width = this.cols * this.cellWidth;
            var height = this.rows * this.cellHeight;
            ctx.save();
            ctx.strokeStyle = ex.Color.Red.toString();
            for (var x = 0; x < this.cols + 1; x++) {
                ctx.beginPath();
                ctx.moveTo(this.x + x * this.cellWidth, this.y);
                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
                ctx.stroke();
            }
            for (var y = 0; y < this.rows + 1; y++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + y * this.cellHeight);
                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
                ctx.stroke();
            }
            var solid = ex.Color.Red.clone();
            solid.a = .3;
            this.data.filter(function (cell) {
                return cell.solid;
            }).forEach(function (cell) {
                ctx.fillStyle = solid.toString();
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            });
            if (this._collidingY > -1 && this._collidingX > -1) {
                ctx.fillStyle = ex.Color.Cyan.toString();
                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
            }
            ctx.restore();
        };
        return TileMap;
    })();
    ex.TileMap = TileMap;
})(ex || (ex = {}));
/// <reference path="../Algebra.ts" />
var ex;
(function (ex) {
    (function (CollisionStrategy) {
        CollisionStrategy[CollisionStrategy["Naive"] = 0] = "Naive";
        CollisionStrategy[CollisionStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
        CollisionStrategy[CollisionStrategy["SeparatingAxis"] = 2] = "SeparatingAxis";
    })(ex.CollisionStrategy || (ex.CollisionStrategy = {}));
    var CollisionStrategy = ex.CollisionStrategy;
    /**
     * Axis Aligned collision primitive for Excalibur.
     * @class BoundingBox
     * @constructor
     * @param left {number} x coordinate of the left edge
     * @param top {number} y coordinate of the top edge
     * @param right {number} x coordinate of the right edge
     * @param bottom {number} y coordinate of the bottom edge
     */
    var BoundingBox = (function () {
        function BoundingBox(left, top, right, bottom) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        /**
         * Returns the calculated width of the bounding box
         * @method getWidth
         * @returns number
         */
        BoundingBox.prototype.getWidth = function () {
            return this.right - this.left;
        };
        /**
         * Returns the calculated height of the bounding box
         * @method getHeight
         * @returns number
         */
        BoundingBox.prototype.getHeight = function () {
            return this.bottom - this.top;
        };
        /**
         * Returns the perimeter of the bounding box
         * @method getPerimeter
         * @returns number
         */
        BoundingBox.prototype.getPerimeter = function () {
            var wx = this.getWidth();
            var wy = this.getHeight();
            return 2 * (wx + wy);
        };
        BoundingBox.prototype.contains = function (val) {
            if (val instanceof ex.Point) {
                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);
            }
            else if (val instanceof BoundingBox) {
                if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {
                    return true;
                }
                return false;
            }
            return false;
        };
        /**
         * Combines this bounding box and another together returning a new bounding box
         * @method combine
         * @param other {BoundingBox} The bounding box to combine
         * @returns BoundingBox
         */
        BoundingBox.prototype.combine = function (other) {
            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
            return compositeBB;
        };
        /**
         * Test wether this bounding box collides with another returning,
         * the intersection vector that can be used to resovle the collision. If there
         * is no collision null is returned.
         * @method collides
         * @param collidable {ICollidable} Other collidable to test
         * @returns Vector
         */
        BoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof BoundingBox) {
                var other = collidable;
                var totalBoundingBox = this.combine(other);
                // If the total bounding box is less than the sum of the 2 bounds then there is collision
                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() && totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {
                    // collision
                    var overlapX = 0;
                    if (this.right >= other.left && this.right <= other.right) {
                        overlapX = other.left - this.right;
                    }
                    else {
                        overlapX = other.right - this.left;
                    }
                    var overlapY = 0;
                    if (this.top <= other.bottom && this.top >= other.top) {
                        overlapY = other.bottom - this.top;
                    }
                    else {
                        overlapY = other.top - this.bottom;
                    }
                    if (Math.abs(overlapX) < Math.abs(overlapY)) {
                        return new ex.Vector(overlapX, 0);
                    }
                    else {
                        return new ex.Vector(0, overlapY);
                    }
                }
                else {
                    return null;
                }
            }
            return null;
        };
        BoundingBox.prototype.debugDraw = function (ctx) {
            ctx.lineWidth = 2;
            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());
        };
        return BoundingBox;
    })();
    ex.BoundingBox = BoundingBox;
    var SATBoundingBox = (function () {
        function SATBoundingBox(points) {
            this._points = points.map(function (p) { return p.toVector(); });
        }
        SATBoundingBox.prototype.getSides = function () {
            var lines = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                lines.push(new ex.Line(this._points[i], this._points[(i + 1) % len]));
            }
            return lines;
        };
        SATBoundingBox.prototype.getAxes = function () {
            var axes = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                axes.push(this._points[i].minus(this._points[(i + 1) % len]).normal());
            }
            return axes;
        };
        SATBoundingBox.prototype.project = function (axis) {
            var scalars = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                scalars.push(this._points[i].dot(axis));
            }
            return new ex.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /**
         * Returns the calculated width of the bounding box, by generating an axis aligned box around the current
         * @method getWidth
         * @returns number
         */
        SATBoundingBox.prototype.getWidth = function () {
            var left = this._points.reduce(function (accum, p, i, arr) {
                return Math.min(accum, p.x);
            }, Infinity);
            var right = this._points.reduce(function (accum, p, i, arr) {
                return Math.max(accum, p.x);
            }, -Infinity);
            return right - left;
        };
        /**
         * Returns the calculated height of the bounding box, by generating an axis aligned box around the current
         * @method getHeight
         * @returns number
         */
        SATBoundingBox.prototype.getHeight = function () {
            var top = this._points.reduce(function (accum, p, i, arr) {
                return Math.min(accum, p.y);
            }, Infinity);
            var bottom = this._points.reduce(function (accum, p, i, arr) {
                return Math.max(accum, p.y);
            }, -Infinity);
            return top - bottom;
        };
        /**
         * Tests wether a point is contained within the bounding box, using the PIP algorithm
         * http://en.wikipedia.org/wiki/Point_in_polygon
         * @method contains
         * @param p {Point} The point to test
         * @returns boolean
         */
        SATBoundingBox.prototype.contains = function (p) {
            // Always cast to the right, as long as we cast in a consitent fixed direction we
            // will be fine
            var testRay = new ex.Ray(p, new ex.Vector(1, 0));
            var intersectCount = this.getSides().reduce(function (accum, side, i, arr) {
                if (testRay.intersect(side) >= 0) {
                    return accum + 1;
                }
                return accum;
            }, 0);
            if (intersectCount % 2 === 0) {
                return false;
            }
            return true;
        };
        SATBoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof SATBoundingBox) {
                var other = collidable;
                var axes = this.getAxes();
                axes = other.getAxes().concat(axes);
                var minOverlap = 99999;
                var minAxis = null;
                for (var i = 0; i < axes.length; i++) {
                    var proj1 = this.project(axes[i]);
                    var proj2 = other.project(axes[i]);
                    var overlap = proj1.getOverlap(proj2);
                    if (overlap === 0) {
                        return null;
                    }
                    else {
                        if (overlap <= minOverlap) {
                            minOverlap = overlap;
                            minAxis = axes[i];
                        }
                    }
                }
                if (minAxis) {
                    return minAxis.normalize().scale(minOverlap);
                }
                else {
                    return null;
                }
            }
            return null;
        };
        SATBoundingBox.prototype.debugDraw = function (ctx) {
            ctx.beginPath();
            ctx.lineWidth = 2;
            // Iterate through the supplied points and contruct a 'polygon'
            var firstPoint = this._points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this._points.forEach(function (point) {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            ctx.strokeStyle = ex.Color.Blue.toString();
            ctx.stroke();
        };
        return SATBoundingBox;
    })();
    ex.SATBoundingBox = SATBoundingBox;
})(ex || (ex = {}));
/// <reference path="Events.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur base class
     * @class Class
     * @constructor
     */
    var Class = (function () {
        function Class() {
            this.eventDispatcher = new ex.EventDispatcher(this);
        }
        /**
         * Add an event listener. You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method addEventListener
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Class.prototype.addEventListener = function (eventName, handler) {
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * Removes an event listener. If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified just that handler will be removed.
         *
         * @method removeEventListener
         * @param eventName {string} Name of the event to listen for
         * @param [handler=undefined] {event=>void} Event handler for the thrown event
         */
        Class.prototype.removeEventListener = function (eventName, handler) {
            this.eventDispatcher.unsubscribe(eventName, handler);
        };
        /**
         * Alias for "addEventListener". You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method on
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Class.prototype.on = function (eventName, handler) {
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * Alias for "removeEventListener". If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified only that handler will be removed.
         *
         * @method off
         * @param eventName {string} Name of the event to listen for
         * @param [handler=undefined] {event=>void} Event handler for the thrown event
         */
        Class.prototype.off = function (eventName, handler) {
            this.eventDispatcher.unsubscribe(eventName, handler);
        };
        /**
         * You may wish to extend native Excalibur functionality. Any method on
         * actor may be extended to support additional functionaliy. In the
         * example below we create a new type called "MyActor"
         * <br/><b>Example</b><pre>var MyActor = Actor.extend({
     constructor : function(){
        this.newprop = 'something';
        Actor.apply(this, arguments);
     },
     update : function(engine, delta){
        // Implement custom update
  
           // Call super constructor update
           Actor.prototype.update.call(this, engine, delta);
           console.log("Something cool!");
     }
  });
  var myActor = new MyActor(100, 100, 100, 100, Color.Azure);</pre>
         * @method extend
         * @static
         * @param methods {any}
         */
        Class.extend = function (methods) {
            var parent = this;
            var child;
            if (methods && methods.hasOwnProperty('constructor')) {
                child = methods.constructor;
            }
            else {
                child = function () {
                    return parent.apply(this, arguments);
                };
            }
            // Using constructor allows JS to lazily instantiate super classes
            var Super = function () {
                this.constructor = child;
            };
            Super.prototype = parent.prototype;
            child.prototype = new Super;
            if (methods) {
                for (var prop in methods) {
                    if (methods.hasOwnProperty(prop)) {
                        child.prototype[prop] = methods[prop];
                    }
                }
            }
            // Make subclasses extendable
            child.extend = Class.extend;
            return child;
        };
        return Class;
    })();
    ex.Class = Class;
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Timer = (function () {
        /**
         * The Excalibur timer hooks into the internal timer and fires callbacks, after a certain interval, optionally repeating.
         *
         * @class Timer
         * @constructor
         * @param callback {callback} The callback to be fired after the interval is complete.
         * @param [repeats=false] {boolean} Indicates whether this call back should be fired only once, or repeat after every interval as completed.
         */
        function Timer(fcn, interval, repeats) {
            this.id = 0;
            this.interval = 10;
            this.fcn = function () {
            };
            this.repeats = false;
            this.elapsedTime = 0;
            this._totalTimeAlive = 0;
            this.complete = false;
            this.scene = null;
            this.id = Timer.id++;
            this.interval = interval || this.interval;
            this.fcn = fcn || this.fcn;
            this.repeats = repeats || this.repeats;
        }
        /**
         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
         * @method update
         * @param delta {number} Number of elapsed milliseconds since the last update.
         */
        Timer.prototype.update = function (delta) {
            this._totalTimeAlive += delta;
            this.elapsedTime += delta;
            if (this.elapsedTime > this.interval) {
                this.fcn.call(this);
                if (this.repeats) {
                    this.elapsedTime = 0;
                }
                else {
                    this.complete = true;
                }
            }
        };
        Timer.prototype.getTimeRunning = function () {
            return this._totalTimeAlive;
        };
        /**
         * Cancels the timer, preventing any further executions.
         * @method cancel
         */
        Timer.prototype.cancel = function () {
            if (this.scene) {
                this.scene.cancelTimer(this);
            }
        };
        Timer.id = 0;
        return Timer;
    })();
    ex.Timer = Timer;
})(ex || (ex = {}));
/// <reference path="../Actor.ts"/>
/// <reference path="Side.ts"/>
/// <reference path="ICollisionResolver.ts"/> 
var ex;
(function (ex) {
    var NaiveCollisionResolver = (function () {
        function NaiveCollisionResolver() {
        }
        NaiveCollisionResolver.prototype.register = function (target) {
            // pass
        };
        NaiveCollisionResolver.prototype.remove = function (tartet) {
            // pass
        };
        NaiveCollisionResolver.prototype.evaluate = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== 0 /* PreventCollision */;
            });
            var actor1;
            var actor2;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor1 = potentialColliders[j];
                for (var i = j + 1; i < l; i++) {
                    actor2 = potentialColliders[i];
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor1.collides(actor2)) {
                        var side = actor1.getSideFromIntersect(minimumTranslationVector);
                        var collisionPair = new ex.CollisionPair(actor1, actor2, minimumTranslationVector, side);
                        if (!collisionPairs.some(function (cp) {
                            return cp.equals(collisionPair);
                        })) {
                            collisionPairs.push(collisionPair);
                        }
                    }
                }
            }
            collisionPairs.forEach(function (p) { return p.evaluate(); });
            return collisionPairs;
        };
        NaiveCollisionResolver.prototype.update = function (targets) {
            return 0;
        };
        NaiveCollisionResolver.prototype.debugDraw = function (ctx, delta) {
        };
        return NaiveCollisionResolver;
    })();
    ex.NaiveCollisionResolver = NaiveCollisionResolver;
})(ex || (ex = {}));
/// <reference path="BoundingBox.ts"/>
var ex;
(function (ex) {
    var TreeNode = (function () {
        function TreeNode(parent) {
            this.parent = parent;
            this.parent = parent || null;
            this.actor = null;
            this.bounds = new ex.BoundingBox();
            this.left = null;
            this.right = null;
            this.height = 0;
        }
        TreeNode.prototype.isLeaf = function () {
            return (!this.left && !this.right);
        };
        return TreeNode;
    })();
    ex.TreeNode = TreeNode;
    var DynamicTree = (function () {
        function DynamicTree() {
            this.root = null;
            this.nodes = {};
        }
        DynamicTree.prototype.insert = function (leaf) {
            // If there are no nodes in the tree, make this the root leaf
            if (this.root === null) {
                this.root = leaf;
                this.root.parent = null;
                return;
            }
            // Search the tree for a node that is not a leaf and find the best place to insert
            var leafAABB = leaf.bounds;
            var currentRoot = this.root;
            while (!currentRoot.isLeaf()) {
                var left = currentRoot.left;
                var right = currentRoot.right;
                var area = currentRoot.bounds.getPerimeter();
                var combinedAABB = currentRoot.bounds.combine(leafAABB);
                var combinedArea = combinedAABB.getPerimeter();
                // Calculate cost heuristic for creating a new parent and leaf
                var cost = 2 * combinedArea;
                // Minimum cost of pushing the leaf down the tree
                var inheritanceCost = 2 * (combinedArea - area);
                // Cost of descending
                var leftCost = 0;
                var leftCombined = leafAABB.combine(left.bounds);
                var newArea;
                var oldArea;
                if (left.isLeaf()) {
                    leftCost = leftCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = left.bounds.getPerimeter();
                    newArea = leftCombined.getPerimeter();
                    leftCost = (newArea - oldArea) + inheritanceCost;
                }
                var rightCost = 0;
                var rightCombined = leafAABB.combine(right.bounds);
                if (right.isLeaf()) {
                    rightCost = rightCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = right.bounds.getPerimeter();
                    newArea = rightCombined.getPerimeter();
                    rightCost = (newArea - oldArea) + inheritanceCost;
                }
                // cost is acceptable
                if (cost < leftCost && cost < rightCost) {
                    break;
                }
                // Descend to the depths
                if (leftCost < rightCost) {
                    currentRoot = left;
                }
                else {
                    currentRoot = right;
                }
            }
            // Create the new parent node and insert into the tree
            var oldParent = currentRoot.parent;
            var newParent = new TreeNode(oldParent);
            newParent.bounds = leafAABB.combine(currentRoot.bounds);
            newParent.height = currentRoot.height + 1;
            if (oldParent !== null) {
                // The sibling node was not the root
                if (oldParent.left === currentRoot) {
                    oldParent.left = newParent;
                }
                else {
                    oldParent.right = newParent;
                }
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling node was the root
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
                this.root = newParent;
            }
            // Walk up the tree fixing heights and AABBs
            var currentNode = leaf.parent;
            while (currentNode) {
                currentNode = this.balance(currentNode);
                if (!currentNode.left) {
                    throw new Error("Parent of current leaf cannot have a null left child" + currentNode);
                }
                if (!currentNode.right) {
                    throw new Error("Parent of current leaf cannot have a null right child" + currentNode);
                }
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode = currentNode.parent;
            }
        };
        DynamicTree.prototype.remove = function (leaf) {
            if (leaf === this.root) {
                this.root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.left === leaf) {
                sibling = parent.right;
            }
            else {
                sibling = parent.left;
            }
            if (grandParent) {
                if (grandParent.left === parent) {
                    grandParent.left = sibling;
                }
                else {
                    grandParent.right = sibling;
                }
                sibling.parent = grandParent;
                var currentNode = grandParent;
                while (currentNode) {
                    currentNode = this.balance(currentNode);
                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                    currentNode = currentNode.parent;
                }
            }
            else {
                this.root = sibling;
                sibling.parent = null;
            }
        };
        DynamicTree.prototype.registerActor = function (actor) {
            var node = new TreeNode();
            node.actor = actor;
            node.bounds = actor.getBounds();
            node.bounds.left -= 2;
            node.bounds.top -= 2;
            node.bounds.right += 2;
            node.bounds.bottom += 2;
            this.nodes[actor.id] = node;
            this.insert(node);
        };
        DynamicTree.prototype.updateActor = function (actor) {
            var node = this.nodes[actor.id];
            if (!node)
                return;
            var b = actor.getBounds();
            if (node.bounds.contains(b)) {
                return false;
            }
            this.remove(node);
            b.left -= 5;
            b.top -= 5;
            b.right += 5;
            b.bottom += 5;
            var multdx = actor.dx * 2;
            var multdy = actor.dy * 2;
            if (multdx < 0) {
                b.left += multdx;
            }
            else {
                b.right += multdx;
            }
            if (multdy < 0) {
                b.top += multdy;
            }
            else {
                b.bottom += multdy;
            }
            node.bounds = b;
            this.insert(node);
            return true;
        };
        DynamicTree.prototype.removeActor = function (actor) {
            var node = this.nodes[actor.id];
            if (!node)
                return;
            this.remove(node);
            this.nodes[actor.id] = null;
            delete this.nodes[actor.id];
        };
        DynamicTree.prototype.balance = function (node) {
            if (node === null) {
                throw new Error("Cannot balance at null node");
            }
            if (node.isLeaf() || node.height < 2) {
                return node;
            }
            var left = node.left;
            var right = node.right;
            var a = node;
            var b = left;
            var c = right;
            var d = left.left;
            var e = left.right;
            var f = right.left;
            var g = right.right;
            var balance = c.height - b.height;
            // Rotate c node up
            if (balance > 1) {
                // Swap the right node with it's parent
                c.left = a;
                c.parent = a.parent;
                a.parent = c;
                // The original node's old parent should point to the right node
                // this is mega confusing
                if (c.parent) {
                    if (c.parent.left === a) {
                        c.parent.left = c;
                    }
                    else {
                        c.parent.right = c;
                    }
                }
                else {
                    this.root = c;
                }
                // Rotate
                if (f.height > g.height) {
                    c.right = f;
                    a.right = g;
                    g.parent = a;
                    a.bounds = b.bounds.combine(g.bounds);
                    c.bounds = a.bounds.combine(f.bounds);
                    a.height = 1 + Math.max(b.height, g.height);
                    c.height = 1 + Math.max(a.height, f.height);
                }
                else {
                    c.right = g;
                    a.right = f;
                    f.parent = a;
                    a.bounds = b.bounds.combine(f.bounds);
                    c.bounds = a.bounds.combine(g.bounds);
                    a.height = 1 + Math.max(b.height, f.height);
                    c.height = 1 + Math.max(a.height, g.height);
                }
                return c;
            }
            // Rotate left node up
            if (balance < -1) {
                // swap
                b.left = a;
                b.parent = a.parent;
                a.parent = b;
                // node's old parent should point to b
                if (b.parent) {
                    if (b.parent.left === a) {
                        b.parent.left = b;
                    }
                    else {
                        if (b.parent.right !== a)
                            throw "Error rotating Dynamic Tree";
                        b.parent.right = b;
                    }
                }
                else {
                    this.root = b;
                }
                // rotate
                if (d.height > e.height) {
                    b.right = d;
                    a.left = e;
                    e.parent = a;
                    a.bounds = c.bounds.combine(e.bounds);
                    b.bounds = a.bounds.combine(d.bounds);
                    a.height = 1 + Math.max(c.height, e.height);
                    b.height = 1 + Math.max(a.height, d.height);
                }
                else {
                    b.right = e;
                    a.left = d;
                    d.parent = a;
                    a.bounds = c.bounds.combine(d.bounds);
                    b.bounds = a.bounds.combine(e.bounds);
                    a.height = 1 + Math.max(c.height, d.height);
                    b.height = 1 + Math.max(a.height, e.height);
                }
                return b;
            }
            return node;
        };
        DynamicTree.prototype.getHeight = function () {
            if (this.root === null) {
                return 0;
            }
            return this.root.height;
        };
        DynamicTree.prototype.query = function (actor, callback) {
            var bounds = actor.getBounds();
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.collides(bounds)) {
                    if (currentNode.isLeaf() && currentNode.actor !== actor) {
                        if (callback.call(actor, currentNode.actor)) {
                            return true;
                        }
                    }
                    else {
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                else {
                    return null;
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.rayCast = function (ray, max) {
            // todo implement
            return null;
        };
        DynamicTree.prototype.getNodes = function () {
            var helper = function (currentNode) {
                if (currentNode) {
                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
                }
                else {
                    return [];
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.debugDraw = function (ctx, delta) {
            // draw all the nodes in the Dynamic Tree
            var helper = function (currentNode) {
                if (currentNode) {
                    if (currentNode.isLeaf()) {
                        ctx.strokeStyle = 'green';
                    }
                    else {
                        ctx.strokeStyle = 'white';
                    }
                    currentNode.bounds.debugDraw(ctx);
                    if (currentNode.left)
                        helper(currentNode.left);
                    if (currentNode.right)
                        helper(currentNode.right);
                }
            };
            helper(this.root);
        };
        return DynamicTree;
    })();
    ex.DynamicTree = DynamicTree;
})(ex || (ex = {}));
/// <reference path="ICollisionResolver.ts"/>
/// <reference path="DynamicTree.ts"/>
var ex;
(function (ex) {
    var DynamicTreeCollisionResolver = (function () {
        function DynamicTreeCollisionResolver() {
            this._dynamicCollisionTree = new ex.DynamicTree();
        }
        DynamicTreeCollisionResolver.prototype.register = function (target) {
            this._dynamicCollisionTree.registerActor(target);
        };
        DynamicTreeCollisionResolver.prototype.remove = function (target) {
            this._dynamicCollisionTree.removeActor(target);
        };
        DynamicTreeCollisionResolver.prototype.evaluate = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== 0 /* PreventCollision */;
            });
            var actor;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor = potentialColliders[j];
                this._dynamicCollisionTree.query(actor, function (other) {
                    if (other.collisionType === 0 /* PreventCollision */ || other.isKilled())
                        return false;
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor.collides(other)) {
                        var side = actor.getSideFromIntersect(minimumTranslationVector);
                        var collisionPair = new ex.CollisionPair(actor, other, minimumTranslationVector, side);
                        if (!collisionPairs.some(function (cp) {
                            return cp.equals(collisionPair);
                        })) {
                            collisionPairs.push(collisionPair);
                        }
                        return true;
                    }
                    return false;
                });
            }
            collisionPairs.forEach(function (p) { return p.evaluate(); });
            return collisionPairs;
        };
        DynamicTreeCollisionResolver.prototype.update = function (targets) {
            var _this = this;
            var updated = 0;
            targets.forEach(function (a) {
                if (_this._dynamicCollisionTree.updateActor(a)) {
                    updated++;
                }
            });
            return updated;
        };
        DynamicTreeCollisionResolver.prototype.debugDraw = function (ctx, delta) {
            this._dynamicCollisionTree.debugDraw(ctx, delta);
        };
        return DynamicTreeCollisionResolver;
    })();
    ex.DynamicTreeCollisionResolver = DynamicTreeCollisionResolver;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Collision pairs are used internally by Excalibur to resolve collision between actors. The
     * Pair prevents collisions from being evaluated more than one time
     * @class CollisionPair
     * @constructor
     * @param left {Actor} The first actor in the collision pair
     * @param right {Actor} The second actor in the collision pair
     * @param intersect {Vector} The minimum translation vector to separate the actors from the perspective of the left actor
     * @param side {Side} The side on which the collision occured from the perspective of the left actor
     */
    var CollisionPair = (function () {
        function CollisionPair(left, right, intersect, side) {
            this.left = left;
            this.right = right;
            this.intersect = intersect;
            this.side = side;
        }
        /**
         * Determines if this collision pair and another are equivalent.
         * @method equals
         * @param collisionPair {CollisionPair}
         * @returns boolean
         */
        CollisionPair.prototype.equals = function (collisionPair) {
            return (collisionPair.left === this.left && collisionPair.right === this.right) || (collisionPair.right === this.left && collisionPair.left === this.right);
        };
        /**
         * Evaluates the collision pair, performing collision resolution and event publishing appropriate to each collision type.
         * @method evaluate
         */
        CollisionPair.prototype.evaluate = function () {
            // todo fire collision events on left and right actor
            // todo resolve collisions                  
            // Publish collision events on both participants
            this.left.eventDispatcher.publish('collision', new ex.CollisionEvent(this.left, this.right, this.side, this.intersect));
            this.right.eventDispatcher.publish('collision', new ex.CollisionEvent(this.right, this.left, ex.Util.getOppositeSide(this.side), this.intersect.scale(-1.0)));
            // If the actor is active push the actor out if its not passive
            var leftSide = this.side;
            if ((this.left.collisionType === 2 /* Active */ || this.left.collisionType === 3 /* Elastic */) && this.right.collisionType !== 1 /* Passive */) {
                this.left.y += this.intersect.y;
                this.left.x += this.intersect.x;
                // Naive elastic bounce
                if (this.left.collisionType === 3 /* Elastic */) {
                    if (leftSide === 3 /* Left */) {
                        this.left.dx = Math.abs(this.left.dx);
                    }
                    else if (leftSide === 4 /* Right */) {
                        this.left.dx = -Math.abs(this.left.dx);
                    }
                    else if (leftSide === 1 /* Top */) {
                        this.left.dy = Math.abs(this.left.dy);
                    }
                    else if (leftSide === 2 /* Bottom */) {
                        this.left.dy = -Math.abs(this.left.dy);
                    }
                }
            }
            var rightSide = ex.Util.getOppositeSide(this.side);
            var rightIntersect = this.intersect.scale(-1.0);
            if ((this.right.collisionType === 2 /* Active */ || this.right.collisionType === 3 /* Elastic */) && this.left.collisionType !== 1 /* Passive */) {
                this.right.y += rightIntersect.y;
                this.right.x += rightIntersect.x;
                // Naive elastic bounce
                if (this.right.collisionType === 3 /* Elastic */) {
                    if (rightSide === 3 /* Left */) {
                        this.right.dx = Math.abs(this.right.dx);
                    }
                    else if (rightSide === 4 /* Right */) {
                        this.right.dx = -Math.abs(this.right.dx);
                    }
                    else if (rightSide === 1 /* Top */) {
                        this.right.dy = Math.abs(this.right.dy);
                    }
                    else if (rightSide === 2 /* Bottom */) {
                        this.right.dy = -Math.abs(this.right.dy);
                    }
                }
            }
        };
        return CollisionPair;
    })();
    ex.CollisionPair = CollisionPair;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Algebra.ts" />
var ex;
(function (ex) {
    /**
    * A base implementation of a camera. This class is meant to be extended.
    * @class Camera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var BaseCamera = (function () {
        function BaseCamera() {
            this.focus = new ex.Point(0, 0);
            this.lerp = false;
            this._cameraMoving = false;
            this._currentLerpTime = 0;
            this._lerpDuration = 1 * 1000; // 5 seconds
            this._totalLerpTime = 0;
            this._lerpStart = null;
            this._lerpEnd = null;
            //camera effects
            this.isShaking = false;
            this.shakeMagnitudeX = 0;
            this.shakeMagnitudeY = 0;
            this.shakeDuration = 0;
            this.elapsedShakeTime = 0;
            this.isZooming = false;
            this.currentZoomScale = 1;
            this.maxZoomScale = 1;
            this.zoomDuration = 0;
            this.elapsedZoomTime = 0;
            this.zoomIncrement = 0.01;
        }
        BaseCamera.prototype.easeInOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime * currentTime + startValue;
            currentTime -= 2;
            return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
        };
        /**
        * Sets the {{#crossLink Actor}}{{/crossLink}} to follow with the camera
        * @method setActorToFollow
        * @param actor {Actor} The actor to follow
        */
        BaseCamera.prototype.setActorToFollow = function (actor) {
            this.follow = actor;
        };
        /**
        * Returns the focal point of the camera
        * @method getFocus
        * @returns Point
        */
        BaseCamera.prototype.getFocus = function () {
            return this.focus;
        };
        /**
        * Sets the focal point of the camera. This value can only be set if there is no actor to be followed.
        * @method setFocus
        * @param x {number} The x coordinate of the focal point
        * @param y {number} The y coordinate of the focal point
        */
        BaseCamera.prototype.setFocus = function (x, y) {
            if (!this.follow && !this.lerp) {
                this.focus.x = x;
                this.focus.y = y;
            }
            if (this.lerp) {
                this._lerpStart = this.focus.clone();
                this._lerpEnd = new ex.Point(x, y);
                this._currentLerpTime = 0;
                this._cameraMoving = true;
            }
        };
        /**
        * Sets the camera to shake at the specified magnitudes for the specified duration
        * @method shake
        * @param magnitudeX {number} the x magnitude of the shake
        * @param magnitudeY {number} the y magnitude of the shake
        * @param duration {number} the duration of the shake
        */
        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {
            this.isShaking = true;
            this.shakeMagnitudeX = magnitudeX;
            this.shakeMagnitudeY = magnitudeY;
            this.shakeDuration = duration;
        };
        /**
        * Zooms the camera in or out by the specified scale over the specified duration.
        * If no duration is specified, it will zoom by a set amount until the scale is reached.
        * @method zoom
        * @param scale {number} the scale of the zoom
        * @param [duration] {number} the duration of the zoom
        */
        BaseCamera.prototype.zoom = function (scale, duration) {
            this.isZooming = true;
            this.maxZoomScale = scale;
            this.zoomDuration = duration | 0;
            if (duration) {
                this.zoomIncrement = Math.abs(this.maxZoomScale - this.currentZoomScale) / duration * 1000;
            }
            if (this.maxZoomScale < 1) {
                if (duration) {
                    this.zoomIncrement = -1 * this.zoomIncrement;
                }
                else {
                    this.isZooming = false;
                    this.setCurrentZoomScale(this.maxZoomScale);
                }
            }
            else {
                if (!duration) {
                    this.isZooming = false;
                    this.setCurrentZoomScale(this.maxZoomScale);
                }
            }
            // console.log("zoom increment: " + this.zoomIncrement);
        };
        /**
        * gets the current zoom scale
        * @method getZoom
        * @returns {Number} the current zoom scale
        */
        BaseCamera.prototype.getZoom = function () {
            return this.currentZoomScale;
        };
        BaseCamera.prototype.setCurrentZoomScale = function (zoomScale) {
            this.currentZoomScale = zoomScale;
        };
        /**
        * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
        * @method update
        * @param delta {number} The number of milliseconds since the last update
        */
        BaseCamera.prototype.update = function (ctx, delta) {
            var focus = this.getFocus();
            var xShake = 0;
            var yShake = 0;
            var canvasWidth = ctx.canvas.width;
            var canvasHeight = ctx.canvas.height;
            var newCanvasWidth = canvasWidth * this.getZoom();
            var newCanvasHeight = canvasHeight * this.getZoom();
            if (this.lerp) {
                if (this._currentLerpTime < this._lerpDuration && this._cameraMoving) {
                    if (this._lerpEnd.x < this._lerpStart.x) {
                        this.focus.x = this._lerpStart.x - (this.easeInOutCubic(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                    }
                    else {
                        this.focus.x = this.easeInOutCubic(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                    }
                    if (this._lerpEnd.y < this._lerpStart.y) {
                        this.focus.y = this._lerpStart.y - (this.easeInOutCubic(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                    }
                    else {
                        this.focus.y = this.easeInOutCubic(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                    }
                    this._currentLerpTime += delta;
                }
                else {
                    this._lerpStart = null;
                    this._lerpEnd = null;
                    this._currentLerpTime = 0;
                    this._cameraMoving = false;
                }
            }
            if (this.isDoneShaking()) {
                this.isShaking = false;
                this.elapsedShakeTime = 0;
                this.shakeMagnitudeX = 0;
                this.shakeMagnitudeY = 0;
                this.shakeDuration = 0;
            }
            else {
                this.elapsedShakeTime += delta;
                xShake = (Math.random() * this.shakeMagnitudeX | 0) + 1;
                yShake = (Math.random() * this.shakeMagnitudeY | 0) + 1;
            }
            ctx.translate(-focus.x + xShake + (newCanvasWidth / 2), -focus.y + yShake + (newCanvasHeight / 2));
            if (this.isDoneZooming()) {
                this.isZooming = false;
                this.elapsedZoomTime = 0;
                this.zoomDuration = 0;
                this.setCurrentZoomScale(this.maxZoomScale);
            }
            else {
                this.elapsedZoomTime += delta;
                this.setCurrentZoomScale(this.getZoom() + this.zoomIncrement * delta / 1000);
            }
            ctx.scale(this.getZoom(), this.getZoom());
        };
        BaseCamera.prototype.debugDraw = function (ctx) {
            var focus = this.getFocus();
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        BaseCamera.prototype.isDoneShaking = function () {
            return !(this.isShaking) || (this.elapsedShakeTime >= this.shakeDuration);
        };
        BaseCamera.prototype.isDoneZooming = function () {
            if (this.zoomDuration != 0) {
                return (this.elapsedZoomTime >= this.zoomDuration);
            }
            else {
                if (this.maxZoomScale < 1) {
                    return (this.currentZoomScale <= this.maxZoomScale);
                }
                else {
                    return (this.currentZoomScale >= this.maxZoomScale);
                }
            }
        };
        return BaseCamera;
    })();
    ex.BaseCamera = BaseCamera;
    /**
    * An extension of BaseCamera that is locked vertically; it will only move side to side.
    * @class SideCamera
    * @extends BaseCamera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var SideCamera = (function (_super) {
        __extends(SideCamera, _super);
        function SideCamera() {
            _super.apply(this, arguments);
        }
        SideCamera.prototype.getFocus = function () {
            if (this.follow) {
                return new ex.Point(this.follow.x + this.follow.getWidth() / 2, this.focus.y);
            }
            else {
                return this.focus;
            }
        };
        return SideCamera;
    })(BaseCamera);
    ex.SideCamera = SideCamera;
    /**
    * An extension of BaseCamera that is locked to an actor or focal point; the actor will appear in the center of the screen.
    * @class TopCamera
    * @extends BaseCamera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var TopCamera = (function (_super) {
        __extends(TopCamera, _super);
        function TopCamera() {
            _super.apply(this, arguments);
        }
        TopCamera.prototype.getFocus = function () {
            if (this.follow) {
                return new ex.Point(this.follow.x + this.follow.getWidth() / 2, this.follow.y + this.follow.getHeight() / 2);
            }
            else {
                return this.focus;
            }
        };
        return TopCamera;
    })(BaseCamera);
    ex.TopCamera = TopCamera;
})(ex || (ex = {}));
/// <reference path="Class.ts" />
/// <reference path="Timer.ts" />
/// <reference path="Collision/NaiveCollisionResolver.ts"/>
/// <reference path="Collision/DynamicTreeCollisionResolver.ts"/>
/// <reference path="CollisionPair.ts" />
/// <reference path="Camera.ts" />
var ex;
(function (ex) {
    /**
     * Actors are composed together into groupings called Scenes in
     * Excalibur. The metaphor models the same idea behind real world
     * actors in a scene. Only actors in scenes will be updated and drawn.
     * @class Scene
     * @constructor
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(engine) {
            _super.call(this);
            /**
             * The actors in the current scene
             * @property children {Actor[]}
             */
            this.children = [];
            this.tileMaps = [];
            this.uiActors = [];
            this._collisionResolver = new ex.DynamicTreeCollisionResolver();
            this._killQueue = [];
            this._timers = [];
            this._cancelQueue = [];
            this._isInitialized = false;
            this.camera = new ex.BaseCamera();
            if (engine) {
                this.camera.setFocus(engine.width / 2, engine.height / 2);
            }
        }
        /**
         * This is called when the scene is made active and started. It is meant to be overriden,
         * this is where you should setup any DOM UI or event handlers needed for the scene.
         * @method onActivate
         */
        Scene.prototype.onActivate = function () {
            // will be overridden
        };
        /**
         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,
         * this is where you should cleanup any DOM UI or event handlers needed for the scene.
         * @method onDeactivate
         */
        Scene.prototype.onDeactivate = function () {
            // will be overridden
        };
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         * @method onInitialize
         * @param engine {Engine}
         */
        Scene.prototype.onInitialize = function (engine) {
            // will be overridden
        };
        /**
         * Publish an event to all actors in the scene
         * @method publish
         * @param eventType {string} The name of the event to publish
         * @param event {GameEvent} The event object to send
         */
        Scene.prototype.publish = function (eventType, event) {
            this.children.forEach(function (actor) {
                actor.triggerEvent(eventType, event);
            });
        };
        /**
         * Updates all the actors and timers in the Scene. Called by the Engine.
         * @method update
         * @param engine {Engine} Reference to the current Engine
         * @param delta {number} The number of milliseconds since the last update
         */
        Scene.prototype.update = function (engine, delta) {
            if (!this._isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.publish('initialize', new ex.InitializeEvent(engine));
                this._isInitialized = true;
            }
            this.uiActors.forEach(function (ui) {
                ui.update(engine, delta);
            });
            this.tileMaps.forEach(function (cm) {
                cm.update(engine, delta);
            });
            var len = 0;
            for (var i = 0, len = this.children.length; i < len; i++) {
                this.children[i].update(engine, delta);
            }
            // Run collision resolution strategy
            if (this._collisionResolver) {
                this._collisionResolver.update(this.children);
                this._collisionResolver.evaluate(this.children);
            }
            // Remove actors from scene graph after being killed
            var actorIndex = 0;
            for (var i = 0, len = this._killQueue.length; i < len; i++) {
                actorIndex = this.children.indexOf(this._killQueue[i]);
                if (actorIndex > -1) {
                    this.children.splice(actorIndex, 1);
                }
            }
            this._killQueue.length = 0;
            // Remove timers in the cancel queue before updating them
            var timerIndex = 0;
            for (var i = 0, len = this._cancelQueue.length; i < len; i++) {
                this.removeTimer(this._cancelQueue[i]);
            }
            this._cancelQueue.length = 0;
            // Cycle through timers updating timers
            var that = this;
            this._timers = this._timers.filter(function (timer) {
                timer.update(delta);
                return !timer.complete;
            });
        };
        /**
         * Draws all the actors in the Scene. Called by the Engine.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         * @param delta {number} The number of milliseconds since the last draw
         */
        Scene.prototype.draw = function (ctx, delta) {
            ctx.save();
            if (this.camera) {
                this.camera.update(ctx, delta);
            }
            this.tileMaps.forEach(function (cm) {
                cm.draw(ctx, delta);
            });
            var len = 0;
            var start = 0;
            var end = 0;
            var actor;
            for (var i = 0, len = this.children.length; i < len; i++) {
                actor = this.children[i];
                // only draw actors that are visible
                if (actor.visible) {
                    this.children[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                ctx.strokeStyle = 'yellow';
                this.debugDraw(ctx);
            }
            ctx.restore();
            this.uiActors.forEach(function (ui) {
                if (ui.visible) {
                    ui.draw(ctx, delta);
                }
            });
            if (this.engine && this.engine.isDebug) {
                this.uiActors.forEach(function (ui) {
                    ui.debugDraw(ctx);
                });
            }
        };
        /**
         * Draws all the actors' debug information in the Scene. Called by the Engine.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         */
        Scene.prototype.debugDraw = function (ctx) {
            this.tileMaps.forEach(function (map) {
                map.debugDraw(ctx);
            });
            this.children.forEach(function (actor) {
                actor.debugDraw(ctx);
            });
            // todo possibly enable this with excalibur flags features?
            //this._collisionResolver.debugDraw(ctx, 20);
            //this.camera.debugDraw(ctx);
        };
        Scene.prototype.add = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.addUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.addChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.addTileMap(entity);
            }
        };
        Scene.prototype.remove = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.removeUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this._collisionResolver.remove(entity);
                this.removeChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.removeTileMap(entity);
            }
        };
        /**
         * Adds an actor to act as a piece of UI, meaning it is always positioned
         * in screen coordinates. UI actors do not participate in collisions
         * @method addUIActor
         * @param actor {Actor}
         */
        Scene.prototype.addUIActor = function (actor) {
            this.uiActors.push(actor);
        };
        /**
         * Removes an actor as a piec of UI
         * @method removeUIActor
         * @param actor {Actor}
         */
        Scene.prototype.removeUIActor = function (actor) {
            var index = this.uiActors.indexOf(actor);
            if (index > -1) {
                this.uiActors.splice(index, 1);
            }
        };
        /**
         * Adds an actor to the Scene, once this is done the actor will be drawn and updated.
         * @method addChild
         * @param actor {Actor}
         */
        Scene.prototype.addChild = function (actor) {
            this._collisionResolver.register(actor);
            actor.scene = this;
            this.children.push(actor);
            actor.parent = this.actor;
        };
        /**
         * Adds a TileMap to the Scene, once this is done the TileMap will be drawn and updated.
         * @method addTileMap
         * @param tileMap {TileMap}
         */
        Scene.prototype.addTileMap = function (tileMap) {
            this.tileMaps.push(tileMap);
        };
        /**
         * Removes a TileMap from the Scene, it willno longer be drawn or updated.
         * @method removeTileMap
         * @param tileMap {TileMap}
         */
        Scene.prototype.removeTileMap = function (tileMap) {
            var index = this.tileMaps.indexOf(tileMap);
            if (index > -1) {
                this.tileMaps.splice(index, 1);
            }
        };
        /**
         * Removes an actor from the Scene, it will no longer be drawn or updated.
         * @method removeChild
         * @param actor {Actor} The actor to remove
         */
        Scene.prototype.removeChild = function (actor) {
            this._collisionResolver.remove(actor);
            this._killQueue.push(actor);
            actor.parent = null;
        };
        /**
         * Adds a timer to the Scene
         * @method addTimer
         * @param timer {Timer} The timer to add
         * @returns Timer
         */
        Scene.prototype.addTimer = function (timer) {
            this._timers.push(timer);
            timer.scene = this;
            return timer;
        };
        /**
         * Removes a timer to the Scene, can be dangerous
         * @method removeTimer
         * @private
         * @param timer {Timer} The timer to remove
         * @returns Timer
         */
        Scene.prototype.removeTimer = function (timer) {
            var i = this._timers.indexOf(timer);
            if (i !== -1) {
                this._timers.splice(i, 1);
            }
            return timer;
        };
        /**
         * Cancels a timer, removing it from the scene nicely
         * @method cancelTimer
         * @param timer {Timer} The timer to cancel
         * @returns Timer
         */
        Scene.prototype.cancelTimer = function (timer) {
            this._cancelQueue.push(timer);
            return timer;
        };
        /**
         * Tests whether a timer is active in the scene
         * @method isTimerActive
         * @param timer {Timer}
         * @returns boolean
         */
        Scene.prototype.isTimerActive = function (timer) {
            return (this._timers.indexOf(timer) > -1);
        };
        return Scene;
    })(ex.Class);
    ex.Scene = Scene;
})(ex || (ex = {}));
/// <reference path="Algebra.ts" />
/// <reference path="Engine.ts" />
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    var Internal;
    (function (Internal) {
        var Actions;
        (function (Actions) {
            var EaseTo = (function () {
                function EaseTo(actor, x, y, duration, easingFcn) {
                    this.actor = actor;
                    this.easingFcn = easingFcn;
                    this._currentLerpTime = 0;
                    this._lerpDuration = 1 * 1000; // 5 seconds
                    this._lerpStart = new ex.Point(0, 0);
                    this._lerpEnd = new ex.Point(0, 0);
                    this._initialized = false;
                    this._stopped = false;
                    this._distance = 0;
                    this._lerpDuration = duration;
                    this._lerpEnd = new ex.Point(x, y);
                }
                EaseTo.prototype._initialize = function () {
                    this._lerpStart = new ex.Point(this.actor.x, this.actor.y);
                    this._currentLerpTime = 0;
                    this._distance = this._lerpStart.toVector().distance(this._lerpEnd.toVector());
                };
                EaseTo.prototype.update = function (delta) {
                    if (!this._initialized) {
                        this._initialize();
                        this._initialized = true;
                    }
                    var newX = this.actor.x;
                    var newY = this.actor.y;
                    if (this._currentLerpTime < this._lerpDuration) {
                        if (this._lerpEnd.x < this._lerpStart.x) {
                            newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                        }
                        else {
                            newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                        }
                        if (this._lerpEnd.y < this._lerpStart.y) {
                            newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                        }
                        else {
                            newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                        }
                        this.actor.x = newX;
                        this.actor.y = newY;
                        this._currentLerpTime += delta;
                    }
                    else {
                        this.actor.x = this._lerpEnd.x;
                        this.actor.y = this._lerpEnd.y;
                    }
                };
                EaseTo.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this._lerpStart.toVector()) >= this._distance;
                };
                EaseTo.prototype.reset = function () {
                    this._initialized = false;
                };
                EaseTo.prototype.stop = function () {
                    this._stopped = true;
                };
                return EaseTo;
            })();
            Actions.EaseTo = EaseTo;
            var MoveTo = (function () {
                function MoveTo(actor, destx, desty, speed) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = new ex.Vector(destx, desty);
                    this.speed = speed;
                }
                MoveTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = new ex.Vector(this.actor.x, this.actor.y);
                        this.distance = this.start.distance(this.end);
                        this.dir = this.end.minus(this.start).normalize();
                    }
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                MoveTo.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this.start) >= this.distance;
                };
                MoveTo.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                MoveTo.prototype.reset = function () {
                    this._started = false;
                };
                return MoveTo;
            })();
            Actions.MoveTo = MoveTo;
            var MoveBy = (function () {
                function MoveBy(actor, destx, desty, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = new ex.Vector(destx, desty);
                    if (time <= 0) {
                        ex.Logger.getInstance().error("Attempted to moveBy time less than or equal to zero : " + time);
                        throw new Error("Cannot move in time <= 0");
                    }
                    this.time = time;
                }
                MoveBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = new ex.Vector(this.actor.x, this.actor.y);
                        this.distance = this.start.distance(this.end);
                        this.dir = this.end.minus(this.start).normalize();
                        this.speed = this.distance / (this.time / 1000);
                    }
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                MoveBy.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this.start) >= this.distance;
                };
                MoveBy.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                MoveBy.prototype.reset = function () {
                    this._started = false;
                };
                return MoveBy;
            })();
            Actions.MoveBy = MoveBy;
            var Follow = (function () {
                function Follow(actor, actorToFollow, followDistance) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.actorToFollow = actorToFollow;
                    this.current = new ex.Vector(this.actor.x, this.actor.y);
                    this.end = new ex.Vector(actorToFollow.x, actorToFollow.y);
                    this.maximumDistance = (followDistance != undefined) ? followDistance : this.current.distance(this.end);
                    this.speed = 0;
                }
                Follow.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.distanceBetween = this.current.distance(this.end);
                        this.dir = this.end.minus(this.current).normalize();
                    }
                    var actorToFollowSpeed = Math.sqrt(Math.pow(this.actorToFollow.dx, 2) + Math.pow(this.actorToFollow.dy, 2));
                    if (actorToFollowSpeed != 0) {
                        this.speed = actorToFollowSpeed;
                    }
                    this.current.x = this.actor.x;
                    this.current.y = this.actor.y;
                    this.end.x = this.actorToFollow.x;
                    this.end.y = this.actorToFollow.y;
                    this.distanceBetween = this.current.distance(this.end);
                    this.dir = this.end.minus(this.current).normalize();
                    if (this.distanceBetween >= this.maximumDistance) {
                        var m = this.dir.scale(this.speed);
                        this.actor.dx = m.x;
                        this.actor.dy = m.y;
                    }
                    else {
                        this.actor.dx = 0;
                        this.actor.dy = 0;
                    }
                    if (this.isComplete(this.actor)) {
                        // TODO this should never occur
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                Follow.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                Follow.prototype.isComplete = function (actor) {
                    // the actor following should never stop unless specified to do so
                    return this._stopped;
                };
                Follow.prototype.reset = function () {
                    this._started = false;
                };
                return Follow;
            })();
            Actions.Follow = Follow;
            var Meet = (function () {
                function Meet(actor, actorToMeet, speed) {
                    this._started = false;
                    this._stopped = false;
                    this._speedWasSpecified = false;
                    this.actor = actor;
                    this.actorToMeet = actorToMeet;
                    this.current = new ex.Vector(this.actor.x, this.actor.y);
                    this.end = new ex.Vector(actorToMeet.x, actorToMeet.y);
                    this.speed = speed || 0;
                    if (speed != undefined) {
                        this._speedWasSpecified = true;
                    }
                }
                Meet.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.distanceBetween = this.current.distance(this.end);
                        this.dir = this.end.minus(this.current).normalize();
                    }
                    var actorToMeetSpeed = Math.sqrt(Math.pow(this.actorToMeet.dx, 2) + Math.pow(this.actorToMeet.dy, 2));
                    if ((actorToMeetSpeed != 0) && (!this._speedWasSpecified)) {
                        this.speed = actorToMeetSpeed;
                    }
                    this.current.x = this.actor.x;
                    this.current.y = this.actor.y;
                    this.end.x = this.actorToMeet.x;
                    this.end.y = this.actorToMeet.y;
                    this.distanceBetween = this.current.distance(this.end);
                    this.dir = this.end.minus(this.current).normalize();
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    if (this.isComplete(this.actor)) {
                        // console.log("meeting is complete")
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                Meet.prototype.isComplete = function (actor) {
                    return this._stopped || (this.distanceBetween <= 1);
                };
                Meet.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                Meet.prototype.reset = function () {
                    this._started = false;
                };
                return Meet;
            })();
            Actions.Meet = Meet;
            var RotateTo = (function () {
                function RotateTo(actor, angleRadians, speed) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = angleRadians;
                    this.speed = speed;
                }
                RotateTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = this.actor.rotation;
                        this.distance = Math.abs(this.end - this.start);
                    }
                    this.actor.rx = this.speed;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.rotation = this.end;
                        this.actor.rx = 0;
                    }
                };
                RotateTo.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.rotation - this.start) >= this.distance);
                };
                RotateTo.prototype.stop = function () {
                    this.actor.rx = 0;
                    this._stopped = true;
                };
                RotateTo.prototype.reset = function () {
                    this._started = false;
                };
                return RotateTo;
            })();
            Actions.RotateTo = RotateTo;
            var RotateBy = (function () {
                function RotateBy(actor, angleRadians, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = angleRadians;
                    this.time = time;
                    this.speed = (this.end - this.actor.rotation) / time * 1000;
                }
                RotateBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = this.actor.rotation;
                        this.distance = Math.abs(this.end - this.start);
                    }
                    this.actor.rx = this.speed;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.rotation = this.end;
                        this.actor.rx = 0;
                    }
                };
                RotateBy.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.rotation - this.start) >= this.distance);
                };
                RotateBy.prototype.stop = function () {
                    this.actor.rx = 0;
                    this._stopped = true;
                };
                RotateBy.prototype.reset = function () {
                    this._started = false;
                };
                return RotateBy;
            })();
            Actions.RotateBy = RotateBy;
            var ScaleTo = (function () {
                function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endX = scaleX;
                    this.endY = scaleY;
                    this.speedX = speedX;
                    this.speedY = speedY;
                }
                ScaleTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.startX = this.actor.scale.x;
                        this.startY = this.actor.scale.y;
                        this.distanceX = Math.abs(this.endX - this.startX);
                        this.distanceY = Math.abs(this.endY - this.startY);
                    }
                    if (!(Math.abs(this.actor.scale.x - this.startX) >= this.distanceX)) {
                        var directionX = this.endY < this.startY ? -1 : 1;
                        this.actor.sx = this.speedX * directionX;
                    }
                    else {
                        this.actor.sx = 0;
                    }
                    if (!(Math.abs(this.actor.scale.y - this.startY) >= this.distanceY)) {
                        var directionY = this.endY < this.startY ? -1 : 1;
                        this.actor.sy = this.speedY * directionY;
                    }
                    else {
                        this.actor.sy = 0;
                    }
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.scale.x = this.endX;
                        this.actor.scale.y = this.endY;
                        this.actor.sx = 0;
                        this.actor.sy = 0;
                    }
                };
                ScaleTo.prototype.isComplete = function (actor) {
                    return this._stopped || ((Math.abs(this.actor.scale.y - this.startX) >= this.distanceX) && (Math.abs(this.actor.scale.y - this.startY) >= this.distanceY));
                };
                ScaleTo.prototype.stop = function () {
                    this.actor.sx = 0;
                    this.actor.sy = 0;
                    this._stopped = true;
                };
                ScaleTo.prototype.reset = function () {
                    this._started = false;
                };
                return ScaleTo;
            })();
            Actions.ScaleTo = ScaleTo;
            var ScaleBy = (function () {
                function ScaleBy(actor, scaleX, scaleY, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endX = scaleX;
                    this.endY = scaleY;
                    this.time = time;
                    this.speedX = (this.endX - this.actor.scale.x) / time * 1000;
                    this.speedY = (this.endY - this.actor.scale.y) / time * 1000;
                }
                ScaleBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.startX = this.actor.scale.x;
                        this.startY = this.actor.scale.y;
                        this.distanceX = Math.abs(this.endX - this.startX);
                        this.distanceY = Math.abs(this.endY - this.startY);
                    }
                    var directionX = this.endX < this.startX ? -1 : 1;
                    var directionY = this.endY < this.startY ? -1 : 1;
                    this.actor.sx = this.speedX * directionX;
                    this.actor.sy = this.speedY * directionY;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.scale.x = this.endX;
                        this.actor.scale.y = this.endY;
                        this.actor.sx = 0;
                        this.actor.sy = 0;
                    }
                };
                ScaleBy.prototype.isComplete = function (actor) {
                    return this._stopped || ((Math.abs(this.actor.scale.x - this.startX) >= this.distanceX) && (Math.abs(this.actor.scale.y - this.startY) >= this.distanceY));
                };
                ScaleBy.prototype.stop = function () {
                    this.actor.sx = 0;
                    this.actor.sy = 0;
                    this._stopped = true;
                };
                ScaleBy.prototype.reset = function () {
                    this._started = false;
                };
                return ScaleBy;
            })();
            Actions.ScaleBy = ScaleBy;
            var Delay = (function () {
                function Delay(actor, delay) {
                    this.elapsedTime = 0;
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.delay = delay;
                }
                Delay.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    this.elapsedTime += delta;
                };
                Delay.prototype.isComplete = function (actor) {
                    return this._stopped || (this.elapsedTime >= this.delay);
                };
                Delay.prototype.stop = function () {
                    this._stopped = true;
                };
                Delay.prototype.reset = function () {
                    this.elapsedTime = 0;
                    this._started = false;
                };
                return Delay;
            })();
            Actions.Delay = Delay;
            var Blink = (function () {
                function Blink(actor, timeVisible, timeNotVisible, numBlinks) {
                    if (numBlinks === void 0) { numBlinks = 1; }
                    this.timeVisible = 0;
                    this.timeNotVisible = 0;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                    this._stopped = false;
                    this._started = false;
                    this.actor = actor;
                    this.timeVisible = timeVisible;
                    this.timeNotVisible = timeNotVisible;
                    this.duration = (timeVisible + timeNotVisible) * numBlinks;
                }
                Blink.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    this.elapsedTime += delta;
                    this.totalTime += delta;
                    if (this.actor.visible && this.elapsedTime >= this.timeVisible) {
                        this.actor.visible = false;
                        this.elapsedTime = 0;
                    }
                    if (!this.actor.visible && this.elapsedTime >= this.timeNotVisible) {
                        this.actor.visible = true;
                        this.elapsedTime = 0;
                    }
                    if (this.isComplete(this.actor)) {
                        this.actor.visible = true;
                    }
                };
                Blink.prototype.isComplete = function (actor) {
                    return this._stopped || (this.totalTime >= this.duration);
                };
                Blink.prototype.stop = function () {
                    this.actor.visible = true;
                    this._stopped = true;
                };
                Blink.prototype.reset = function () {
                    this._started = false;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                };
                return Blink;
            })();
            Actions.Blink = Blink;
            var Fade = (function () {
                function Fade(actor, endOpacity, speed) {
                    this.multiplyer = 1;
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endOpacity = endOpacity;
                    this.speed = speed;
                    if (endOpacity < actor.opacity) {
                        this.multiplyer = -1;
                    }
                }
                Fade.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    if (this.speed > 0) {
                        this.actor.opacity += this.multiplyer * (Math.abs(this.actor.opacity - this.endOpacity) * delta) / this.speed;
                    }
                    this.speed -= delta;
                    ex.Logger.getInstance().debug("actor opacity: " + this.actor.opacity);
                    if (this.isComplete(this.actor)) {
                        this.actor.opacity = this.endOpacity;
                    }
                };
                Fade.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.opacity - this.endOpacity) < 0.05);
                };
                Fade.prototype.stop = function () {
                    this._stopped = true;
                };
                Fade.prototype.reset = function () {
                    this._started = false;
                };
                return Fade;
            })();
            Actions.Fade = Fade;
            var Die = (function () {
                function Die(actor) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                }
                Die.prototype.update = function (delta) {
                    this.actor.actionQueue.clearActions();
                    this.actor.kill();
                    this._stopped = true;
                };
                Die.prototype.isComplete = function () {
                    return this._stopped;
                };
                Die.prototype.stop = function () {
                };
                Die.prototype.reset = function () {
                };
                return Die;
            })();
            Actions.Die = Die;
            var CallMethod = (function () {
                function CallMethod(actor, method) {
                    this._method = null;
                    this._actor = null;
                    this._hasBeenCalled = false;
                    this._actor = actor;
                    this._method = method;
                }
                CallMethod.prototype.update = function (delta) {
                    this._method.call(this._actor);
                    this._hasBeenCalled = true;
                };
                CallMethod.prototype.isComplete = function (actor) {
                    return this._hasBeenCalled;
                };
                CallMethod.prototype.reset = function () {
                    this._hasBeenCalled = false;
                };
                CallMethod.prototype.stop = function () {
                    this._hasBeenCalled = true;
                };
                return CallMethod;
            })();
            Actions.CallMethod = CallMethod;
            var Repeat = (function () {
                function Repeat(actor, repeat, actions) {
                    var _this = this;
                    this._stopped = false;
                    this.actor = actor;
                    this.actionQueue = new ActionQueue(actor);
                    this.repeat = repeat;
                    this.originalRepeat = repeat;
                    actions.forEach(function (action) {
                        action.reset();
                        _this.actionQueue.add(action);
                    });
                }
                Repeat.prototype.update = function (delta) {
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    if (!this.actionQueue.hasNext()) {
                        this.actionQueue.reset();
                        this.repeat--;
                    }
                    this.actionQueue.update(delta);
                };
                Repeat.prototype.isComplete = function () {
                    return this._stopped || (this.repeat <= 0);
                };
                Repeat.prototype.stop = function () {
                    this._stopped = true;
                };
                Repeat.prototype.reset = function () {
                    this.repeat = this.originalRepeat;
                };
                return Repeat;
            })();
            Actions.Repeat = Repeat;
            var RepeatForever = (function () {
                function RepeatForever(actor, actions) {
                    var _this = this;
                    this._stopped = false;
                    this.actor = actor;
                    this.actionQueue = new ActionQueue(actor);
                    actions.forEach(function (action) {
                        action.reset();
                        _this.actionQueue.add(action);
                    });
                }
                RepeatForever.prototype.update = function (delta) {
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    if (this._stopped) {
                        return;
                    }
                    if (!this.actionQueue.hasNext()) {
                        this.actionQueue.reset();
                    }
                    this.actionQueue.update(delta);
                };
                RepeatForever.prototype.isComplete = function () {
                    return this._stopped;
                };
                RepeatForever.prototype.stop = function () {
                    this._stopped = true;
                    this.actionQueue.clearActions();
                };
                RepeatForever.prototype.reset = function () {
                };
                return RepeatForever;
            })();
            Actions.RepeatForever = RepeatForever;
            var ActionQueue = (function () {
                function ActionQueue(actor) {
                    this._actions = [];
                    this._completedActions = [];
                    this.actor = actor;
                }
                ActionQueue.prototype.add = function (action) {
                    this._actions.push(action);
                };
                ActionQueue.prototype.remove = function (action) {
                    var index = this._actions.indexOf(action);
                    this._actions.splice(index, 1);
                };
                ActionQueue.prototype.clearActions = function () {
                    this._actions.length = 0;
                    this._completedActions.length = 0;
                    this._currentAction.stop();
                };
                ActionQueue.prototype.getActions = function () {
                    return this._actions.concat(this._completedActions);
                };
                ActionQueue.prototype.hasNext = function () {
                    return this._actions.length > 0;
                };
                ActionQueue.prototype.reset = function () {
                    this._actions = this.getActions();
                    this._actions.forEach(function (action) {
                        action.reset();
                    });
                    this._completedActions = [];
                };
                ActionQueue.prototype.update = function (delta) {
                    if (this._actions.length > 0) {
                        this._currentAction = this._actions[0];
                        this._currentAction.update(delta);
                        if (this._currentAction.isComplete(this.actor)) {
                            //Logger.getInstance().log("Action complete!", Log.DEBUG);
                            this._completedActions.push(this._actions.shift());
                        }
                    }
                };
                return ActionQueue;
            })();
            Actions.ActionQueue = ActionQueue;
        })(Actions = Internal.Actions || (Internal.Actions = {}));
    })(Internal = ex.Internal || (ex.Internal = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var EasingFunctions = (function () {
        function EasingFunctions() {
        }
        /*
       easeInQuad: function (t) { return t * t },
       // decelerating to zero velocity
       easeOutQuad: function (t) { return t * (2 - t) },
       // acceleration until halfway, then deceleration
       easeInOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
       // accelerating from zero velocity
       easeInCubic: function (t) { return t * t * t },
       // decelerating to zero velocity
       easeOutCubic: function (t) { return (--t) * t * t + 1 },
       // acceleration until halfway, then deceleration
       easeInOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
       // accelerating from zero velocity
       easeInQuart: function (t) { return t * t * t * t },
       // decelerating to zero velocity
       easeOutQuart: function (t) { return 1 - (--t) * t * t * t },
       // acceleration until halfway, then deceleration
       easeInOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
       // accelerating from zero velocity
       easeInQuint: function (t) { return t * t * t * t * t },
       // decelerating to zero velocity
       easeOutQuint: function (t) { return 1 + (--t) * t * t * t * t },
       // acceleration until halfway, then deceleration
       easeInOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t }
        */
        EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            return endValue * currentTime / duration + startValue;
        };
        EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {
            //endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * currentTime * currentTime + startValue;
        };
        EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {
            //endValue = (endValue - startValue);
            currentTime /= duration;
            return -endValue * currentTime * (currentTime - 2) + startValue;
        };
        EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime + startValue;
            currentTime--;
            return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
        };
        EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * currentTime * currentTime * currentTime + startValue;
        };
        EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
        };
        EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime * currentTime + startValue;
            currentTime -= 2;
            return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
        };
        return EasingFunctions;
    })();
    ex.EasingFunctions = EasingFunctions;
})(ex || (ex = {}));
/// <reference path="Interfaces/IDrawable.ts" />
/// <reference path="Modules/MovementModule.ts" />
/// <reference path="Modules/OffscreenCullingModule.ts" />
/// <reference path="Modules/CapturePointerModule.ts" />
/// <reference path="Modules/CollisionDetectionModule.ts" />
/// <reference path="Collision/Side.ts" />
/// <reference path="Algebra.ts" />
/// <reference path="Util.ts" />
/// <reference path="TileMap.ts" />
/// <reference path="Collision/BoundingBox.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Action.ts" />
/// <reference path="EasingFunctions.ts"/>
var ex;
(function (ex) {
    /**
     * An enum that describes the types of collisions actors can participate in
     * @class CollisionType
     */
    (function (CollisionType) {
        /**
         * Actors with the PreventCollision setting do not participate in any
         * collisions and do not raise collision events.
         * @property PreventCollision {CollisionType}
         * @static
         */
        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";
        /**
         * Actors with the Passive setting only raise collision events, but are not
         * influenced or moved by other actors and do not influence or move other actors.
         * @property Passive {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Passive"] = 1] = "Passive";
        /**
         * Actors with the Active setting raise collision events and participate
         * in collisions with other actors and will be push or moved by actors sharing
         * the Active or Fixed setting.
         * @property Active {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Active"] = 2] = "Active";
        /**
         * Actors with the Elastic setting will behave the same as Active, except that they will
         * "bounce" in the opposite direction given their velocity dx/dy. This is a naive implementation meant for
         * prototyping, for a more robust elastic collision listen to the "collision" event and perform your custom logic.
         * @property Elastic {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Elastic"] = 3] = "Elastic";
        /**
         * Actors with the Fixed setting raise collision events and participate in
         * collisions with other actors. Actors with the Fixed setting will not be
         * pushed or moved by other actors sharing the Fixed or Actors. Think of Fixed
         * actors as "immovable/onstoppable" objects. If two Fixed actors meet they will
         * not be pushed or moved by each other, they will not interact except to throw
         * collision events.
         * @property Fixed {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Fixed"] = 4] = "Fixed";
    })(ex.CollisionType || (ex.CollisionType = {}));
    var CollisionType = ex.CollisionType;
    /**
     * The most important primitive in Excalibur is an "Actor." Anything that
     * can move on the screen, collide with another Actor, respond to events,
     * or interact with the current scene, must be an actor. An Actor <b>must</b>
     * be part of a {{#crossLink "Scene"}}{{/crossLink}} for it to be drawn to the screen.
     * @class Actor
     * @extends Class
     * @constructor
     * @param [x=0.0] {number} The starting x coordinate of the actor
     * @param [y=0.0] {number} The starting y coordinate of the actor
     * @param [width=0.0] {number} The starting width of the actor
     * @param [height=0.0] {number} The starting height of the actor
     * @param [color=undefined] {Color} The starting color of the actor
     */
    var Actor = (function (_super) {
        __extends(Actor, _super);
        function Actor(x, y, width, height, color) {
            _super.call(this);
            /**
             * The unique identifier for the actor
             */
            this.id = Actor.maxId++;
            /**
             * The x coordinate of the actor (left edge)
             * @property x {number}
             */
            this.x = 0;
            /**
             * The y coordinate of the actor (top edge)
             * @property y {number}
             */
            this.y = 0;
            this.height = 0;
            this.width = 0;
            /**
             * The rotation of the actor in radians
             * @property rotation {number}
             */
            this.rotation = 0; // radians
            /**
             * The rotational velocity of the actor in radians/second
             * @property rx {number}
             */
            this.rx = 0; //radions/sec
            /**
             * The scale vector of the actor
             * @property scale
             */
            this.scale = new ex.Vector(1, 1);
            /**
             * The x scalar velocity of the actor in scale/second
             * @property sx {number}
             */
            this.sx = 0; //scale/sec
            /**
             * The y scalar velocity of the actor in scale/second
             * @property sy {number}
             */
            this.sy = 0; //scale/sec
            /**
             * The x velocity of the actor in pixels/second
             * @property dx {number}
             */
            this.dx = 0; // pixels/sec
            /**
             * The x velocity of the actor in pixels/second
             * @property dx {number}
             */
            this.dy = 0;
            /**
             * The x acceleration of the actor in pixels/second^2
             * @property ax {number}
             */
            this.ax = 0; // pixels/sec/sec
            /**
             * The y acceleration of the actor in pixels/second^2
             * @property ay {number}
             */
            this.ay = 0;
            /**
             * Indicates wether the actor is physically in the viewport
             * @property isOffScreen {boolean}
             */
            this.isOffScreen = false;
            /**
             * The visibility of an actor
             * @property visible {boolean}
             */
            this.visible = true;
            /**
             * The opacity of an actor
             * @property opacity {number}
             */
            this.opacity = 1;
            this.previousOpacity = 1;
            /**
             * Convenience reference to the global logger
             * @property logger {Logger}
             */
            this.logger = ex.Logger.getInstance();
            /**
            * The scene that the actor is in
            * @property scene {Scene}
            */
            this.scene = null; //formerly "parent"
            /**
            * The parent of this actor
            * @property parent {Actor}
            */
            this.parent = null;
            /**
             * Gets or sets the current collision type of this actor. By
             * default all actors participate in Active collisions.
             * @property collisionType {CollisionType}
             */
            this.collisionType = 0 /* PreventCollision */;
            this.collisionGroups = [];
            this._collisionHandlers = {};
            this._isInitialized = false;
            this.frames = {};
            /**
             * Access to the current drawing on for the actor, this can be an {{#crossLink "Animation"}}{{/crossLink}},
             * {{#crossLink "Sprite"}}{{/crossLink}}, or {{#crossLink "Polygon"}}{{/crossLink}}.
             * Set drawings with the {{#crossLink "Actor/setDrawing:method"}}{{/crossLink}}.
             * @property currentDrawing {IDrawable}
             */
            this.currentDrawing = null;
            this.centerDrawingX = false;
            this.centerDrawingY = false;
            /**
             * Modify the current actor update pipeline.
             *
             *
             */
            this.pipeline = [];
            /**
             * Whether or not to enable the CapturePointer trait that propogates pointer events to this actor
             * @property [enableCapturePointer=false] {boolean}
             */
            this.enableCapturePointer = false;
            /**
             * Configuration for CapturePointer trait
             * @property capturePointer {ICapturePointerConfig}
             */
            this.capturePointer = {
                captureMoveEvents: false
            };
            this._isKilled = false;
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
            if (color) {
                this.color = color.clone();
                // set default opacity of an actor to the color
                this.opacity = color.a;
            }
            // Build default pipeline
            this.pipeline.push(new ex.MovementModule());
            //this.pipeline.push(new ex.CollisionDetectionModule());
            this.pipeline.push(new ex.OffscreenCullingModule());
            this.pipeline.push(new ex.CapturePointerModule());
            this.actionQueue = new ex.Internal.Actions.ActionQueue(this);
            this.sceneNode = new ex.Scene();
            this.sceneNode.actor = this;
            this.anchor = new ex.Point(.5, .5);
        }
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         * @method onInitialize
         * @param engine {Engine}
         */
        Actor.prototype.onInitialize = function (engine) {
        };
        Actor.prototype._checkForPointerOptIn = function (eventName) {
            if (eventName && (eventName.toLowerCase() === 'pointerdown' || eventName.toLowerCase() === 'pointerdown' || eventName.toLowerCase() === 'pointermove')) {
                this.enableCapturePointer = true;
                if (eventName.toLowerCase() === 'pointermove') {
                    this.capturePointer.captureMoveEvents = true;
                }
            }
        };
        /**
        * Add an event listener. You can listen for a variety of
        * events off of the engine; see the events section below for a complete list.
        * @method addEventListener
        * @param eventName {string} Name of the event to listen for
        * @param handler {event=>void} Event handler for the thrown event
        */
        Actor.prototype.addEventListener = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            _super.prototype.addEventListener.call(this, eventName, handler);
        };
        /**
         * Alias for "addEventListener". You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method on
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Actor.prototype.on = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * If the current actors is a member of the scene. This will remove
         * it from the scene graph. It will no longer be drawn or updated.
         * @method kill
         */
        Actor.prototype.kill = function () {
            if (this.scene) {
                this.scene.removeChild(this);
                this._isKilled = true;
            }
            else {
                this.logger.warn("Cannot kill actor, it was never added to the Scene");
            }
        };
        /**
         * Indicates wether the actor has been killed.
         * @method isKilled
         * @returns boolean
         */
        Actor.prototype.isKilled = function () {
            return this._isKilled;
        };
        /**
         * Adds a child actor to this actor. All movement of the child actor will be
         * relative to the parent actor. Meaning if the parent moves the child will
         * move with
         * @method addChild
         * @param actor {Actor} The child actor to add
         */
        Actor.prototype.addChild = function (actor) {
            actor.collisionType = 0 /* PreventCollision */;
            this.sceneNode.addChild(actor);
        };
        /**
         * Removes a child actor from this actor.
         * @method removeChild
         * @param actor {Actor} The child actor to remove
         */
        Actor.prototype.removeChild = function (actor) {
            this.sceneNode.removeChild(actor);
        };
        /**
         * Sets the current drawing of the actor to the drawing correspoding to
         * the key.
         * @method setDrawing
         * @param key {string} The key of the drawing
         */
        Actor.prototype.setDrawing = function (key) {
            if (this.currentDrawing != this.frames[key]) {
                this.frames[key].reset();
            }
            this.currentDrawing = this.frames[key];
        };
        Actor.prototype.addDrawing = function (args) {
            if (arguments.length === 2) {
                this.frames[arguments[0]] = arguments[1];
                if (!this.currentDrawing) {
                    this.currentDrawing = arguments[1];
                }
            }
            else {
                if (arguments[0] instanceof ex.Sprite) {
                    this.addDrawing("default", arguments[0]);
                }
                if (arguments[0] instanceof ex.Texture) {
                    this.addDrawing("default", arguments[0].asSprite());
                }
            }
        };
        /**
         * Artificially trigger an event on an actor, useful when creating custom events.
         * @method triggerEvent
         * @param eventName {string} The name of the event to trigger
         * @param [event=undefined] {GameEvent} The event object to pass to the callback
         */
        Actor.prototype.triggerEvent = function (eventName, event) {
            this.eventDispatcher.publish(eventName, event);
        };
        /**
         * Adds an actor to a collision group. Actors with no named collision group are
         * considered to be in every collision group.
         *
         * Once in a collision group(s) actors will only collide with other actors in
         * that group.
         *
         * @method addCollisionGroup
         * @param name {string} The name of the collision group
         */
        Actor.prototype.addCollisionGroup = function (name) {
            this.collisionGroups.push(name);
        };
        /**
         * Remove an actor from a collision group.
         * @method removeCollisionGroup
         * @param name {string} The name of the collision group
         */
        Actor.prototype.removeCollisionGroup = function (name) {
            var index = this.collisionGroups.indexOf(name);
            if (index !== -1) {
                this.collisionGroups.splice(index, 1);
            }
        };
        /**
         * Get the center point of an actor
         * @method getCenter
         * @returns Vector
         */
        Actor.prototype.getCenter = function () {
            var anchor = this._getCalculatedAnchor();
            return new ex.Vector(this.x + this.getWidth() / 2, this.y + this.getHeight() / 2);
        };
        /**
         * Gets the calculated width of an actor
         * @method getWidth
         * @returns number
         */
        Actor.prototype.getWidth = function () {
            return this.width * this.scale.x;
        };
        /**
         * Sets the width of an actor, factoring in the current scale
         * @method setWidth
         */
        Actor.prototype.setWidth = function (width) {
            this.width = width / this.scale.x;
        };
        /**
         * Gets the calculated height of an actor
         * @method getHeight
         * @returns number
         */
        Actor.prototype.getHeight = function () {
            return this.height * this.scale.y;
        };
        /**
         * Sets the height of an actor, factoring in the current scale
         * @method setHeight
         */
        Actor.prototype.setHeight = function (height) {
            this.height = height / this.scale.y;
        };
        /**
         * Centers the actor's drawing around the center of the actor's bounding box
         * @method setCenterDrawing
         * @param center {boolean} Indicates to center the drawing around the actor
         */
        Actor.prototype.setCenterDrawing = function (center) {
            this.centerDrawingY = center;
            this.centerDrawingX = center;
        };
        /**
         * Gets the left edge of the actor
         * @method getLeft
         * @returns number
         */
        Actor.prototype.getLeft = function () {
            return this.x;
        };
        /**
         * Gets the right edge of the actor
         * @method getRight
         * @returns number
         */
        Actor.prototype.getRight = function () {
            return this.x + this.getWidth();
        };
        /**
         * Gets the top edge of the actor
         * @method getTop
         * @returns number
         */
        Actor.prototype.getTop = function () {
            return this.y;
        };
        /**
         * Gets the bottom edge of the actor
         * @method getBottom
         * @returns number
         */
        Actor.prototype.getBottom = function () {
            return this.y + this.getHeight();
        };
        /**
        * Gets the x value of the Actor in global coordinates
        * @method getGlobalX
        * @returns number
        */
        Actor.prototype.getGlobalX = function () {
            if (!this.parent)
                return this.x;
            return this.x * this.parent.scale.y + this.parent.getGlobalX();
        };
        /**
        * Gets the y value of the Actor in global coordinates
        * @method getGlobalY
        * @returns number
        */
        Actor.prototype.getGlobalY = function () {
            if (!this.parent)
                return this.y;
            return this.y * this.parent.scale.y + this.parent.getGlobalY();
        };
        /**
         * Gets the global scale of the Actor
         * @method getGlobalScale
         * @returns Point
         */
        Actor.prototype.getGlobalScale = function () {
            if (!this.parent)
                return new ex.Point(this.scale.x, this.scale.y);
            var parentScale = this.parent.getGlobalScale();
            return new ex.Point(this.scale.x * parentScale.x, this.scale.y * parentScale.y);
        };
        /**
         * Returns the actor's bounding box calculated for this instant.
         * @method getBounds
         * @returns BoundingBox
         */
        Actor.prototype.getBounds = function () {
            var anchor = this._getCalculatedAnchor();
            return new ex.BoundingBox(this.getGlobalX() - anchor.x, this.getGlobalY() - anchor.y, this.getGlobalX() + this.getWidth() - anchor.x, this.getGlobalY() + this.getHeight() - anchor.y);
        };
        /**
         * Tests whether the x/y specified are contained in the actor
         * @method contains
         * @param x {number} X coordinate to test (in world coordinates)
         * @param y {number} Y coordinate to test (in world coordinates)
         */
        Actor.prototype.contains = function (x, y) {
            return this.getBounds().contains(new ex.Point(x, y));
        };
        /**
         * Returns the side of the collision based on the intersection
         * @method getSideFromIntersect
         * @param intersect {Vector} The displacement vector returned by a collision
         * @returns Side
        */
        Actor.prototype.getSideFromIntersect = function (intersect) {
            if (intersect) {
                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {
                    if (intersect.x < 0) {
                        return 4 /* Right */;
                    }
                    return 3 /* Left */;
                }
                else {
                    if (intersect.y < 0) {
                        return 2 /* Bottom */;
                    }
                    return 1 /* Top */;
                }
            }
            return 0 /* None */;
        };
        /**
         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.
         * @method collides
         * @param actor {Actor} The other actor to test
         * @returns Side
         */
        Actor.prototype.collidesWithSide = function (actor) {
            var separationVector = this.collides(actor);
            if (!separationVector) {
                return 0 /* None */;
            }
            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {
                if (this.x < actor.x) {
                    return 4 /* Right */;
                }
                else {
                    return 3 /* Left */;
                }
            }
            else {
                if (this.y < actor.y) {
                    return 2 /* Bottom */;
                }
                else {
                    return 1 /* Top */;
                }
            }
            return 0 /* None */;
        };
        /**
         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns
         * null when there is no collision;
         * @method collides
         * @param actor {Actor} The other actor to test
         * @returns Vector
         */
        Actor.prototype.collides = function (actor) {
            var bounds = this.getBounds();
            var otherBounds = actor.getBounds();
            var intersect = bounds.collides(otherBounds);
            return intersect;
        };
        /**
         * Register a handler to fire when this actor collides with another in a specified group
         * @method onCollidesWith
         * @param group {string} The group name to listen for
         * @param func {callback} The callback to fire on collision with another actor from the group. The callback is passed the other actor.
         */
        Actor.prototype.onCollidesWith = function (group, func) {
            if (!this._collisionHandlers[group]) {
                this._collisionHandlers[group] = [];
            }
            this._collisionHandlers[group].push(func);
        };
        Actor.prototype.getCollisionHandlers = function () {
            return this._collisionHandlers;
        };
        /**
         * Removes all collision handlers for this group on this actor
         * @method removeCollidesWith
         * @param group {string} Group to remove all handlers for on this actor.
         */
        Actor.prototype.removeCollidesWith = function (group) {
            this._collisionHandlers[group] = [];
        };
        /**
         * Returns true if the two actors are less than or equal to the distance specified from each other
         * @method within
         * @param actor {Actor} Actor to test
         * @param distance {number} Distance in pixels to test
         * @returns boolean
         */
        Actor.prototype.within = function (actor, distance) {
            return Math.sqrt(Math.pow(this.x - actor.x, 2) + Math.pow(this.y - actor.y, 2)) <= distance;
        };
        /**
         * Clears all queued actions from the Actor
         * @method clearActions
         */
        Actor.prototype.clearActions = function () {
            this.actionQueue.clearActions();
        };
        Actor.prototype.easeTo = function (x, y, duration, easingFcn) {
            if (easingFcn === void 0) { easingFcn = ex.EasingFunctions.Linear; }
            this.actionQueue.add(new ex.Internal.Actions.EaseTo(this, x, y, duration, easingFcn));
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position at the
         * speed specified (in pixels per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @method moveTo
         * @param x {number} The x location to move the actor to
         * @param y {number} The y location to move the actor to
         * @param speed {number} The speed in pixels per second to move
         * @returns Actor
         */
        Actor.prototype.moveTo = function (x, y, speed) {
            this.actionQueue.add(new ex.Internal.Actions.MoveTo(this, x, y, speed));
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position by a
         * certain time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @method moveBy
         * @param x {number} The x location to move the actor to
         * @param y {number} The y location to move the actor to
         * @param time {number} The time it should take the actor to move to the new location in milliseconds
         * @returns Actor
         */
        Actor.prototype.moveBy = function (x, y, time) {
            this.actionQueue.add(new ex.Internal.Actions.MoveBy(this, x, y, time));
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle at the speed
         * specified (in radians per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @method rotateTo
         * @param angleRadians {number} The angle to rotate to in radians
         * @param speed {number} The angular velocity of the rotation specified in radians per second
         * @returns Actor
         */
        Actor.prototype.rotateTo = function (angleRadians, speed) {
            this.actionQueue.add(new ex.Internal.Actions.RotateTo(this, angleRadians, speed));
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle by a certain
         * time (in milliseconds) and return back the actor. This method is part
         * of the actor 'Action' fluent API allowing action chaining.
         * @method rotateBy
         * @param angleRadians {number} The angle to rotate to in radians
         * @param time {number} The time it should take the actor to complete the rotation in milliseconds
         * @returns Actor
         */
        Actor.prototype.rotateBy = function (angleRadians, time) {
            this.actionQueue.add(new ex.Internal.Actions.RotateBy(this, angleRadians, time));
            return this;
        };
        /**
         * This method will scale an actor to the specified size at the speed
         * specified (in magnitude increase per second) and return back the
         * actor. This method is part of the actor 'Action' fluent API allowing
         * action chaining.
         * @method scaleTo
         * @param size {number} The scaling factor to apply
         * @param speed {number} The speed of scaling specified in magnitude increase per second
         * @returns Actor
         */
        Actor.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {
            this.actionQueue.add(new ex.Internal.Actions.ScaleTo(this, sizeX, sizeY, speedX, speedY));
            return this;
        };
        /**
         * This method will scale an actor to the specified size by a certain time
         * (in milliseconds) and return back the actor. This method is part of the
         * actor 'Action' fluent API allowing action chaining.
         * @method scaleBy
         * @param size {number} The scaling factor to apply
         * @param time {number} The time it should take to complete the scaling in milliseconds
         * @returns Actor
         */
        Actor.prototype.scaleBy = function (sizeX, sizeY, time) {
            this.actionQueue.add(new ex.Internal.Actions.ScaleBy(this, sizeX, sizeY, time));
            return this;
        };
        /**
         * This method will cause an actor to blink (become visible and not
         * visible). Optionally, you may specify the number of blinks. Specify the amount of time
         * the actor should be visible per blink, and the amount of time not visible.
         * This method is part of the actor 'Action' fluent API allowing action chaining.
         * @method blink
         * @param timeVisible {number} The amount of time to stay visible per blink in milliseconds
         * @param timeNotVisible {number} The amount of time to stay not visible per blink in milliseconds
         * @param [numBlinks] {number} The number of times to blink
         * @returns Actor
         */
        Actor.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            this.actionQueue.add(new ex.Internal.Actions.Blink(this, timeVisible, timeNotVisible, numBlinks));
            return this;
        };
        /**
         * This method will cause an actor's opacity to change from its current value
         * to the provided value by a specified time (in milliseconds). This method is
         * part of the actor 'Action' fluent API allowing action chaining.
         * @method fade
         * @param opacity {number} The ending opacity
         * @param time {number} The time it should take to fade the actor (in milliseconds)
         * @returns Actor
         */
        Actor.prototype.fade = function (opacity, time) {
            this.actionQueue.add(new ex.Internal.Actions.Fade(this, opacity, time));
            return this;
        };
        /**
         * This method will delay the next action from executing for a certain
         * amount of time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @method delay
         * @param time {number} The amount of time to delay the next action in the queue from executing in milliseconds
         * @returns Actor
         */
        Actor.prototype.delay = function (time) {
            this.actionQueue.add(new ex.Internal.Actions.Delay(this, time));
            return this;
        };
        /**
         * This method will add an action to the queue that will remove the actor from the
         * scene once it has completed its previous actions. Any actions on the
         * action queue after this action will not be executed.
         * @method die
         * @returns Actor
         */
        Actor.prototype.die = function () {
            this.actionQueue.add(new ex.Internal.Actions.Die(this));
            return this;
        };
        /**
         * This method allows you to call an arbitrary method as the next action in the
         * action queue. This is useful if you want to execute code in after a specific
         * action, i.e An actor arrives at a destinatino after traversing a path
         * @method callMethod
         * @returns Actor
         */
        Actor.prototype.callMethod = function (method) {
            this.actionQueue.add(new ex.Internal.Actions.CallMethod(this, method));
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions a certain number of times. If the number of repeats
         * is not specified it will repeat forever. This method is part of
         * the actor 'Action' fluent API allowing action chaining
         * @method repeat
         * @param [times=undefined] {number} The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions will repeat forever
         * @returns Actor
         */
        Actor.prototype.repeat = function (times) {
            if (!times) {
                this.repeatForever();
                return this;
            }
            this.actionQueue.add(new ex.Internal.Actions.Repeat(this, times, this.actionQueue.getActions()));
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions forever. This method is part of the actor 'Action'
         * fluent API allowing action chaining.
         * @method repeatForever
         * @returns Actor
         */
        Actor.prototype.repeatForever = function () {
            this.actionQueue.add(new ex.Internal.Actions.RepeatForever(this, this.actionQueue.getActions()));
            return this;
        };
        /**
         * This method will cause the actor to follow another at a specified distance
         * @method follow
         * @param actor {Actor} The actor to follow
         * @param [followDistance=currentDistance] {number} The distance to maintain when following, if not specified the actor will follow at the current distance.
         * @returns Actor
         */
        Actor.prototype.follow = function (actor, followDistance) {
            if (followDistance == undefined) {
                this.actionQueue.add(new ex.Internal.Actions.Follow(this, actor));
            }
            else {
                this.actionQueue.add(new ex.Internal.Actions.Follow(this, actor, followDistance));
            }
            return this;
        };
        /**
         * This method will cause the actor to move towards another until they
         * collide "meet" at a specified speed.
         * @method meet
         * @param actor {Actor} The actor to meet
         * @param [speed=0] {number} The speed in pixels per second to move, if not specified it will match the speed of the other actor
         * @returns Actor
         */
        Actor.prototype.meet = function (actor, speed) {
            if (speed == undefined) {
                this.actionQueue.add(new ex.Internal.Actions.Meet(this, actor));
            }
            else {
                this.actionQueue.add(new ex.Internal.Actions.Meet(this, actor, speed));
            }
            return this;
        };
        /**
         * Returns a promise that resolves when the current action queue up to now
         * is finished.
         * @method asPromise
         * @returns Promise
         */
        Actor.prototype.asPromise = function () {
            var complete = new ex.Promise();
            this.callMethod(function () {
                complete.resolve();
            });
            return complete;
        };
        Actor.prototype._getCalculatedAnchor = function () {
            return new ex.Point(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);
        };
        /**
         * Called by the Engine, updates the state of the actor
         * @method update
         * @param engine {Engine} The reference to the current game engine
         * @param delta {number} The time elapsed since the last update in milliseconds
         */
        Actor.prototype.update = function (engine, delta) {
            if (!this._isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.publish('initialize', new ex.InitializeEvent(engine));
                this._isInitialized = true;
            }
            var eventDispatcher = this.eventDispatcher;
            // Update action queue
            this.actionQueue.update(delta);
            for (var i = 0; i < this.pipeline.length; i++) {
                this.pipeline[i].update(this, engine, delta);
            }
            eventDispatcher.publish(ex.EventType[5 /* Update */], new ex.UpdateEvent(delta));
        };
        /**
         * Called by the Engine, draws the actor to the screen
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The rendering context
         * @param delta {number} The time since the last draw in milliseconds
         */
        Actor.prototype.draw = function (ctx, delta) {
            if (this.isOffScreen) {
                return;
            }
            var anchorPoint = this._getCalculatedAnchor();
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale.x, this.scale.y);
            // calculate changing opacity
            if (this.previousOpacity != this.opacity) {
                for (var drawing in this.frames) {
                    this.frames[drawing].addEffect(new ex.Effects.Opacity(this.opacity));
                }
                this.previousOpacity = this.opacity;
            }
            if (this.currentDrawing) {
                var xDiff = 0;
                var yDiff = 0;
                if (this.centerDrawingX) {
                    xDiff = (this.currentDrawing.width * this.currentDrawing.getScaleX() - this.getWidth()) / 2;
                }
                if (this.centerDrawingY) {
                    yDiff = (this.currentDrawing.height * this.currentDrawing.getScaleY() - this.getHeight()) / 2;
                }
                this.currentDrawing.draw(ctx, -xDiff - anchorPoint.x, -yDiff - anchorPoint.y);
            }
            else {
                if (this.color) {
                    ctx.fillStyle = this.color.toString();
                    ctx.fillRect(-anchorPoint.x, -anchorPoint.y, this.width, this.height);
                }
            }
            this.sceneNode.draw(ctx, delta);
            ctx.restore();
        };
        /**
         * Called by the Engine, draws the actors debugging to the screen
         * @method debugDraw
         * @param ctx {CanvasRenderingContext2D} The rendering context
         */
        Actor.prototype.debugDraw = function (ctx) {
            var bb = this.getBounds();
            bb.debugDraw(ctx);
            ctx.fillStyle = ex.Color.Yellow.toString();
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        /**
         * Indicates the next id to be set
         */
        Actor.maxId = 0;
        return Actor;
    })(ex.Class);
    ex.Actor = Actor;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Logging level that Excalibur will tag
     * @class LogLevel
     */
    (function (LogLevel) {
        /**
         @property Debug {LogLevel}
         @static
         @final
         */
        /**
        @property Info {LogLevel}
        @static
        @final
        */
        /**
        @property Warn {LogLevel}
        @static
        @final
        */
        /**
        @property Error {LogLevel}
        @static
        @final
        */
        /**
        @property Fatal {LogLevel}
        @static
        @final
        */
        LogLevel[LogLevel["Debug"] = 0] = "Debug";
        LogLevel[LogLevel["Info"] = 1] = "Info";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
    })(ex.LogLevel || (ex.LogLevel = {}));
    var LogLevel = ex.LogLevel;
    /**
     * Static singleton that represents the logging facility for Excalibur.
     * Excalibur comes built-in with a ConsoleAppender and ScreenAppender.
     * Derive from IAppender to create your own logging appenders.
     * @class Logger
     * @static
     */
    var Logger = (function () {
        function Logger() {
            this.appenders = [];
            /**
             * Gets or sets the default logging level. Excalibur will only log
             * messages if equal to or above this level.
             * @property defaultLevel {LogLevel}
             */
            this.defaultLevel = 1 /* Info */;
            if (Logger._instance) {
                throw new Error("Logger is a singleton");
            }
            Logger._instance = this;
            // Default console appender
            Logger._instance.addAppender(new ConsoleAppender());
            return Logger._instance;
        }
        /**
         * Gets the current static instance of Logger
         * @method getInstance
         * @static
         * @returns Logger
         */
        Logger.getInstance = function () {
            if (Logger._instance == null) {
                Logger._instance = new Logger();
            }
            return Logger._instance;
        };
        /**
         * Adds a new IAppender to the list of appenders to write to
         * @method addAppender
         * @param appender {IAppender} Appender to add
         */
        Logger.prototype.addAppender = function (appender) {
            this.appenders.push(appender);
        };
        /**
         * Clears all appenders from the logger
         * @method clearAppenders
         */
        Logger.prototype.clearAppenders = function () {
            this.appenders.length = 0;
        };
        /**
         * Logs a message at a given LogLevel
         * @method _log
         * @private
         * @param level {LogLevel}The LogLevel`to log the message at
         * @param args An array of arguments to write to an appender
         */
        Logger.prototype._log = function (level, args) {
            var _this = this;
            if (level == null) {
                level = this.defaultLevel;
            }
            this.appenders.forEach(function (appender) {
                if (level >= _this.defaultLevel) {
                    appender.log(level, args);
                }
            });
        };
        /**
         * Writes a log message at the LogLevel.Debug level
         * @method debug
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(0 /* Debug */, args);
        };
        /**
         * Writes a log message at the LogLevel.Info level
         * @method info
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(1 /* Info */, args);
        };
        /**
         * Writes a log message at the LogLevel.Warn level
         * @method warn
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(2 /* Warn */, args);
        };
        /**
         * Writes a log message at the LogLevel.Error level
         * @method error
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(3 /* Error */, args);
        };
        /**
         * Writes a log message at the LogLevel.Fatal level
         * @method fatal
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.fatal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(4 /* Fatal */, args);
        };
        Logger._instance = null;
        return Logger;
    })();
    ex.Logger = Logger;
    /**
     * Console appender for browsers (i.e. console.log)
     * @class ConsoleAppender
     * @constructor
     * @extends IAppender
     */
    var ConsoleAppender = (function () {
        function ConsoleAppender() {
        }
        ConsoleAppender.prototype.log = function (level, args) {
            // Check for console support
            if (!console && !console.log && console.warn && console.error) {
                // todo maybe do something better than nothing
                return;
            }
            // Create a new console args array
            var consoleArgs = [];
            consoleArgs.unshift.apply(consoleArgs, args);
            consoleArgs.unshift("[" + LogLevel[level] + "] : ");
            if (level < 2 /* Warn */) {
                // Call .log for Debug/Info
                if (console.log.apply) {
                    // this is required on some older browsers that don't support apply on console.log :(
                    console.log.apply(console, consoleArgs);
                }
                else {
                    console.log(consoleArgs.join(' '));
                }
            }
            else if (level < 3 /* Error */) {
                // Call .warn for Warn
                if (console.warn.apply) {
                    console.warn.apply(console, consoleArgs);
                }
                else {
                    console.warn(consoleArgs.join(' '));
                }
            }
            else {
                // Call .error for Error/Fatal
                if (console.error.apply) {
                    console.error.apply(console, consoleArgs);
                }
                else {
                    console.error(consoleArgs.join(' '));
                }
            }
        };
        return ConsoleAppender;
    })();
    ex.ConsoleAppender = ConsoleAppender;
    /**
     * On-screen (canvas) appender
     * @todo Clean this up
     * @class ScreenAppender
     * @extends IAppender
     * @constructor
     * @param width {number} Width of the screen appender in pixels
     * @param height {number} Height of the screen appender in pixels
     */
    var ScreenAppender = (function () {
        function ScreenAppender(width, height) {
            this._messages = [];
            this.canvas = document.createElement('canvas');
            this.canvas.width = width || window.innerWidth;
            this.canvas.height = height || window.innerHeight;
            this.canvas.style.position = 'absolute';
            this.ctx = this.canvas.getContext('2d');
            document.body.appendChild(this.canvas);
        }
        ScreenAppender.prototype.log = function (level, args) {
            var message = args.join(",");
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this._messages.unshift("[" + LogLevel[level] + "] : " + message);
            var pos = 10;
            var opacity = 1.0;
            for (var i = 0; i < this._messages.length; i++) {
                this.ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
                this.ctx.fillText(this._messages[i], 200, pos);
                pos += 10;
                opacity = opacity > 0 ? opacity - .05 : 0;
            }
        };
        return ScreenAppender;
    })();
    ex.ScreenAppender = ScreenAppender;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Actor.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    /**
     * An enum representing all of the built in event types for Excalibur
     * @class EventType
     */
    (function (EventType) {
        /**
        @property UserEvent {EventType}
        @static
        @final
        */
        /**
        @property Blur {EventType}
        @static
        @final
        */
        /**
        @property Focus {EventType}
        @static
        @final
        */
        /**
        @property Update {EventType}
        @static
        @final
        */
        /**
        @property EnterViewPort {EventType}
        @static
        @final
        */
        /**
        @property ExitViewPort {EventType}
        @static
        @final
        */
        /**
        @property Activate {EventType}
        @static
        @final
        */
        /**
        @property Deactivate {EventType}
        @static
        @final
        */
        /**
        @property Initialize {EventType}
        @static
        @final
        */
        EventType[EventType["Collision"] = 0] = "Collision";
        EventType[EventType["EnterViewPort"] = 1] = "EnterViewPort";
        EventType[EventType["ExitViewPort"] = 2] = "ExitViewPort";
        EventType[EventType["Blur"] = 3] = "Blur";
        EventType[EventType["Focus"] = 4] = "Focus";
        EventType[EventType["Update"] = 5] = "Update";
        EventType[EventType["Activate"] = 6] = "Activate";
        EventType[EventType["Deactivate"] = 7] = "Deactivate";
        EventType[EventType["Initialize"] = 8] = "Initialize";
    })(ex.EventType || (ex.EventType = {}));
    var EventType = ex.EventType;
    /**
     * Base event type in Excalibur that all other event types derive from.
     *
     * @class GameEvent
     * @constructor
     * @param target {any} Events can have target game object, like the Engine, or an Actor.
     */
    var GameEvent = (function () {
        function GameEvent() {
        }
        return GameEvent;
    })();
    ex.GameEvent = GameEvent;
    /**
     * Event received by the Engine when the browser window is visible
     *
     * @class VisibleEvent
     * @extends GameEvent
     * @constructor
     */
    var VisibleEvent = (function (_super) {
        __extends(VisibleEvent, _super);
        function VisibleEvent() {
            _super.call(this);
        }
        return VisibleEvent;
    })(GameEvent);
    ex.VisibleEvent = VisibleEvent;
    /**
     * Event received by the Engine when the browser window is hidden
     *
     * @class HiddenEvent
     * @extends GameEvent
     * @constructor
     */
    var HiddenEvent = (function (_super) {
        __extends(HiddenEvent, _super);
        function HiddenEvent() {
            _super.call(this);
        }
        return HiddenEvent;
    })(GameEvent);
    ex.HiddenEvent = HiddenEvent;
    /**
     * Event thrown on an actor when a collision has occured
     *
     * @class CollisionEvent
     * @extends GameEvent
     * @constructor
     * @param actor {Actor} The actor the event was thrown on
     * @param other {Actor} The actor that was collided with
     * @param side {Side} The side that was collided with
     */
    var CollisionEvent = (function (_super) {
        __extends(CollisionEvent, _super);
        function CollisionEvent(actor, other, side, intersection) {
            _super.call(this);
            this.actor = actor;
            this.other = other;
            this.side = side;
            this.intersection = intersection;
        }
        return CollisionEvent;
    })(GameEvent);
    ex.CollisionEvent = CollisionEvent;
    /**
     * Event thrown on a game object on Excalibur update
     *
     * @class UpdateEvent
     * @extends GameEvent
     * @constructor
     * @param delta {number} The number of milliseconds since the last update
     */
    var UpdateEvent = (function (_super) {
        __extends(UpdateEvent, _super);
        function UpdateEvent(delta) {
            _super.call(this);
            this.delta = delta;
        }
        return UpdateEvent;
    })(GameEvent);
    ex.UpdateEvent = UpdateEvent;
    /**
     * Event thrown on an Actor only once before the first update call
     *
     * @class InitializeEvent
     * @extends GameEvent
     * @constructor
     * @param engine {Engine} The reference to the current engine
     */
    var InitializeEvent = (function (_super) {
        __extends(InitializeEvent, _super);
        function InitializeEvent(engine) {
            _super.call(this);
            this.engine = engine;
        }
        return InitializeEvent;
    })(GameEvent);
    ex.InitializeEvent = InitializeEvent;
    /**
     * Event thrown on a Scene on activation
     *
     * @class ActivateEvent
     * @extends GameEvent
     * @constructor
     * @param oldScene {Scene} The reference to the old scene
     */
    var ActivateEvent = (function (_super) {
        __extends(ActivateEvent, _super);
        function ActivateEvent(oldScene) {
            _super.call(this);
            this.oldScene = oldScene;
        }
        return ActivateEvent;
    })(GameEvent);
    ex.ActivateEvent = ActivateEvent;
    /**
     * Event thrown on a Scene on deactivation
     *
     * @class DeactivateEvent
     * @extends GameEvent
     * @constructor
     * @param newScene {Scene} The reference to the new scene
     */
    var DeactivateEvent = (function (_super) {
        __extends(DeactivateEvent, _super);
        function DeactivateEvent(newScene) {
            _super.call(this);
            this.newScene = newScene;
        }
        return DeactivateEvent;
    })(GameEvent);
    ex.DeactivateEvent = DeactivateEvent;
    /**
     * Event thrown on an Actor when it completely leaves the screen.
     * @class ExitViewPortEvent
     * @constructor
     */
    var ExitViewPortEvent = (function (_super) {
        __extends(ExitViewPortEvent, _super);
        function ExitViewPortEvent() {
            _super.call(this);
        }
        return ExitViewPortEvent;
    })(GameEvent);
    ex.ExitViewPortEvent = ExitViewPortEvent;
    /**
     * Event thrown on an Actor when it completely leaves the screen.
     * @class EnterViewPortEvent
     * @constructor
     */
    var EnterViewPortEvent = (function (_super) {
        __extends(EnterViewPortEvent, _super);
        function EnterViewPortEvent() {
            _super.call(this);
        }
        return EnterViewPortEvent;
    })(GameEvent);
    ex.EnterViewPortEvent = EnterViewPortEvent;
    /**
     * Enum representing the different mouse buttons
     * @class MouseButton
     */
    (function (MouseButton) {
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Left"] = 0] = "Left";
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Middle"] = 1] = "Middle";
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Right"] = 2] = "Right";
    })(ex.MouseButton || (ex.MouseButton = {}));
    var MouseButton = ex.MouseButton;
})(ex || (ex = {}));
/// <reference path="Events.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur's internal event dispatcher implementation. Callbacks are fired immediately after an event is published
     * @class EventDispatcher
     * @constructor
     * @param target {any} The object that will be the recipient of events from this event dispatcher
     */
    var EventDispatcher = (function () {
        function EventDispatcher(target) {
            this._handlers = {};
            this.log = ex.Logger.getInstance();
            this.target = target;
        }
        /**
         * Publish an event for target
         * @method publish
         * @param eventName {string} The name of the event to publish
         * @param [event=undefined] {GameEvent} Optionally pass an event data object to the handler
         */
        EventDispatcher.prototype.publish = function (eventName, event) {
            if (!eventName) {
                // key not mapped
                return;
            }
            eventName = eventName.toLowerCase();
            var target = this.target;
            if (!event) {
                event = new ex.GameEvent();
            }
            event.target = target;
            if (this._handlers[eventName]) {
                this._handlers[eventName].forEach(function (callback) {
                    callback.call(target, event);
                });
            }
        };
        /**
         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
         * @method subscribe
         * @param eventName {string} The name of the event to subscribe to
         * @param handler {GameEvent=>void} The handler callback to fire on this event
         */
        EventDispatcher.prototype.subscribe = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            if (!this._handlers[eventName]) {
                this._handlers[eventName] = [];
            }
            this._handlers[eventName].push(handler);
        };
        /**
         * Unsubscribe a event handler(s) from an event. If a specific handler
         * is specified for an event, only that handler will be unsubscribed.
         * Otherwise all handlers will be unsubscribed for that event.
         * @method unsubscribe
         * @param eventName {string} The name of the event to unsubscribe
         * @param [handler=undefined] Optionally the specific handler to unsubscribe
         *
         */
        EventDispatcher.prototype.unsubscribe = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            var eventHandlers = this._handlers[eventName];
            if (eventHandlers) {
                // if no explicit handler is give with the event name clear all handlers
                if (!handler) {
                    this._handlers[eventName].length = 0;
                }
                else {
                    var index = eventHandlers.indexOf(handler);
                    if (index < 0)
                        return;
                    this._handlers[eventName].splice(index, 1);
                }
            }
        };
        return EventDispatcher;
    })();
    ex.EventDispatcher = EventDispatcher;
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Color = (function () {
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @class Color
         * @constructor
         * @param r {number} The red component of color (0-255)
         * @param g {number} The green component of color (0-255)
         * @param b {number} The blue component of color (0-255)
         * @param [a=1] {number} The alpha component of color (0-1.0)
         */
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            this.a = (a != null ? a : 1);
        }
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @method fromRGB
         * @static
         * @param r {number} The red component of color (0-255)
         * @param g {number} The green component of color (0-255)
         * @param b {number} The blue component of color (0-255)
         * @param [a=1] {number} The alpha component of color (0-1.0)
         */
        Color.fromRGB = function (r, g, b, a) {
            return new Color(r, g, b, a);
        };
        /**
         * Creates a new inscance of Color from a hex string
         *
         * @method fromHex
         * @static
         * @param hex {string} CSS color string of the form #ffffff, the alpha component is optional
         */
        Color.fromHex = function (hex) {
            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
            var match = null;
            if (match = hex.match(hexRegEx)) {
                var r = parseInt(match[1], 16);
                var g = parseInt(match[2], 16);
                var b = parseInt(match[3], 16);
                var a = 1;
                if (match[4]) {
                    a = parseInt(match[4], 16) / 255;
                }
                return new Color(r, g, b, a);
            }
            else {
                throw new Error("Invalid hex string: " + hex);
            }
        };
        /**
         * Returns a CSS string representation of a color.
         * @method toString
         * @returns string
         */
        Color.prototype.toString = function () {
            var result = String(this.r.toFixed(0)) + ", " + String(this.g.toFixed(0)) + ", " + String(this.b.toFixed(0));
            if (this.a !== undefined || this.a !== null) {
                return "rgba(" + result + ", " + String(this.a) + ")";
            }
            return "rgb(" + result + ")";
        };
        /**
         * Returns a CSS string representation of a color.
         * @method fillStyle
         * @returns string
         */
        Color.prototype.fillStyle = function () {
            return this.toString();
        };
        /**
         * Returns a clone of the current color.
         * @method clone
         * @returns Color
         */
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        /**
         * Color constant
         * @property Black {ex.Color}
         * @static
         * @final
         */
        Color.Black = Color.fromHex('#000000');
        /**
         * Color constant
         * @property White {ex.Color}
         * @static
         * @final
         */
        Color.White = Color.fromHex('#FFFFFF');
        /**
         * Color constant
         * @property Gray {ex.Color}
         * @static
         * @final
         */
        Color.Gray = Color.fromHex('#808080');
        /**
         * Color constant
         * @property LightGray {ex.Color}
         * @static
         * @final
         */
        Color.LightGray = Color.fromHex('#D3D3D3');
        /**
         * Color constant
         * @property DarkGray {ex.Color}
         * @static
         * @final
         */
        Color.DarkGray = Color.fromHex('#A9A9A9');
        /**
         * Color constant
         * @property Yellow {ex.Color}
         * @static
         * @final
         */
        Color.Yellow = Color.fromHex('#FFFF00');
        /**
         * Color constant
         * @property Orange {ex.Color}
         * @static
         * @final
         */
        Color.Orange = Color.fromHex('#FFA500');
        /**
         * Color constant
         * @property Red {ex.Color}
         * @static
         * @final
         */
        Color.Red = Color.fromHex('#FF0000');
        /**
         * Color constant
         * @property Vermillion {ex.Color}
         * @static
         * @final
         */
        Color.Vermillion = Color.fromHex('#FF5B31');
        /**
         * Color constant
         * @property Rose {ex.Color}
         * @static
         * @final
         */
        Color.Rose = Color.fromHex('#FF007F');
        /**
         * Color constant
         * @property Magenta {ex.Color}
         * @static
         * @final
         */
        Color.Magenta = Color.fromHex('#FF00FF');
        /**
         * Color constant
         * @property Violet {ex.Color}
         * @static
         * @final
         */
        Color.Violet = Color.fromHex('#7F00FF');
        /**
         * Color constant
         * @property Blue {ex.Color}
         * @static
         * @final
         */
        Color.Blue = Color.fromHex('#0000FF');
        /**
         * Color constant
         * @property Azure {ex.Color}
         * @static
         * @final
         */
        Color.Azure = Color.fromHex('#007FFF');
        /**
         * Color constant
         * @property Cyan {ex.Color}
         * @static
         * @final
         */
        Color.Cyan = Color.fromHex('#00FFFF');
        /**
         * Color constant
         * @property Viridian {ex.Color}
         * @static
         * @final
         */
        Color.Viridian = Color.fromHex('#59978F');
        /**
         * Color constant
         * @property Green {ex.Color}
         * @static
         * @final
         */
        Color.Green = Color.fromHex('#00FF00');
        /**
         * Color constant
         * @property Chartreuse {ex.Color}
         * @static
         * @final
         */
        Color.Chartreuse = Color.fromHex('#7FFF00');
        /**
         * Color constant
         * @property Transparent {ex.Color}
         * @static
         * @final
         */
        Color.Transparent = Color.fromHex('#FFFFFF00');
        return Color;
    })();
    ex.Color = Color;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * Helper Actor primitive for drawing UI's, optimized for UI drawing. Does
     * not participate in collisions.
     * @class UIActor
     * @extends Actor
     * @constructor
     * @param [x=0.0] {number} The starting x coordinate of the actor
     * @param [y=0.0] {number} The starting y coordinate of the actor
     * @param [width=0.0] {number} The starting width of the actor
     * @param [height=0.0] {number} The starting height of the actor
     */
    var UIActor = (function (_super) {
        __extends(UIActor, _super);
        function UIActor(x, y, width, height) {
            _super.call(this, x, y, width, height);
            this.pipeline = [];
            this.pipeline.push(new ex.MovementModule());
            this.pipeline.push(new ex.CapturePointerModule());
            this.anchor.setTo(0, 0);
            this.collisionType = 0 /* PreventCollision */;
            this.enableCapturePointer = true;
        }
        UIActor.prototype.onInitialize = function (engine) {
            this._engine = engine;
        };
        UIActor.prototype.contains = function (x, y, useWorld) {
            if (useWorld === void 0) { useWorld = true; }
            if (useWorld)
                return _super.prototype.contains.call(this, x, y);
            var coords = this._engine.worldToScreenCoordinates(new ex.Point(x, y));
            return _super.prototype.contains.call(this, coords.x, coords.y);
        };
        return UIActor;
    })(ex.Actor);
    ex.UIActor = UIActor;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
/// <reference path="Engine.ts" />
var ex;
(function (ex) {
    /**
     * Triggers a method of firing arbitrary code on collision. These are useful
     * as 'buttons', 'switches', or to trigger effects in a game. By defualt triggers
     * are invisible, and can only be seen with debug mode enabled on the Engine.
     * @class Trigger
     * @constructor
     * @param [x=0] {number} The x position of the trigger
     * @param [y=0] {number} The y position of the trigger
     * @param [width=0] {number} The width of the trigger
     * @param [height=0] {number} The height of the trigger
     * @param [action=null] {()=>void} Callback to fire when trigger is activated
     * @param [repeats=1] {number} The number of times that this trigger should fire, by default it is 1, if -1 is supplied it will fire indefinitely
     */
    var Trigger = (function (_super) {
        __extends(Trigger, _super);
        function Trigger(x, y, width, height, action, repeats) {
            _super.call(this, x, y, width, height);
            this.action = function () {
            };
            this.repeats = 1;
            this.target = null;
            this.repeats = repeats || this.repeats;
            this.action = action || this.action;
            this.collisionType = 0 /* PreventCollision */;
            this.eventDispatcher = new ex.EventDispatcher(this);
            this.actionQueue = new ex.Internal.Actions.ActionQueue(this);
        }
        Trigger.prototype.update = function (engine, delta) {
            // Update action queue
            this.actionQueue.update(delta);
            // Update placements based on linear algebra
            this.x += this.dx * delta / 1000;
            this.y += this.dy * delta / 1000;
            this.rotation += this.rx * delta / 1000;
            this.scale.x += this.sx * delta / 1000;
            this.scale.y += this.sy * delta / 1000;
            // check for trigger collisions
            if (this.target) {
                if (this.collides(this.target)) {
                    this.dispatchAction();
                }
            }
            else {
                for (var i = 0; i < engine.currentScene.children.length; i++) {
                    var other = engine.currentScene.children[i];
                    if (other !== this && other.collisionType !== 0 /* PreventCollision */ && this.collides(other)) {
                        this.dispatchAction();
                    }
                }
            }
            // remove trigger if its done, -1 repeat forever
            if (this.repeats === 0) {
                this.kill();
            }
        };
        Trigger.prototype.dispatchAction = function () {
            this.action.call(this);
            this.repeats--;
        };
        Trigger.prototype.draw = function (ctx, delta) {
            // does not draw
            return;
        };
        Trigger.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            // Meant to draw debug information about actors
            ctx.save();
            ctx.translate(this.x, this.y);
            var bb = this.getBounds();
            bb.left = bb.left - this.getGlobalX();
            bb.right = bb.right - this.getGlobalX();
            bb.top = bb.top - this.getGlobalY();
            bb.bottom = bb.bottom - this.getGlobalY();
            // Currently collision primitives cannot rotate 
            // ctx.rotate(this.rotation);
            ctx.fillStyle = ex.Color.Violet.toString();
            ctx.strokeStyle = ex.Color.Violet.toString();
            ctx.fillText('Trigger', 10, 10);
            bb.debugDraw(ctx);
            ctx.restore();
        };
        return Trigger;
    })(ex.Actor);
    ex.Trigger = Trigger;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Algebra.ts" />
/// <reference path="Util.ts" />
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * An enum that represents the types of emitter nozzles
     * @class EmitterType
     */
    (function (EmitterType) {
        /**
         * Constant for the circular emitter type
         * @property Circle {EmitterType}
         */
        EmitterType[EmitterType["Circle"] = 0] = "Circle";
        /**
         * Constant for the rectangular emitter type
         * @property Rectangle {EmitterType}
         */
        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
    })(ex.EmitterType || (ex.EmitterType = {}));
    var EmitterType = ex.EmitterType;
    var Particle = (function () {
        function Particle(emitter, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            this.position = new ex.Vector(0, 0);
            this.velocity = new ex.Vector(0, 0);
            this.acceleration = new ex.Vector(0, 0);
            this.particleRotationalVelocity = 0;
            this.currentRotation = 0;
            this.focus = null;
            this.focusAccel = 0;
            this.opacity = 1;
            this.beginColor = ex.Color.White.clone();
            this.endColor = ex.Color.White.clone();
            // Life is counted in ms
            this.life = 300;
            this.fadeFlag = false;
            // Color transitions
            this.rRate = 1;
            this.gRate = 1;
            this.bRate = 1;
            this.aRate = 0;
            this.currentColor = ex.Color.White.clone();
            this.emitter = null;
            this.particleSize = 5;
            this.particleSprite = null;
            this.sizeRate = 0;
            this.elapsedMultiplier = 0;
            this.emitter = emitter;
            this.life = life || this.life;
            this.opacity = opacity || this.opacity;
            this.endColor = endColor || this.endColor.clone();
            this.beginColor = beginColor || this.beginColor.clone();
            this.currentColor = this.beginColor.clone();
            this.position = position || this.position;
            this.velocity = velocity || this.velocity;
            this.acceleration = acceleration || this.acceleration;
            this.rRate = (this.endColor.r - this.beginColor.r) / this.life;
            this.gRate = (this.endColor.g - this.beginColor.g) / this.life;
            this.bRate = (this.endColor.b - this.beginColor.b) / this.life;
            this.aRate = this.opacity / this.life;
            this.startSize = startSize || 0;
            this.endSize = endSize || 0;
            if ((this.endSize > 0) && (this.startSize > 0)) {
                this.sizeRate = (this.endSize - this.startSize) / this.life;
                this.particleSize = this.startSize;
            }
        }
        Particle.prototype.kill = function () {
            this.emitter.removeParticle(this);
        };
        Particle.prototype.update = function (delta) {
            this.life = this.life - delta;
            this.elapsedMultiplier = this.elapsedMultiplier + delta;
            if (this.life < 0) {
                this.kill();
            }
            if (this.fadeFlag) {
                this.opacity = ex.Util.clamp(this.aRate * this.life, 0.0001, 1);
            }
            if ((this.startSize > 0) && (this.endSize > 0)) {
                this.particleSize = ex.Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
            }
            this.currentColor.r = ex.Util.clamp(this.currentColor.r + this.rRate * delta, 0, 255);
            this.currentColor.g = ex.Util.clamp(this.currentColor.g + this.gRate * delta, 0, 255);
            this.currentColor.b = ex.Util.clamp(this.currentColor.b + this.bRate * delta, 0, 255);
            this.currentColor.a = ex.Util.clamp(this.opacity, 0.0001, 1);
            if (this.focus) {
                var accel = this.focus.minus(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);
                this.velocity = this.velocity.add(accel);
            }
            else {
                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
            }
            this.position = this.position.add(this.velocity.scale(delta / 1000));
            if (this.particleRotationalVelocity) {
                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);
            }
        };
        Particle.prototype.draw = function (ctx) {
            if (this.particleSprite) {
                this.particleSprite.setRotation(this.currentRotation);
                this.particleSprite.setScaleX(this.particleSize);
                this.particleSprite.setScaleY(this.particleSize);
                this.particleSprite.draw(ctx, this.position.x, this.position.y);
                return;
            }
            this.currentColor.a = ex.Util.clamp(this.opacity, 0.0001, 1);
            ctx.fillStyle = this.currentColor.toString();
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };
        return Particle;
    })();
    ex.Particle = Particle;
    /**
     * Using a particle emitter is a great way to create interesting effects
     * in your game, like smoke, fire, water, explosions, etc. Particle Emitters
     * extend Actor allowing you to use all of the features that come with Actor
     * @class ParticleEmitter
     * @constructor
     * @param [x=0] {number} The x position of the emitter
     * @param [y=0] {number} The y position of the emitter
     * @param [width=0] {number} The width of the emitter
     * @param [height=0] {number} The height of the emitter
     */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        function ParticleEmitter(x, y, width, height) {
            _super.call(this, x, y, width, height, ex.Color.White);
            this._particlesToEmit = 0;
            this.numParticles = 0;
            /**
             * Gets or sets the isEmitting flag
             * @property isEmitting {boolean}
             */
            this.isEmitting = true;
            /**
             * Gets or sets the backing particle collection
             * @property particles {Util.Collection&lt;Particle&gt;}
             */
            this.particles = null;
            /**
             * Gets or sets the backing deadParticle collection
             * @property particles {Util.Collection&lt;Particle&gt;}
             */
            this.deadParticles = null;
            /**
             * Gets or sets the minimum partical velocity
             * @property [minVel=0] {number}
             */
            this.minVel = 0;
            /**
             * Gets or sets the maximum partical velocity
             * @property [maxVel=0] {number}
             */
            this.maxVel = 0;
            /**
             * Gets or sets the acceleration vector for all particles
             * @property [acceleration=new Vector(0,0)] {Vector}
             */
            this.acceleration = new ex.Vector(0, 0);
            /**
             * Gets or sets the minimum angle in radians
             * @property [minAngle=0] {number}
             */
            this.minAngle = 0;
            /**
             * Gets or sets the maximum angle in radians
             * @property [maxAngle=0] {number}
             */
            this.maxAngle = 0;
            /**
             * Gets or sets the emission rate for particles (particles/sec)
             * @property [emitRate=1] {number}
             */
            this.emitRate = 1; //particles/sec
            /**
             * Gets or sets the life of each particle in milliseconds
             * @property [particleLife=2000] {number}
             */
            this.particleLife = 2000;
            /**
             * Gets or sets the opacity of each particle from 0 to 1.0
             * @property [opacity=1.0] {number}
             */
            this.opacity = 1;
            /**
             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
             * @property [fade=false] {boolean}
             */
            this.fadeFlag = false;
            /**
             * Gets or sets the optional focus where all particles should accelerate towards
             * @property [focus=null] {Vector}
             */
            this.focus = null;
            /**
             * Gets or sets the acceleration for focusing particles if a focus has been specified
             * @property [focusAccel=1] {number}
             */
            this.focusAccel = 1;
            /*
             * Gets or sets the optional starting size for the particles
             * @property [startSize=null] {number}
             */
            this.startSize = null;
            /*
             * Gets or sets the optional ending size for the particles
             * @property [endSize=null] {number}
             */
            this.endSize = null;
            /**
             * Gets or sets the minimum size of all particles
             * @property [minSize=5] {number}
             */
            this.minSize = 5;
            /**
             * Gets or sets the maximum size of all particles
             * @property [maxSize=5] {number}
             */
            this.maxSize = 5;
            /**
             * Gets or sets the beginning color of all particles
             * @property [beginColor=Color.White] {Color}
             */
            this.beginColor = ex.Color.White;
            /**
             * Gets or sets the ending color of all particles
             * @property [endColor=Color.White] {Color}
             */
            this.endColor = ex.Color.White;
            /**
             * Gets or sets the sprite that a particle should use
             * @property [particleSprite=null] {Sprite}
             */
            this.particleSprite = null;
            /**
             * Gets or sets the emitter type for the particle emitter
             * @property [emitterType=EmitterType.Rectangle] {EmitterType}
             */
            this.emitterType = 1 /* Rectangle */;
            /**
             * Gets or sets the emitter radius, only takes effect when the emitterType is Circle
             * @property [radius=0] {number}
             */
            this.radius = 0;
            /**
             * Gets or sets the particle rotational speed velocity
             * @property [particleRotationalVelocity=0] {number}
             */
            this.particleRotationalVelocity = 0;
            /**
             * Indicates whether particles should start with a random rotation
             * @property [randomRotation=false] {boolean}
             */
            this.randomRotation = false;
            this.collisionType = 0 /* PreventCollision */;
            this.particles = new ex.Util.Collection();
            this.deadParticles = new ex.Util.Collection();
        }
        ParticleEmitter.prototype.removeParticle = function (particle) {
            this.deadParticles.push(particle);
        };
        /**
         * Causes the emitter to emit particles
         * @method emit
         * @param particleCount {number} Number of particles to emit right now
         */
        ParticleEmitter.prototype.emit = function (particleCount) {
            for (var i = 0; i < particleCount; i++) {
                this.particles.push(this.createParticle());
            }
        };
        ParticleEmitter.prototype.clearParticles = function () {
            this.particles.clear();
        };
        // Creates a new particle given the contraints of the emitter
        ParticleEmitter.prototype.createParticle = function () {
            // todo implement emitter contraints;
            var ranX = 0;
            var ranY = 0;
            var angle = ex.Util.randomInRange(this.minAngle, this.maxAngle);
            var vel = ex.Util.randomInRange(this.minVel, this.maxVel);
            var size = this.startSize || ex.Util.randomInRange(this.minSize, this.maxSize);
            var dx = vel * Math.cos(angle);
            var dy = vel * Math.sin(angle);
            if (this.emitterType === 1 /* Rectangle */) {
                ranX = ex.Util.randomInRange(this.x, this.x + this.getWidth());
                ranY = ex.Util.randomInRange(this.y, this.y + this.getHeight());
            }
            else if (this.emitterType === 0 /* Circle */) {
                var radius = ex.Util.randomInRange(0, this.radius);
                ranX = radius * Math.cos(angle) + this.x;
                ranY = radius * Math.sin(angle) + this.y;
            }
            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new ex.Vector(ranX, ranY), new ex.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
            p.fadeFlag = this.fadeFlag;
            p.particleSize = size;
            if (this.particleSprite) {
                p.particleSprite = this.particleSprite;
            }
            p.particleRotationalVelocity = this.particleRotationalVelocity;
            if (this.randomRotation) {
                p.currentRotation = ex.Util.randomInRange(0, Math.PI * 2);
            }
            if (this.focus) {
                p.focus = this.focus.add(new ex.Vector(this.x, this.y));
                p.focusAccel = this.focusAccel;
            }
            return p;
        };
        ParticleEmitter.prototype.update = function (engine, delta) {
            var _this = this;
            _super.prototype.update.call(this, engine, delta);
            if (this.isEmitting) {
                this._particlesToEmit += this.emitRate * (delta / 1000);
                var numParticles = Math.ceil(this.emitRate * delta / 1000);
                if (this._particlesToEmit > 1.0) {
                    this.emit(Math.floor(this._particlesToEmit));
                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
                }
            }
            this.particles.forEach(function (particle, index) {
                particle.update(delta);
            });
            this.deadParticles.forEach(function (particle, index) {
                _this.particles.removeElement(particle);
            });
            this.deadParticles.clear();
        };
        ParticleEmitter.prototype.draw = function (ctx, delta) {
            this.particles.forEach(function (particle, index) {
                // todo is there a more efficient to draw 
                // possibly use a webgl offscreen canvas and shaders to do particles?
                particle.draw(ctx);
            });
        };
        ParticleEmitter.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            ctx.fillStyle = ex.Color.Black.toString();
            ctx.fillText("Particles: " + this.particles.count(), this.x, this.y + 20);
            if (this.focus) {
                ctx.fillRect(this.focus.x + this.x, this.focus.y + this.y, 3, 3);
                ex.Util.drawLine(ctx, "yellow", this.focus.x + this.x, this.focus.y + this.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);
                ctx.fillText("Focus", this.focus.x + this.x, this.focus.y + this.y);
            }
        };
        return ParticleEmitter;
    })(ex.Actor);
    ex.ParticleEmitter = ParticleEmitter;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Animations allow you to display a series of images one after another,
     * creating the illusion of change. Generally these images will come from a sprite sheet source.
     * @class Animation
     * @extends IDrawable
     * @constructor
     * @param engine {Engine} Reference to the current game engine
     * @param images {Sprite[]} An array of sprites to create the frames for the animation
     * @param speed {number} The number in milliseconds to display each frame in the animation
     * @param [loop=false] {boolean} Indicates whether the animation should loop after it is completed
     */
    var Animation = (function () {
        function Animation(engine, images, speed, loop) {
            this.currIndex = 0;
            this.oldTime = Date.now();
            this.rotation = 0.0;
            this.scaleX = 1.0;
            this.scaleY = 1.0;
            /**
             * Indicates whether the animation should loop after it is completed
             * @property [loop=false] {boolean}
             */
            this.loop = false;
            this.freezeFrame = -1;
            this.flipVertical = false;
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.sprites = images;
            this.speed = speed;
            this.engine = engine;
            if (loop != null) {
                this.loop = loop;
            }
            this.height = images[0] ? images[0].height : 0;
            this.width = images[0] ? images[0].width : 0;
        }
        Animation.prototype.addEffect = function (effect) {
            for (var i in this.sprites) {
                this.sprites[i].addEffect(effect);
            }
        };
        Animation.prototype.removeEffect = function (param) {
            for (var i in this.sprites) {
                this.sprites[i].removeEffect(param);
            }
        };
        Animation.prototype.clearEffects = function () {
            for (var i in this.sprites) {
                this.sprites[i].clearEffects();
            }
        };
        Animation.prototype.transformAboutPoint = function (point) {
            for (var i in this.sprites) {
                this.sprites[i].transformAboutPoint(point);
            }
        };
        Animation.prototype.setRotation = function (radians) {
            this.rotation = radians;
            for (var i in this.sprites) {
                this.sprites[i].setRotation(radians);
            }
        };
        Animation.prototype.getRotation = function () {
            return this.rotation;
        };
        Animation.prototype.setScaleX = function (scaleX) {
            this.scaleX = scaleX;
            for (var i in this.sprites) {
                this.sprites[i].setScaleX(scaleX);
            }
        };
        Animation.prototype.setScaleY = function (scaleY) {
            this.scaleY = scaleY;
            for (var i in this.sprites) {
                this.sprites[i].setScaleY(scaleY);
            }
        };
        Animation.prototype.getScaleX = function () {
            return this.scaleX;
        };
        Animation.prototype.getScaleY = function () {
            return this.scaleY;
        };
        /**
         * Resets the animation to first frame.
         * @method reset
         */
        Animation.prototype.reset = function () {
            this.currIndex = 0;
        };
        /**
         * Indicates whether the animation is complete, animations that loop are never complete.
         * @method isDone
         * @returns boolean
         */
        Animation.prototype.isDone = function () {
            return (!this.loop && this.currIndex >= this.sprites.length);
        };
        /**
         * Not meant to be called by game developers. Ticks the animation forward internally an
         * calculates whether to change to teh frame.
         * @method tick
         */
        Animation.prototype.tick = function () {
            var time = Date.now();
            if ((time - this.oldTime) > this.speed) {
                this.currIndex = (this.loop ? (this.currIndex + 1) % this.sprites.length : this.currIndex + 1);
                this.oldTime = time;
            }
        };
        /**
         * Skips ahead a specified number of frames in the animation
         * @method skip
         * @param frames {number} Frames to skip ahead
         */
        Animation.prototype.skip = function (frames) {
            this.currIndex = (this.currIndex + frames) % this.sprites.length;
        };
        Animation.prototype.draw = function (ctx, x, y) {
            this.tick();
            if (this.currIndex < this.sprites.length) {
                var currSprite = this.sprites[this.currIndex];
                if (this.flipVertical) {
                    currSprite.flipVertical = this.flipVertical;
                }
                if (this.flipHorizontal) {
                    currSprite.flipHorizontal = this.flipHorizontal;
                }
                currSprite.draw(ctx, x, y);
            }
            if (this.freezeFrame !== -1 && this.currIndex >= this.sprites.length) {
                var currSprite = this.sprites[ex.Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];
                currSprite.draw(ctx, x, y);
            }
        };
        /**
         * Plays an animation at an arbitrary location in the game.
         * @method play
         * @param x {number} The x position in the game to play
         * @param y {number} The y position in the game to play
         */
        Animation.prototype.play = function (x, y) {
            this.reset();
            this.engine.playAnimation(this, x, y);
        };
        return Animation;
    })();
    ex.Animation = Animation;
})(ex || (ex = {}));
/// <reference path="MonkeyPatch.ts" />
/// <reference path="Util.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    var Internal;
    (function (Internal) {
        var FallbackAudio = (function () {
            function FallbackAudio(path, volume) {
                this.log = ex.Logger.getInstance();
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                if (window.AudioContext) {
                    this.log.debug("Using new Web Audio Api for " + path);
                    this.soundImpl = new WebAudio(path, volume);
                }
                else {
                    this.log.debug("Falling back to Audio Element for " + path);
                    this.soundImpl = new AudioTag(path, volume);
                }
            }
            FallbackAudio.prototype.setVolume = function (volume) {
                this.soundImpl.setVolume(volume);
            };
            FallbackAudio.prototype.setLoop = function (loop) {
                this.soundImpl.setLoop(loop);
            };
            FallbackAudio.prototype.load = function () {
                this.soundImpl.onload = this.onload;
                this.soundImpl.onprogress = this.onprogress;
                this.soundImpl.onerror = this.onerror;
                this.soundImpl.load();
            };
            FallbackAudio.prototype.isPlaying = function () {
                return this.soundImpl.isPlaying();
            };
            FallbackAudio.prototype.play = function () {
                return this.soundImpl.play();
            };
            FallbackAudio.prototype.pause = function () {
                this.soundImpl.pause();
            };
            FallbackAudio.prototype.stop = function () {
                this.soundImpl.stop();
            };
            return FallbackAudio;
        })();
        Internal.FallbackAudio = FallbackAudio;
        var AudioTag = (function () {
            function AudioTag(path, volume) {
                var _this = this;
                this.path = path;
                this.audioElements = new Array(5);
                this._loadedAudio = null;
                this.isLoaded = false;
                this.index = 0;
                this.log = ex.Logger.getInstance();
                this._isPlaying = false;
                this._currentOffset = 0;
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                for (var i = 0; i < this.audioElements.length; i++) {
                    (function (i) {
                        _this.audioElements[i] = new Audio();
                    })(i);
                }
                if (volume) {
                    this.setVolume(ex.Util.clamp(volume, 0, 1.0));
                }
                else {
                    this.setVolume(1.0);
                }
            }
            AudioTag.prototype.isPlaying = function () {
                return this._isPlaying;
            };
            AudioTag.prototype.audioLoaded = function () {
                this.isLoaded = true;
            };
            AudioTag.prototype.setVolume = function (volume) {
                this.audioElements.forEach(function (a) {
                    a.volume = volume;
                });
            };
            AudioTag.prototype.setLoop = function (loop) {
                this.audioElements.forEach(function (a) {
                    a.loop = loop;
                });
            };
            AudioTag.prototype.getLoop = function () {
                this.audioElements.some(function (a) { return a.loop; });
            };
            AudioTag.prototype.load = function () {
                var _this = this;
                var request = new XMLHttpRequest();
                request.open("GET", this.path, true);
                request.responseType = 'blob';
                request.onprogress = this.onprogress;
                request.onerror = this.onerror;
                request.onload = function (e) {
                    if (request.status !== 200) {
                        _this.log.error("Failed to load audio resource ", _this.path, " server responded with error code", request.status);
                        _this.onerror(request.response);
                        _this.isLoaded = false;
                        return;
                    }
                    _this._loadedAudio = URL.createObjectURL(request.response);
                    _this.audioElements.forEach(function (a) {
                        a.src = _this._loadedAudio;
                    });
                    _this.onload(e);
                };
                request.send();
            };
            AudioTag.prototype.play = function () {
                var _this = this;
                this.audioElements[this.index].load();
                //this.audioElements[this.index].currentTime = this._currentOffset;
                this.audioElements[this.index].play();
                this._currentOffset = 0;
                var done = new ex.Promise();
                this._isPlaying = true;
                if (!this.getLoop()) {
                    this.audioElements[this.index].addEventListener('ended', function () {
                        _this._isPlaying = false;
                        done.resolve(true);
                    });
                }
                this.index = (this.index + 1) % this.audioElements.length;
                return done;
            };
            AudioTag.prototype.pause = function () {
                this.index = (this.index - 1 + this.audioElements.length) % this.audioElements.length;
                this._currentOffset = this.audioElements[this.index].currentTime;
                this.audioElements.forEach(function (a) {
                    a.pause();
                });
                this._isPlaying = false;
            };
            AudioTag.prototype.stop = function () {
                this.audioElements.forEach(function (a) {
                    a.pause();
                    //a.currentTime = 0;
                });
                this._isPlaying = false;
            };
            return AudioTag;
        })();
        Internal.AudioTag = AudioTag;
        if (window.AudioContext) {
            var audioContext = new window.AudioContext();
        }
        var WebAudio = (function () {
            function WebAudio(soundPath, volume) {
                this.context = audioContext;
                this.volume = this.context.createGain();
                this.buffer = null;
                this.sound = null;
                this.path = "";
                this.isLoaded = false;
                this.loop = false;
                this._isPlaying = false;
                this._isPaused = false;
                this._currentOffset = 0;
                this.logger = ex.Logger.getInstance();
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                this.path = soundPath;
                if (volume) {
                    this.volume.gain.value = ex.Util.clamp(volume, 0, 1.0);
                }
                else {
                    this.volume.gain.value = 1.0; // max volume
                }
            }
            WebAudio.prototype.setVolume = function (volume) {
                this.volume.gain.value = volume;
            };
            WebAudio.prototype.load = function () {
                var _this = this;
                var request = new XMLHttpRequest();
                request.open('GET', this.path);
                request.responseType = 'arraybuffer';
                request.onprogress = this.onprogress;
                request.onerror = this.onerror;
                request.onload = function () {
                    if (request.status !== 200) {
                        _this.logger.error("Failed to load audio resource ", _this.path, " server responded with error code", request.status);
                        _this.onerror(request.response);
                        _this.isLoaded = false;
                        return;
                    }
                    _this.context.decodeAudioData(request.response, function (buffer) {
                        _this.buffer = buffer;
                        _this.isLoaded = true;
                        _this.onload(_this);
                    }, function (e) {
                        _this.logger.error("Unable to decode " + _this.path + " this browser may not fully support this format, or the file may be corrupt, " + "if this is an mp3 try removing id3 tags and album art from the file.");
                        _this.isLoaded = false;
                        _this.onload(_this);
                    });
                };
                try {
                    request.send();
                }
                catch (e) {
                    console.error("Error loading sound! If this is a cross origin error, you must host your sound with your html and javascript.");
                }
            };
            WebAudio.prototype.setLoop = function (loop) {
                this.loop = loop;
            };
            WebAudio.prototype.isPlaying = function () {
                return this._isPlaying;
            };
            WebAudio.prototype.play = function () {
                var _this = this;
                if (this.isLoaded) {
                    this.sound = this.context.createBufferSource();
                    this.sound.buffer = this.buffer;
                    this.sound.loop = this.loop;
                    this.sound.connect(this.volume);
                    this.volume.connect(this.context.destination);
                    this.sound.start(0, this._currentOffset % this.buffer.duration);
                    this._currentOffset = 0;
                    var done;
                    if (!this._isPaused || !this._playPromise) {
                        done = new ex.Promise();
                    }
                    else {
                        done = this._playPromise;
                    }
                    this._isPaused = false;
                    this._isPlaying = true;
                    if (!this.loop) {
                        this.sound.onended = (function () {
                            _this._isPlaying = false;
                            if (!_this._isPaused) {
                                done.resolve(true);
                            }
                        }).bind(this);
                    }
                    this._playPromise = done;
                    return done;
                }
                else {
                    return ex.Promise.wrap(true);
                }
            };
            WebAudio.prototype.pause = function () {
                if (this._isPlaying) {
                    try {
                        window.clearTimeout(this._playingTimer);
                        this.sound.stop(0);
                        this._currentOffset = this.context.currentTime;
                        this._isPlaying = false;
                        this._isPaused = true;
                    }
                    catch (e) {
                        this.logger.warn("The sound clip", this.path, "has already been paused!");
                    }
                }
            };
            WebAudio.prototype.stop = function () {
                if (this.sound) {
                    try {
                        window.clearTimeout(this._playingTimer);
                        this._currentOffset = 0;
                        this.sound.stop(0);
                        this._isPlaying = false;
                        this._isPaused = false;
                    }
                    catch (e) {
                        this.logger.warn("The sound clip", this.path, "has already been stopped!");
                    }
                }
            };
            return WebAudio;
        })();
        Internal.WebAudio = WebAudio;
    })(Internal = ex.Internal || (ex.Internal = {}));
})(ex || (ex = {}));
/// <reference path="Log.ts" />
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
var ex;
(function (ex) {
    /**
     * Valid states for a promise to be in
     * @class PromiseState
     */
    (function (PromiseState) {
        /**
        @property Resolved {PromiseState}
        */
        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
        /**
        @property Rejected {PromiseState}
        */
        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
        /**
        @property Pending {PromiseState}
        */
        PromiseState[PromiseState["Pending"] = 2] = "Pending";
    })(ex.PromiseState || (ex.PromiseState = {}));
    var PromiseState = ex.PromiseState;
    /**
     * Promises/A+ spec implementation of promises
     * @class Promise
     * @constructor
     */
    var Promise = (function () {
        function Promise() {
            this._state = 2 /* Pending */;
            this.successCallbacks = [];
            this.rejectCallback = function () {
            };
            this.logger = ex.Logger.getInstance();
        }
        /**
         * Wrap a value in a resolved promise
         * @method wrap<T>
         * @param [value=undefined] {T} An optional value to wrap in a resolved promise
         * @returns Promise&lt;T&gt;
         */
        Promise.wrap = function (value) {
            var promise = (new Promise()).resolve(value);
            return promise;
        };
        /**
         * Returns a new promise that resolves when all the promises passed to it resolve, or rejects
         * when at least 1 promise rejects.
         * @param promises {Promise[]}
         * @returns Promise
         */
        Promise.join = function () {
            var promises = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                promises[_i - 0] = arguments[_i];
            }
            var joinedPromise = new Promise();
            if (!promises) {
                return joinedPromise.resolve();
            }
            var total = promises.length;
            var successes = 0;
            var rejects = 0;
            var errors = [];
            promises.forEach(function (p) {
                p.then(function () {
                    successes += 1;
                    if (successes === total) {
                        joinedPromise.resolve();
                    }
                    else if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }, function () {
                    rejects += 1;
                    if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }).error(function (e) {
                    errors.push(e);
                    if ((errors.length + successes + rejects) === total) {
                        joinedPromise.reject(errors);
                    }
                });
            });
            return joinedPromise;
        };
        /**
         * Chain success and reject callbacks after the promise is resovled
         * @method then
         * @param successCallback {T=>any} Call on resolution of promise
         * @param rejectCallback {any=>any} Call on rejection of promise
         * @returns Promise&lt;T&gt;
         */
        Promise.prototype.then = function (successCallback, rejectCallback) {
            if (successCallback) {
                this.successCallbacks.push(successCallback);
                // If the promise is already resovled call immediately
                if (this.state() === 0 /* Resolved */) {
                    try {
                        successCallback.call(this, this.value);
                    }
                    catch (e) {
                        this.handleError(e);
                    }
                }
            }
            if (rejectCallback) {
                this.rejectCallback = rejectCallback;
                // If the promise is already rejected call immediately
                if (this.state() === 1 /* Rejected */) {
                    try {
                        rejectCallback.call(this, this.value);
                    }
                    catch (e) {
                        this.handleError(e);
                    }
                }
            }
            return this;
        };
        /**
         * Add an error callback to the promise
         * @method error
         * @param errorCallback {any=>any} Call if there was an error in a callback
         * @returns Promise&lt;T&gt;
         */
        Promise.prototype.error = function (errorCallback) {
            if (errorCallback) {
                this.errorCallback = errorCallback;
            }
            return this;
        };
        /**
         * Resolve the promise and pass an option value to the success callbacks
         * @method resolve
         * @param [value=undefined] {T} Value to pass to the success callbacks
         */
        Promise.prototype.resolve = function (value) {
            var _this = this;
            if (this._state === 2 /* Pending */) {
                this.value = value;
                try {
                    this._state = 0 /* Resolved */;
                    this.successCallbacks.forEach(function (cb) {
                        cb.call(_this, _this.value);
                    });
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            else {
                throw new Error('Cannot resolve a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Reject the promise and pass an option value to the reject callbacks
         * @method reject
         * @param [value=undefined] {T} Value to pass to the reject callbacks
         */
        Promise.prototype.reject = function (value) {
            if (this._state === 2 /* Pending */) {
                this.value = value;
                try {
                    this._state = 1 /* Rejected */;
                    this.rejectCallback.call(this, this.value);
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            else {
                throw new Error('Cannot reject a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Inpect the current state of a promise
         * @method state
         * @returns PromiseState
         */
        Promise.prototype.state = function () {
            return this._state;
        };
        Promise.prototype.handleError = function (e) {
            if (this.errorCallback) {
                this.errorCallback.call(this, e);
            }
            else {
                throw e;
            }
        };
        return Promise;
    })();
    ex.Promise = Promise;
})(ex || (ex = {}));
/// <reference path="Interfaces/ILoadable.ts" />
var ex;
(function (ex) {
    /**
     * The Resource type allows games built in Excalibur to load generic resources.
     * For any type of remote resource it is recome
     * @class Resource
     * @extend ILoadable
     * @constructor
     * @param path {string} Path to the remote resource
     */
    var Resource = (function () {
        function Resource(path, responseType, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            this.path = path;
            this.responseType = responseType;
            this.bustCache = bustCache;
            this.data = null;
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
        }
        /**
         * Returns true if the Resource is completely loaded and is ready
         * to be drawn.
         * @method isLoaded
         * @returns boolean
         */
        Resource.prototype.isLoaded = function () {
            return !!this.data;
        };
        Resource.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        Resource.prototype.cacheBust = function (uri) {
            var query = /\?\w*=\w*/;
            if (query.test(uri)) {
                uri += ("&__=" + Date.now());
            }
            else {
                uri += ("?__=" + Date.now());
            }
            return uri;
        };
        Resource.prototype._start = function (e) {
            this.logger.debug("Started loading resource " + this.path);
        };
        /**
         * Begin loading the resource and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;any&gt;
         */
        Resource.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var request = new XMLHttpRequest();
            request.open("GET", this.bustCache ? this.cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = function (e) {
                _this._start(e);
            };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function (e) {
                if (request.status !== 200) {
                    _this.logger.error("Failed to load resource ", _this.path, " server responded with error code", request.status);
                    _this.onerror(request.response);
                    complete.resolve(request.response);
                    return;
                }
                _this.data = _this.processDownload(request.response);
                _this.oncomplete();
                _this.logger.debug("Completed loading resource", _this.path);
                complete.resolve(_this.data);
            };
            request.send();
            return complete;
        };
        /**
         * Returns the loaded data once the resource is loaded
         * @method GetData
         * @returns any
         */
        Resource.prototype.getData = function () {
            return this.data;
        };
        /**
         * This method is meant to be overriden to handle any additional
         * processing. Such as decoding downloaded audio bits.
         * @method ProcessDownload
         */
        Resource.prototype.processDownload = function (data) {
            // Handle any additional loading after the xhr has completed.
            return URL.createObjectURL(data);
        };
        return Resource;
    })();
    ex.Resource = Resource;
})(ex || (ex = {}));
/// <reference path="Sound.ts" />
/// <reference path="Util.ts" />
/// <reference path="Promises.ts" />
/// <reference path="Resource.ts" />
/// <reference path="Interfaces/ILoadable.ts" />
var ex;
(function (ex) {
    /**
     * The Texture object allows games built in Excalibur to load image resources.
     * It is generally recommended to preload images using the "Texture" object.
     * @class Texture
     * @extend Resource
     * @constructor
     * @param path {string} Path to the image resource
     * @param [bustCache=true] {boolean} Optionally load texture with cache busting
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture(path, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            _super.call(this, path, 'blob', bustCache);
            this.path = path;
            this.bustCache = bustCache;
            this.loaded = new ex.Promise();
            this._isLoaded = false;
            this._sprite = null;
            this._sprite = new ex.Sprite(this, 0, 0, 0, 0);
        }
        /**
         * Returns true if the Texture is completely loaded and is ready
         * to be drawn.
         * @method isLoaded
         * @returns boolean
         */
        Texture.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the texture and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;HTMLImageElement&gt;
         */
        Texture.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var loaded = _super.prototype.load.call(this);
            loaded.then(function () {
                _this.image = new Image();
                _this.image.addEventListener("load", function () {
                    _this._isLoaded = true;
                    _this.width = _this._sprite.swidth = _this._sprite.width = _this.image.naturalWidth;
                    _this.height = _this._sprite.sheight = _this._sprite.height = _this.image.naturalHeight;
                    _this.loaded.resolve(_this.image);
                    complete.resolve(_this.image);
                });
                _this.image.src = _super.prototype.getData.call(_this);
            }, function () {
                complete.reject("Error loading texture.");
            });
            return complete;
        };
        Texture.prototype.asSprite = function () {
            return this._sprite;
        };
        return Texture;
    })(ex.Resource);
    ex.Texture = Texture;
    /**
     * The Sound object allows games built in Excalibur to load audio
     * components, from soundtracks to sound effects. It is generally
     * recommended to load sound resources when using Excalibur
     * @class Sound
     * @extend Resource
     * @constructor
     * @param ...paths {string[]} A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    var Sound = (function () {
        function Sound() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i - 0] = arguments[_i];
            }
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            this.onload = function () {
            };
            this._isLoaded = false;
            this._selectedFile = "";
            this._wasPlayingOnHidden = false;
            /* Chrome : MP3, WAV, Ogg
             * Firefox : WAV, Ogg,
             * IE : MP3, WAV coming soon
             * Safari MP3, WAV, Ogg
             */
            this._selectedFile = "";
            for (var i = 0; i < paths.length; i++) {
                if (Sound.canPlayFile(paths[i])) {
                    this._selectedFile = paths[i];
                    break;
                }
            }
            if (!this._selectedFile) {
                this.logger.warn("This browser does not support any of the files specified");
                this._selectedFile = paths[0]; // select the first specified
            }
            this.sound = new ex.Internal.FallbackAudio(this._selectedFile, 1.0);
        }
        Sound.canPlayFile = function (file) {
            try {
                var a = new Audio();
                var filetype = /.*\.([A-Za-z0-9]+)$/;
                var type = file.match(filetype)[1];
                if (a.canPlayType('audio/' + type)) {
                    return true;
                }
                {
                    return false;
                }
            }
            catch (e) {
                ex.Logger.getInstance().warn("Cannot determine audio support, assuming no support for the Audio Tag", e);
                return false;
            }
        };
        Sound.prototype.wireEngine = function (engine) {
            var _this = this;
            if (engine) {
                this._engine = engine;
                this._engine.on('hidden', function () {
                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {
                        _this._wasPlayingOnHidden = true;
                        _this.pause();
                    }
                });
                this._engine.on('visible', function () {
                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {
                        _this.play();
                        _this._wasPlayingOnHidden = false;
                    }
                });
            }
        };
        /**
         * Sets the volume of the sound clip
         * @method setVolume
         * @param volume {number} A volume value between 0-1.0
         */
        Sound.prototype.setVolume = function (volume) {
            if (this.sound)
                this.sound.setVolume(volume);
        };
        /**
         * Indicates whether the clip should loop when complete
         * @method setLoop
         * @param loop {boolean} Set the looping flag
         */
        Sound.prototype.setLoop = function (loop) {
            if (this.sound)
                this.sound.setLoop(loop);
        };
        Sound.prototype.isPlaying = function () {
            if (this.sound)
                return this.sound.isPlaying();
        };
        /**
         * Play the sound, returns a promise that resolves when the sound is done playing
         * @method play
         * @return ex.Promise
         */
        Sound.prototype.play = function () {
            if (this.sound)
                return this.sound.play();
        };
        /**
         * Stop the sound, and do not rewind
         * @method pause
         */
        Sound.prototype.pause = function () {
            if (this.sound)
                this.sound.pause();
        };
        /**
         * Stop the sound and rewind
         * @method stop
         */
        Sound.prototype.stop = function () {
            if (this.sound)
                this.sound.stop();
        };
        /**
         * Returns true if the sound is loaded
         * @method isLoaded
         */
        Sound.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the sound and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;Sound&gt;
         */
        Sound.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            this.logger.debug("Started loading sound", this._selectedFile);
            this.sound.onprogress = this.onprogress;
            this.sound.onload = function () {
                _this.oncomplete();
                _this._isLoaded = true;
                _this.logger.debug("Completed loading sound", _this._selectedFile);
                complete.resolve(_this.sound);
            };
            this.sound.onerror = function (e) {
                _this.onerror(e);
                complete.resolve(e);
            };
            this.sound.load();
            return complete;
        };
        return Sound;
    })();
    ex.Sound = Sound;
    /**
     * The loader provides a mechanism to preload multiple resources at
     * one time. The loader must be passed to the engine in order to
     * trigger the loading progress bar
     * @class Loader
     * @extend ILoadable
     * @constructor
     * @param [loadables=undefined] {ILoadable[]} Optionally provide the list of resources you want to load at constructor time
     */
    var Loader = (function () {
        function Loader(loadables) {
            this.resourceList = [];
            this.index = 0;
            this.resourceCount = 0;
            this.numLoaded = 0;
            this.progressCounts = {};
            this.totalCounts = {};
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            if (loadables) {
                this.addResources(loadables);
            }
        }
        Loader.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Add a resource to the loader to load
         * @method addResource
         * @param loadable {ILoadable} Resource to add
         */
        Loader.prototype.addResource = function (loadable) {
            var key = this.index++;
            this.resourceList.push(loadable);
            this.progressCounts[key] = 0;
            this.totalCounts[key] = 1;
            this.resourceCount++;
        };
        /**
         * Add a list of resources to the loader to load
         * @method addResources
         * @param loadables {ILoadable[]} The list of resources to load
         */
        Loader.prototype.addResources = function (loadables) {
            var _this = this;
            loadables.forEach(function (l) {
                _this.addResource(l);
            });
        };
        Loader.prototype.sumCounts = function (obj) {
            var sum = 0;
            var prev = 0;
            for (var i in obj) {
                sum += obj[i] | 0;
            }
            return sum;
        };
        /**
         * Returns true if the loader has completely loaded all resources
         * @method isLoaded
         */
        Loader.prototype.isLoaded = function () {
            return this.numLoaded === this.resourceCount;
        };
        /**
         * Begin loading all of the supplied resources, returning a promise that resolves when loading of all is complete
         * @method load
         * @returns Promsie&lt;any&gt;
         */
        Loader.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var me = this;
            if (this.resourceList.length === 0) {
                me.oncomplete.call(me);
                return complete;
            }
            var progressArray = new Array(this.resourceList.length);
            var progressChunks = this.resourceList.length;
            this.resourceList.forEach(function (r, i) {
                if (_this._engine) {
                    r.wireEngine(_this._engine);
                }
                r.onprogress = function (e) {
                    var total = e.total;
                    var loaded = e.loaded;
                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };
                    var progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: (accum.loaded + next.loaded), total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                r.oncomplete = r.onerror = function () {
                    me.numLoaded++;
                    if (me.numLoaded === me.resourceCount) {
                        me.onprogress.call(me, { loaded: 100, total: 100 });
                        me.oncomplete.call(me);
                        complete.resolve();
                    }
                };
            });
            function loadNext(list, index) {
                if (!list[index])
                    return;
                list[index].load().then(function () {
                    loadNext(list, index + 1);
                });
            }
            loadNext(this.resourceList, 0);
            return complete;
        };
        return Loader;
    })();
    ex.Loader = Loader;
})(ex || (ex = {}));
/// <reference path="Promises.ts" />
/// <reference path="Loader.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur's built in templating class, it is a loadable that will load
     * and html fragment from a url. Excalibur templating is very basic only
     * allowing bindings of the type data-text="this.obj.someprop",
     * data-style="color:this.obj.color.toString()". Bindings allow all valid
     * javascript expressions.
     * @class Template
     * @extends ILoadable
     * @constructor
     * @param path {string} Location of the html template
     */
    var Template = (function () {
        function Template(path) {
            this.path = path;
            this._isLoaded = false;
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            this._innerElement = document.createElement('div');
            this._innerElement.className = "excalibur-template";
        }
        Template.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Returns the full html template string once loaded.
         * @method getTemplateString
         * @returns string
         */
        Template.prototype.getTemplateString = function () {
            if (!this._isLoaded)
                return "";
            return this._htmlString;
        };
        Template.prototype._compile = function () {
            this._innerElement.innerHTML = this._htmlString;
            this._styleElements = this._innerElement.querySelectorAll('[data-style]');
            this._textElements = this._innerElement.querySelectorAll('[data-text]');
        };
        Template.prototype._evaluateExpresion = function (expression, ctx) {
            var func = new Function("return " + expression + ";");
            var val = func.call(ctx);
            return val;
        };
        /**
         * Applies any ctx object you wish and evaluates the template.
         * Overload this method to include your favorite template library.
         * You may return either an HTML string or a Dom node.
         * @method apply
         * @param ctx {any} Any object you wish to apply to the template
         * @returns any
         */
        Template.prototype.apply = function (ctx) {
            var _this = this;
            for (var j = 0; j < this._styleElements.length; j++) {
                (function () {
                    // poor man's json parse for things that aren't exactly json :(
                    // Extract style expressions
                    var styles = {};
                    _this._styleElements[j].dataset["style"].split(";").forEach(function (s) {
                        if (s) {
                            var vals = s.split(":");
                            styles[vals[0].trim()] = vals[1].trim();
                        }
                    });
                    for (var style in styles) {
                        (function () {
                            var expression = styles[style];
                            _this._styleElements[j].style[style] = _this._evaluateExpresion(expression, ctx);
                        })();
                    }
                })();
            }
            for (var i = 0; i < this._textElements.length; i++) {
                (function () {
                    // Evaluate text expressions
                    var expression = _this._textElements[i].dataset["text"];
                    _this._textElements[i].innerText = _this._evaluateExpresion(expression, ctx);
                })();
            }
            // If the template HTML has a root element return that, otherwise use constructed root
            if (this._innerElement.children.length === 1) {
                this._innerElement = this._innerElement.firstChild;
            }
            return this._innerElement;
        };
        /**
         * Begins loading the template. Returns a promise that resolves with the template string when loaded.
         * @method load
         * @returns {Promise}
         */
        Template.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var request = new XMLHttpRequest();
            request.open("GET", this.path, true);
            request.responseType = "text";
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function (e) {
                if (request.status !== 200) {
                    _this.logger.error("Failed to load html template resource ", _this.path, " server responded with error code", request.status);
                    _this.onerror(request.response);
                    _this._isLoaded = false;
                    complete.resolve("error");
                    return;
                }
                _this._htmlString = request.response;
                _this.oncomplete();
                _this.logger.debug("Completed loading template", _this.path);
                _this._compile();
                _this._isLoaded = true;
                complete.resolve(_this._htmlString);
            };
            if (request.overrideMimeType) {
                request.overrideMimeType('text/plain; charset=x-user-defined');
            }
            request.send();
            return complete;
        };
        /**
         * Indicates whether the template has been loaded
         * @method isLoaded
         * @returns {boolean}
         */
        Template.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        return Template;
    })();
    ex.Template = Template;
    /**
     * Excalibur's binding library that allows you to bind an html
     * template to the dom given a certain context. Excalibur bindings are only updated
     * when the update() method is called
     * @class Binding
     * @constructor
     * @param parentElementId {string} The id of the element in the dom to attach the template binding
     * @param template {Template} The template you wish to bind
     * @param ctx {any} The context of the binding, which can be any object
     */
    var Binding = (function () {
        function Binding(parentElementId, template, ctx) {
            this.parent = document.getElementById(parentElementId);
            this.template = template;
            this._ctx = ctx;
            this.update();
        }
        /**
         * Listen to any arbitrary object's events to update this binding
         * @method listen
         * @param obj {any} Any object that supports addEventListener
         * @param events {string[]} A list of events to listen for
         * @param [hander=defaultHandler] {callback} A optional handler to fire on any event
         */
        Binding.prototype.listen = function (obj, events, handler) {
            var _this = this;
            // todo
            if (!handler) {
                handler = function () {
                    _this.update();
                };
            }
            if (obj.addEventListener) {
                events.forEach(function (e) {
                    obj.addEventListener(e, handler);
                });
            }
        };
        /**
         * Update this template binding with the latest values from the ctx reference passed to the constructor
         * @method update
         */
        Binding.prototype.update = function () {
            var html = this._applyTemplate(this.template, this._ctx);
            if (html instanceof String) {
                this.parent.innerHTML = html;
            }
            if (html instanceof Node) {
                if (this.parent.lastChild !== html) {
                    this.parent.appendChild(html);
                }
            }
        };
        Binding.prototype._applyTemplate = function (template, ctx) {
            if (template.isLoaded()) {
                return template.apply(ctx);
            }
        };
        return Binding;
    })();
    ex.Binding = Binding;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * Enum representing the different horizontal text alignments
     * @class TextAlign
     */
    (function (TextAlign) {
        /**
         * The text is left-aligned.
         * @property Left
         * @static
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * The text is right-aligned.
         * @property Right
         * @static
         */
        TextAlign[TextAlign["Right"] = 1] = "Right";
        /**
         * The text is centered.
         * @property Center
         * @static
         */
        TextAlign[TextAlign["Center"] = 2] = "Center";
        /**
         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).
         * @property Start
         * @static
         */
        TextAlign[TextAlign["Start"] = 3] = "Start";
        /**
         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).
         * @property End
         * @static
         */
        TextAlign[TextAlign["End"] = 4] = "End";
    })(ex.TextAlign || (ex.TextAlign = {}));
    var TextAlign = ex.TextAlign;
    /**
     * Enum representing the different baseline text alignments
     * @class BaseAlign
     */
    (function (BaseAlign) {
        /**
         * The text baseline is the top of the em square.
         * @property Top
         * @static
         */
        BaseAlign[BaseAlign["Top"] = 0] = "Top";
        /**
         * The text baseline is the hanging baseline.  Currently unsupported; this will act like alphabetic.
         * @property Hanging
         * @static
         */
        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
        /**
         * The text baseline is the middle of the em square.
         * @property Middle
         * @static
         */
        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
        /**
         * The text baseline is the normal alphabetic baseline.
         * @property Alphabetic
         * @static
         */
        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
        /**
         * The text baseline is the ideographic baseline; this is the bottom of
         * the body of the characters, if the main body of characters protrudes
         * beneath the alphabetic baseline.  Currently unsupported; this will
         * act like alphabetic.
         * @property Ideographic
         * @static
         */
        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
        /**
         * The text baseline is the bottom of the bounding box.  This differs
         * from the ideographic baseline in that the ideographic baseline
         * doesn't consider descenders.
         * @property Bottom
         * @static
         */
        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
    })(ex.BaseAlign || (ex.BaseAlign = {}));
    var BaseAlign = ex.BaseAlign;
    /**
     * Labels are the way to draw small amounts of text to the screen in Excalibur. They are
     * actors and inherit all of the benifits and capabilities.
     * @class Label
     * @extends Actor
     * @constructor
     * @param [text=empty] {string} The text of the label
     * @param [x=0] {number} The x position of the label
     * @param [y=0] {number} The y position of the label
     * @param [font=sans-serif] {string} Use any valid css font string for the label's font. Default is "10px sans-serif".
     * @param [spriteFont=undefined] {SpriteFont} Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precendence over a css font.
     *
     */
    var Label = (function (_super) {
        __extends(Label, _super);
        function Label(text, x, y, font, spriteFont) {
            _super.call(this, x, y);
            /**
             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
             * @property [letterSpacing=0] {number}
             */
            this.letterSpacing = 0; //px
            this.caseInsensitive = true;
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = ex.Color.Black.clone();
            this._shadowColorDirty = false;
            this._textSprites = {};
            this._shadowSprites = {};
            this._color = ex.Color.Black.clone();
            this.text = text || "";
            this.color = ex.Color.Black.clone();
            this.spriteFont = spriteFont;
            this.collisionType = 0 /* PreventCollision */;
            this.font = font || "10px sans-serif"; // coallesce to default canvas font
            if (spriteFont) {
                this._textSprites = spriteFont.getTextSprites();
            }
        }
        /**
         * Returns the width of the text in the label (in pixels);
         * @method getTextWidth {number}
         * @param ctx {CanvasRenderingContext2D} Rending context to measure the string with
         */
        Label.prototype.getTextWidth = function (ctx) {
            var oldFont = ctx.font;
            ctx.font = this.font;
            var width = ctx.measureText(this.text).width;
            ctx.font = oldFont;
            return width;
        };
        // TypeScript doesn't support string enums :(
        Label.prototype._lookupTextAlign = function (textAlign) {
            switch (textAlign) {
                case 0 /* Left */:
                    return "left";
                    break;
                case 1 /* Right */:
                    return "right";
                    break;
                case 2 /* Center */:
                    return "center";
                    break;
                case 4 /* End */:
                    return "end";
                    break;
                case 3 /* Start */:
                    return "start";
                    break;
                default:
                    return "start";
                    break;
            }
        };
        Label.prototype._lookupBaseAlign = function (baseAlign) {
            switch (baseAlign) {
                case 3 /* Alphabetic */:
                    return "alphabetic";
                    break;
                case 5 /* Bottom */:
                    return "bottom";
                    break;
                case 1 /* Hanging */:
                    return "hangin";
                    break;
                case 4 /* Ideographic */:
                    return "ideographic";
                    break;
                case 2 /* Middle */:
                    return "middle";
                    break;
                case 0 /* Top */:
                    return "top";
                    break;
                default:
                    return "alphabetic";
                    break;
            }
        };
        /**
         * Sets the text shadow for sprite fonts
         * @method setTextShadow
         * @param offsetX {number} The x offset in pixels to place the shadow
         * @param offsetY {number} The y offset in pixles to place the shadow
         * @param shadowColor {Color} The color of the text shadow
         */
        Label.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this._textShadowOn = true;
            this._shadowOffsetX = offsetX;
            this._shadowOffsetY = offsetY;
            this._shadowColor = shadowColor.clone();
            this._shadowColorDirty = true;
            for (var character in this._textSprites) {
                this._shadowSprites[character] = this._textSprites[character].clone();
            }
        };
        /**
         * Clears the current text shadow
         * @method clearTextShadow
         */
        Label.prototype.clearTextShadow = function () {
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = ex.Color.Black.clone();
        };
        Label.prototype.update = function (engine, delta) {
            _super.prototype.update.call(this, engine, delta);
            if (this.spriteFont && this._color !== this.color) {
                for (var character in this._textSprites) {
                    this._textSprites[character].clearEffects();
                    this._textSprites[character].addEffect(new ex.Effects.Fill(this.color.clone()));
                    this._color = this.color;
                }
            }
            if (this.spriteFont && this._textShadowOn && this._shadowColorDirty && this._shadowColor) {
                for (var character in this._shadowSprites) {
                    this._shadowSprites[character].clearEffects();
                    this._shadowSprites[character].addEffect(new ex.Effects.Fill(this._shadowColor.clone()));
                }
                this._shadowColorDirty = false;
            }
        };
        Label.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            if (this._textShadowOn) {
                ctx.save();
                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
                this._fontDraw(ctx, delta, this._shadowSprites);
                ctx.restore();
            }
            this._fontDraw(ctx, delta, this._textSprites);
            _super.prototype.draw.call(this, ctx, delta);
            ctx.restore();
        };
        Label.prototype._fontDraw = function (ctx, delta, sprites) {
            if (this.spriteFont) {
                var currX = 0;
                for (var i = 0; i < this.text.length; i++) {
                    var character = this.text[i];
                    if (this.caseInsensitive) {
                        character = character.toLowerCase();
                    }
                    try {
                        var charSprite = sprites[character];
                        if (this.previousOpacity !== this.opacity) {
                            charSprite.clearEffects();
                            charSprite.addEffect(new ex.Effects.Opacity(this.opacity));
                        }
                        charSprite.draw(ctx, currX, 0);
                        currX += (charSprite.swidth + this.letterSpacing);
                    }
                    catch (e) {
                        ex.Logger.getInstance().error("SpriteFont Error drawing char " + character);
                    }
                }
                if (this.previousOpacity !== this.opacity) {
                    this.previousOpacity = this.opacity;
                }
            }
            else {
                var oldAlign = ctx.textAlign;
                var oldTextBaseline = ctx.textBaseline;
                ctx.textAlign = this._lookupTextAlign(this.textAlign);
                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
                if (this.color) {
                    this.color.a = this.opacity;
                }
                ctx.fillStyle = this.color.toString();
                ctx.font = this.font;
                if (this.maxWidth) {
                    ctx.fillText(this.text, 0, 0, this.maxWidth);
                }
                else {
                    ctx.fillText(this.text, 0, 0);
                }
                ctx.textAlign = oldAlign;
                ctx.textBaseline = oldTextBaseline;
            }
        };
        Label.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
        };
        return Label;
    })(ex.Actor);
    ex.Label = Label;
})(ex || (ex = {}));
/// <reference path="../Events.ts"/>
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        (function (PointerType) {
            PointerType[PointerType["Touch"] = 0] = "Touch";
            PointerType[PointerType["Mouse"] = 1] = "Mouse";
            PointerType[PointerType["Pen"] = 2] = "Pen";
            PointerType[PointerType["Unknown"] = 3] = "Unknown";
        })(Input.PointerType || (Input.PointerType = {}));
        var PointerType = Input.PointerType;
        (function (PointerButton) {
            PointerButton[PointerButton["Left"] = 0] = "Left";
            PointerButton[PointerButton["Middle"] = 1] = "Middle";
            PointerButton[PointerButton["Right"] = 2] = "Right";
            PointerButton[PointerButton["Unknown"] = 3] = "Unknown";
        })(Input.PointerButton || (Input.PointerButton = {}));
        var PointerButton = Input.PointerButton;
        var PointerEvent = (function (_super) {
            __extends(PointerEvent, _super);
            function PointerEvent(x, y, index, pointerType, button, ev) {
                _super.call(this);
                this.x = x;
                this.y = y;
                this.index = index;
                this.pointerType = pointerType;
                this.button = button;
                this.ev = ev;
            }
            return PointerEvent;
        })(ex.GameEvent);
        Input.PointerEvent = PointerEvent;
        ;
        /**
         * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to W3C Pointer Events.
         * There is always at least one pointer available (primary).
         *
         * @class Pointers
         * @extends Class
         * @constructor
         */
        var Pointers = (function (_super) {
            __extends(Pointers, _super);
            function Pointers(engine) {
                _super.call(this);
                this._pointerDown = [];
                this._pointerUp = [];
                this._pointerMove = [];
                this._pointerCancel = [];
                this._pointers = [];
                this._activePointers = [];
                this._engine = engine;
                this._pointers.push(new Pointer());
                this._activePointers = [-1];
                this.primary = this._pointers[0];
            }
            /**
             * Initializes pointer event listeners
             */
            Pointers.prototype.init = function () {
                // Touch Events
                document.addEventListener('touchstart', this._handleTouchEvent("down", this._pointerDown));
                document.addEventListener('touchend', this._handleTouchEvent("up", this._pointerUp));
                document.addEventListener('touchmove', this._handleTouchEvent("move", this._pointerMove));
                document.addEventListener('touchcancel', this._handleTouchEvent("cancel", this._pointerCancel));
                // W3C Pointer Events
                // Current: IE11, IE10
                if (window.PointerEvent) {
                    // IE11
                    this._engine.canvas.style.touchAction = "none";
                    document.addEventListener('pointerdown', this._handlePointerEvent("down", this._pointerDown));
                    document.addEventListener('pointerup', this._handlePointerEvent("up", this._pointerUp));
                    document.addEventListener('pointermove', this._handlePointerEvent("move", this._pointerMove));
                    document.addEventListener('pointercancel', this._handlePointerEvent("cancel", this._pointerMove));
                }
                else if (window.MSPointerEvent) {
                    // IE10
                    this._engine.canvas.style.msTouchAction = "none";
                    document.addEventListener('MSPointerDown', this._handlePointerEvent("down", this._pointerDown));
                    document.addEventListener('MSPointerUp', this._handlePointerEvent("up", this._pointerUp));
                    document.addEventListener('MSPointerMove', this._handlePointerEvent("move", this._pointerMove));
                    document.addEventListener('MSPointerCancel', this._handlePointerEvent("cancel", this._pointerMove));
                }
                else {
                    // Mouse Events
                    document.addEventListener('mousedown', this._handleMouseEvent("down", this._pointerDown));
                    document.addEventListener('mouseup', this._handleMouseEvent("up", this._pointerUp));
                    document.addEventListener('mousemove', this._handleMouseEvent("move", this._pointerMove));
                }
            };
            Pointers.prototype.update = function (delta) {
                this._pointerUp.length = 0;
                this._pointerDown.length = 0;
                this._pointerMove.length = 0;
                this._pointerCancel.length = 0;
            };
            /**
             * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
             * @param index {number} The pointer index to retrieve
             */
            Pointers.prototype.at = function (index) {
                if (index >= this._pointers.length) {
                    for (var i = this._pointers.length - 1, max = index; i < max; i++) {
                        this._pointers.push(new Pointer());
                        this._activePointers.push(-1);
                    }
                }
                return this._pointers[index];
            };
            /**
             * Get number of pointers being watched
             */
            Pointers.prototype.count = function () {
                return this._pointers.length;
            };
            /**
             * Propogates events to actor if necessary
             */
            Pointers.prototype.propogate = function (actor) {
                var isUIActor = actor instanceof ex.UIActor;
                this._pointerUp.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointerup", e);
                    }
                });
                this._pointerDown.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointerdown", e);
                    }
                });
                if (actor.capturePointer.captureMoveEvents) {
                    this._pointerMove.forEach(function (e) {
                        if (actor.contains(e.x, e.y, !isUIActor)) {
                            actor.eventDispatcher.publish("pointermove", e);
                        }
                    });
                }
                this._pointerCancel.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointercancel", e);
                    }
                });
            };
            Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    var x = e.pageX - ex.Util.getPosition(_this._engine.canvas).x;
                    var y = e.pageY - ex.Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, 0, 1 /* Mouse */, e.button, e);
                    eventArr.push(pe);
                    _this.at(0).eventDispatcher.publish(eventName, pe);
                };
            };
            Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                        var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                        if (index === -1)
                            continue;
                        var x = e.changedTouches[i].pageX - ex.Util.getPosition(_this._engine.canvas).x;
                        var y = e.changedTouches[i].pageY - ex.Util.getPosition(_this._engine.canvas).y;
                        var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                        var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, index, 0 /* Touch */, 3 /* Unknown */, e);
                        eventArr.push(pe);
                        _this.at(index).eventDispatcher.publish(eventName, pe);
                        // only with multi-pointer
                        if (_this._pointers.length > 1) {
                            if (eventName === "up") {
                                // remove pointer ID from pool when pointer is lifted
                                _this._activePointers[index] = -1;
                            }
                            else if (eventName === "down") {
                                // set pointer ID to given index
                                _this._activePointers[index] = e.changedTouches[i].identifier;
                            }
                        }
                    }
                };
            };
            Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    // get the index for this pointer ID if multi-pointer is asked for
                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;
                    if (index === -1)
                        return;
                    var x = e.pageX - ex.Util.getPosition(_this._engine.canvas).x;
                    var y = e.pageY - ex.Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, index, _this._stringToPointerType(e.pointerType), e.button, e);
                    eventArr.push(pe);
                    _this.at(index).eventDispatcher.publish(eventName, pe);
                    // only with multi-pointer
                    if (_this._pointers.length > 1) {
                        if (eventName === "up") {
                            // remove pointer ID from pool when pointer is lifted
                            _this._activePointers[index] = -1;
                        }
                        else if (eventName === "down") {
                            // set pointer ID to given index
                            _this._activePointers[index] = e.pointerId;
                        }
                    }
                };
            };
            /**
             * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
             * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
             * @private
             */
            Pointers.prototype._getPointerIndex = function (pointerId) {
                var idx;
                if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
                    return idx;
                }
                for (var i = 0; i < this._activePointers.length; i++) {
                    if (this._activePointers[i] === -1)
                        return i;
                }
                // ignore pointer because game isn't watching
                return -1;
            };
            Pointers.prototype._stringToPointerType = function (s) {
                switch (s) {
                    case "touch":
                        return 0 /* Touch */;
                    case "mouse":
                        return 1 /* Mouse */;
                    case "pen":
                        return 2 /* Pen */;
                    default:
                        return 3 /* Unknown */;
                }
            };
            return Pointers;
        })(ex.Class);
        Input.Pointers = Pointers;
        /**
         * Captures and dispatches PointerEvents
         * @class Pointer
         * @constructor
         * @extends Class
         */
        var Pointer = (function (_super) {
            __extends(Pointer, _super);
            function Pointer() {
                _super.apply(this, arguments);
            }
            return Pointer;
        })(ex.Class);
        Input.Pointer = Pointer;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        /**
        * Enum representing input key codes
        * @class Keys
        *
        */
        (function (Keys) {
            /**
            @property Num1 {Keys}
            */
            /**
            @property Num2 {Keys}
            */
            /**
            @property Num3 {Keys}
            */
            /**
            @property Num4 {Keys}
            */
            /**
            @property Num5 {Keys}
            */
            /**
            @property Num6 {Keys}
            */
            /**
            @property Num7 {Keys}
            */
            /**
            @property Num8 {Keys}
            */
            /**
            @property Num9 {Keys}
            */
            /**
            @property Num0 {Keys}
            */
            Keys[Keys["Num1"] = 97] = "Num1";
            Keys[Keys["Num2"] = 98] = "Num2";
            Keys[Keys["Num3"] = 99] = "Num3";
            Keys[Keys["Num4"] = 100] = "Num4";
            Keys[Keys["Num5"] = 101] = "Num5";
            Keys[Keys["Num6"] = 102] = "Num6";
            Keys[Keys["Num7"] = 103] = "Num7";
            Keys[Keys["Num8"] = 104] = "Num8";
            Keys[Keys["Num9"] = 105] = "Num9";
            Keys[Keys["Num0"] = 96] = "Num0";
            /**
            @property Numlock {Keys}
            */
            Keys[Keys["Numlock"] = 144] = "Numlock";
            /**
            @property Semicolon {Keys}
            */
            Keys[Keys["Semicolon"] = 186] = "Semicolon";
            /**
            @property A {Keys}
            */
            /**
            @property B {Keys}
            */
            /**
            @property C {Keys}
            */
            /**
            @property D {Keys}
            */
            /**
            @property E {Keys}
            */
            /**
            @property F {Keys}
            */
            /**
            @property G {Keys}
            */
            /**
            @property H {Keys}
            */
            /**
            @property I {Keys}
            */
            /**
            @property J {Keys}
            */
            /**
            @property K {Keys}
            */
            /**
            @property L {Keys}
            */
            /**
            @property M {Keys}
            */
            /**
            @property N {Keys}
            */
            /**
            @property O {Keys}
            */
            /**
            @property P {Keys}
            */
            /**
            @property Q {Keys}
            */
            /**
            @property R {Keys}
            */
            /**
            @property S {Keys}
            */
            /**
            @property T {Keys}
            */
            /**
            @property U {Keys}
            */
            /**
            @property V {Keys}
            */
            /**
            @property W {Keys}
            */
            /**
            @property X {Keys}
            */
            /**
            @property Y {Keys}
            */
            /**
            @property Z {Keys}
            */
            Keys[Keys["A"] = 65] = "A";
            Keys[Keys["B"] = 66] = "B";
            Keys[Keys["C"] = 67] = "C";
            Keys[Keys["D"] = 68] = "D";
            Keys[Keys["E"] = 69] = "E";
            Keys[Keys["F"] = 70] = "F";
            Keys[Keys["G"] = 71] = "G";
            Keys[Keys["H"] = 72] = "H";
            Keys[Keys["I"] = 73] = "I";
            Keys[Keys["J"] = 74] = "J";
            Keys[Keys["K"] = 75] = "K";
            Keys[Keys["L"] = 76] = "L";
            Keys[Keys["M"] = 77] = "M";
            Keys[Keys["N"] = 78] = "N";
            Keys[Keys["O"] = 79] = "O";
            Keys[Keys["P"] = 80] = "P";
            Keys[Keys["Q"] = 81] = "Q";
            Keys[Keys["R"] = 82] = "R";
            Keys[Keys["S"] = 83] = "S";
            Keys[Keys["T"] = 84] = "T";
            Keys[Keys["U"] = 85] = "U";
            Keys[Keys["V"] = 86] = "V";
            Keys[Keys["W"] = 87] = "W";
            Keys[Keys["X"] = 88] = "X";
            Keys[Keys["Y"] = 89] = "Y";
            Keys[Keys["Z"] = 90] = "Z";
            /**
            @property Shift {Keys}
            */
            /**
            @property Alt {Keys}
            */
            /**
            @property Up {Keys}
            */
            /**
            @property Down {Keys}
            */
            /**
            @property Left {Keys}
            */
            /**
            @property Right {Keys}
            */
            /**
            @property Space {Keys}
            */
            /**
            @property Esc {Keys}
            */
            Keys[Keys["Shift"] = 16] = "Shift";
            Keys[Keys["Alt"] = 18] = "Alt";
            Keys[Keys["Up"] = 38] = "Up";
            Keys[Keys["Down"] = 40] = "Down";
            Keys[Keys["Left"] = 37] = "Left";
            Keys[Keys["Right"] = 39] = "Right";
            Keys[Keys["Space"] = 32] = "Space";
            Keys[Keys["Esc"] = 27] = "Esc";
        })(Input.Keys || (Input.Keys = {}));
        var Keys = Input.Keys;
        ;
        /**
         * Event thrown on a game object for a key event
         *
         * @class KeyEvent
         * @extends GameEvent
         * @constructor
         * @param key {InputKey} The key responsible for throwing the event
         */
        var KeyEvent = (function (_super) {
            __extends(KeyEvent, _super);
            function KeyEvent(key) {
                _super.call(this);
                this.key = key;
            }
            return KeyEvent;
        })(ex.GameEvent);
        Input.KeyEvent = KeyEvent;
        /**
         * Manages Keyboard input events that you can query or listen for events on
         *
         * @class Keyboard
         * @extends Class
         * @constructor
         *
         */
        var Keyboard = (function (_super) {
            __extends(Keyboard, _super);
            function Keyboard(engine) {
                _super.call(this);
                this._keys = [];
                this._keysUp = [];
                this._keysDown = [];
                this._engine = engine;
            }
            /**
             * Initialize Keyboard event listeners
             */
            Keyboard.prototype.init = function () {
                var _this = this;
                window.addEventListener('blur', function (ev) {
                    _this._keys.length = 0; // empties array efficiently
                });
                // key up is on window because canvas cannot have focus
                window.addEventListener('keyup', function (ev) {
                    var key = _this._keys.indexOf(ev.keyCode);
                    _this._keys.splice(key, 1);
                    _this._keysUp.push(ev.keyCode);
                    var keyEvent = new KeyEvent(ev.keyCode);
                    _this.eventDispatcher.publish("up", keyEvent);
                });
                // key down is on window because canvas cannot have focus
                window.addEventListener('keydown', function (ev) {
                    if (_this._keys.indexOf(ev.keyCode) === -1) {
                        _this._keys.push(ev.keyCode);
                        _this._keysDown.push(ev.keyCode);
                        var keyEvent = new KeyEvent(ev.keyCode);
                        _this.eventDispatcher.publish("down", keyEvent);
                    }
                });
            };
            Keyboard.prototype.update = function (delta) {
                // Reset keysDown and keysUp after update is complete
                this._keysDown.length = 0;
                this._keysUp.length = 0;
            };
            /**
             * Gets list of keys being pressed down
             */
            Keyboard.prototype.getKeys = function () {
                return this._keys;
            };
            /**
             *  Tests if a certain key is down.
             * @method isKeyDown
             * @param key {Keys} Test wether a key is down
             * @returns boolean
             */
            Keyboard.prototype.isKeyDown = function (key) {
                return this._keysDown.indexOf(key) > -1;
            };
            /**
             *  Tests if a certain key is pressed.
             * @method isKeyPressed
             * @param key {Keys} Test wether a key is pressed
             * @returns boolean
             */
            Keyboard.prototype.isKeyPressed = function (key) {
                return this._keys.indexOf(key) > -1;
            };
            /**
             *  Tests if a certain key is up.
             * @method isKeyUp
             * @param key {Keys} Test wether a key is up
             * @returns boolean
             */
            Keyboard.prototype.isKeyUp = function (key) {
                return this._keysUp.indexOf(key) > -1;
            };
            return Keyboard;
        })(ex.Class);
        Input.Keyboard = Keyboard;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        /**
         * Manages Gamepad API input. You can query the gamepads that are connected
         * or listen to events ("button" and "axis").
         * @class Gamepads
         * @extends Class
         * @param pads {Gamepad[]} The connected gamepads.
         * @param supported {boolean} Whether or not the Gamepad API is present
         */
        var Gamepads = (function (_super) {
            __extends(Gamepads, _super);
            function Gamepads(engine) {
                _super.call(this);
                /**
                 * Whether or not to poll for Gamepad input (default: false)
                 * @property enabled {boolean}
                 */
                this.enabled = false;
                /**
                 * Whether or not Gamepad API is supported
                 * @property supported {boolean}
                 */
                this.supported = !!navigator.getGamepads;
                this._gamePadTimeStamps = [0, 0, 0, 0];
                this._oldPads = [];
                this._pads = [];
                this._initSuccess = false;
                this._navigator = navigator;
                this._engine = engine;
            }
            Gamepads.prototype.init = function () {
                if (!this.supported)
                    return;
                if (this._initSuccess)
                    return;
                // In Chrome, this will return 4 undefined items until a button is pressed
                // In FF, this will not return any items until a button is pressed
                this._oldPads = this._clonePads(this._navigator.getGamepads());
                if (this._oldPads.length && this._oldPads[0]) {
                    this._initSuccess = true;
                }
            };
            /**
             * Updates Gamepad state and publishes Gamepad events
             */
            Gamepads.prototype.update = function (delta) {
                if (!this.enabled || !this.supported)
                    return;
                this.init();
                var gamepads = this._navigator.getGamepads();
                for (var i = 0; i < gamepads.length; i++) {
                    if (!gamepads[i]) {
                        // Reset connection status
                        this.at(i).connected = false;
                        continue;
                    }
                    else {
                        // Set connection status
                        this.at(i).connected = true;
                    }
                    ;
                    // Only supported in Chrome
                    if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                        continue;
                    }
                    this._gamePadTimeStamps[i] = gamepads[i].timestamp;
                    // Buttons
                    var b, a, value, buttonIndex, axesIndex;
                    for (b in Buttons) {
                        if (typeof Buttons[b] !== "number")
                            continue;
                        buttonIndex = Buttons[b];
                        value = gamepads[i].buttons[buttonIndex].value;
                        if (value !== this._oldPads[i].getButton(buttonIndex)) {
                            if (gamepads[i].buttons[buttonIndex].pressed) {
                                this.at(i).updateButton(buttonIndex, value);
                                this.at(i).eventDispatcher.publish("button", new GamepadButtonEvent(buttonIndex, value));
                            }
                            else {
                                this.at(i).updateButton(buttonIndex, 0);
                            }
                        }
                    }
                    for (a in Axes) {
                        if (typeof Axes[a] !== "number")
                            continue;
                        axesIndex = Axes[a];
                        value = gamepads[i].axes[axesIndex];
                        if (value !== this._oldPads[i].getAxes(axesIndex)) {
                            this.at(i).updateAxes(axesIndex, value);
                            this.at(i).eventDispatcher.publish("axis", new GamepadAxisEvent(axesIndex, value));
                        }
                    }
                    this._oldPads[i] = this._clonePad(gamepads[i]);
                }
            };
            /**
             * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
             */
            Gamepads.prototype.at = function (index) {
                if (index >= this._pads.length) {
                    for (var i = this._pads.length - 1, max = index; i < max; i++) {
                        this._pads.push(new Gamepad());
                        this._oldPads.push(new Gamepad());
                    }
                }
                return this._pads[index];
            };
            /**
             * Gets the number of connected gamepads
             */
            Gamepads.prototype.count = function () {
                return this._pads.filter(function (p) { return p.connected; }).length;
            };
            Gamepads.prototype._clonePads = function (pads) {
                var arr = [];
                for (var i = 0, len = pads.length; i < len; i++) {
                    arr.push(this._clonePad(pads[i]));
                }
                return arr;
            };
            /**
             * Fastest way to clone a known object is to do it yourself
             */
            Gamepads.prototype._clonePad = function (pad) {
                var i, len;
                var clonedPad = new Gamepad();
                if (!pad)
                    return clonedPad;
                for (i = 0, len = pad.buttons.length; i < len; i++) {
                    clonedPad.updateButton(i, pad.buttons[i].value);
                }
                for (i = 0, len = pad.axes.length; i < len; i++) {
                    clonedPad.updateAxes(i, pad.axes[i]);
                }
                return clonedPad;
            };
            /**
             * The minimum value an axis has to move before considering it a change
             * @property MinAxisMoveThreshold {number}
             * @static
             */
            Gamepads.MinAxisMoveThreshold = 0.05;
            return Gamepads;
        })(ex.Class);
        Input.Gamepads = Gamepads;
        /**
         * Individual state for a Gamepad
         * @class Gamepad
         * @extends Class
         */
        var Gamepad = (function (_super) {
            __extends(Gamepad, _super);
            function Gamepad() {
                _super.call(this);
                this.connected = false;
                this._buttons = new Array(16);
                this._axes = new Array(4);
                var i;
                for (i = 0; i < this._buttons.length; i++) {
                    this._buttons[i] = 0;
                }
                for (i = 0; i < this._axes.length; i++) {
                    this._axes[i] = 0;
                }
            }
            /**
             * Whether or not the given button is pressed
             * @param button {Buttons}
             * @param [threshold=1] {number} The threshold over which the button is considered to be pressed
             */
            Gamepad.prototype.isButtonPressed = function (button, threshold) {
                if (threshold === void 0) { threshold = 1; }
                return this._buttons[button] >= threshold;
            };
            /**
             * Gets the given button value
             * @param button {Buttons}
             */
            Gamepad.prototype.getButton = function (button) {
                return this._buttons[button];
            };
            /**
             * Gets the given axis value
             * @param axes {Axes}
             */
            Gamepad.prototype.getAxes = function (axes) {
                var value = this._axes[axes];
                if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
                    return 0;
                }
                else {
                    return value;
                }
            };
            Gamepad.prototype.updateButton = function (buttonIndex, value) {
                this._buttons[buttonIndex] = value;
            };
            Gamepad.prototype.updateAxes = function (axesIndex, value) {
                this._axes[axesIndex] = value;
            };
            return Gamepad;
        })(ex.Class);
        Input.Gamepad = Gamepad;
        /**
         * Gamepad Buttons enumeration
         * @class Buttons
         */
        (function (Buttons) {
            /**
             * Face 1 button (e.g. A)
             * @property Face1 {Buttons}
             * @static
             */
            /**
             * Face 2 button (e.g. B)
             * @property Face2 {Buttons}
             * @static
             */
            /**
             * Face 3 button (e.g. X)
             * @property Face3 {Buttons}
             * @static
             */
            /**
             * Face 4 button (e.g. Y)
             * @property Face4 {Buttons}
             * @static
             */
            Buttons[Buttons["Face1"] = 0] = "Face1";
            Buttons[Buttons["Face2"] = 1] = "Face2";
            Buttons[Buttons["Face3"] = 2] = "Face3";
            Buttons[Buttons["Face4"] = 3] = "Face4";
            /**
             * Left bumper button
             * @property LeftBumper {Buttons}
             * @static
             */
            /**
             * Right bumper button
             * @property RightBumper {Buttons}
             * @static
             */
            Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
            Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
            /**
             * Left trigger button
             * @property LeftTrigger {Buttons}
             * @static
             */
            /**
             * Right trigger button
             * @property RightTrigger {Buttons}
             * @static
             */
            Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
            Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
            /**
             * Select button
             * @property Select {Buttons}
             * @static
             */
            /**
             * Start button
             * @property Start {Buttons}
             * @static
             */
            Buttons[Buttons["Select"] = 8] = "Select";
            Buttons[Buttons["Start"] = 9] = "Start";
            /**
             * Left analog stick press (e.g. L3)
             * @property LeftStick {Buttons}
             * @static
             */
            /**
             * Right analog stick press (e.g. R3)
             * @property Start {Buttons}
             * @static
             */
            Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
            Buttons[Buttons["RightStick"] = 11] = "RightStick";
            /**
             * D-pad up
             * @property DpadUp {Buttons}
             * @static
             */
            /**
             * D-pad down
             * @property DpadDown {Buttons}
             * @static
             */
            /**
             * D-pad left
             * @property DpadLeft {Buttons}
             * @static
             */
            /**
             * D-pad right
             * @property DpadRight {Buttons}
             * @static
             */
            Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
            Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
            Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
            Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
        })(Input.Buttons || (Input.Buttons = {}));
        var Buttons = Input.Buttons;
        /**
         * Gamepad Axes enumeration
         * @class Axes
         */
        (function (Axes) {
            /**
             * Left analogue stick X direction
             * @property LeftStickX {Axes}
             * @static
             */
            /**
             * Left analogue stick Y direction
             * @property LeftStickY {Axes}
             * @static
             */
            /**
             * Right analogue stick X direction
             * @property RightStickX {Axes}
             * @static
             */
            /**
             * Right analogue stick Y direction
             * @property RightStickY {Axes}
             * @static
             */
            Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
            Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
            Axes[Axes["RightStickX"] = 2] = "RightStickX";
            Axes[Axes["RightStickY"] = 3] = "RightStickY";
        })(Input.Axes || (Input.Axes = {}));
        var Axes = Input.Axes;
        var GamepadButtonEvent = (function (_super) {
            __extends(GamepadButtonEvent, _super);
            function GamepadButtonEvent(button, value) {
                _super.call(this);
                this.button = button;
                this.value = value;
            }
            return GamepadButtonEvent;
        })(ex.GameEvent);
        Input.GamepadButtonEvent = GamepadButtonEvent;
        var GamepadAxisEvent = (function (_super) {
            __extends(GamepadAxisEvent, _super);
            function GamepadAxisEvent(axis, value) {
                _super.call(this);
                this.axis = axis;
                this.value = value;
            }
            return GamepadAxisEvent;
        })(ex.GameEvent);
        Input.GamepadAxisEvent = GamepadAxisEvent;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
/// <reference path="MonkeyPatch.ts" />
/// <reference path="Events.ts" />
/// <reference path="EventDispatcher.ts" />
/// <reference path="Class.ts" />
/// <reference path="Color.ts" />
/// <reference path="Log.ts" />
/// <reference path="Collision/Side.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Actor.ts" />
/// <reference path="UIActor.ts" />
/// <reference path="Trigger.ts" />
/// <reference path="Particles.ts" />
/// <reference path="Animation.ts" />
/// <reference path="Camera.ts" />
/// <reference path="Sound.ts" />
/// <reference path="Loader.ts" />
/// <reference path="Promises.ts" />
/// <reference path="Util.ts" />
/// <reference path="Binding.ts" />
/// <reference path="TileMap.ts" />
/// <reference path="Label.ts" />
/// <reference path="PostProcessing/IPostProcessor.ts"/>
/// <reference path="Input/IEngineInput.ts"/>
/// <reference path="Input/Pointer.ts"/>
/// <reference path="Input/Keyboard.ts"/>
/// <reference path="Input/Gamepad.ts"/>
var ex;
(function (ex) {
    /**
     * Enum representing the different display modes available to Excalibur
     * @class DisplayMode
     */
    (function (DisplayMode) {
        /**
         * Show the game as full screen
         * @property FullScreen {DisplayMode}
         */
        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";
        /**
         * Scale the game to the parent DOM container
         * @property Container {DisplayMode}
         */
        DisplayMode[DisplayMode["Container"] = 1] = "Container";
        /**
         * Show the game as a fixed size
         * @Property Fixed {DisplayMode}
         */
        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";
    })(ex.DisplayMode || (ex.DisplayMode = {}));
    var DisplayMode = ex.DisplayMode;
    // internal
    var AnimationNode = (function () {
        function AnimationNode(animation, x, y) {
            this.animation = animation;
            this.x = x;
            this.y = y;
        }
        return AnimationNode;
    })();
    /**
     * The 'Engine' is the main driver for a game. It is responsible for
     * starting/stopping the game, maintaining state, transmitting events,
     * loading resources, and managing the scene.
     *
     * @class Engine
     * @constructor
     * @param [width] {number} The width in pixels of the Excalibur game viewport
     * @param [height] {number} The height in pixels of the Excalibur game viewport
     * @param [canvasElementId] {string} If this is not specified, then a new canvas will be created and inserted into the body.
     * @param [displayMode] {DisplayMode} If this is not specified, then it will fall back to fixed if a height and width are specified, else the display mode will be FullScreen.
     */
    var Engine = (function (_super) {
        __extends(Engine, _super);
        function Engine(width, height, canvasElementId, displayMode) {
            _super.call(this);
            /**
             * Sets or gets the collision strategy for Excalibur
             * @property collisionStrategy {CollisionStrategy}
             */
            this.collisionStrategy = 1 /* DynamicAABBTree */;
            this.hasStarted = false;
            this.fps = 0;
            this.postProcessors = [];
            this.sceneHash = {};
            this.animations = [];
            /**
             * Indicates whether the engine is set to fullscreen or not
             * @property isFullscreen {boolean}
             */
            this.isFullscreen = false;
            /**
             * Indicates the current DisplayMode of the engine.
             * @property [displayMode=FullScreen] {DisplayMode}
             */
            this.displayMode = 0 /* FullScreen */;
            /**
             * Indicates whether audio should be paused when the game is no longer visible.
             * @property [pauseAudioWhenHidden=true] {boolean}
             */
            this.pauseAudioWhenHidden = true;
            /**
             * Indicates whether the engine should draw with debug information
             * @property [isDebug=false] {boolean}
             */
            this.isDebug = false;
            this.debugColor = new ex.Color(255, 255, 255);
            /**
             * Sets the background color for the engine.
             * @property [backgroundColor=new Color(0, 0, 100)] {Color}
             */
            this.backgroundColor = new ex.Color(0, 0, 100);
            this.isSmoothingEnabled = true;
            this.isLoading = false;
            this.progress = 0;
            this.total = 1;
            this.logger = ex.Logger.getInstance();
            this.logger.info("Powered by Excalibur.js visit", "http://excaliburjs.com", "for more information.");
            this.logger.debug("Building engine...");
            this.canvasElementId = canvasElementId;
            if (canvasElementId) {
                this.logger.debug("Using Canvas element specified: " + canvasElementId);
                this.canvas = document.getElementById(canvasElementId);
            }
            else {
                this.logger.debug("Using generated canvas element");
                this.canvas = document.createElement('canvas');
            }
            if (width && height) {
                if (displayMode == undefined) {
                    this.displayMode = 2 /* Fixed */;
                }
                this.logger.debug("Engine viewport is size " + width + " x " + height);
                this.width = width;
                this.canvas.width = width;
                this.height = height;
                this.canvas.height = height;
            }
            else if (!displayMode) {
                this.logger.debug("Engine viewport is fullscreen");
                this.displayMode = 0 /* FullScreen */;
            }
            this.loader = new ex.Loader();
            this.initialize();
            this.rootScene = this.currentScene = new ex.Scene(this);
            this.addScene('root', this.rootScene);
        }
        /**
         * Plays a sprite animation on the screen at the specified x and y
         * (in game coordinates, not screen pixels). These animations play
         * independent of actors, and will be cleaned up internally as soon
         * as they are complete. Note animations that loop will never be
         * cleaned up.
         * @method playAnimation
         * @param animation {Animation} Animation to play
         * @param x {number} x game coordinate to play the animation
         * @param y {number} y game coordinate to play the animation
         */
        Engine.prototype.playAnimation = function (animation, x, y) {
            this.animations.push(new AnimationNode(animation, x, y));
        };
        /**
         * Adds an actor to the current scene of the game. This is synonymous
         * to calling engine.currentScene.addChild(actor : Actor).
         *
         * Actors can only be drawn if they are a member of a scene, and only
         * the 'currentScene' may be drawn or updated.
         * @method addChild
         * @param actor {Actor} The actor to add to the current scene
         */
        Engine.prototype.addChild = function (actor) {
            this.currentScene.addChild(actor);
        };
        /**
         * Removes an actor from the currentScene of the game. This is synonymous
         * to calling engine.currentScene.removeChild(actor : Actor).
         * Actors that are removed from a scene will no longer be drawn or updated.
         *
         * @method removeChild
         * @param actor {Actor} The actor to remove from the current scene.
         */
        Engine.prototype.removeChild = function (actor) {
            this.currentScene.removeChild(actor);
        };
        /**
         * Adds a TileMap to the Scene, once this is done the TileMap will be drawn and updated.
         * @method addTileMap
         * @param tileMap {TileMap}
         */
        Engine.prototype.addTileMap = function (tileMap) {
            this.currentScene.addTileMap(tileMap);
        };
        /**
         * Removes a TileMap from the Scene, it willno longer be drawn or updated.
         * @method removeTileMap
         * @param tileMap {TileMap}
         */
        Engine.prototype.removeTileMap = function (tileMap) {
            this.currentScene.removeTileMap(tileMap);
        };
        /**
         * Adds an excalibur timer to the current scene.
         * @param timer {Timer} The timer to add to the current scene.
         * @method addTimer
         */
        Engine.prototype.addTimer = function (timer) {
            return this.currentScene.addTimer(timer);
        };
        /**
         * Removes an excalibur timer from the current scene.
         * @method removeTimer
         * @param timer {Timer} The timer to remove to the current scene.
         */
        Engine.prototype.removeTimer = function (timer) {
            return this.currentScene.removeTimer(timer);
        };
        /**
         * Adds a scene to the engine, think of scenes in excalibur as you
         * would scenes in a play.
         * @method addScene
         * @param name {string} The name of the scene, must be unique
         * @param scene {Scene} The scene to add to the engine
         */
        Engine.prototype.addScene = function (name, scene) {
            if (this.sceneHash[name]) {
                this.logger.warn("Scene", name, "already exists overwriting");
            }
            this.sceneHash[name] = scene;
            scene.engine = this;
        };
        Engine.prototype.removeScene = function (entity) {
            if (entity instanceof ex.Scene) {
                for (var key in this.sceneHash) {
                    if (this.sceneHash.hasOwnProperty(key)) {
                        if (this.sceneHash[key] === entity) {
                            delete this.sceneHash[key];
                        }
                    }
                }
            }
            if (typeof entity === "string") {
                // remove scene
                delete this.sceneHash[entity];
            }
        };
        Engine.prototype.add = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.currentScene.addUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.addChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.addTileMap(entity);
            }
            if (arguments.length === 2) {
                this.addScene(arguments[0], arguments[1]);
            }
        };
        Engine.prototype.remove = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.currentScene.removeUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.removeChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.removeTileMap(entity);
            }
            if (entity instanceof ex.Scene) {
                this.removeScene(entity);
            }
            if (typeof entity === "string") {
                this.removeScene(entity);
            }
        };
        /**
         * Changes the currently updating and drawing scene to a different,
         * named scene.
         * @method goToScene
         * @param name {string} The name of the scene to trasition to.
         */
        Engine.prototype.goToScene = function (name) {
            if (this.sceneHash[name]) {
                this.currentScene.onDeactivate.call(this.currentScene);
                var oldScene = this.currentScene;
                this.currentScene = this.sceneHash[name];
                oldScene.eventDispatcher.publish('deactivate', new ex.DeactivateEvent(this.currentScene));
                this.currentScene.onActivate.call(this.currentScene);
                this.currentScene.eventDispatcher.publish('activate', new ex.ActivateEvent(oldScene));
            }
            else {
                this.logger.error("Scene", name, "does not exist!");
            }
        };
        /**
         * Returns the width of the engines drawing surface in pixels.
         * @method getWidth
         * @returns number The width of the drawing surface in pixels.
         */
        Engine.prototype.getWidth = function () {
            if (this.currentScene && this.currentScene.camera) {
                return this.width / this.currentScene.camera.getZoom();
            }
            return this.width;
        };
        /**
         * Returns the height of the engines drawing surface in pixels.
         * @method getHeight
         * @returns number The height of the drawing surface in pixels.
         */
        Engine.prototype.getHeight = function () {
            if (this.currentScene && this.currentScene.camera) {
                return this.height / this.currentScene.camera.getZoom();
            }
            return this.height;
        };
        /**
         * Transforms the current x, y from screen coordinates to world coordinates
         * @method screenToWorldCoordinates
         * @param point {Point} screen coordinate to convert
         */
        Engine.prototype.screenToWorldCoordinates = function (point) {
            // todo set these back this.canvas.clientWidth
            var newX = point.x;
            var newY = point.y;
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                newX = focus.x + (point.x - (this.getWidth() / 2));
                newY = focus.y + (point.y - (this.getHeight() / 2));
            }
            newX = Math.floor((newX / this.canvas.clientWidth) * this.getWidth());
            newY = Math.floor((newY / this.canvas.clientHeight) * this.getHeight());
            return new ex.Point(newX, newY);
        };
        /**
         * Transforms a world coordinate, to a screen coordinate
         * @method worldToScreenCoordinates
         * @param point {Point} world coordinate to convert
         *
         */
        Engine.prototype.worldToScreenCoordinates = function (point) {
            // todo set these back this.canvas.clientWidth
            // this isn't correct on zoom
            var screenX = point.x;
            var screenY = point.y;
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                screenX = (point.x - focus.x) + (this.getWidth() / 2); //(this.getWidth() / this.canvas.clientWidth);
                screenY = (point.y - focus.y) + (this.getHeight() / 2); // (this.getHeight() / this.canvas.clientHeight);
            }
            screenX = Math.floor((screenX / this.getWidth()) * this.canvas.clientWidth);
            screenY = Math.floor((screenY / this.getHeight()) * this.canvas.clientHeight);
            return new ex.Point(screenX, screenY);
        };
        /**
         * Sets the internal canvas height based on the selected display mode.
         * @method setHeightByDisplayMode
         * @private
         */
        Engine.prototype.setHeightByDisplayMode = function (parent) {
            if (this.displayMode === 1 /* Container */) {
                this.width = this.canvas.width = parent.clientWidth;
                this.height = this.canvas.height = parent.clientHeight;
            }
            if (this.displayMode === 0 /* FullScreen */) {
                document.body.style.margin = '0px';
                document.body.style.overflow = 'hidden';
                this.width = this.canvas.width = parent.innerWidth;
                this.height = this.canvas.height = parent.innerHeight;
            }
        };
        /**
         * Initializes the internal canvas, rendering context, displaymode, and native event listeners
         * @method initialize
         * @private
         */
        Engine.prototype.initialize = function () {
            var _this = this;
            if (this.displayMode === 0 /* FullScreen */ || this.displayMode === 1 /* Container */) {
                var parent = (this.displayMode === 1 /* Container */ ? (this.canvas.parentElement || document.body) : window);
                this.setHeightByDisplayMode(parent);
                window.addEventListener('resize', function (ev) {
                    _this.logger.debug("View port resized");
                    _this.setHeightByDisplayMode(parent);
                    _this.logger.info("parent.clientHeight " + parent.clientHeight);
                    _this.setAntialiasing(_this.isSmoothingEnabled);
                });
            }
            // initialize inputs
            this.input = {
                keyboard: new ex.Input.Keyboard(this),
                pointers: new ex.Input.Pointers(this),
                gamepads: new ex.Input.Gamepads(this)
            };
            this.input.keyboard.init();
            this.input.pointers.init();
            this.input.gamepads.init();
            // Issue #385 make use of the visibility api
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
            document.addEventListener("visibilitychange", function () {
                if (document.hidden || document.msHidden) {
                    _this.eventDispatcher.publish('hidden', new ex.HiddenEvent());
                    _this.logger.debug("Window hidden");
                }
                else {
                    _this.eventDispatcher.publish('visible', new ex.VisibleEvent());
                    _this.logger.debug("Window visible");
                }
            });
            /*
            // DEPRECATED in favor of visibility api
            window.addEventListener('blur', () => {
               this.eventDispatcher.publish(EventType[EventType.Blur], new BlurEvent());
            });
   
            window.addEventListener('focus', () => {
               this.eventDispatcher.publish(EventType[EventType.Focus], new FocusEvent());
            });*/
            this.ctx = this.canvas.getContext('2d');
            if (!this.canvasElementId) {
                document.body.appendChild(this.canvas);
            }
        };
        /**
         * If supported by the browser, this will set the antialiasing flag on the
         * canvas. Set this to false if you want a 'jagged' pixel art look to your
         * image resources.
         * @method setAntialiasing
         * @param isSmooth {boolean} Set smoothing to true or false
         */
        Engine.prototype.setAntialiasing = function (isSmooth) {
            this.isSmoothingEnabled = isSmooth;
            this.ctx.imageSmoothingEnabled = isSmooth;
            this.ctx.webkitImageSmoothingEnabled = isSmooth;
            this.ctx.mozImageSmoothingEnabled = isSmooth;
            this.ctx.msImageSmoothingEnabled = isSmooth;
        };
        /**
         *  Return the current smoothing status of the canvas
         * @method getAntialiasing
         * @returns boolean
         */
        Engine.prototype.getAntialiasing = function () {
            return this.ctx.imageSmoothingEnabled || this.ctx.webkitImageSmoothingEnabled || this.ctx.mozImageSmoothingEnabled || this.ctx.msImageSmoothingEnabled;
        };
        /**
         * Updates the entire state of the game
         * @method update
         * @private
         * @param delta {number} Number of milliseconds elapsed since the last update.
         */
        Engine.prototype.update = function (delta) {
            if (this.isLoading) {
                // suspend updates untill loading is finished
                return;
            }
            // process engine level events
            this.currentScene.update(this, delta);
            // update animations
            this.animations = this.animations.filter(function (a) {
                return !a.animation.isDone();
            });
            // Update input listeners
            this.input.keyboard.update(delta);
            this.input.pointers.update(delta);
            this.input.gamepads.update(delta);
            // Publish update event
            this.eventDispatcher.publish(ex.EventType[5 /* Update */], new ex.UpdateEvent(delta));
        };
        /**
         * Draws the entire game
         * @method draw
         * @private
         * @param draw {number} Number of milliseconds elapsed since the last draw.
         */
        Engine.prototype.draw = function (delta) {
            var ctx = this.ctx;
            if (this.isLoading) {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, this.width, this.height);
                this.drawLoadingBar(ctx, this.progress, this.total);
                // Drawing nothing else while loading
                return;
            }
            ctx.clearRect(0, 0, this.width, this.height);
            ctx.fillStyle = this.backgroundColor.toString();
            ctx.fillRect(0, 0, this.width, this.height);
            this.currentScene.draw(this.ctx, delta);
            // todo needs to be a better way of doing this
            this.animations.forEach(function (a) {
                a.animation.draw(ctx, a.x, a.y);
            });
            this.fps = 1.0 / (delta / 1000);
            // Draw debug information
            if (this.isDebug) {
                this.ctx.font = "Consolas";
                this.ctx.fillStyle = this.debugColor.toString();
                var keys = this.input.keyboard.getKeys();
                for (var j = 0; j < keys.length; j++) {
                    this.ctx.fillText(keys[j].toString() + " : " + (ex.Input.Keys[keys[j]] ? ex.Input.Keys[keys[j]] : "Not Mapped"), 100, 10 * j + 10);
                }
                this.ctx.fillText("FPS:" + this.fps.toFixed(2).toString(), 10, 10);
            }
            for (var i = 0; i < this.postProcessors.length; i++) {
                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.width, this.height), this.ctx);
            }
            //ctx.drawImage(currentImage, 0, 0, this.width, this.height);
        };
        /**
         * Starts the internal game loop for Excalibur after loading
         * any provided assets.
         * @method start
         * @param [loader=undefined] {ILoadable} Optional resources to load before
         * starting the mainloop. Some loadable such as a Loader collection, Sound, or Texture.
         * @returns Promise
         */
        Engine.prototype.start = function (loader) {
            var loadingComplete;
            if (loader) {
                loader.wireEngine(this);
                loadingComplete = this.load(loader);
            }
            else {
                loadingComplete = ex.Promise.wrap();
            }
            if (!this.hasStarted) {
                this.hasStarted = true;
                this.logger.debug("Starting game...");
                // Mainloop
                var lastTime = Date.now();
                var game = this;
                (function mainloop() {
                    if (!game.hasStarted) {
                        return;
                    }
                    window.requestAnimationFrame(mainloop);
                    // Get the time to calculate time-elapsed
                    var now = Date.now();
                    var elapsed = Math.floor(now - lastTime) || 1;
                    // Resolves issue #138 if the game has been paused, or blurred for 
                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability 
                    // and provides more expected behavior when the engine comes back
                    // into focus
                    if (elapsed > 200) {
                        elapsed = 1;
                    }
                    game.update(elapsed);
                    game.draw(elapsed);
                    lastTime = now;
                })();
                this.logger.debug("Game started");
            }
            else {
            }
            return loadingComplete;
        };
        /**
         * Stops Excalibur's mainloop, useful for pausing the game.
         * @method stop
         */
        Engine.prototype.stop = function () {
            if (this.hasStarted) {
                this.hasStarted = false;
                this.logger.debug("Game stopped");
            }
        };
        /**
         * Takes a screen shot of the current viewport and returns it as an
         * HTML Image Element.
         * @method screenshot
         * @returns HTMLImageElement
         */
        Engine.prototype.screenshot = function () {
            var result = new Image();
            var raw = this.canvas.toDataURL("image/png");
            result.src = raw;
            return result;
        };
        /**
         * Draws the Excalibur loading bar
         * @method drawLoadingBar
         * @private
         * @param ctx {CanvasRenderingContext2D} The canvas rendering context
         * @param loaded {number} Number of bytes loaded
         * @param total {number} Total number of bytes to load
         */
        Engine.prototype.drawLoadingBar = function (ctx, loaded, total) {
            if (this.loadingDraw) {
                this.loadingDraw(ctx, loaded, total);
                return;
            }
            var y = this.canvas.height / 2;
            var width = this.canvas.width / 3;
            var x = width;
            // loading image
            var image = new Image();
            // 64 bit string encoding of the excalibur logo
            image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAEsCAYAAAA7Ldc6AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjenhJ3MAAA6Y0lEQVR4Xu3dUagkWZ3ncUEEQYSiRXBdmi2KdRUZxgJZhmV9qOdmkWJYlmYYhkKWcWcfpEDQFx9K2O4Fm6UaVhoahi4GF2wWh1pnYawHoXzxpVu6Gimatqni0kpTiGLhgy++3Pn9Mk6kkXlPZp4TGSfiROT3A39aq25EnMi6GfH/ZcSJ/BAAAAAAAAAAAAAAYAw/+9nPLqluqO6rroc/BgAAAIDhhNBxV3Ue6mn4KwAAAAA4nkLGddUdh40QOrp1J/wYAAAAAPSjYHHV4UIVCx3duhoWAQAAAIB0DhOq26qzEC4O1VlYFAAAAAAOU4i4rLrpMBFCxYV66623zt99993z999///ydd97p/t3tsBoAAAAAiFNwaEPHgxAkotWGjt/85jer+vWvf739M9x+BQAAAOAihYX2sbndJ1hdKF/hODs7W4WNNni09fjx4+7PPgirBgAAAICGgsLB0PHzn/98Z+joln+us9zNsAkAAAAAp0zhYN9jc1flMOErGk+ePImGje3yz22t43LYHAAAAIBTo0Bw8LG5b7/99vl7772XHDq6xe1XAAAAwIlTEDj42Nw2dHzwwQfRYJFaXk9nvTfCEAAAAAAsmZr/rMfmxsJEbjm8bG3jUhgOAAAAgKVRw9/rsblDla+gdLZzNwwLAAAAwFKo0T/6sblDFbdfAQAAAAvlBl81yGNzh6hf/epX3W17gju3XwEAAABzpqZ+8MfmDlW+raszjjthyAAAAADmRM180cfmDlWe0N4Z0/UwfAAAAAC1UwM/2mNzhyhPaO+M7WnYDQAAAAC1UwPvuR3dhn5dQz82d6ji9isAAABghtS8R8NHjaGjLU9w3xrv1bA7AAAAAGqlxn0jfPhqx1hPsDqmPMbOuM/C7gAAAAColRr3C+GjhrkdKeXvF+mM/XbYJQAAAAA1UtM+2/DB7VcAAADAjKhhn234cPn7RjrjfxB2CwAAAEBt1LDPOny4/KWHnX24GXYNAAAAQE3UrM8+fPhLD7v7oLocdg8AAABALdSozz58uB49etQNH9x+BQAAANRGjfpG+PAtTHMMHy5/E3tnX26EXQQAAABQAzfpnYZ9FT5q/46PXeXQ1N0X1aWwmwAAAACmpgZ9MeHD9d5773XDx92wmwAAAACmpgZ9UeHDxe1XAAAAQIXcnHca9UWEj/fff78bPp6quP0KAAAAmJoa88WFD9e7777bDSB3wu4CAAAAmIoa80WGD5cfG9zZt+thlwEAAABMQU35YsPH9u1XYZcBAAAATEFN+WLDh+udd97pBpDbYbcBAAAAjE0N+aLDh/elu3+qq2HXAQAAAIxJzfiiw4fr7OysGz7Owq4DAAAAGJOa8cWHDxe3XwEAAAATUyN+EuHjyZMn3fDhuhxeAgAAAABjUBN+EuHD9fjx4274eBBeAgAAAABjUBN+MuHD5f3r7O/N8DIAAAAAKE0N+EmFD26/AgAAACai5vukwofr0aNH3fBxP7wUAAAAAEpS831y4cP19ttvdwPIjfByAAAAACjFjXenCT+Z8PHBBx90w4frUnhJAAAAAJSgpvskw4frvffe64aPu+ElAQAAAFCCmu6TDR8ubr8CAAAARuKGu9N8n1z4eP/997vh42l4WQAAAAAMTQ33SYcP17vvvtsNIHfCSwMAAABgSGq2Tz58uN56661uALkeXh4AAAAAQ1GjTfhQPX78uBs+uP0KAAAAGJoabcKH6uzsrBs+XLfDSwQAAABgCGqyCR+qSPh4oOK7PwAAAIChqMEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qAgfAAAAQGFqsAkfKsIHAAAAUJgabMKHivABAAAAFKYGm/ChInwAAAAAhanBvt1puAkffyrCBwAAADAkNdh3Og034eNPRfgAAAAAhqQGm/ChInwAAAAAhanBJnyoCB8AAABAYWqwCR8qwgcAAABQmBpswoeK8AEAAAAUpgab8KEifAAAAACFqcEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qAgfAAAAQGFqsAkfKsIHAAAAUJgabMKHivABAAAAFKYGm/ChInwAAAAAhanBJnyoCB8AAABAYWqwCR8qwgcAAABQmBpswoeK8AEAAAAUpgab8KEifAAAAACFqcEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qB49etQNHi7CBwAAADAkNdiED9W7777bDR4uwgcAAAAwJDXYhA8V4QMAAAAoTA024UNF+AAAAAAKU4NN+FARPgAAAIDC1GATPlSEDwAAAKAwNdiEDxXhAwAAAChMDTbhQ0X4AAAAAApTg034UBE+AAAAgMLUYBM+VIQPAAAAoDA12IQPFeEDAAAAKEwNNuFDRfgAAAAAClODTfhQET4AAACAwtRgEz5UhA8AAACgMDXYhA8V4QMAAAAoTA024UNF+AAAAAAKU4NN+FARPgAAAIDC1GATPlSEDwAAAKAwNdiEDxXhAwAAAChMDTbhQ0X4AAAAAApTg034UBE+AAAAgMLUYBM+VIQPAAAAoDA12IQPFeEDAAAAKEwNNuFDRfgAMHfn5+ffUCULixWh1b/QbCXJm2GxIrT+e81mktwLiwEASlCDTfhQET4ALIGa5yoCiFb9pWYLWV4Iiw9O6yaAAEAN1GBvhI+HDx8SPpoaLXz4RNec7xbhG2G3AEzE78Pm7ZgmLDY4rfrNZgvZroRVDErrJYAAwNTUYG+EDzfhseZ86TX1lQ+f6Jrz3SIQQICJ+X3YvB3ThMUGpdVeadbey1fDagal9RJAAGBKarAJH6oabrvyia453y0CAQSYmN+HzdsxTVhsUFptn9uvWq+E1QxK6yWAAMBU1GATPlQ1hA/zia453y0CAQSYmN+HzdsxTVhsUFrtMQGkSPPv9TarT0IAAYChqMEmfKhqCR/mE11zvlsEAggwMb8Pm7djmrDYoLRaroAAAAgfbdUUPswnuuZ8twgEEGBifh82b8c0YbFBabXMAQGAU6cGm/Chqi18mE90zfluEQggwMT8PmzejmnCYoPTqh81W8jGU7AAYO7UYBM+VDWGD/OJrjnfLQIBBJiY34fN2zFNWGxwWvVzzRayFDuGaN0EEAAYgxpswoeq1vBhPtE157tFIIAAE/P7sHk7pgmLFaHVv9JsJQnfhA4Ac6cGm/Chqjl8mE90zfluEQggwMT8PmzejmnCYsVoEynjcVD5RFikCK2fAAIAJanBJnyoag8f5hNdc75bBAIIMDG/D5u3Y5qwWFHajCelv6Dqfju654g4eHwp/FhR2g4BBABKUYNN+FDNIXyYT3TN+S5NWAwAonSYqC6A1EC7SgABgBLUYBM+VHMJH+YTXXO+SxMWA4AoHSYIIBHaVQIIAAxNDTbhQzWn8GE+0TXnuzRhMQCI0mGCABKhXSWAAMCQ1GATPlRzCx/mE11zvksTFgOAKB0mCCAR2lUCCAAMRQ024UM1x/BhPtE157s0YTEAiNJhggASoV0lgADAENRgEz5Ucw0f5hNdc75LExYDgCgdJgggEdpVAggAHEsNNuFDNefwYT7RNee7NGExAIjSYYIAEqFdJYAAwDHUYBM+VHMPH+YTXXO+SxMWA4AoHSYIIBHaVQIIAPSlBpvwoVpC+DCf6JrzXZqwGABE6TBBAInQrhJAAKAPNdiED9VSwof5RNec79KExQAgSocJAkiEdpUAAgC51GATPlRLCh/mE11zvksTFgOAKB0mCCAR2lUCCADkUINN+FBFwsd91WzDh/lE15zv0oTFACBKhwkCSIR2lQACAKnUYBM+VJHwcSe8RLPmE11zvksTFgOAKB0mCCAR2lUCCIDy/unvPnRZdS2hbiXUHdX9Tt0ImynKTXa36SZ8LCt8mE90zfkuTVgMAKJ0mCCARGhXCSAALlJT7zCw3ejvqvOJ61YYdjFusrtNN+FjeeHDfKJrzndpwmIAEKXDBAEkQruac6wlgACnwk39VpNfc90Nwy7CTXa36SZ8LDN8mE90zfkuTVgMAKJ0mCCARGhXc461BBDgVKipHzSA/OhrHz7/6bc+drAevvTM+S9e/uTeevzdT62qs/77YdiDc5PdbboJH8sNH+YTXXO+SxMWAwajX6svqZ5XuXH176PrkWoX/137c17Gy34hrK56Gqv396th7O1+vKna5Xeq2exvGGOysNjiaVf975dqkACi9XxB5d+XF7zOULvM5ncM86LfpSsqH/NeV8WOde0x7hWVf+5KWPQ0qKlfB5AHL146/+33Lu+sP/7ws+fn//z5UesPP/jMamxthWEPyk12t+kmfCw7fFh40ycLiwG96dfITVHbfA/N66zmBKZxfEL1nMon1n0how+ftL3e58LmqqDxEEAitKs5v++9A4iWdcD178W+EJ/K66judwzzoN8b/y72Oc6f1hVANfXrAOKrDrEQMHW14wt1OQx9EG6yu0034WP54cP8Rm/e72nCYrOnXfEnMm7gcj0fVjEpjcONbe74Jzuoa9t+vf0p7BBNUSo3/P4k9xNhGKPw9sJ2/WnfWPy6uvEfdV9jwjiShcWK0Opzjm9F3x9ef7OZJNlj0TL+nSv5/vK6He5r+B2b9XlLQ8p6j8iXwqKD07oH/73Uz/lDpqx/oy0EkNrKt2y1Y1RdD0M/mpvsbtNN+DiN8GF+ozfv9zRhsUXQ7vhkmutRWHxSGoeb+RwOK6NfFdA2/QnYmI14jPf9G2FIxWgbDln+tLhPsB2Ktz1pSNb2CSARXn+zmSTJY9HPlg4e22r4HZv1eUtDWmwA0c/0Oa9uO7kA4idgnbs83yIWAKYu3xrWjlE1yJOw3GR3m27Cx+mED/MbvXm/pwmLLYZ2KWv/g+LN7D7avj9dyvXVsPgotD03431e22LC0AanVfe9zaAkj2eST6q1XQJIhNffbCZJSqM39XvMVxgnmSei7Wbtd1isGhrSIgOI/t4fwAzh5ALI+vG6nucRCwBT1y9f/fRqfKGOnojuJrvbdBM+Tit8mN/ozfs9TVhsMbRLfZp5fwI42W0I2nbWv5mMdjDXtnz7Ue7VmVGEIQ5Gq2yveNTKv6ejN4jaJgEkwutvNpPkUKPneUVTXmlrTXI1RNuc9XlLQ1pcANHfDXksJIDUVr9//cpqfKGehqH34ia723QTPk4vfJjf6M37PU1YbFG0W7knA3slLD4qbde3W+RwgzDKrVfajsPcmLeCZAnDHIRW1+d3ZgqjhxBtjwAS4fU3m0myr9HLPQaMYdSrwtrerM9bGtKiAoj+fOgPYgggNZYf79uOU3U1DD+Lm+xu0034OM3wYX6jN+/3NGGxxdGu9XlC0diNXZ+J56PceqXt1NgUbQhDPZpW5Vuu5mS0EGraFgEkwutvNpNkrEZvSKN9KKNtzfq8pSEtJoDoz4aY87GNAFJjvfHtj6/GGOpmGH4SNdiXVPc7DTfh4091cuHD/EZv3u9pwmKLo13r01SOepDU9nJvbRplfNpOzU3RWhju0bSquQUQezMMvzhtiwAS4fU3m0kSa/Rym9YpvBCGW5S2M+vzloa0iACi/9/nFuYUo55bJ6dmfhYBpO8XEqrBdvh40Gm4CR9/qpMMH+Y3evN+TxMWWyTtXp+5C6M8H1/byT3Qj/Kpt7Yxi/BhYchH06rmGEBslNtkvJ1mc2nCYkVo9TnHt2oDiP5/9VcYO4rPCdE2Zn3e0pCWEkCG/m6jFgGkxtr+QkLVpbALO6nBJnyEInxs8hu9eb+nCYstknbPtzjlzmEY5bG82k7Wv5MUv/VK2xgyfDgw+XG9PjG7wY+ecPXnDmL+e1/29/aT/73CKo6mVR0bQDzmdl89mdjru/BQA/9Z+Dvvq38+9/a7mDFCKQEkwutvNpNkPRb97z6fMvt3zB+oOLj4d+jCv7v/LPxd+14a4verVfT2VK1/1uctDWn2AUT/u8StVy0CSK31469/ZDXOUDfCLkSpwSZ8hCJ8XOQ3evN+TxMWWyztohvCXEWbfa0/d0zFD97axlDhw+s56iqSlncj5ZPh3jASfvxoWlWfAOIA4WawdwDQsu0XHOaG5K7i9+lrGwSQCK+/2UyS1Vj035wPRRwg/Nof8zvmY80Q39vjMRd7UqDWPevzloY06wCi/+bMR/Tvk4/PF/ZBf9Z+yOLjWvcDJQJIrfXwpWdW4wx1N+zCBWqwCR+hCB9xfqM37/c0YbFF027mnoB9IC5ysvV6VTkNp8dS9FNurT/35BnjdQz+mmmdPplFf6fDjxxNq0oNIP5384l30P30+lTHBMCqfj/CYkVo9TnHtxoDSMqxaBU8VhsZiNbnqy5Z54aIYvNBtO5Zn7c0pLkHkJTx+xiVfazRMg7Bo8wlqkanoV/d5hRr/GuprcfxuqK3YanJvtttugkfhI9teqPfUyULiy2adjPn051WkQOm1pt7oqrtasw2N1RFG2DTNi4EkfBXR9OqDgUQ3xc9xn3wfecFFD25a/0EkAivv9lMEv9synvN76eSVxqOvc2myK1YWu+sz1sa0twDyL4Pxfx3o3//0Kx1G/pY019bpdyGpUb7Vrfx/vWvfx1t0JdchI/9dKC4tzpkJAqLLZ52tU9zN2hj7fU1q01WuoHqE8xaXm6KLyzzv+NqzOGPjqZV7QogPvGOuo/aXm4jY78Lixeh9RNAIrz+ZjNJHGIPXfkc6xHbvhrS931f5DX1epvVpwmLVUNDmm0AUe0Lxv77YoF4sTrNfLThr622bsOKPg1LzbZvwXraNt+PHj2KNulLLcLHYeGAkSwsdhK0u1mvjQx6svX6mtUmcYNQ+taa3Nej5bFN9omYtu3gNNi/jdYVCyBuKCY58Wq7ff5dSjY0BJAIr7/ZzCDGDrrHhJDBf9e0zqzXMixWDQ1pzgFk122Br4dVIlenmY82/LVV5GlYl8OubFDTvb4K8tZbb53MVRDCRxodNO41x440YbGToN31FYjck+4gJwqtJ/dWp1pvvfInucVvuRqT9qcbQCa/3cDbX40kT7FH8nrdzSbShMWK0Opzjm9zCSCjX0k0bbfP75kN/rp6nc2q04TFqqEhzTWA7Loq5+M8Vz766jbzsYa/xvrptz62HrPqdtiVDWq8T+4qCOEjnQ4a91aHj/kq+t0GXn+zmWRHP5ZX68ideF66cep761XxqzJT0D61AaTo/fc5NI7cSenFfme0bgJIhNffbOYok4SPlrbfd07I0LenZr2WYbFqaEhzDSAxizzOj6rTyEeb/Rrrl69+ej1m1VPVrsnoG3NBnjx5Em3cl1CEjzw6cNxbHULmq/iXq2kbuV+2dFSToOVzTk7FD/5af+7J0jyuRU5E1H45gIxy/30qjSf7ClVYdHBaNQEkwutvNtNb8Ucop9A4+uzHoA8+0PqyxhAWq4aGtKQAMsqX8S5ap5GPNvu11tZk9Jthdy5QI37WNuXvvPNOtHmfexE+8ungca85hszWGAEk99YDN9+9PhnXcrkTz0vfetX36gcnpZHpNc/9dyr1hCICSITX32ymF18RreVqW59bUwd98IHWl/VahsWqoSEtJYAUfc+cjE4TH230a61fvPzJ9bhVZ2F3LlAzfr3bnP/qV7+KNvFzLcJHPz6ANMeR2SoeQMzbaTaXrNe4tFzOv0fxg7+2kbvfdlrPcK+EXvfc27CKNDVaLwEkwutvNtNLsQa0D42nz3FhsA8ltK6s1zIsVg0NaSkBhFuvjqXG/VKniY82+rXWH3/42fMffe3D67Grdn4zupry+22D/vbbby9mQjrhoz8dQO41x5HZGiuA5M7LsKyDs34+5zYafwJZ/OCvbeTuczWf1J4ave659+cXee94vc3q04TFitDqc45vtQaQ6j5l1ph8PMw12AcTWlfWaxkWq4aGtIQAUsUtgbOnpv1a28B7Ynes0a+5Mq6CXFatJ6S/99570YZ+TkX4OI4OIn0PPrUYJYCYtrXr+x92SX4soX42N+AUn4OgbfR58tWkk2RPmV773N9PAsimWgNIVVc/WhpX7hW3ox/Q0dK6sl7LsFg1NKQlBBC+bHAIatpnHUAiV0FuhV27QA36xoT0Od+KRfg4ng4ifQ8+tRgtgJi2V+Q2F/1czglplE9EtZ1dz3vfZbAGA/n0+ud+Kl3Ft/eHxYrQ6nOObzUGkOqufrQ0tj6P5R3kqq3Wk/VahsWqoSHNPYC8GRbHsdSwzzqAuLaugux8IpapUX/QNu1z/W4QwscwdCDpc/CpydgBJHdS9sEDtX4mZ1LnWLde9bnFgqsfEwv/DqmKNLdaLwEkwutvNpOl6veUxpd7i+Yg80C0nqzXMixWDQ1p7gGkqqcAzpqa9dkHkMhVkOj3gpia9auq9a1Yc3sqFuFjODqQ9Dn41GTUAGLaZu6tSXubCP19zpWGUQ782s7zzeaScfWjAvp3yAnHBJBNNQaQqudTaXy5V4QHOV5rPVmvZVisGhrS3AMIt18NRc367AOI6/F3P7Xah05dDbt4gZr2m90mfi5fUEj4GJYOJPea48lsjR5ATNvNCQ07J2brz3Pu2x/tdgxtK7ex4MlXFdC/Q877mQCyqbYAMtr7vS+NMfeDikH2yetpVpcmLFYNDWnOAYQPm4akRn0RAcT1k29+dLUfoe6HXYxS836328zXPh+E8DE8HUxyDz61mSqA5D4LPzpO/XnqLQyj3HrV0rZyb63gE7EK6N8h5/1MANlUWwCZ5NiWQ2PM/d6iQZpXrSfrtQyLVUNDmnMASX64ChKoUV9MAPnt9y6v9qNT+76c8JJqYz7IBx98EG3+py7CRxk6mNxrjilpwmIQvRw5jz11gNi4CqL/n3MSGu2eW21rkqYC6fSa+8qZbwX075CvVvl9nBOIjQCyqbYAUqzpHFIYa7Kw2FG0mlmftzSkOQeQ6oPxrKhJX0wAcT148dJqX0J5QvrlsKsXqJHfmA/y85//vKpJ6R6L56i04wtF+BiIDiZZB5+wGAK9JDmv3/q56frfOVdQijZG27S93DkuPA++AL2uQ4SMfQggm2oLILP4Ph2NM3e/jr6Sq3VkbTMsVg0Nac4BZBbBeDbUoN9oG/Y3vv3xaFM/p4pMSD90K9bGt6TXEkI8Bo+lOzYV4WNAOphkHXzCYgj0kuQ+inJ18tV/U+eQjHrrlWl7uSdHnn7Vk1670iFjHwLIpqoCSFisehpq7uO6j25gtY5Zv5Ya0pwDyKjno8VTg36rbdb9ONtYUz+3evLas6v96dTO7wYxNfY3uo3+w4cPo6FgrCJ8jEMHk3vNMSVNWAwdellyTiZuMnMmno/+uENtM7ehYP7HAX6NVL5l7wWV33NjhYx9CCCbagogs/meBY119GZa65j1eUtDmm0ACYthKG7O20Z9KQHE9fClZ1b71KlrYZej3OB3G37Pu4iFg9JF+BiPjif3msNKmrAYtuilebN5hZKkNp+TNCHaLr8TR9LL4u9R8ROCHOZqCBsxBJBNNQWQomMZksZKAMmkIRFA0FBjvsgA4luxtp6KtfcLCs2NfrfxHzuEED7GpeMJB58B6KXJuaqRapIrC2HbqZiA3qHXw7dT5V5BmgoBZBMBpAeNNbeZPnoSs9Yx6/OWhjTXADKb38vZUFO+yADi+v3rV7bngzwIu72TG/5uAHAIGWNOCOFjfD6gNMeVNGExROjl8e01Q5nsSSNh+6k4IYleB1/tyH108dQIIJsIID1orASQTBoSAQQNNeWLDSCuX7766dW+depgU+/GvxsEHAxKhhDCxzR8QGmOK2nCYojQy+PbboZoQie7/1vb9j7kOOkTkvbfV77mFjxaBJBNBJAeNFYCSCYNiQCChhryRQcQV2Q+yN5J6eYA0A0EpUII4WM6PqA0x5U0YTHsoJco9xG2MZNN6ta2c28lO8lvQNd+O6gNecVrCgSQTQSQHjRWAkgmDYkAgoab8bYxX2oAcfkRw+1+hroRXoKdHAS6wWDoLyskfEzLB5TmuJImLIY99DIdMwdgsluvTNvPDSCTjncK2meHj5yHDpTg961/z9zI+PYv/7t5XDnvZwLIJgJIDxorASSThkQAQUON+DqA+IsI/W3if/jBZ6JN/JwrMindlRJCbnUDgkPI2dlZNFDkFOFjej6gNMeVNGEx7KGXKfc2pq5Jv3xM2yeA7KH99eN0x3iqlbfh96Yf27wRMsJQovT3Oe9nAsgmAkgPGisBJJOGRABBQ0343a2mfF0OJL59yd+r4QY+1tjPqbwPP/76R7b3MyWEbHxPiOuYJ2QRPurgA0pzXEkTFsMeepn8fQ99TXpLk7ZPANlB++pgOXT48JWUNmT49r2jGg0tn/N+JoBsIoD0oLGO3kxrHbM+b2lIBBA01IDf32rId5avILSBJNbgz6EiT8ZypYSQq6qnncCwChG5t2QRPurhA0pzXEkTFsMOeolyvxk9ptjJ5hBvuxlCslMKIEPcduV1uPko8m+s9ea8nwkgmwggPWisBJBMGhIBBA0131dV11W+FeuOKjmQeF6FnzI1t6sjR4SQS6oHneCwuiXr8ePH0bCxXYSPuviA0hxX0oTFsINeoiGaVD9VaZJbsbTd3AByEick7ecxE8797+mG40pYXTHaRs77mQCyiQDSg8aaO+eNAEIAwSFqyB1Mbqhuqx6ozvfVgxcvzerKSN8QYgoNt7dCxPnDhw/Pnzx5Eg0eLsJHfXxAaY4racJiiNDLk3tS2WeSW7G0XQLIFu1j36tavl3r+bCaUWh7Oe9nAsgmAkgPHmsz5GRHB3GtY9bnLQ2JAII8as4vqXylxFdJzlTnsfIcCz9Naw5XRXaEkKRQoPBwTXXWCROrevTo0SpsED7q5wNKc1xJExbDFr00uY17imInnV20zdwJ9KcQQLLeI4E/FR79Kpa2mTNWAsgmAkgPGmvW9+CExY6i1cz6vKUhEUBwHDXqvkLiqyPRMOLG3ldFan+i1o6nY/k2tEthV3dSiPAtWRuP6nW9/fbb5++//z7ho3I+oDTHlTRhMXToZXHTXuLL6Ca5FavZdLqw2CJp9/pc/XglLD46bTvn/UwA2UQA6SGMN9XvwmJH0Xpmfd7SkAggGI6a9WsqXxk5j1XtQWRHCPFtZ1fDLu6lQBG9GuLbsggf9fIBpTmupAmLoUMvi59ilMonnpywMvqtWNpm7pOeJn10cEnat5x/W5v0BO3tN8NIQgDZRADJpHFOcsum1pM1JyssVg0NiQCC4alh921aN1XRqyK1BxGPb2vMT1Wp80J8NcTfGbLxpKytInxUxAeU5riSJiyGQC9JzjefvxmW8Xc65Bj1VixtL+t3Qka/VWws2rfcMFZ8ovk+2n7OeAkgmwggmTTO3EeOD/KBitZTze9YHxoSAQRluXFXXZi87luzap4j8vi7n9oYbyh/V8rBW7JMIeOyg0YndBA+KuUDSnNcSRMWg+jlyP1eiC+ERb1sztOyRr0VS9vK/dR/kY/i1X7lfro72a1XrTCOVASQTTUFkEdhsappnLnHiq+GRY+i9cw9gOQ+VY8Agn7UuPv2rAtXRDxZvdanZvnb4COT070P18JuHaTA4e8NuU/4qJcPKM1xJU1YDKKXI+fxkxuf/On/5za3o92KpW3lfjq3yJOS9iv3dXguLDoJbf9KM4xkBJBNNQWQWRxrNczcuW/rD2GOofXkvjerukqr8WT9LggBBMdR8+4rIheCiL9LpMarIR6Tvwl+e7wqz3VJuhpiDiLhf6IyPqA0x5U0YbGTp5ci59YDXyW5cAVDf5b76eEoJ1Fvp9lclsXNA9E+Zb03ZNLXQNuf5H78bVovASTC6282k2yQZr0Uj68ZZrqw6NG0qrkHkNxbOwkgGIaad3/hoedWnLflqw21Xg3xLVmRqyHJc0NQLx9QmuNKmrDYSdPL4E+ac04g0e+C0J/nrme0W7GazWUZ9fsuxqB9yvl0d/JbZjSG3KaMALKptgAyyO1KpWh8ubcRDfb6al25v+vV3CaqseReqTQCCIaj5v2y6sI3rtd6NcQT53dcDfEcl+TbslAXH1Ca40qasNhJ08uQM39j7wFbfz/JJM5DtJ2s3wtZ3Ikp7FeqyfffY2iGkqzImLVeAkiE199sJtnrYdEqaXy5t18NFqi0rtnNz2ppLLkPITECCNL8q+f+x+XwPw9S8+4vNty4GuK5If6CwFgQmLp2XA1xOUwRRGbGB5TmuJImLHay9BLkfvJ28KlI+pmcQGPFbyfQNnKDkVV9y0gO7cusvpBR288drxFANtUWQKzKWxs1rj63aQ52fNC6cre/egJhDTSWnLmDLQIIDlP4uKU6D/9Nmiehxt2P7r1wNeSXr346GgKmLl+hiTyuty2CyIz4gNIcV9KExU6Sdj/3nueky/76udyTafFbsbT+PrcJVPMp47G0L1XMp0il7fcJjASQTTUGkCpvbdS4cpvoQW9R1Pr6BO7Jw5zH0AwlGwEE+ylwXA/ho62nqpvhrw9S4+7vD3ETvy43+rEQUEP5Ks2O27JcDiLXw66hUj6gNMeVNGGxk6Nd94mj2KNz9bO5E9KL34qlbeRembFFXAXRfswtgOTeDmMEkE01BpDqHserMfX5cGLwORhaZ+5E7snDnMaQewW9RQDBbgoaV0Pg6AaQth6okp4Epab9qmrjSVlu8mv9zhCXH9m7J4h4XzzpPvm2NIzHB5TmuJImLHZytOtFn9uun3fAqebJKKb197lXeREnKO3HbAKItt3n38kIIJtqDCBW1VUQjafPfgz+BZ1aZ+44Jp1To+33Oca3CCCIU7i4FELGKnD86//0P1fV/v9O3VYdvC1Lzbpvydr4AsOffPOjVYcQ14Eg4vJVET+KOPkRvijLB5TmuJImLHZStNu5zWivE52Wy72NpuitWF63qs8Js+qn96TQPuTebjfJJ9Xarv+N+lz9MALIploDiN+DVcwF0TieW40oT6nfs9wPhWzwIJRK2+579cMIIIhTqLjbCRnnX/zK98//w3/7f+efe/7VbvhoK+dqiL9vw437qjz5u9bJ6d3yE7N869iOyeptOYz4ljOujEzIB5TmuJImLHYytMu5Tbh/tvdJTsvm3vZU9FYsrb/vSXP2t2KF/cgxenOjbfZpwloEkE21BhCb/IlYGkPfDySKNM9ab58wNMnjeLVd37bW57VrEUBwkcJEO+l8VX/216+d/8f//v/X5TDyb67/r24AaetWWMVeoUl3w76quYQQl6/YeCK9r9509yFSvk3LYctXR/jSwhH5gNIcV9KExU6Gdjl3suVRn/5r+dyrLVby5NS36fAysw4hzW5kGbW50fb6/K50EUA21RxAbNJbsbT9Pk9vKvaaat0+NuU66gOivrTNPvPpuggg2KQQsTHp/N/9l1c2wke3Pv9Xf98NH23dV6XckuXG3I36quYUQtryVZGHLz2zesRwd1/2lK+Q3FZ5/sg1FcGkAB9QmuNKmrDYSdDu5n7CNsijHrWe3E+1S9+K1fcqiMc12S0Px9LYs94b4uZmlFtltB3fInbMJ6pGANlUewCx58LqRqXt5j4ko1WscTatv09jP+rVJG2v72vXRQDBnyg4bEw691UO33YVCx9t/fv/+n/Pn/3yd7ZDyJnqYHOtBnz2IaQthxF/n8iB+SLRCi8HBuIDSnNcSRMWWzztap9L5oN84q/19LnqUOxWLK3b4+k7z8D7MemVEG9flf36eBlVrjGeTjZE+DACyKY5BBD/uxdt6rdpe30b6OLNqrbR5/HTNsrVJG2n7/i2EUDQUGC4MOn8L/72H6OhY7scUnylpF02lIPMjbD6ndSAXwghtU9MTylPXv/Fy59cBZID80YIIAPzAaU5rqQJiy2edjXrdZFBG0+tr7Zvyz3mdh83TZPcPqLtts1w9olTy/S5x9yK7avWPVT4MALIpjkEkNZYDfQxn94X/+BB2/AHRX0VfQ21/r5XjmMIIGgoLFyYdB4LG/vKc0W66wh18DtD1IRvhJA5PB0rt3yF5Mlrz65CyRvf/vh6X1X3w8uAgfiA0hxX0oTFFk27mfuplRvCwW+90Tqz/m2k9K1Yx0x4Nt9DPtYtSg5w3as2fQJIn3vMW4M3N16nal/48N/lhBMCyKY5BRDz+7HI+0nrdWN/zHhHmw+lbfWZm9Iq8T71cePQmHI/RCCA4PCk85zyLVmRx/XeCZvaSY34hRASa+SXUL460tlXAsjAfEBpjiuL0vsgqWX7fMJc5L5srddjyVX6qVjHTqb0a+sGtURg84l/O3i0ev1OaLljPgEepAnTelKbQb+uOe9nAsimmgKIf4dTjkP+ucGaaK3L7yH/++UeA7sGmQuXSts79mEMg30wovX4qmns+NPlv896jwgB5NQpHCRPOk8t37oVeUpWSgjZeDpWzd+YfkwRQMryAaU5rizKMQEkt8Eu3bT0uepQ8mTVZ27MLm7ujw5vXkdY175x9fp30nLHNje9G0Qt522nBqBV06f/5ryfi/zuar0EkAivv9lMEv9szuu4+j1T9WqktZzf18cGD/PyUzxl6tjzmMft/e81di3n1z51DH5fE0CQTqEge9J5ank9PUPIxveE+JG3sSZ+zkUAKcsHlOa4sih9m83ck4IVPdlq/f5EMrcpcDNS7FYnrXvIeQjmdfn30K+/w4RP0BfG7z8Lf+ef8c/m/O72PnF62WYVR/E+Oky4UbnQTOjP2n3z3/vnDn2Kum11v73+O8prso/Wm/U+CosVodVP/nq0vP5mM0lWY9F/+1xx9Hb8b+DfpwvzMPRn3d81f8Bx7FXNrqme0tXnavEufj3aY9G+18+36vrqSc6xcHWFWv/Neo8IAeRUKQz0nnSeWjsmp6eEED+u9rytuT4Za1cRQMryAaU5rixK9kFSy/iEkmuU+5y1HTcKuUrfijV0CCmt94lTyw7Z3JSw/u4Z/e+c93ORZkLrJYBEeP3NZpKsxqL/DnnFsbSik7oP0faPnaNWmoPN6oMV/ZcAgjQKAkdPOk+t3BCipvySyl/kd+7y92wsaVI6AaQsH1Ca48qiZB0k9fP+RCv3E+dHYfFRaHt9/p2KnbRM659TCDnqxKnlcxuGsbwShrii/5/ze1KkmdB6CSARXn+zmSTrseh/+5P42k0aPloax5BXc4bk4+T6aor+NwEEhykADDbpPLV6hJCrnSZ99eSoWDM/xyKAlOUDSnNcWZSsg6R+vqp5FjHanj8JzVX0VizT+h1CcsPbFI4+cWodxzxtp4QL++Q/a/4qSZFmQuslgER4/c1mkmyMRf+/z1XQsVQRPkxj8YdJNX4osnG+0P8ngGA/Nf6DTzpPrUgI2fuIXjXnG5PS/UV/sYZ+bkUAKcsHlOa4sijJB0n9bJ9PFzc+dR6LttvnU/gxvhjPJ/3af4+OPnFqHd7PWj5h9esdmyeT8+9QpJnQegkgEV5/s5kkF8aiP6sthLjRryZ8tDSm2q7MXniN9GcEEOymhr/YpPOU2jExfe+XFapBv9s26/5CP3+fRqypn1M5SLX7pDo4JwZ5fEBpjiuLknSQ1M/1+bTMP1/0qsIu3q6qz9WGUa7WaDuelFnjp482yIlT66khhOwMwPq7nPdzkWZC6yWARHj9zWaSRMeiP68lhPg9UPyLBvvy2FRTX5n1sTD6GunPCSCIU6NffNJ5SkVCiAPR1TDMC9Sgez7I07Zh9zeLx5r6OZW/jLDdH9WtsKsYiA8ozXFlUZIOkvq5PrfUrCf8TkHb73PFpvitWC1tx7eK1fY75fEM+rQyrW+KCa9uaPb+/unvc157Asim6gOI6e+mbq5H+5LBY2icU16ZdUDbeczR3xFAEKcmf7RJ54fKwWfrywrPVJfCUC9Qk36907CvvlE81tjPpQggZfmA0hxXFuXgQVI/k/tt51bFwdfjaIaTpfitWF3anp8qNvXvlrdf8sTtMDhWI+h9ORiiws+lKvL7rPUSQCK8/mYzSfaORX/v5nrsEOzHQxd97HgJGrOvGo11ZdbbORjQ/DOrn05HADkFau5Hn3R+qPyN6d0xqfbOhVCjvr4Va+5PxSKAlOUDSnNcWZRDJ+++j7as4pYDjaPPhHQb5VasLm3Tn9Ye+pLAITkQuDEbrVHSttxMlAoifn8m/7uFn09FANk0mwDS0s/5WJD6ZZV9+H07y+DRpfE7sPn3stRxKOt10s8RQLBJjf1kk84P1Z//zT90A4hrZzOuRv2yan0rlpv4WHM/hyKAAMugk5evGPgkPXSz7tsdHDomDYjavvcv94vJYtpmptp77FEX/a44iAwVhNvfv+ommA9B+9Ueh4YIIz72+Gr6JPMCsRBq6CeddJ5SkSdj7ZsPcqvTuM92QjoBBFgenbDdMLkRcNPkpv2eat/kbjdW/hmXl/FJf/QrOqk8tjBGNzr79q3dL/+cf57QgaPod8jvLd925FC+73fPDXj3PeVlTur3z/ur8vuufa1cu3RfKx+7CB04nhr5KiadHyoHome//J1uADk0H2T9BYUPXrwUbfBrLwIIAAAAFkdNfDWTzg9VZD7I7bAbF6hh35iQPserIAQQAAAALIoa+OomnR+qz//V33cDiGvfrVj32wZ+jldBHr70DAEEAAAAy6DGvdpJ54dq6/tBHoRdukBN+7VOAz+7qyD+LpPO+K+F3QIAAADmRU179ZPO91XkVqybYdcuUOM+26sgBBAAAADMnpr1C5PO3dDHGv2aK/It6dEJ6WrcZzsXhAACAACA2VOjvjHp/OqN/xNt8GstX6m58pcvd8OHywHkctjFC9S8r5+INafvBSGAAAAAYNbUpG9MOveE7liTX2v5Ss3Wo3hdvpqzM3yYmvcbbSPvb0ePNfs1FgEEAAAAs6UmfWPS+b/9z/872uTXWv42dN8u1t0H1R3Vzu8Caal5v6Rafzv6k9eejTb8tRUBBAAAALOkJn3Wk84/9/yr28HDtXPieYwa+DttM//Gtz8ebfhrKwIIAAAAZkeN+mwnne+Z77Hzuz92UQN/tdPMn//xh5+NNv01FQEEAAAAs6NmfZaTzvfM9zh4y9UuauLXk9F/+eqno01/TfWjr324G0D2znMBAAAAJqdmfZaTznfN9wi71Zua+NttQz+H27DasbrCLgAAAAB1UsM+y0nn/kb27rhD3Qi7dRQ18rO6Das71rALAAAAQH3UsM9u0rnHt/Xlgq5e8z32UTO/vg2r9qdhteN0heEDAAAAdVHDPrtJ5x5f5Jaro+Z77KJmfn0b1oMXL0Ub/1qqHacrDB8AAACoi5r2WU0693yP7nhDHT3fYxc189fbpr72LyVsx+kKwwcAAADqocZ9VpPOS8732Kfb2P/hB5+JNv81VHecYegAAABAHdS4z2bS+Y75HmeqQed77KKG/n7b2Nf8ON52jK4wdAAAAGB6btxVs5h0vmO+x33V4PM9dlFDf6tt7B++9Ey0+Z+6/ISudoyuMHQAAABgWm7cVbOYdL5jvsftsCujUUO/ngfibxuPBYCp67ffu9wNIPfD0AEAAIBpqYGvftK5r8ZE5nv4ik3x+R4xaugvd5r7aACYugggAAAAqI4a+Judhr7KSed/8bf/OOl8j13U1D9tG/zfv34lGgKmLAIIAAAAqqIG/lqnoa9y0vkXv/L9yed77OKmvm3wa/xCQgIIAAAAqqEG/rKq6knnf/bXr20HD9fo8z12UVO/8YWEbvgP1ePvfur8Fy9/8mB5Xsmh+sk3P9oNGIeKAAIAAIBpqImvetJ5bfM9dlFTv34S1gyKAAIAAIBpqJG/02nsq5p0Xut8jxg19de2mvxay3NVqrlyBAAAgBOiRr7aSec1z/eIUVPfDSBu8j0n5FDdUfnKyaHyY369/r0VhgIAAADUR418tZPOd8z3uBWGDgAAAGBO1MxXOel8z3yP62HoAAAAAOZEzXyVk853zPfwOKub7wEAAAAgkRr66iadewyR+R7+RvYq53sAAAAASKCGvrpJ5x5Dd0yhmO8BAAAAzJma+qomnXu+h8fQHZOK+R4AAADA3Kmpr2rSueecMN8DAAAAWCA19RuTzl3+jo1YMBijmO8BAAAALJga+41J5y4HAM+9GPsqCPM9AAAAgIVTg++5Hw4h61uw2nr2y98Z5SlYe+Z78O3dAAAAwBKp2fetWH4K1plqIwz4y/9KXQ3ZM9/jchgaAAAAgKVS4+8gcku1cUXEIWHoLyTcMd/DV2OY7wEAAACcEoUAPxnrfggFqxryW9E/9/yr3dDR1s2weQAAAACnSKHAV0PWIeHYEOJbua785cvd0OFivgcAAAAwV//0dx+6prquutWpmyr/efbcCoWDGyEkHBVCvIwntrfrCcV8DwAAAGBOHCpCwLivOk+op6o7quRvFVdIuKraCCE5E9P//G/+gfkeAAAAwJwpQDh4OEjEQkZqnaluhFXupbDgELIOEJ6YHgsb28V8DwAAAGDGFBguqW6HAHGhfvz1j5z/9FsfO3/40jPnv3j5k6t68OKl1Z/Ffj6Ug8jBeRgKDr4dax0k/OWBsdDhYr4HAAAAMHMKCVdVD0JoWNdPvvnR88ff/dT5H37wmfPzf/783nry2rOrQPKjr314Yx2hbodN7aQAcbsTKKLzQZjvAQAAAMycwoHDh+dvrAODr3b89nuXo0HjUP3xh59dXR3pri+U55LsnJuhEOHvCll/YaGvcnTDx675HmFxAAAAALVTILgQPhweYsEit3zVxFdQuutW+SrLvhByrRswvviV76/Cx475HklzTAAAAABUQEFgI3z41qm+Vz32lW/LarcRau9VCwULP8VqFTJ8FcST0tv/H8rzPa6GHwcAAABQO4UATzhfz/lw+Pj961eiAWKIioSQnU+rUrjwt6Vvh462PN+DR+wCAAAAc6IAsPG0qxJXPrbrjW9/vBtAXDsnjitkrK+CdIr5HgAAAMDcuPHvBoGh5nwcKk9O9+T2zrbvhyFdoLCxMRdExXwPAAAAYI7U+K+/ZNCTxGNhoVT5Sku77VA7v7tDocNPxGK+BwAAADBXavg3rn6McevVdm19ceHO26oUPK6rmO8BAAAAzJUa/ptt8z/21Y+2IldBCBkAAADAEqnZXz/5yt9wHgsIY9TWXBDmdwAAAABL1Gn6V18UGAsHY9TDl57pBpDbYXgAAAAAlkKN/rW26fcViFgwGKuevPZsN4DsfBoWAAAAgJlSo3+jbfo9ETwWDMYqX31px+IKQwQAAACwFGr0b7UN/1jf/bGv2rG4whABAAAALIUafQIIAAAAgHGo0SeAAAAAABiHGv11APFTqGKhYMxqx+IKQwQAAACwFGr010/BmnoS+taXEZ6FIQIAAABYCjX6V9um/0df+3A0GIxVv3z1090AwmN4AQAAgCVSs/+0bfx///qVaDgYo9749se7AeRWGB4AAACAJVGzf7dt/KeaB/LHH352dQWmHYfqahgeAAAAgCVRs7/+MkKHAIeBWEgoWVu3XzH/AwAAAFgyNf3r27DGfhyvA8+Pv/6RbgDh9isAAABgydz0twHAV0H+8IPPRMNCiXLgabetchC6FIYFAAAAYInc9KvOQggY7ZG8nvTebjMUVz8AAACAU6Dm/3o3DDx48VI0NAxVvsqyNfH8QRgKAAAAgFOgEHCnEwiKhRCHj59886Pd8OFbr3jyFQAAAHBqFAQedILBKoQM+WQs33a1deXDdSNsHgAAAMApURjwfJCNEOKrFb/93uVooMiprQnnbRE+AAAAgFOmUOAQcr8TElblqyG535buqyf+no+tR+22RfgAAAAA0FBAWD+et1u+IuKrGb4qErs9yyHFocOBJXK7lctP3GLOBwAAAIBNDgqqC1dDepYnmzvU8F0fAAAAAHZTaLimuquKBYtDRfAAAAAAkM8hQnVD5Uf2bkxW75QDh6+aOHRcC4sCAAAAAAAAAAAAAAAAAAAAAAAg1Yc+9C+CyYFQsnpjxgAAAABJRU5ErkJggg==';
            var imageHeight = width * 3 / 8;
            var oldAntialias = this.getAntialiasing();
            this.setAntialiasing(true);
            ctx.drawImage(image, 0, 0, 800, 300, x, y - imageHeight - 20, width, imageHeight);
            // loading box
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, 20);
            var progress = width * (loaded / total);
            ctx.fillStyle = 'white';
            var margin = 5;
            var width = progress - margin * 2;
            var height = 20 - margin * 2;
            ctx.fillRect(x + margin, y + margin, width > 0 ? width : 0, height);
            this.setAntialiasing(oldAntialias);
        };
        /**
         * Sets the loading screen draw function if you want to customize the draw
         * @method setLoadingDrawFunction
         * @param fcn {ctx: CanvasRenderingContext2D, loaded: number, total: number) => void}
         * Callback to draw the loading screen which is passed a rendering context, the number of bytes loaded, and the total number of bytes to load.
         */
        Engine.prototype.setLoadingDrawFunction = function (fcn) {
            this.loadingDraw = fcn;
        };
        /**
         * Another option available to you to load resources into the game.
         * Immediately after calling this the game will pause and the loading screen
         * will appear.
         * @method load
         * @param loader {ILoadable} Some loadable such as a Loader collection, Sound, or Texture.
         */
        Engine.prototype.load = function (loader) {
            var _this = this;
            var complete = new ex.Promise();
            this.isLoading = true;
            loader.onprogress = function (e) {
                _this.progress = e.loaded;
                _this.total = e.total;
                _this.logger.debug('Loading ' + (100 * _this.progress / _this.total).toFixed(0));
            };
            loader.oncomplete = function () {
                setTimeout(function () {
                    _this.isLoading = false;
                    complete.resolve();
                }, 500);
            };
            loader.load();
            return complete;
        };
        return Engine;
    })(ex.Class);
    ex.Engine = Engine;
    ;
})(ex || (ex = {}));
//# sourceMappingURL=excalibur-0.2.5.js.map
;
// Concatenated onto excalibur after build
// Exports the excalibur module so it can be used with browserify
// https://github.com/excaliburjs/Excalibur/issues/312
if (typeof module !== 'undefined') {module.exports = ex;}
},{}],"/home/a/snake/lib/food.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
var _ = require('underscore');

module.exports = function (opts) {
    'use strict';
    var
        parts = opts.parts,
        ex = opts.ex,
        game = opts.game,
        color = opts.color,
        w = game.width,
        h = game.height,
        size = opts.size,
        findX = function () {
            var x = size * _.random(2, Math.floor(w / size) - 2);
            return _.pluck(parts, 'x').indexOf(x) === -1 ? x : findX();
        },
        findY = function () {
            var y = size * _.random(2, Math.floor(h / size) - 2);
            return _.pluck(parts, 'y').indexOf(y) === -1 ? y : findY();
        },
        actor = new ex.Actor(findX(), findY(), size, size, color);
    this.eat = function () {
        actor.kill();
    };
    this.actor = actor;
    game.add(actor);
};

},{"underscore":"/home/a/snake/node_modules/underscore/underscore.js"}],"/home/a/snake/lib/mobile.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
/*global window*/
module.exports = function (snake) {
    'use strict';
    var handleOrientation = function (event) {
        var y = event.beta,
            x = event.gamma,
            maxX = 30,
            maxY = 20;
        if (y > maxY) {
            snake.down();
        } else if (y < -maxY) {
            snake.up();
        } else if (x > maxX) {
            snake.right();
        } else if (x < -maxX) {
            snake.left();
        }
    };
    window.addEventListener('deviceorientation', handleOrientation);
};

},{}],"/home/a/snake/lib/score.js":[function(require,module,exports){
/*jslint node:true*/
/*global window*/
module.exports = function () {
    'use strict';
    var ls = window.localStorage,
        score = 0,
        record = ls.getItem('record') || 0;
    this.inc = function () {
        score += 1;
        if (score > record) {
            record = score;
            ls.setItem('record', record);
        }
        document.title = 'Score: ' + score + ' Record: ' + record;
    };
    document.title = 'Score: ' + score + ' Record: ' + record;
};
},{}],"/home/a/snake/lib/snake.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
var Food = require('./food'),
    _ = require('underscore'),
    Score = require('./score');

module.exports = function (opts) {
    'use strict';
    var
        self = this,
        v = {},
        running = false,
        speed = 150,
        score = new Score(),
        game = opts.game,
        size = Math.floor(Math.min(game.width, game.height) / 22),
        ex = opts.ex,
        color = opts.color,
        part = function (x, y, color) {
            var actor = new ex.Actor(x, y, size, size, color);
            game.add(actor);
            return actor;
        },
        startPlaceRandX = _.random(2, Math.floor(game.width / size) - 2),
        startPlaceRandY = _.random(2, Math.floor(game.height / size) - 2),
        parts = [
            part((startPlaceRandX + 1) * size, startPlaceRandY * size, color.body),
            part(startPlaceRandX * size, startPlaceRandY * size, color.body)
        ],
        food = new Food({
            ex: ex,
            game: game,
            color: color.food,
            parts: parts,
            size: size
        }),
        cutTail = function () {
            var last = parts.pop(),
                prelast = parts[parts.length - 1];
            last.moveTo(
                prelast.x,
                prelast.y,
                2 * speed
            );
            return last;
        },
        addNeck = function (time) {
            var firstPart = parts[0],
                x = firstPart.x,
                y =  firstPart.y,
                newPart = part(x, y, color.body);
            parts.unshift(newPart);
            newPart.moveTo(
                x + v.x * size,
                y + v.y * size,
                speed
            );
            newPart.on('exitviewport', function () {
                self.onLose();
            });
            return newPart;
        },
        hiTail = function (actor) {
            var i;
            for (i = 2; i < parts.length - 2; i += 1) {
                if (parts[i] && actor.within(parts[i], size / 2)) {
                    return true;
                }
            }
        },
        step = function () {
            addNeck().callMethod(function () {
                if (this.within(food.actor, size / 2)) {
                    speed += 50;
                    food.eat();
                    score.inc();
                    food = new Food({
                        ex: ex,
                        game: game,
                        color: color.food,
                        parts: parts,
                        size: size
                    });
                    step();
                } else if (hiTail(this)) {
                    self.onLose();
                } else {
                    cutTail().callMethod(function () {
                        this.kill();
                        step();
                    });
                }
            });
        };
    this.right = function () {
        v.x = 1;
        v.y = 0;
    };
    this.left = function () {
        v.x = -1;
        v.y = 0;
    };
    this.up = function () {
        v.x = 0;
        v.y = -1;
    };
    this.down = function () {
        v.x = 0;
        v.y = 1;
    };
    this.run = function (obj) {
        v.x = obj.x || 0;
        v.y = obj.y || 0;
        step();
    };
};

},{"./food":"/home/a/snake/lib/food.js","./score":"/home/a/snake/lib/score.js","underscore":"/home/a/snake/node_modules/underscore/underscore.js"}],"/home/a/snake/node_modules/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/home/a/snake/node_modules/underscore/underscore.js":[function(require,module,exports){
//     Underscore.js 1.7.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.7.0';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var createCallback = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  _.iteratee = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return createCallback(value, context, argCount);
    if (_.isObject(value)) return _.matches(value);
    return _.property(value);
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    if (obj == null) return obj;
    iteratee = createCallback(iteratee, context);
    var i, length = obj.length;
    if (length === +length) {
      for (i = 0; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    if (obj == null) return [];
    iteratee = _.iteratee(iteratee, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length),
        currentKey;
    for (var index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index = 0, currentKey;
    if (arguments.length < 3) {
      if (!length) throw new TypeError(reduceError);
      memo = obj[keys ? keys[index++] : index++];
    }
    for (; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== + obj.length && _.keys(obj),
        index = (keys || obj).length,
        currentKey;
    if (arguments.length < 3) {
      if (!index) throw new TypeError(reduceError);
      memo = obj[keys ? keys[--index] : --index];
    }
    while (index--) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    predicate = _.iteratee(predicate, context);
    _.some(obj, function(value, index, list) {
      if (predicate(value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    predicate = _.iteratee(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(_.iteratee(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    if (obj == null) return true;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    if (obj == null) return false;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (obj.length !== +obj.length) obj = _.values(obj);
    return _.indexOf(obj, target) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = obj && obj.length === +obj.length ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = _.iteratee(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = _.iteratee(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = _.iteratee(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    for (var i = 0, length = input.length; i < length; i++) {
      var value = input[i];
      if (!_.isArray(value) && !_.isArguments(value)) {
        if (!strict) output.push(value);
      } else if (shallow) {
        push.apply(output, value);
      } else {
        flatten(value, shallow, strict, output);
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = _.iteratee(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i];
      if (isSorted) {
        if (!i || seen !== value) result.push(value);
        seen = value;
      } else if (iteratee) {
        var computed = iteratee(value, i, array);
        if (_.indexOf(seen, computed) < 0) {
          seen.push(computed);
          result.push(value);
        }
      } else if (_.indexOf(result, value) < 0) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true, []));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(slice.call(arguments, 1), true, true, []);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function(array) {
    if (array == null) return [];
    var length = _.max(arguments, 'length').length;
    var results = Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var idx = array.length;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var Ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    args = slice.call(arguments, 2);
    bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      Ctor.prototype = func.prototype;
      var self = new Ctor;
      Ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (_.isObject(result)) return result;
      return self;
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = hasher ? hasher.apply(this, arguments) : key;
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last > 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed before being called N times.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      } else {
        func = null;
      }
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    if (!_.isObject(obj)) return obj;
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (hasOwnProperty.call(source, prop)) {
            obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj, iteratee, context) {
    var result = {}, key;
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      iteratee = createCallback(iteratee, context);
      for (key in obj) {
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
    } else {
      var keys = concat.apply([], slice.call(arguments, 1));
      obj = new Object(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (key in obj) result[key] = obj[key];
      }
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    if (!_.isObject(obj)) return obj;
    for (var i = 1, length = arguments.length; i < length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (
      aCtor !== bCtor &&
      // Handle Object.create(x) cases
      'constructor' in a && 'constructor' in b &&
      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
        _.isFunction(bCtor) && bCtor instanceof bCtor)
    ) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size, result;
    // Recursively compare objects and arrays.
    if (className === '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size === b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      size = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      result = _.keys(b).length === size;
      if (result) {
        while (size--) {
          // Deep compare each member
          key = keys[size];
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
  if (typeof /./ !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    var pairs = _.pairs(attrs), length = pairs.length;
    return function(obj) {
      if (obj == null) return !length;
      obj = new Object(obj);
      for (var i = 0; i < length; i++) {
        var pair = pairs[i], key = pair[0];
        if (pair[1] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = createCallback(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? object[property]() : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}]},{},["/home/a/snake/index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiaW5kZXguanMiLCJsaWIvZXhjYWxpYnVyLmpzIiwibGliL2Zvb2QuanMiLCJsaWIvbW9iaWxlLmpzIiwibGliL3Njb3JlLmpzIiwibGliL3NuYWtlLmpzIiwibm9kZV9tb2R1bGVzL2RvbXJlYWR5L3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXVTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKmpzbGludCBub2RlOnRydWUqL1xuLypnbG9iYWwgd2luZG93Ki9cbnZhciBkb21yZWFkeSA9IHJlcXVpcmUoJ2RvbXJlYWR5JyksXG4gICAgZXggPSByZXF1aXJlKCcuL2xpYi9leGNhbGlidXInKSxcbiAgICBTbmFrZSA9IHJlcXVpcmUoJy4vbGliL3NuYWtlJyksXG4gICAgbW9iaWxlID0gcmVxdWlyZSgnLi9saWIvbW9iaWxlJyk7XG5cbmRvbXJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGdhbWUgPSBuZXcgZXguRW5naW5lKCksXG4gICAgICAgIHNuYWtlID0gbmV3IFNuYWtlKHtcbiAgICAgICAgICAgIGV4OiBleCxcbiAgICAgICAgICAgIGdhbWU6IGdhbWUsXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGhlYWQ6IGV4LkNvbG9yLlJlZCxcbiAgICAgICAgICAgICAgICBib2R5OiBleC5Db2xvci5ZZWxsb3csXG4gICAgICAgICAgICAgICAgZm9vZDogZXguQ29sb3IuR3JlZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHJlcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdhbWUucm9vdFNjZW5lLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYWN0b3Iua2lsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC50aXRsZSA9ICcnO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc25ha2UgPSBuZXcgU25ha2Uoe1xuICAgICAgICAgICAgICAgICAgICBleDogZXgsXG4gICAgICAgICAgICAgICAgICAgIGdhbWU6IGdhbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkOiBleC5Db2xvci5SZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBleC5Db2xvci5ZZWxsb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBmb29kOiBleC5Db2xvci5HcmVlblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc25ha2Uub25Mb3NlID0gcmVwbGF5O1xuICAgICAgICAgICAgICAgIHNuYWtlLnJ1bih7eDogMX0pO1xuICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgZ2FtZS5pbnB1dC5rZXlib2FyZC5vbignZG93bicsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGsgPSBrLmtleTtcbiAgICAgICAgaWYgKGsgPT09IDM3KSB7XG4gICAgICAgICAgICBzbmFrZS5sZWZ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoayA9PT0gMzgpIHtcbiAgICAgICAgICAgIHNuYWtlLnVwKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoayA9PT0gMzkpIHtcbiAgICAgICAgICAgIHNuYWtlLnJpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoayA9PT0gNDApIHtcbiAgICAgICAgICAgIHNuYWtlLmRvd24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSAzMikge1xuICAgICAgICAgICAgaWYgKHBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGdhbWUuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2FtZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXBsYXkoKTtcbiAgICB9KTtcbiAgICBtb2JpbGUoc25ha2UpO1xuICAgIGdhbWUuc3RhcnQoKTtcbiAgICBzbmFrZS5vbkxvc2UgPSByZXBsYXk7XG4gICAgc25ha2UucnVuKHt4OiAxfSk7XG59KTtcbiIsIi8qISBleGNhbGlidXIgLSB2MC4yLjUgLSAyMDE1LTAyLTA0XG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXJcbiogQ29weXJpZ2h0IChjKSAyMDE1IDsgTGljZW5zZWQgQlNEKi9cbmlmICh0eXBlb2Ygd2luZG93ID09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93ID0geyBhdWRpb0NvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB9IH07XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHdpbmRvdy5zZXRJbnRlcnZhbChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICB9O1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0IHx8IHdpbmRvdy5tb3pBdWRpb0NvbnRleHQgfHwgd2luZG93Lm1zQXVkaW9Db250ZXh0IHx8IHdpbmRvdy5vQXVkaW9Db250ZXh0O1xufVxuLy8gUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4vLyBQcm9kdWN0aW9uIHN0ZXBzIG9mIEVDTUEtMjYyLCBFZGl0aW9uIDUsIDE1LjQuNC4xOFxuLy8gUmVmZXJlbmNlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjQuNC4xOFxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBULCBrO1xuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcgdGhpcyBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMS4gTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0IHBhc3NpbmcgdGhlIHx0aGlzfCB2YWx1ZSBhcyB0aGUgYXJndW1lbnQuXG4gICAgICAgIHZhciBPID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXG4gICAgICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgLy8gNC4gSWYgSXNDYWxsYWJsZShjYWxsYmFjaykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gU2VlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjExXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA1LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4gTGV0IGsgYmUgMFxuICAgICAgICBrID0gMDtcbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWU7XG4gICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgVG9TdHJpbmcoaykuXG4gICAgICAgICAgICAvLyAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3JcbiAgICAgICAgICAgIC8vIGIuIExldCBrUHJlc2VudCBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEhhc1Byb3BlcnR5IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAgICAgICAvLyAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjXG4gICAgICAgICAgICAvLyBjLiBJZiBrUHJlc2VudCBpcyB0cnVlLCB0aGVuXG4gICAgICAgICAgICBpZiAoayBpbiBPKSB7XG4gICAgICAgICAgICAgICAgLy8gaS4gTGV0IGtWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgICAgICAgICAgIGtWYWx1ZSA9IE9ba107XG4gICAgICAgICAgICAgICAgLy8gaWkuIENhbGwgdGhlIENhbGwgaW50ZXJuYWwgbWV0aG9kIG9mIGNhbGxiYWNrIHdpdGggVCBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBsaXN0IGNvbnRhaW5pbmcga1ZhbHVlLCBrLCBhbmQgTy5cbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFQsIGtWYWx1ZSwgaywgTyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkLiBJbmNyZWFzZSBrIGJ5IDEuXG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gOC4gcmV0dXJuIHVuZGVmaW5lZFxuICAgIH07XG59XG4vLyBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcbmlmICghQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNBcmcgKi8pIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgICAgIGlmICh0eXBlb2YgZnVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbi8vIFBvbHlmaWxsIGZyb20gIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQjUG9seWZpbGxcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZlRvQmluZCA9IHRoaXMsIGZOT1AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH0sIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID8gdGhpcyA6IG9UaGlzLCBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcbiAgICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICB9O1xufVxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBFZmZlY3RzO1xuICAgIChmdW5jdGlvbiAoRWZmZWN0cykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgXCJHcmF5c2NhbGVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHJlbW92aW5nIGNvbG9yIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAY2xhc3MgRWZmZWN0cy5HcmF5c2NhbGVcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBleHRlbmRzIElTcHJpdGVFZmZlY3RcbiAgICAgICAgICovXG4gICAgICAgIHZhciBHcmF5c2NhbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gR3JheXNjYWxlKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR3JheXNjYWxlLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBhdmcgPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDFdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDJdKSAvIDM7XG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gYXZnO1xuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGF2ZztcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBhdmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEdyYXlzY2FsZTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgRWZmZWN0cy5HcmF5c2NhbGUgPSBHcmF5c2NhbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBcIkludmVydFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXG4gICAgICAgICAqIEBjbGFzcyBFZmZlY3RzLkludmVydFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQGV4dGVuZHMgSVNwcml0ZUVmZmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEludmVydCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBJbnZlcnQoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJbnZlcnQucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDBdO1xuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXTtcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMl07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEludmVydDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgRWZmZWN0cy5JbnZlcnQgPSBJbnZlcnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBcIk9wYWNpdHlcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHNldHRpbmcgdGhlIGFscGhhIG9mIGFsbCBwaXhlbHMgdG8gYSBnaXZlbiB2YWx1ZS5cbiAgICAgICAgICogQGNsYXNzIEVmZmVjdHMuT3BhY2l0eVxuICAgICAgICAgKiBAZXh0ZW5kcyBJU3ByaXRlRWZmZWN0XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gb3BhY2l0eSB7bnVtYmVyfSBUaGUgbmV3IG9wYWNpdHkgb2YgdGhlIHNwcml0ZSBmcm9tIDAtMS4wXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgT3BhY2l0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT3BhY2l0eS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IE1hdGgucm91bmQodGhpcy5vcGFjaXR5ICogMjU1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIE9wYWNpdHk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEVmZmVjdHMuT3BhY2l0eSA9IE9wYWNpdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBcIkNvbG9yaXplXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIHRoZSBwaXhlbHMgdG8gYW5cbiAgICAgICAgICogYXZlcmFnZSBvZiB0aGUgb3JpZ2luYWwgY29sb3IgYW5kIHRoZSBwcm92aWRlZCBjb2xvclxuICAgICAgICAgKiBAY2xhc3MgRWZmZWN0cy5Db2xvcml6ZVxuICAgICAgICAgKiBAZXh0ZW5kcyBJU3ByaXRlRWZmZWN0XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gY29sb3Ige0NvbG9yfSBUaGUgY29sb3IgdG8gYXBwbHkgdG8gdGhlIHNwcml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIENvbG9yaXplID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbG9yaXplKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ29sb3JpemUucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgdGhpcy5jb2xvci5yKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMV0gKyB0aGlzLmNvbG9yLmcpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSArIHRoaXMuY29sb3IuYikgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gQ29sb3JpemU7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEVmZmVjdHMuQ29sb3JpemUgPSBDb2xvcml6ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFwiRmlsbFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoXG4gICAgICAgICAqIGEgZ2l2ZW4gY29sb3JcbiAgICAgICAgICogQGNsYXNzIEVmZmVjdHMuRmlsbFxuICAgICAgICAgKiBAZXh0ZW5kcyBJU3ByaXRlRWZmZWN0XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gY29sb3Ige0NvbG9yfSBUaGUgY29sb3IgdG8gYXBwbHkgdG8gdGhlIHNwcml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEZpbGwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRmlsbChjb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEZpbGwucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSB0aGlzLmNvbG9yLnI7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IHRoaXMuY29sb3IuZztcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gdGhpcy5jb2xvci5iO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gRmlsbDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgRWZmZWN0cy5GaWxsID0gRmlsbDtcbiAgICB9KShFZmZlY3RzID0gZXguRWZmZWN0cyB8fCAoZXguRWZmZWN0cyA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1Nwcml0ZUVmZmVjdHMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0ludGVyZmFjZXMvSVBpcGVsaW5lTW9kdWxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgTW92ZW1lbnRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNb3ZlbWVudE1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBNb3ZlbWVudE1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgcGxhY2VtZW50cyBiYXNlZCBvbiBsaW5lYXIgYWxnZWJyYVxuICAgICAgICAgICAgYWN0b3IueCArPSBhY3Rvci5keCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIGFjdG9yLnkgKz0gYWN0b3IuZHkgKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICBhY3Rvci5keCArPSBhY3Rvci5heCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIGFjdG9yLmR5ICs9IGFjdG9yLmF5ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgYWN0b3Iucm90YXRpb24gKz0gYWN0b3IucnggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICBhY3Rvci5zY2FsZS54ICs9IGFjdG9yLnN4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgYWN0b3Iuc2NhbGUueSArPSBhY3Rvci5zeSAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1vdmVtZW50TW9kdWxlO1xuICAgIH0pKCk7XG4gICAgZXguTW92ZW1lbnRNb2R1bGUgPSBNb3ZlbWVudE1vZHVsZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vSW50ZXJmYWNlcy9JUGlwZWxpbmVNb2R1bGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBPZmZzY3JlZW5DdWxsaW5nTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBPZmZzY3JlZW5DdWxsaW5nTW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBldmVudERpc3BhdGNoZXIgPSBhY3Rvci5ldmVudERpc3BhdGNoZXI7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gYWN0b3IuYW5jaG9yO1xuICAgICAgICAgICAgdmFyIGdsb2JhbFNjYWxlID0gYWN0b3IuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGdsb2JhbFNjYWxlLnggKiBhY3Rvci5nZXRXaWR0aCgpIC8gYWN0b3Iuc2NhbGUueDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBnbG9iYWxTY2FsZS55ICogYWN0b3IuZ2V0SGVpZ2h0KCkgLyBhY3Rvci5zY2FsZS55O1xuICAgICAgICAgICAgdmFyIGFjdG9yU2NyZWVuQ29vcmRzID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhuZXcgZXguUG9pbnQoYWN0b3IuZ2V0R2xvYmFsWCgpIC0gYW5jaG9yLnggKiB3aWR0aCwgYWN0b3IuZ2V0R2xvYmFsWSgpIC0gYW5jaG9yLnkgKiBoZWlnaHQpKTtcbiAgICAgICAgICAgIHZhciB6b29tID0gMS4wO1xuICAgICAgICAgICAgaWYgKGFjdG9yLnNjZW5lICYmIGFjdG9yLnNjZW5lLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHpvb20gPSBhY3Rvci5zY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhY3Rvci5pc09mZlNjcmVlbikge1xuICAgICAgICAgICAgICAgIGlmIChhY3RvclNjcmVlbkNvb3Jkcy54ICsgd2lkdGggKiB6b29tIDwgMCB8fCBhY3RvclNjcmVlbkNvb3Jkcy55ICsgaGVpZ2h0ICogem9vbSA8IDAgfHwgYWN0b3JTY3JlZW5Db29yZHMueCA+IGVuZ2luZS53aWR0aCB8fCBhY3RvclNjcmVlbkNvb3Jkcy55ID4gZW5naW5lLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIucHVibGlzaCgnZXhpdHZpZXdwb3J0JywgbmV3IGV4LkV4aXRWaWV3UG9ydEV2ZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rvci5pc09mZlNjcmVlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yU2NyZWVuQ29vcmRzLnggKyB3aWR0aCAqIHpvb20gPiAwICYmIGFjdG9yU2NyZWVuQ29vcmRzLnkgKyBoZWlnaHQgKiB6b29tID4gMCAmJiBhY3RvclNjcmVlbkNvb3Jkcy54IDwgZW5naW5lLndpZHRoICYmIGFjdG9yU2NyZWVuQ29vcmRzLnkgPCBlbmdpbmUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdlbnRlcnZpZXdwb3J0JywgbmV3IGV4LkVudGVyVmlld1BvcnRFdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuaXNPZmZTY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPZmZzY3JlZW5DdWxsaW5nTW9kdWxlO1xuICAgIH0pKCk7XG4gICAgZXguT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZSA9IE9mZnNjcmVlbkN1bGxpbmdNb2R1bGU7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0ludGVyZmFjZXMvSVBpcGVsaW5lTW9kdWxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wb2dhdGVzIHBvaW50ZXIgZXZlbnRzIHRvIHRoZSBhY3RvclxuICAgICAqL1xuICAgIHZhciBDYXB0dXJlUG9pbnRlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENhcHR1cmVQb2ludGVyTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIENhcHR1cmVQb2ludGVyTW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICghYWN0b3IuZW5hYmxlQ2FwdHVyZVBvaW50ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGFjdG9yLmlzS2lsbGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZW5naW5lLmlucHV0LnBvaW50ZXJzLnByb3BvZ2F0ZShhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDYXB0dXJlUG9pbnRlck1vZHVsZTtcbiAgICB9KSgpO1xuICAgIGV4LkNhcHR1cmVQb2ludGVyTW9kdWxlID0gQ2FwdHVyZVBvaW50ZXJNb2R1bGU7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0ludGVyZmFjZXMvSVBpcGVsaW5lTW9kdWxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbGxpc2lvbkRldGVjdGlvbk1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnREaXNwYXRjaGVyID0gYWN0b3IuZXZlbnREaXNwYXRjaGVyO1xuICAgICAgICAgICAgaWYgKGFjdG9yLmNvbGxpc2lvblR5cGUgIT09IDAgLyogUHJldmVudENvbGxpc2lvbiAqLykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZW5naW5lLmN1cnJlbnRTY2VuZS50aWxlTWFwcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gZW5naW5lLmN1cnJlbnRTY2VuZS50aWxlTWFwc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdE1hcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGUgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQm91bmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW50ZXJzZWN0TWFwID0gbWFwLmNvbGxpZGVzKGFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heC0tIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IGFjdG9yLmdldFNpZGVGcm9tSW50ZXJzZWN0KGludGVyc2VjdE1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIucHVibGlzaCgnY29sbGlzaW9uJywgbmV3IGV4LkNvbGxpc2lvbkV2ZW50KGFjdG9yLCBudWxsLCBzaWRlLCBpbnRlcnNlY3RNYXApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gMiAvKiBBY3RpdmUgKi8gfHwgYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gMyAvKiBFbGFzdGljICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLnkgKz0gaW50ZXJzZWN0TWFwLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IueCArPSBpbnRlcnNlY3RNYXAueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOYWl2ZSBlbGFzdGljIGJvdW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8gJiYgIWhhc0JvdW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQm91bmNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID09PSAzIC8qIExlZnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmR4ID0gTWF0aC5hYnMoYWN0b3IuZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPT09IDQgLyogUmlnaHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmR4ID0gLU1hdGguYWJzKGFjdG9yLmR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWRlID09PSAxIC8qIFRvcCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZHkgPSBNYXRoLmFicyhhY3Rvci5keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA9PT0gMiAvKiBCb3R0b20gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmR5ID0gLU1hdGguYWJzKGFjdG9yLmR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkRldGVjdGlvbk1vZHVsZTtcbiAgICB9KSgpO1xuICAgIGV4LkNvbGxpc2lvbkRldGVjdGlvbk1vZHVsZSA9IENvbGxpc2lvbkRldGVjdGlvbk1vZHVsZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgc2lkZXMgb2YgYW4gQWN0b3IgZm9yIGNvbGxpc2lvblxuICAgICAqIEBjbGFzcyBTaWRlXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChTaWRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgTm9uZSB7U2lkZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgU2lkZVtTaWRlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgVG9wIHtTaWRlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBTaWRlW1NpZGVbXCJUb3BcIl0gPSAxXSA9IFwiVG9wXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgQm90dG9tIHtTaWRlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBTaWRlW1NpZGVbXCJCb3R0b21cIl0gPSAyXSA9IFwiQm90dG9tXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgTGVmdCB7U2lkZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgU2lkZVtTaWRlW1wiTGVmdFwiXSA9IDNdID0gXCJMZWZ0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgUmlnaHQge1NpZGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIFNpZGVbU2lkZVtcIlJpZ2h0XCJdID0gNF0gPSBcIlJpZ2h0XCI7XG4gICAgfSkoZXguU2lkZSB8fCAoZXguU2lkZSA9IHt9KSk7XG4gICAgdmFyIFNpZGUgPSBleC5TaWRlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIDJEIHBvaW50IG9uIGEgcGxhbmVcbiAgICAgKiBAY2xhc3MgUG9pbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgICogQHBhcmFtIHkge251bWJlcn0gWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAqXG4gICAgICovXG4gICAgdmFyIFBvaW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFggQ29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgICAgICogQHByb3BlcnR5IHgge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZIENvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSB5IHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHBvaW50IHRvIGEgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgdG9WZWN0b3JcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBQb2ludC5wcm90b3R5cGUudG9WZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb3RhdGVzIHRoZSBjdXJyZW50IHBvaW50IGFyb3VuZCBhbm90aGVyIGJ5IGEgY2VydGFpbiBudW1iZXIgb2ZcbiAgICAgICAgICogZGVncmVlcyBpbiByYWRpYW5zXG4gICAgICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBQb2ludC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCBhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IGV4LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgdmFyIHggPSBjb3NBbmdsZSAqICh0aGlzLnggLSBhbmNob3IueCkgLSBzaW5BbmdsZSAqICh0aGlzLnkgLSBhbmNob3IueSkgKyBhbmNob3IueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2luQW5nbGUgKiAodGhpcy54IC0gYW5jaG9yLngpICsgY29zQW5nbGUgKiAodGhpcy55IC0gYW5jaG9yLnkpICsgYW5jaG9yLnk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNsYXRlcyB0aGUgY3VycmVudCBwb2ludCBieSBhIHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2ZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdmVjdG9yLngsIHRoaXMueSArIHZlY3Rvci55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHggYW5kIHkgY29tcG9uZW50cyBhdCBvbmNlXG4gICAgICAgICAqIEBtZXRob2Qgc2V0VG9cbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn1cbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIFBvaW50LnByb3RvdHlwZS5zZXRUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lcyBhIG5ldyBwb2ludCB0aGF0IGlzIGEgY29weSBvZiB0aGlzIG9uZS5cbiAgICAgICAgICogQG1ldGhvZCBjbG9uZVxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQb2ludDtcbiAgICB9KSgpO1xuICAgIGV4LlBvaW50ID0gUG9pbnQ7XG4gICAgLyoqXG4gICAgICogQSAyRCB2ZWN0b3Igb24gYSBwbGFuZS5cbiAgICAgKiBAY2xhc3MgVmVjdG9yXG4gICAgICogQGV4dGVuZHMgUG9pbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBYIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXG4gICAgICogQHBhcmFtIHkge251bWJlcn0gWSBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxuICAgICAqL1xuICAgIHZhciBWZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVmVjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBWZWN0b3IoeCwgeSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHZlY3RvciBvZiB1bml0IGxlbmd0aCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzcGVjaWZpZWQgYW5nbGUuXG4gICAgICAgICAqIEBtZXRob2QgZnJvbUFuZ2xlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIGFuZ2xlIHtudW1iZXJ9IFRoZSBhbmdsZSB0byBnZW5lcmF0ZSB0aGUgdmVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLmZyb21BbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3RhbmNlIHRvIGFub3RoZXIgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZGlzdGFuY2VcbiAgICAgICAgICogQHBhcmFtIHYge1ZlY3Rvcn0gVGhlIG90aGVyIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgdiA9IG5ldyBWZWN0b3IoMC4wLCAwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB2LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gdi55LCAyKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3JtYWxpemVzIGEgdmVjdG9yIHRvIGhhdmUgYSBtYWduaXR1ZGUgb2YgMS5cbiAgICAgICAgICogQG1ldGhvZCBub3JtYWxpemVcbiAgICAgICAgICogQHJldHVybiBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRpc3RhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggLyBkLCB0aGlzLnkgLyBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGVzIGEgdmVjdG9yJ3MgYnkgYSBmYWN0b3Igb2Ygc2l6ZVxuICAgICAgICAgKiBAbWV0aG9kIHNjYWxlXG4gICAgICAgICAqIEBwYXJhbSBzaXplIHtudW1iZXJ9IFRoZSBmYWN0b3IgdG8gc2NhbGUgdGhlIG1hZ25pdHVkZSBieVxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICogc2l6ZSwgdGhpcy55ICogc2l6ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIG9uZSB2ZWN0b3IgdG8gYW5vdGhlclxuICAgICAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgdmVjdG9yIHRvIGFkZFxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCArIHYueCwgdGhpcy55ICsgdi55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnRyYWN0cyBhIHZlY3RvciBmcm9tIHRoZSBjdXJyZW50IHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIG1pbnVzXG4gICAgICAgICAqIEBwYXJhbSB2IHtWZWN0b3J9IFRoZSB2ZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm1pbnVzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgZG90IHByb2R1Y3Qgd2l0aCBhbm90aGVyIHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGRvdFxuICAgICAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgdmVjdG9yIHRvIGRvdFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIDJEIGNyb3NzIHByb2R1Y3Qgd2l0aCBhbm90aGVyIHZlY3Rvci4gMkQgY3Jvc3MgcHJvZHVjdHMgcmV0dXJuIGEgc2NhbGFyIHZhbHVlIG5vdCBhIHZlY3Rvci5cbiAgICAgICAgICogQG1ldGhvZCBjcm9zc1xuICAgICAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgdmVjdG9yIHRvIGNyb3NzXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5jcm9zcyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdi55IC0gdGhpcy55ICogdi54O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcGVycGVuZGljdWxhciB2ZWN0b3IgdG8gdGhpcyBvbmVcbiAgICAgICAgICogQG1ldGhvZCBwZXJwZW5kaWN1bGFyXG4gICAgICAgICAqIEByZXR1cm4gVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnBlcnBlbmRpY3VsYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnksIC10aGlzLngpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbm9ybWFsIHZlY3RvciB0byB0aGlzIG9uZVxuICAgICAgICAgKiBAbWV0aG9kIG5vcm1hbFxuICAgICAgICAgKiBAcmV0dXJuIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJwZW5kaWN1bGFyKCkubm9ybWFsaXplKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBvZiB0aGlzIHZlY3Rvci5cbiAgICAgICAgICogQG1ldGhvZCB0b0FuZ2xlXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS50b0FuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcG9pbnQgcmVwcmVzZW50aW9uIG9mIHRoaXMgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgdG9Qb2ludFxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS50b1BvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb3RhdGVzIHRoZSBjdXJyZW50IHZlY3RvciBhcm91bmQgYSBwb2ludCBieSBhIGNlcnRhaW4gbnVtYmVyIG9mXG4gICAgICAgICAqIGRlZ3JlZXMgaW4gcmFkaWFuc1xuICAgICAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCBhbmNob3IpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJvdGF0ZS5jYWxsKHRoaXMsIGFuZ2xlLCBhbmNob3IpLnRvVmVjdG9yKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWZWN0b3I7XG4gICAgfSkoUG9pbnQpO1xuICAgIGV4LlZlY3RvciA9IFZlY3RvcjtcbiAgICAvKipcbiAgICAgKiBBIDJEIHJheSB0aGF0IGNhbiBiZSBjYXN0IGludG8gdGhlIHNjZW5lIHRvIGRvIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgKiBAY2xhc3MgUmF5XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHBvcyB7UG9pbnR9IFRoZSBzdGFydGluZyBwb3NpdGlvbiBmb3IgdGhlIHJheVxuICAgICAqIEBwYXJhbSBkaXIge1ZlY3Rvcn0gVGhlIHZlY3RvciBpbmRpY2F0aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJheVxuICAgICAqL1xuICAgIHZhciBSYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSYXkocG9zLCBkaXIpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgdGhpcy5kaXIgPSBkaXIubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3RzIGEgd2hldGhlciB0aGlzIHJheSBpbnRlcnNlY3RzIHdpdGggYSBsaW5lIHNlZ21lbnQuIFJldHVybnMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgb24gc3VjY2Vzcy5cbiAgICAgICAgICogVGhpcyBudW1iZXIgaW5kaWNhdGVzIHRoZSBtYXRoZW1hdGljYWwgaW50ZXJzZWN0aW9uIHRpbWUuXG4gICAgICAgICAqIEBtZXRob2QgaW50ZXJzZWN0XG4gICAgICAgICAqIEBwYXJhbSBsaW5lIHtMaW5lfSBUaGUgbGluZSB0byB0ZXN0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgUmF5LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IGxpbmUuYmVnaW4udG9WZWN0b3IoKS5taW51cyh0aGlzLnBvcy50b1ZlY3RvcigpKTtcbiAgICAgICAgICAgIC8vIFRlc3QgaXMgbGluZSBhbmQgcmF5IGFyZSBwYXJhbGxlbCBhbmQgbm9uIGludGVyc2VjdGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgPT09IDAgJiYgbnVtZXJhdG9yLmNyb3NzKHRoaXMuZGlyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBwYXJhbGxlbFxuICAgICAgICAgICAgdmFyIGRpdmlzb3IgPSAodGhpcy5kaXIuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSk7XG4gICAgICAgICAgICBpZiAoZGl2aXNvciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gbnVtZXJhdG9yLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xuICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gKG51bWVyYXRvci5jcm9zcyh0aGlzLmRpcikgLyBkaXZpc29yKSAvIGxpbmUuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHUgPj0gMCAmJiB1IDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIGdpdmVuIHRoZSBpbnRlcnNlY3Rpb24gdGltZVxuICAgICAgICAgKiBAbWV0aG9kIGdldFBvaW50XG4gICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBSYXkucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcy50b1ZlY3RvcigpLmFkZCh0aGlzLmRpci5zY2FsZSh0aW1lKSkudG9Qb2ludCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmF5O1xuICAgIH0pKCk7XG4gICAgZXguUmF5ID0gUmF5O1xuICAgIC8qKlxuICAgICAqIEEgMkQgbGluZSBzZWdtZW50XG4gICAgICogQGNsYXNzIExpbmVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gYmVnaW4ge1BvaW50fSBUaGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICAqIEBwYXJhbSBlbmQge1BvaW50fSBUaGUgZW5kaW5nIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgKi9cbiAgICB2YXIgTGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpbmUoYmVnaW4sIGVuZCkge1xuICAgICAgICAgICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNsb3BlIG9mIHRoZSBsaW5lIGluIHRoZSBmb3JtIG9mIGEgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2xvcGVcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBMaW5lLnByb3RvdHlwZS5nZXRTbG9wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuYmVnaW4udG9WZWN0b3IoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZC50b1ZlY3RvcigpO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcbiAgICAgICAgICAgIHJldHVybiBlbmQubWludXMoYmVnaW4pLnNjYWxlKDEgLyBkaXN0YW5jZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgc2VnbWVudCBpbiBwaXhlbHNcbiAgICAgICAgICogQG1ldGhvZCBnZXRMZW5ndGhcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBMaW5lLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmJlZ2luLnRvVmVjdG9yKCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQudG9WZWN0b3IoKTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaW5lO1xuICAgIH0pKCk7XG4gICAgZXguTGluZSA9IExpbmU7XG4gICAgdmFyIFByb2plY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcm9qZWN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIFByb2plY3Rpb24ucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24gKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCA+IHByb2plY3Rpb24ubWluICYmIHByb2plY3Rpb24ubWF4ID4gdGhpcy5taW47XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb24ucHJvdG90eXBlLmdldE92ZXJsYXAgPSBmdW5jdGlvbiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxhcHMocHJvamVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXggPiBwcm9qZWN0aW9uLm1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbi5tYXggLSB0aGlzLm1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCAtIHByb2plY3Rpb24ubWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvamVjdGlvbjtcbiAgICB9KSgpO1xuICAgIGV4LlByb2plY3Rpb24gPSBQcm9qZWN0aW9uO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50cy50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgVXRpbDtcbiAgICAoZnVuY3Rpb24gKFV0aWwpIHtcbiAgICAgICAgVXRpbC5Ud29QSSA9IE1hdGguUEkgKiAyO1xuICAgICAgICBmdW5jdGlvbiBiYXNlNjRFbmNvZGUoaW5wdXRTdHIpIHtcbiAgICAgICAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICAgICAgICB2YXIgb3V0cHV0U3RyID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaW5wdXRTdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9hbGwgdGhyZWUgXCImIDB4ZmZcIiBhZGRlZCBiZWxvdyBhcmUgdGhlcmUgdG8gZml4IGEga25vd24gYnVnIFxuICAgICAgICAgICAgICAgIC8vd2l0aCBieXRlcyByZXR1cm5lZCBieSB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xuICAgICAgICAgICAgICAgIHZhciBieXRlMyA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgdmFyIGVuYzEgPSBieXRlMSA+PiAyO1xuICAgICAgICAgICAgICAgIHZhciBlbmMyID0gKChieXRlMSAmIDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgICAgIHZhciBlbmMzLCBlbmM0O1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihieXRlMikpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jMyA9IGVuYzQgPSA2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYzMgPSAoKGJ5dGUyICYgMTUpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYnl0ZTMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmM0ID0gYnl0ZTMgJiA2MztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXRTdHIgKz0gYjY0LmNoYXJBdChlbmMxKSArIGI2NC5jaGFyQXQoZW5jMikgKyBiNjQuY2hhckF0KGVuYzMpICsgYjY0LmNoYXJBdChlbmM0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5iYXNlNjRFbmNvZGUgPSBiYXNlNjRFbmNvZGU7XG4gICAgICAgIGZ1bmN0aW9uIGNsYW1wKHZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgPD0gbWluID8gbWluIDogKHZhbCA+PSBtYXggPyBtYXggOiB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwuY2xhbXAgPSBjbGFtcDtcbiAgICAgICAgZnVuY3Rpb24gZHJhd0xpbmUoY3R4LCBjb2xvciwgc3RhcnR4LCBzdGFydHksIGVuZHgsIGVuZHkpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhzdGFydHgsIHN0YXJ0eSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGVuZHgsIGVuZHkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwuZHJhd0xpbmUgPSBkcmF3TGluZTtcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tSW5SYW5nZShtaW4sIG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLnJhbmRvbUluUmFuZ2UgPSByYW5kb21JblJhbmdlO1xuICAgICAgICBmdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKG1pbiwgbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChyYW5kb21JblJhbmdlKG1pbiwgbWF4KSk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5yYW5kb21JbnRJblJhbmdlID0gcmFuZG9tSW50SW5SYW5nZTtcbiAgICAgICAgZnVuY3Rpb24gY2Fub25pY2FsaXplQW5nbGUoYW5nbGUpIHtcbiAgICAgICAgICAgIHZhciB0bXBBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgaWYgKGFuZ2xlID4gdGhpcy5Ud29QSSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0bXBBbmdsZSA+IHRoaXMuVHdvUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wQW5nbGUgLT0gdGhpcy5Ud29QSTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRtcEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0bXBBbmdsZSArPSB0aGlzLlR3b1BJO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0bXBBbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLmNhbm9uaWNhbGl6ZUFuZ2xlID0gY2Fub25pY2FsaXplQW5nbGU7XG4gICAgICAgIGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gMTgwIC8gTWF0aC5QSSAqIHJhZGlhbnM7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC50b0RlZ3JlZXMgPSB0b0RlZ3JlZXM7XG4gICAgICAgIGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC50b1JhZGlhbnMgPSB0b1JhZGlhbnM7XG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgb0xlZnQgPSAwLCBvVG9wID0gMDtcbiAgICAgICAgICAgIHZhciBjYWxjT2Zmc2V0TGVmdCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBvTGVmdCArPSBwYXJlbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjT2Zmc2V0TGVmdChwYXJlbnQub2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNhbGNPZmZzZXRUb3AgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgb1RvcCArPSBwYXJlbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNPZmZzZXRUb3AocGFyZW50Lm9mZnNldFBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbGNPZmZzZXRMZWZ0KGVsKTtcbiAgICAgICAgICAgIGNhbGNPZmZzZXRUb3AoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludChvTGVmdCwgb1RvcCk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5nZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xuICAgICAgICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVNpZGUoc2lkZSkge1xuICAgICAgICAgICAgaWYgKHNpZGUgPT09IDEgLyogVG9wICovKVxuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEJvdHRvbSAqLztcbiAgICAgICAgICAgIGlmIChzaWRlID09PSAyIC8qIEJvdHRvbSAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBUb3AgKi87XG4gICAgICAgICAgICBpZiAoc2lkZSA9PT0gMyAvKiBMZWZ0ICovKVxuICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIFJpZ2h0ICovO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT09IDQgLyogUmlnaHQgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogTGVmdCAqLztcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5nZXRPcHBvc2l0ZVNpZGUgPSBnZXRPcHBvc2l0ZVNpZGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGNhbGlidXJzIGR5bmFtaWNhbGx5IHJlc2l6aW5nIGNvbGxlY3Rpb25cbiAgICAgICAgICogQGNsYXNzIENvbGxlY3Rpb25cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBbaW5pdGlhbFNpemU9MjAwXSB7bnVtYmVyfSBJbml0aWFsIHNpemUgb2YgdGhlIGludGVybmFsIGJhY2tpbmcgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHZhciBDb2xsZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oaW5pdGlhbFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQXJyYXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kUG9pbnRlciA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBpbml0aWFsU2l6ZSB8fCBDb2xsZWN0aW9uLkRlZmF1bHRTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBcnJheSA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuaW50ZXJuYWxBcnJheS5sZW5ndGggKiAyO1xuICAgICAgICAgICAgICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdTaXplKTtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FycmF5W2ldID0gdGhpcy5pbnRlcm5hbEFycmF5W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbnRlcm5hbEFycmF5O1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBcnJheSA9IG5ld0FycmF5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHVzaCBlbGVtZW50cyB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHB1c2hcbiAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50IHtUfVxuICAgICAgICAgICAgICogQHJldHVybnMgVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRQb2ludGVyID09PSB0aGlzLmludGVybmFsQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXlbdGhpcy5lbmRQb2ludGVyKytdID0gZWxlbWVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBvcFxuICAgICAgICAgICAgICogQHJldHVybnMgVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRQb2ludGVyID0gdGhpcy5lbmRQb2ludGVyIC0gMSA8IDAgPyAwIDogdGhpcy5lbmRQb2ludGVyIC0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5W3RoaXMuZW5kUG9pbnRlcl07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBjb3VudFxuICAgICAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZFBvaW50ZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbXB0aWVzIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kUG9pbnRlciA9IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBpbnRlcm5hbCBiYWNraW5nIGFycmF5XG4gICAgICAgICAgICAgKiBAbWV0aG9kIGludGVybmFsU2l6ZVxuICAgICAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmludGVybmFsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICAgICAgICAgKiBAbWV0aG9kIGVsZW1lbnRBdFxuICAgICAgICAgICAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IEluZGV4IG9mIGVsZW1lbnQgdG8gcmV0cmVpdmVcbiAgICAgICAgICAgICAqIEByZXR1cm5zIFRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWxlbWVudEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5zZXJ0cyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5zZXJ0XG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gSW5kZXggdG8gaW5zZXJ0IHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5jb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAgICAgICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBJbmRleCBvZiBlbGVtZW50IHRvIHJlbW92ZVxuICAgICAgICAgICAgICogQHJldHVybnMgVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gTyhuKSBTaGlmdCBcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuaW50ZXJuYWxBcnJheVtpbmRleF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQXJyYXlbaV0gPSB0aGlzLmludGVybmFsQXJyYXlbaSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVuZFBvaW50ZXItLTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBieSByZWZlcmVuY2VcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRWxlbWVudFxuICAgICAgICAgICAgICogQHBhcmFtIGVsZW1lbnQge1R9IEluZGV4IG9mIGVsZW1lbnQgdG8gcmV0cmVpdmVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbnRlcm5hbEFycmF5LmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIGFycmF5IHJlcHJlc2VudGluZyB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCB0b0FycmF5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5LnNsaWNlKDAsIHRoaXMuZW5kUG9pbnRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJdGVyYXRlIG92ZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBmb3JFYWNoXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnVuYyB7KFQsbnVtYmVyKT0+YW55fSBDYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQgcGFzc2luZyBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4LCByZXR1cm5lZCB2YWx1ZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgdGhpcy5pbnRlcm5hbEFycmF5W2ldLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNdXRhdGUgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBtYXBcbiAgICAgICAgICAgICAqIEBwYXJhbSBmdW5jIHsoVCxudW1iZXIpPT5hbnl9IENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggZWxlbWVudCBwYXNzaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgsIGFueSB2YWx1ZXMgcmV0dXJuZWQgbXV0YXRlIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQXJyYXlbaV0gPSBmdW5jLmNhbGwodGhpcywgdGhpcy5pbnRlcm5hbEFycmF5W2ldLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWZhdWx0IGNvbGxlY3Rpb24gc2l6ZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IERlZmF1bHRTaXplIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5EZWZhdWx0U2l6ZSA9IDIwMDtcbiAgICAgICAgICAgIHJldHVybiBDb2xsZWN0aW9uO1xuICAgICAgICB9KSgpO1xuICAgICAgICBVdGlsLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuICAgIH0pKFV0aWwgPSBleC5VdGlsIHx8IChleC5VdGlsID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQSBTcHJpdGUgaXMgb25lIG9mIHRoZSBtYWluIGRyYXdpbmcgcHJpbWl0aXZlcy4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmdcbiAgICAgKiBpbWFnZXMgb3IgcGFydHMgb2YgaW1hZ2VzIGtub3duIGFzIFRleHR1cmVzIHRvIHRoZSBzY3JlZW4uXG4gICAgICogQGNsYXNzIFNwcml0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBpbWFnZSB7VGV4dHVyZX0gVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlXG4gICAgICogQHBhcmFtIHN4IHtudW1iZXJ9IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzcHJpdGVcbiAgICAgKiBAcGFyYW0gc3kge251bWJlcn0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHNwcml0ZVxuICAgICAqIEBwYXJhbSBzd2lkdGgge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHNoZWlnaHQge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHZhciBTcHJpdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTcHJpdGUoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5zeCA9IHN4O1xuICAgICAgICAgICAgdGhpcy5zeSA9IHN5O1xuICAgICAgICAgICAgdGhpcy5zd2lkdGggPSBzd2lkdGg7XG4gICAgICAgICAgICB0aGlzLnNoZWlnaHQgPSBzaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSAxLjA7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IDEuMDtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwLjA7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVBvaW50ID0gbmV3IGV4LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBpeGVsRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBpeGVsc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eUVmZmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN4IDwgMCB8fCBzeSA8IDAgfHwgc3dpZHRoIDwgMCB8fCBzaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU3ByaXRlIGNhbm5vdCBoYXZlIGFueSBuZWdhdGl2ZSBkaW1lbnNpb25zIHg6XCIsIHN4LCBcInk6XCIsIHN5LCBcIndpZHRoOlwiLCBzd2lkdGgsIFwiaGVpZ2h0OlwiLCBzaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ2FudmFzLndpZHRoID0gc3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDYW52YXMuaGVpZ2h0ID0gc2hlaWdodDtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ3R4ID0gdGhpcy5zcHJpdGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5sb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3ByaXRlQ2FudmFzLndpZHRoID0gX3RoaXMuc3ByaXRlQ2FudmFzLndpZHRoIHx8IF90aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgICAgIF90aGlzLnNwcml0ZUNhbnZhcy5oZWlnaHQgPSBfdGhpcy5zcHJpdGVDYW52YXMuaGVpZ2h0IHx8IF90aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkUGl4ZWxzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlydHlFZmZlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHRleHR1cmUgXCIsIF90aGlzLnRleHR1cmUucGF0aCwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBzd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5sb2FkUGl4ZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyZS5pc0xvYWRlZCgpICYmICF0aGlzLnBpeGVsc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGFtcCA9IGV4LlV0aWwuY2xhbXA7XG4gICAgICAgICAgICAgICAgdmFyIG5hdHVyYWxXaWR0aCA9IHRoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsV2lkdGggfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IHRoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3dpZHRoID4gbmF0dXJhbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGUgc3ByaXRlIHdpZHRoXCIsIHRoaXMuc3dpZHRoLCBcImV4Y2VlZHMgdGhlIHdpZHRoXCIsIG5hdHVyYWxXaWR0aCwgXCJvZiB0aGUgYmFja2luZyB0ZXh0dXJlXCIsIHRoaXMudGV4dHVyZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hlaWdodCA+IG5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoZSBzcHJpdGUgaGVpZ2h0XCIsIHRoaXMuc2hlaWdodCwgXCJleGNlZWRzIHRoZSBoZWlnaHRcIiwgbmF0dXJhbEhlaWdodCwgXCJvZiB0aGUgYmFja2luZyB0ZXh0dXJlXCIsIHRoaXMudGV4dHVyZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZS5pbWFnZSwgY2xhbXAodGhpcy5zeCwgMCwgbmF0dXJhbFdpZHRoKSwgY2xhbXAodGhpcy5zeSwgMCwgbmF0dXJhbEhlaWdodCksIGNsYW1wKHRoaXMuc3dpZHRoLCAwLCBuYXR1cmFsV2lkdGgpLCBjbGFtcCh0aGlzLnNoZWlnaHQsIDAsIG5hdHVyYWxIZWlnaHQpLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAvL3RoaXMucGl4ZWxEYXRhID0gdGhpcy5zcHJpdGVDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxJbWFnZS5zcmMgPSB0aGlzLnNwcml0ZUNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbHNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG5ldyB7eyNjcm9zc0xpbmsgRWZmZWN0cy5JU3ByaXRlRWZmZWN0fX17ey9jcm9zc0xpbmt9fSB0byB0aGlzIGRyYXdpbmcuXG4gICAgICAgICAqIEBtZXRob2QgYWRkRWZmZWN0XG4gICAgICAgICAqIEBwYXJhbSBlZmZlY3Qge0VmZmVjdHMuSVNwcml0ZUVmZmVjdH0gRWZmZWN0IHRvIGFkZCB0byB0aGUgdGhpcyBkcmF3aW5nXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgICAgICAgICAvLyBXZSBtdXN0IGNoZWNrIGlmIHRoZSB0ZXh0dXJlIGFuZCB0aGUgYmFja2luZyBzcHJpdGUgcGl4ZWxzIGFyZSBsb2FkZWQgYXMgd2VsbCBiZWZvcmUgXG4gICAgICAgICAgICAvLyBhbiBlZmZlY3QgY2FuIGJlIGFwcGxpZWRcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMucGl4ZWxzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eUVmZmVjdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnJlbW92ZUVmZmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFyIGluZGV4VG9SZW1vdmUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gcGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gdGhpcy5lZmZlY3RzLmluZGV4T2YocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKTtcbiAgICAgICAgICAgIC8vIFdlIG11c3QgY2hlY2sgaWYgdGhlIHRleHR1cmUgYW5kIHRoZSBiYWNraW5nIHNwcml0ZSBwaXhlbHMgYXJlIGxvYWRlZCBhcyB3ZWxsIGJlZm9yZSBcbiAgICAgICAgICAgIC8vIGFuIGVmZmVjdCBjYW4gYmUgYXBwbGllZFxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUuaXNMb2FkZWQoKSB8fCAhdGhpcy5waXhlbHNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5RWZmZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuYXBwbHlFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGFtcCA9IGV4LlV0aWwuY2xhbXA7XG4gICAgICAgICAgICB2YXIgbmF0dXJhbFdpZHRoID0gdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAwO1xuICAgICAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodCB8fCAwO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZS5pbWFnZSwgY2xhbXAodGhpcy5zeCwgMCwgbmF0dXJhbFdpZHRoKSwgY2xhbXAodGhpcy5zeSwgMCwgbmF0dXJhbEhlaWdodCksIGNsYW1wKHRoaXMuc3dpZHRoLCAwLCBuYXR1cmFsV2lkdGgpLCBjbGFtcCh0aGlzLnNoZWlnaHQsIDAsIG5hdHVyYWxIZWlnaHQpLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxEYXRhID0gdGhpcy5zcHJpdGVDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLmZvckVhY2goZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgX3RoaXMuc2hlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgX3RoaXMuc3dpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdC51cGRhdGVQaXhlbCh4LCB5LCBfdGhpcy5waXhlbERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eC5wdXRJbWFnZURhdGEodGhpcy5waXhlbERhdGEsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEltYWdlLnNyYyA9IHRoaXMuc3ByaXRlQ2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgZWZmZWN0cyBmcm9tIHRoZSBkcmF3aW5nIGFuZCByZXR1cm4gaXQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyRWZmZWN0c1xuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5jbGVhckVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBwb2ludCBhYm91dCB3aGljaCB0byBhcHBseSB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGRyYXdpbmcgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgZHJhd2luZy5cbiAgICAgICAgICogQG1ldGhvZCB0cmFuc2Zvcm1BYm90UG9pbnRcbiAgICAgICAgICogQHBhcmFtIHBvaW50IHtQb2ludH0gVGhlIHBvaW50IGFib3V0IHdoaWNoIHRvIGFwcGx5IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS50cmFuc2Zvcm1BYm91dFBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIGZvciB0aGUgZHJhd2luZy5cbiAgICAgICAgICogQG1ldGhvZCBzZXRSb3RhdGlvblxuICAgICAgICAgKiBAcGFyYW0gcmFkaWFucyB7bnVtYmVyfSBUaGUgcm90YXRpb24gdG8gYXBwbHkgdG8gdGhlIGRyYXdpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnNldFJvdGF0aW9uID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSByYWRpYW5zO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCByb3RhdGlvbiBmb3IgdGhlIGRyYXdpbmcgaW4gcmFkaWFucy5cbiAgICAgICAgICogQG1ldGhvZCBnZXRSb3RhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHNjYWxlIHRyYXNmb3JtYXRpb24gaW4gdGhlIHggZGlyZWN0aW9uXG4gICAgICAgICAqIEBtZXRob2Qgc2V0U2NhbGVcbiAgICAgICAgICogQHBhcmFtIHNjYWxlIHtudW1iZXJ9IFRoZSBtYWduaXR1ZGUgdG8gc2NhbGUgdGhlIGRyYXdpbmcgaW4gdGhlIHggZGlyZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnNldFNjYWxlWCA9IGZ1bmN0aW9uIChzY2FsZVgpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc2NhbGUgdHJhc2Zvcm1hdGlvbiBpbiB0aGUgeCBkaXJlY3Rpb25cbiAgICAgICAgICogQG1ldGhvZCBzZXRTY2FsZVxuICAgICAgICAgKiBAcGFyYW0gc2NhbGUge251bWJlcn0gVGhlIG1hZ25pdHVkZSB0byBzY2FsZSB0aGUgZHJhd2luZyBpbiB0aGUgeCBkaXJlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuc2V0U2NhbGVZID0gZnVuY3Rpb24gKHNjYWxlWSkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1hZ25pdHVkZSBvZiB0aGUgZHJhd2luZydzIHNjYWxlIGluIHRoZSB4IGRpcmVjdGlvblxuICAgICAgICAgKiBAbWV0aG9kIGdldFNjYWxlXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5nZXRTY2FsZVggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1hZ25pdHVkZSBvZiB0aGUgZHJhd2luZydzIHNjYWxlIGluIHRoZSB5IGRpcmVjdGlvblxuICAgICAgICAgKiBAbWV0aG9kIGdldFNjYWxlXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5nZXRTY2FsZVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBkcmF3aW5nIChpZiBhbnkpXG4gICAgICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3cyB0aGUgc3ByaXRlIGFwcHJvcHJpYXRlbHkgdG8gdGhlIDJEIHJlbmRlcmluZyBjb250ZXh0LCBhdCBhbiB4IGFuZCB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSAyRCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBjb29yZGluYXRlIG9mIHdoZXJlIHRvIGRyYXdcbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgY29vcmRpbmF0ZSBvZiB3aGVyZSB0byBkcmF3XG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eUVmZmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eUVmZmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcEhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuc3dpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbEltYWdlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmludGVybmFsSW1hZ2UsIDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQsIC0odGhpcy50cmFuc2Zvcm1Qb2ludC54ICogdGhpcy5zd2lkdGgpICogdGhpcy5zY2FsZVgsIC0odGhpcy50cmFuc2Zvcm1Qb2ludC55ICogdGhpcy5zaGVpZ2h0KSAqIHRoaXMuc2NhbGVZLCB0aGlzLnN3aWR0aCAqIHRoaXMuc2NhbGVYLCB0aGlzLnNoZWlnaHQgKiB0aGlzLnNjYWxlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHNwcml0ZVxuICAgICAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICAgICAqIEByZXR1cm5zIFNwcml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3ByaXRlKHRoaXMudGV4dHVyZSwgdGhpcy5zeCwgdGhpcy5zeSwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICByZXN1bHQuc2NhbGVYID0gdGhpcy5zY2FsZVg7XG4gICAgICAgICAgICByZXN1bHQuc2NhbGVZID0gdGhpcy5zY2FsZVk7XG4gICAgICAgICAgICByZXN1bHQucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICAgICAgcmVzdWx0LmZsaXBIb3Jpem9udGFsID0gdGhpcy5mbGlwSG9yaXpvbnRhbDtcbiAgICAgICAgICAgIHJlc3VsdC5mbGlwVmVydGljYWwgPSB0aGlzLmZsaXBWZXJ0aWNhbDtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZEVmZmVjdChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNwcml0ZTtcbiAgICB9KSgpO1xuICAgIGV4LlNwcml0ZSA9IFNwcml0ZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU3ByaXRlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBTcHJpdGVTaGVldHMgYXJlIGEgdXNlZnVsIG1lY2hhbmlzbSBmb3Igc2xpY2luZyB1cCBpbWFnZSByZXNvdXJjZXMgaW50b1xuICAgICAqIHNlcGFyYXRlIHNwcml0ZXMgb3IgZm9yIGdlbmVyYXRpbmcgaW4gZ2FtZSBhbmltYXRpb25zLiBTcHJpdGVzIGFyZSBvcmdhbml6ZWRcbiAgICAgKiBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFNwcml0ZVNoZWV0LlxuICAgICAqIEBjbGFzcyBTcHJpdGVTaGVldFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBpbWFnZSB7VGV4dHVyZX0gVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlU2hlZXRcbiAgICAgKiBAcGFyYW0gY29sdW1ucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIGltYWdlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gcm93cyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGltYWdlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gc3BXaWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgZWFjaCBpbmRpdmlkdWFsIHNwcml0ZSBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gc3BIZWlnaHQge251bWJlcn0gVGhlIGhlaWdodCBvZiBlYWNoIGluZGl2aWR1YWwgc3ByaXRlIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHZhciBTcHJpdGVTaGVldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZVNoZWV0KGltYWdlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxJbWFnZSA9IGltYWdlLmltYWdlO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gbmV3IEFycmF5KGNvbHVtbnMgKiByb3dzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEluc3BlY3QgYWN0dWFsIGltYWdlIGRpbWVuc2lvbnMgd2l0aCBwcmVsb2FkaW5nXG4gICAgICAgICAgICAvKmlmKHNwV2lkdGggKiBjb2x1bW5zID4gdGhpcy5pbnRlcm5hbEltYWdlLm5hdHVyYWxXaWR0aCl7XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpdGVTaGVldCBzcGVjaWZpZWQgaXMgd2lkZXIgdGhhbiBpbWFnZSB3aWR0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgIFxuICAgICAgICAgICAgaWYoc3BIZWlnaHQgKiByb3dzID4gdGhpcy5pbnRlcm5hbEltYWdlLm5hdHVyYWxIZWlnaHQpe1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ByaXRlU2hlZXQgc3BlY2lmaWVkIGlzIGhpZ2hlciB0aGFuIGltYWdlIGhlaWdodFwiKTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ogKyBpICogY29sdW1uc10gPSBuZXcgZXguU3ByaXRlKHRoaXMuaW1hZ2UsIGogKiBzcFdpZHRoLCBpICogc3BIZWlnaHQsIHNwV2lkdGgsIHNwSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbiBhbmltYXRpb24gZnJvbSB0aGUgdGhpcyBTcHJpdGVTaGVldCBieSBsaXN0aW5nIG91dCB0aGVcbiAgICAgICAgICogc3ByaXRlIGluZGljZXMuIFNwcml0ZXMgYXJlIG9yZ2FuaXplZCBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFNwcml0ZVNoZWV0LlxuICAgICAgICAgKiBAbWV0aG9kIGdldEFuaW1hdGlvbkJ5SW5kaWNlc1xuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIEVuZ2luZVxuICAgICAgICAgKiBAcGFyYW0gaW5kaWNlcyB7bnVtYmVyW119IEFuIGFycmF5IG9mIHNwcml0ZSBpbmRpY2VzIHRvIHVzZSBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBBbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZVNoZWV0LnByb3RvdHlwZS5nZXRBbmltYXRpb25CeUluZGljZXMgPSBmdW5jdGlvbiAoZW5naW5lLCBpbmRpY2VzLCBzcGVlZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3ByaXRlc1tpbmRleF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LkFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiBmcm9tIHRoZSB0aGlzIFNwcml0ZVNoZWV0IGJ5IHNwZWNpZmluZyB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgICogaW1hZ2VzIHdpdGggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGluZGV4XG4gICAgICAgICAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uQmV0d2VlblxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIEVuZ2luZVxuICAgICAgICAgKiBAcGFyYW0gYmVnaW5JbmRleCB7bnVtYmVyfSBUaGUgaW5kZXggdG8gc3RhcnQgdGFraW5nIGZyYW1lc1xuICAgICAgICAgKiBAcGFyYW0gZW5kSW5kZXgge251bWJlcn0gVGhlIGluZGV4IHRvIHN0b3AgdGFraW5nIGZyYW1lc1xuICAgICAgICAgKiBAcGFyYW0gc3BlZWQge251bWJlcn0gVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogQHJldHVybnMgQW5pbWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGVTaGVldC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uQmV0d2VlbiA9IGZ1bmN0aW9uIChlbmdpbmUsIGJlZ2luSW5kZXgsIGVuZEluZGV4LCBzcGVlZCkge1xuICAgICAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMuc3ByaXRlcy5zbGljZShiZWdpbkluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgICAgICBpbWFnZXMgPSBpbWFnZXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5BbmltYXRpb24oZW5naW5lLCBpbWFnZXMsIHNwZWVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyZWF0IHRoZSBlbnRpcmUgU3ByaXRlU2hlZXQgYXMgb25lIGFuaW1hdGlvbiwgb3JnYW5pemluZyB0aGUgZnJhbWVzIGluXG4gICAgICAgICAqIHJvdyBtYWpvciBvcmRlci5cbiAgICAgICAgICogQG1ldGhvZCBnZXRBbmltYXRpb25Gb3JBbGxcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBFbmdpbmVcbiAgICAgICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIEFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlU2hlZXQucHJvdG90eXBlLmdldEFuaW1hdGlvbkZvckFsbCA9IGZ1bmN0aW9uIChlbmdpbmUsIHNwZWVkKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlcyA9IHRoaXMuc3ByaXRlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LkFuaW1hdGlvbihlbmdpbmUsIHNwcml0ZXMsIHNwZWVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJlaXZlIGEgc3BlY2lmaWMgc3ByaXRlIGZyb20gdGhlIFNwcml0ZVNoZWV0IGJ5IGl0cyBpbmRleC4gU3ByaXRlcyBhcmUgb3JnYW5pemVkXG4gICAgICAgICAqIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgU3ByaXRlU2hlZXQuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U3ByaXRlXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHNwcml0ZVxuICAgICAgICAgKiBAcmV0dXJucyBTcHJpdGVcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZVNoZWV0LnByb3RvdHlwZS5nZXRTcHJpdGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3ByaXRlU2hlZXQ7XG4gICAgfSkoKTtcbiAgICBleC5TcHJpdGVTaGVldCA9IFNwcml0ZVNoZWV0O1xuICAgIC8qKlxuICAgICAqIFNwcml0ZUZvbnRzIGFyZSBhIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHt7I2Nyb3NzTGluayBMYWJlbH19e3svY3Jvc3NMaW5rfX0gdG8gc3BlY2lmeVxuICAgICAqIGEgcGFydGljdWxhciBiaXRtYXAgYXMgYSBmb250LlxuICAgICAqIEBjbGFzcyBTcHJpdGVGb250XG4gICAgICogQGV4dGVuZHMgU3ByaXRlU2hlZXRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gaW1hZ2Uge1RleHR1cmV9IFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZUZvbnRcbiAgICAgKiBAcGFyYW0gYWxwaGFiZXQge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCB0aGUgY2hhcmF0ZXJzIGluIHRoZSBpbWFnZSwgaW4gcm93IG1ham9yIG9yZGVyLlxuICAgICAqIEBwYXJhbSBjYXNlSW5zZW5zaXR2ZSB7Ym9vbGVhbn0gSW5kaWNhdGUgd2hldGhlciB0aGlzIGZvbnQgdGFrZXMgY2FzZSBpbnRvIGFjY291bnRcbiAgICAgKiBAcGFyYW0gY29sdW1ucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgb2YgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0gcm93cyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3Mgb2YgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0gc3BXZGl0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgZWFjaCBjaGFyYWN0ZXIgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHNwSGVpZ2h0IHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgZWFjaCBjaGFyYWN0ZXIgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgdmFyIFNwcml0ZUZvbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU3ByaXRlRm9udCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlRm9udChpbWFnZSwgYWxwaGFiZXQsIGNhc2VJbnNlbnNpdGl2ZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGltYWdlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXQ7XG4gICAgICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IGNhc2VJbnNlbnNpdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlTG9va3VwID0ge307XG4gICAgICAgICAgICB0aGlzLmNvbG9yTG9va3VwID0ge307XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBleC5Db2xvci5CbGFjaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGRpY3Rpb25hcnkgdGhhdCBtYXBzIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBhbHBoYWJldCB0byB0aGUgYXBwcm9wcmlhdGUgU3ByaXRlLlxuICAgICAgICAgKiBAbWV0aG9kIGdldFRleHRTcHJpdGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGVGb250LnByb3RvdHlwZS5nZXRUZXh0U3ByaXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5hbHBoYWJldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9va3VwW2NoYXJdID0gdGhpcy5zcHJpdGVzW2ldLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3ByaXRlRm9udDtcbiAgICB9KShTcHJpdGVTaGVldCk7XG4gICAgZXguU3ByaXRlRm9udCA9IFNwcml0ZUZvbnQ7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVuZ2luZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU3ByaXRlU2hlZXQudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBUaWxlU3ByaXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGlsZVNwcml0ZShzcHJpdGVTaGVldEtleSwgc3ByaXRlSWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlU2hlZXRLZXkgPSBzcHJpdGVTaGVldEtleTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlSWQgPSBzcHJpdGVJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGlsZVNwcml0ZTtcbiAgICB9KSgpO1xuICAgIGV4LlRpbGVTcHJpdGUgPSBUaWxlU3ByaXRlO1xuICAgIC8qKlxuICAgICAqIEEgbGlnaHQtd2VpZ2h0IG9iamVjdCB0aGF0IG9jY3VwaWVzIGEgc3BhY2UgaW4gYSBjb2xsaXNpb24gbWFwLiBHZW5lcmFsbHlcbiAgICAgKiBjcmVhdGVkIGJ5IGEgQ29sbGlzaW9uTWFwLlxuICAgICAqIEBjbGFzcyBDZWxsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHgge251bWJlcn1cbiAgICAgKiBAcGFyYW0geSB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSBoZWlnaHQge251bWJlcn1cbiAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn1cbiAgICAgKiBAcGFyYW0gW3NvbGlkPWZhbHNlXSB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0gW3Nwcml0ZUlkPS0xXSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHZhciBDZWxsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2VsbChcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCBpbiB3b3JsZCBjb29yZGluYXRlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgeCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB5IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHksIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHdpZHRoIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgd2lkdGgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgd2lkdGgsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGhlaWdodCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGhlaWdodCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoZWlnaHQsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNlbGwgaW4gcm93IG1ham9yIG9yZGVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgaW5kZXgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5kZXgsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGlzIGNlbGwgaXMgc29saWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzb2xpZCB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc29saWQsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHNwcml0ZSB0byB1c2UgZnJvbSB0aGUgQ29sbGlzaW9uTWFwIFNwcml0ZVNoZWV0LCBpZiAtMSBpcyBzcGVjaWZpZWQgbm90aGluZyBpcyBkcmF3bi5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBudW1iZXIge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3ByaXRlcykge1xuICAgICAgICAgICAgaWYgKHNvbGlkID09PSB2b2lkIDApIHsgc29saWQgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHNwcml0ZXMgPT09IHZvaWQgMCkgeyBzcHJpdGVzID0gW107IH1cbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBzcHJpdGVzO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzID0gbmV3IGV4LkJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCB0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhpcyBjZWxsXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Qm91bmRzXG4gICAgICAgICAqIEByZXR1cm5zIEJvdW5kaW5nQm94XG4gICAgICAgICAqL1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xuICAgICAgICB9O1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlZlY3Rvcih0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUucHVzaFNwcml0ZSA9IGZ1bmN0aW9uICh0aWxlU3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMucHVzaCh0aWxlU3ByaXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUucmVtb3ZlU3ByaXRlID0gZnVuY3Rpb24gKHRpbGVTcHJpdGUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKChpbmRleCA9IHRoaXMuc3ByaXRlcy5pbmRleE9mKHRpbGVTcHJpdGUpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIENlbGwucHJvdG90eXBlLmNsZWFyU3ByaXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2VsbDtcbiAgICB9KSgpO1xuICAgIGV4LkNlbGwgPSBDZWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBDb2xsaXNpb25NYXAgb2JqZWN0IHByb3ZpZGVzIGEgbGlnaHR3ZWlnaHQgd2F5IHRvIGRvIGxhcmdlIGNvbXBsZXggc2NlbmVzIHdpdGggY29sbGlzaW9uXG4gICAgICogd2l0aG91dCB0aGUgb3ZlcmhlYWQgb2YgYWN0b3JzLlxuICAgICAqIEBjbGFzcyBDb2xsaXNpb25NYXBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBjb29yZGluYXRlIHRvIGFuY2hvciB0aGUgY29sbGlzaW9uIG1hcCdzIHVwcGVyIGxlZnQgY29ybmVyIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXG4gICAgICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgY29vcmRpbmF0ZSB0byBhbmNob3IgdGhlIGNvbGxpc2lvbiBtYXAncyB1cHBlciBsZWZ0IGNvcm5lciAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSBjZWxsV2lkdGgge251bWJlcn0gVGhlIGluZGl2aWR1YWwgd2lkdGggb2YgZWFjaCBjZWxsIChpbiBwaXhlbHMpIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXG4gICAgICogQHBhcmFtIGNlbGxIZWlnaHQge251bWJlcn0gVGhlIGluZGl2aWR1YWwgaGVpZ2h0IG9mIGVhY2ggY2VsbCAoaW4gcGl4ZWxzKSAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSByb3dzIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgY29sbGlzaW9uIG1hcCAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSBjb2xzIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29scyBpbiB0aGUgY29sbGlzaW9uIG1hcCAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSBzcHJpdGVTaGVldCB7U3ByaXRlU2hlZXR9IFRoZSBzcHJpdGVTaGVldCB0byB1c2UgZm9yIGRyYXdpbmdcbiAgICAgKi9cbiAgICB2YXIgVGlsZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRpbGVNYXAoeCwgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCByb3dzLCBjb2xzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICB0aGlzLmNlbGxXaWR0aCA9IGNlbGxXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2VsbEhlaWdodCA9IGNlbGxIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICAgICAgdGhpcy5jb2xzID0gY29scztcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGluZ1ggPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGluZ1kgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWEVuZCA9IDk5OTk7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllTdGFydCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllFbmQgPSA5OTk5O1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlU2hlZXRzID0ge307XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gbmV3IENlbGwoaSAqIGNlbGxXaWR0aCArIHgsIGogKiBjZWxsSGVpZ2h0ICsgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBpICsgaiAqIGNvbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGF0YVtpICsgaiAqIGNvbHNdID0gY2Q7XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLnJlZ2lzdGVyU3ByaXRlU2hlZXQgPSBmdW5jdGlvbiAoa2V5LCBzcHJpdGVTaGVldCkge1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlU2hlZXRzW2tleV0gPSBzcHJpdGVTaGVldDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGludGVzZWN0aW9uIHZlY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgY29sbGlzaW9ucyB3aXRoIGFjdG9ycy4gSWYgdGhlcmVcbiAgICAgICAgICogaXMgbm8gY29sbGlzaW9uIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn1cbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gYWN0b3IueCArIGFjdG9yLmdldFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYWN0b3IueSArIGFjdG9yLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIGFjdG9yQm91bmRzID0gYWN0b3IuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBhY3RvckJvdW5kcy5sZWZ0OyB4IDw9IHdpZHRoOyB4ICs9IE1hdGgubWluKGFjdG9yLmdldFdpZHRoKCkgLyAyLCB0aGlzLmNlbGxXaWR0aCAvIDIpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IGFjdG9yQm91bmRzLnRvcDsgeSA8PSBoZWlnaHQ7IHkgKz0gTWF0aC5taW4oYWN0b3IuZ2V0SGVpZ2h0KCkgLyAyLCB0aGlzLmNlbGxIZWlnaHQgLyAyKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbEJ5UG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwuc29saWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwID0gYWN0b3JCb3VuZHMuY29sbGlkZXMoY2VsbC5nZXRCb3VuZHMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gYWN0b3IuZ2V0Q2VudGVyKCkubWludXMoY2VsbC5nZXRDZW50ZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCAmJiBvdmVybGFwLmRvdChkaXIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2gob3ZlcmxhcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3ZlcmxhcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNtYWxsZXN0IGNoYW5nZSBvdGhlciB0aGFuIHplcm9cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBhY2N1bS54O1xuICAgICAgICAgICAgICAgIHZhciB5ID0gYWNjdW0ueTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYWNjdW0ueCkgPCBNYXRoLmFicyhuZXh0LngpKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXh0Lng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhY2N1bS55KSA8IE1hdGguYWJzKG5leHQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IG5leHQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5WZWN0b3IoeCwgeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgIHB1YmxpYyBjb2xsaWRlc0FjdG9yKGFjdG9yOiBBY3Rvcik6IGJvb2xlYW57XG4gICAgICAgICAgIFxuICAgICAgICAgICB2YXIgcG9pbnRzOiBQb2ludFtdID0gW107XG4gICAgICAgICAgIHZhciB3aWR0aCA9IGFjdG9yLnggKyBhY3Rvci5nZXRXaWR0aCgpO1xuICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYWN0b3IueSArIGFjdG9yLmdldEhlaWdodCgpO1xuICAgICAgICAgICBmb3IodmFyIHggPSBhY3Rvci54OyB4IDw9IHdpZHRoOyB4ICs9IE1hdGgubWluKGFjdG9yLmdldFdpZHRoKCkvMix0aGlzLmNlbGxXaWR0aC8yKSl7XG4gICAgICAgICAgICAgIGZvcih2YXIgeSA9IGFjdG9yLnk7IHkgPD0gaGVpZ2h0OyB5ICs9IE1hdGgubWluKGFjdG9yLmdldEhlaWdodCgpLzIsIHRoaXMuY2VsbEhlaWdodC8yKSl7XG4gICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBQb2ludCh4LHkpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgIHZhciByZXN1bHQgPSBwb2ludHMuc29tZSgocCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlc1BvaW50KHAueCwgcC55KTtcbiAgICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICBcbiAgICAgICAgfSovXG4gICAgICAgIC8qXG4gICAgICAgIHB1YmxpYyBjb2xsaWRlc1BvaW50KHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbntcbiAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHgvdGhpcy5jZWxsV2lkdGgpOy8vIC0gTWF0aC5mbG9vcih0aGlzLngvdGhpcy5jZWxsV2lkdGgpO1xuICAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IoeS90aGlzLmNlbGxIZWlnaHQpO1xuICBcbiAgXG4gICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsKHgsIHkpO1xuICAgICAgICAgICBpZih4ID49IDAgJiYgeSA+PSAwICYmIHggPCB0aGlzLmNvbHMgJiYgeSA8IHRoaXMucm93cyAmJiBjZWxsKXtcbiAgICAgICAgICAgICAgaWYoY2VsbC5zb2xpZCl7XG4gICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGluZ1ggPSB4O1xuICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRpbmdZID0geTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY2VsbC5zb2xpZDtcbiAgICAgICAgICAgfVxuICBcbiAgXG4gIFxuICAgICAgICAgICBcbiAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9Ki9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNlbGwgYnkgaW5kZXggKHJvdyBtYWpvciBvcmRlcilcbiAgICAgICAgICogQG1ldGhvZCBnZXRDZWxsQnlJbmRleFxuICAgICAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn1cbiAgICAgICAgICogQHJldHVybnMgQ2VsbFxuICAgICAgICAgKi9cbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUuZ2V0Q2VsbEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2VsbCBieSBpdCdzIHggYW5kIHkgY29vcmRpbmF0ZXNcbiAgICAgICAgICogQG1ldGhvZCBnZXRDZWxsXG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9XG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9XG4gICAgICAgICAqIEByZXR1cm5zIENlbGxcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmdldENlbGwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5jb2xzIHx8IHkgPj0gdGhpcy5yb3dzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3ggKyB5ICogdGhpcy5jb2xzXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNlbGwgYnkgdGVzdGluZyBhIHBvaW50IGluIGdsb2JhbCBjb29yZGluYXRlcyxcbiAgICAgICAgICogcmV0dXJucyBudWxsIGlmIG5vIGNlbGwgd2FzIGZvdW5kLlxuICAgICAgICAgKiBAbWV0aG9kIGdldENlbGxCeVBvaW50XG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9XG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9XG4gICAgICAgICAqIEByZXR1cm5zIENlbGxcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmdldENlbGxCeVBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcigoeCAtIHRoaXMueCkgLyB0aGlzLmNlbGxXaWR0aCk7IC8vIC0gTWF0aC5mbG9vcih0aGlzLngvdGhpcy5jZWxsV2lkdGgpO1xuICAgICAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKCh5IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCk7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCh4LCB5KTtcbiAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeSA+PSAwICYmIHggPCB0aGlzLmNvbHMgJiYgeSA8IHRoaXMucm93cyAmJiBjZWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciB3b3JsZENvb3Jkc1VwcGVyTGVmdCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KDAsIDApKTtcbiAgICAgICAgICAgIHZhciB3b3JsZENvb3Jkc0xvd2VyUmlnaHQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBleC5Qb2ludChlbmdpbmUud2lkdGgsIGVuZ2luZS5oZWlnaHQpKTtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcih3b3JsZENvb3Jkc1VwcGVyTGVmdC54IC8gdGhpcy5jZWxsV2lkdGgpIC0gMiwgMCk7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllTdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzVXBwZXJMZWZ0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSAtIDIsIDApO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5YRW5kID0gTWF0aC5tYXgoTWF0aC5mbG9vcih3b3JsZENvb3Jkc0xvd2VyUmlnaHQueCAvIHRoaXMuY2VsbFdpZHRoKSArIDIsIDApO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5ZRW5kID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNMb3dlclJpZ2h0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSArIDIsIDApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgdGhlIGNvbGxpc2lvbiBtYXAgdG8gdGhlIHNjcmVlbi4gQ2FsbGVkIGJ5IHRoZSBTY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSB0aGlzLl9vblNjcmVlblhTdGFydDsgeCA8IE1hdGgubWluKHRoaXMuX29uU2NyZWVuWEVuZCwgdGhpcy5jb2xzKTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IHRoaXMuX29uU2NyZWVuWVN0YXJ0OyB5IDwgTWF0aC5taW4odGhpcy5fb25TY3JlZW5ZRW5kLCB0aGlzLnJvd3MpOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDZWxsKHgsIHkpLnNwcml0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5zcHJpdGVJZCA+IC0xO1xuICAgICAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNzID0gX3RoaXMuX3Nwcml0ZVNoZWV0c1t0cy5zcHJpdGVTaGVldEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gc3MuZ2V0U3ByaXRlKHRzLnNwcml0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ByaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5kcmF3KGN0eCwgeCAqIF90aGlzLmNlbGxXaWR0aCwgeSAqIF90aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJTcHJpdGUgZG9lcyBub3QgZXhpc3QgZm9yIGlkXCIsIHRzLnNwcml0ZUlkLCBcImluIHNwcml0ZSBzaGVldFwiLCB0cy5zcHJpdGVTaGVldEtleSwgc3ByaXRlLCBzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJTcHJpdGUgc2hlZXRcIiwgdHMuc3ByaXRlU2hlZXRLZXksIFwiZG9lcyBub3QgZXhpc3RcIiwgc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgYWxsIHRoZSBjb2xsaXNpb24gbWFwJ3MgZGVidWcgaW5mby4gQ2FsbGVkIGJ5IHRoZSBTY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY29scyAqIHRoaXMuY2VsbFdpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMucm93cyAqIHRoaXMuY2VsbEhlaWdodDtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBleC5Db2xvci5SZWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5jb2xzICsgMTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy54ICsgeCAqIHRoaXMuY2VsbFdpZHRoLCB0aGlzLnkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy54ICsgeCAqIHRoaXMuY2VsbFdpZHRoLCB0aGlzLnkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5yb3dzICsgMTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy54LCB0aGlzLnkgKyB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMueCArIHdpZHRoLCB0aGlzLnkgKyB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc29saWQgPSBleC5Db2xvci5SZWQuY2xvbmUoKTtcbiAgICAgICAgICAgIHNvbGlkLmEgPSAuMztcbiAgICAgICAgICAgIHRoaXMuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbC5zb2xpZDtcbiAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc29saWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2VsbC54LCBjZWxsLnksIGNlbGwud2lkdGgsIGNlbGwuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxpZGluZ1kgPiAtMSAmJiB0aGlzLl9jb2xsaWRpbmdYID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZXguQ29sb3IuQ3lhbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB0aGlzLl9jb2xsaWRpbmdYICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSArIHRoaXMuX2NvbGxpZGluZ1kgKiB0aGlzLmNlbGxIZWlnaHQsIHRoaXMuY2VsbFdpZHRoLCB0aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRpbGVNYXA7XG4gICAgfSkoKTtcbiAgICBleC5UaWxlTWFwID0gVGlsZU1hcDtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQWxnZWJyYS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgKGZ1bmN0aW9uIChDb2xsaXNpb25TdHJhdGVneSkge1xuICAgICAgICBDb2xsaXNpb25TdHJhdGVneVtDb2xsaXNpb25TdHJhdGVneVtcIk5haXZlXCJdID0gMF0gPSBcIk5haXZlXCI7XG4gICAgICAgIENvbGxpc2lvblN0cmF0ZWd5W0NvbGxpc2lvblN0cmF0ZWd5W1wiRHluYW1pY0FBQkJUcmVlXCJdID0gMV0gPSBcIkR5bmFtaWNBQUJCVHJlZVwiO1xuICAgICAgICBDb2xsaXNpb25TdHJhdGVneVtDb2xsaXNpb25TdHJhdGVneVtcIlNlcGFyYXRpbmdBeGlzXCJdID0gMl0gPSBcIlNlcGFyYXRpbmdBeGlzXCI7XG4gICAgfSkoZXguQ29sbGlzaW9uU3RyYXRlZ3kgfHwgKGV4LkNvbGxpc2lvblN0cmF0ZWd5ID0ge30pKTtcbiAgICB2YXIgQ29sbGlzaW9uU3RyYXRlZ3kgPSBleC5Db2xsaXNpb25TdHJhdGVneTtcbiAgICAvKipcbiAgICAgKiBBeGlzIEFsaWduZWQgY29sbGlzaW9uIHByaW1pdGl2ZSBmb3IgRXhjYWxpYnVyLlxuICAgICAqIEBjbGFzcyBCb3VuZGluZ0JveFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBsZWZ0IHtudW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBlZGdlXG4gICAgICogQHBhcmFtIHRvcCB7bnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBlZGdlXG4gICAgICogQHBhcmFtIHJpZ2h0IHtudW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgZWRnZVxuICAgICAqIEBwYXJhbSBib3R0b20ge251bWJlcn0geSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gZWRnZVxuICAgICAqL1xuICAgIHZhciBCb3VuZGluZ0JveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJvdW5kaW5nQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09IHZvaWQgMCkgeyBsZWZ0ID0gMDsgfVxuICAgICAgICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7IHRvcCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gMDsgfVxuICAgICAgICAgICAgaWYgKGJvdHRvbSA9PT0gdm9pZCAwKSB7IGJvdHRvbSA9IDA7IH1cbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAgICAgICogQG1ldGhvZCBnZXRXaWR0aFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgICAgICAgKiBAbWV0aG9kIGdldEhlaWdodFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b20gLSB0aGlzLnRvcDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBlcmltZXRlciBvZiB0aGUgYm91bmRpbmcgYm94XG4gICAgICAgICAqIEBtZXRob2QgZ2V0UGVyaW1ldGVyXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFBlcmltZXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3eCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciB3eSA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICByZXR1cm4gMiAqICh3eCArIHd5KTtcbiAgICAgICAgfTtcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIGV4LlBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmxlZnQgPD0gdmFsLnggJiYgdGhpcy50b3AgPD0gdmFsLnkgJiYgdGhpcy5ib3R0b20gPj0gdmFsLnkgJiYgdGhpcy5yaWdodCA+PSB2YWwueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgPCB2YWwubGVmdCAmJiB0aGlzLnRvcCA8IHZhbC50b3AgJiYgdmFsLmJvdHRvbSA8IHRoaXMuYm90dG9tICYmIHZhbC5yaWdodCA8IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbWJpbmVzIHRoaXMgYm91bmRpbmcgYm94IGFuZCBhbm90aGVyIHRvZ2V0aGVyIHJldHVybmluZyBhIG5ldyBib3VuZGluZyBib3hcbiAgICAgICAgICogQG1ldGhvZCBjb21iaW5lXG4gICAgICAgICAqIEBwYXJhbSBvdGhlciB7Qm91bmRpbmdCb3h9IFRoZSBib3VuZGluZyBib3ggdG8gY29tYmluZVxuICAgICAgICAgKiBAcmV0dXJucyBCb3VuZGluZ0JveFxuICAgICAgICAgKi9cbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBjb21wb3NpdGVCQiA9IG5ldyBCb3VuZGluZ0JveChNYXRoLm1pbih0aGlzLmxlZnQsIG90aGVyLmxlZnQpLCBNYXRoLm1pbih0aGlzLnRvcCwgb3RoZXIudG9wKSwgTWF0aC5tYXgodGhpcy5yaWdodCwgb3RoZXIucmlnaHQpLCBNYXRoLm1heCh0aGlzLmJvdHRvbSwgb3RoZXIuYm90dG9tKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9zaXRlQkI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IHdldGhlciB0aGlzIGJvdW5kaW5nIGJveCBjb2xsaWRlcyB3aXRoIGFub3RoZXIgcmV0dXJuaW5nLFxuICAgICAgICAgKiB0aGUgaW50ZXJzZWN0aW9uIHZlY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc292bGUgdGhlIGNvbGxpc2lvbi4gSWYgdGhlcmVcbiAgICAgICAgICogaXMgbm8gY29sbGlzaW9uIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgICAgICogQHBhcmFtIGNvbGxpZGFibGUge0lDb2xsaWRhYmxlfSBPdGhlciBjb2xsaWRhYmxlIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoY29sbGlkYWJsZSkge1xuICAgICAgICAgICAgaWYgKGNvbGxpZGFibGUgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNvbGxpZGFibGU7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsQm91bmRpbmdCb3ggPSB0aGlzLmNvbWJpbmUob3RoZXIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0b3RhbCBib3VuZGluZyBib3ggaXMgbGVzcyB0aGFuIHRoZSBzdW0gb2YgdGhlIDIgYm91bmRzIHRoZW4gdGhlcmUgaXMgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsQm91bmRpbmdCb3guZ2V0V2lkdGgoKSA8IG90aGVyLmdldFdpZHRoKCkgKyB0aGlzLmdldFdpZHRoKCkgJiYgdG90YWxCb3VuZGluZ0JveC5nZXRIZWlnaHQoKSA8IG90aGVyLmdldEhlaWdodCgpICsgdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPj0gb3RoZXIubGVmdCAmJiB0aGlzLnJpZ2h0IDw9IG90aGVyLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLmxlZnQgLSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5yaWdodCAtIHRoaXMubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AgPD0gb3RoZXIuYm90dG9tICYmIHRoaXMudG9wID49IG90aGVyLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci5ib3R0b20gLSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gb3RoZXIudG9wIC0gdGhpcy5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG92ZXJsYXBYKSA8IE1hdGguYWJzKG92ZXJsYXBZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5WZWN0b3Iob3ZlcmxhcFgsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5WZWN0b3IoMCwgb3ZlcmxhcFkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94O1xuICAgIH0pKCk7XG4gICAgZXguQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcbiAgICB2YXIgU0FUQm91bmRpbmdCb3ggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTQVRCb3VuZGluZ0JveChwb2ludHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudG9WZWN0b3IoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFNpZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBleC5MaW5lKHRoaXMuX3BvaW50c1tpXSwgdGhpcy5fcG9pbnRzWyhpICsgMSkgJSBsZW5dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICAgIH07XG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGF4ZXMucHVzaCh0aGlzLl9wb2ludHNbaV0ubWludXModGhpcy5fcG9pbnRzWyhpICsgMSkgJSBsZW5dKS5ub3JtYWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXhlcztcbiAgICAgICAgfTtcbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIHNjYWxhcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHNjYWxhcnMucHVzaCh0aGlzLl9wb2ludHNbaV0uZG90KGF4aXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguUHJvamVjdGlvbihNYXRoLm1pbi5hcHBseShNYXRoLCBzY2FsYXJzKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgc2NhbGFycykpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCB3aWR0aCBvZiB0aGUgYm91bmRpbmcgYm94LCBieSBnZW5lcmF0aW5nIGFuIGF4aXMgYWxpZ25lZCBib3ggYXJvdW5kIHRoZSBjdXJyZW50XG4gICAgICAgICAqIEBtZXRob2QgZ2V0V2lkdGhcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBwLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oYWNjdW0sIHAueCk7XG4gICAgICAgICAgICB9LCBJbmZpbml0eSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgcCwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGFjY3VtLCBwLngpO1xuICAgICAgICAgICAgfSwgLUluZmluaXR5KTtcbiAgICAgICAgICAgIHJldHVybiByaWdodCAtIGxlZnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94LCBieSBnZW5lcmF0aW5nIGFuIGF4aXMgYWxpZ25lZCBib3ggYXJvdW5kIHRoZSBjdXJyZW50XG4gICAgICAgICAqIEBtZXRob2QgZ2V0SGVpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgcCwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGFjY3VtLCBwLnkpO1xuICAgICAgICAgICAgfSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBwLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoYWNjdW0sIHAueSk7XG4gICAgICAgICAgICB9LCAtSW5maW5pdHkpO1xuICAgICAgICAgICAgcmV0dXJuIHRvcCAtIGJvdHRvbTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3RzIHdldGhlciBhIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGJvdW5kaW5nIGJveCwgdXNpbmcgdGhlIFBJUCBhbGdvcml0aG1cbiAgICAgICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb2ludF9pbl9wb2x5Z29uXG4gICAgICAgICAqIEBtZXRob2QgY29udGFpbnNcbiAgICAgICAgICogQHBhcmFtIHAge1BvaW50fSBUaGUgcG9pbnQgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgLy8gQWx3YXlzIGNhc3QgdG8gdGhlIHJpZ2h0LCBhcyBsb25nIGFzIHdlIGNhc3QgaW4gYSBjb25zaXRlbnQgZml4ZWQgZGlyZWN0aW9uIHdlXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGZpbmVcbiAgICAgICAgICAgIHZhciB0ZXN0UmF5ID0gbmV3IGV4LlJheShwLCBuZXcgZXguVmVjdG9yKDEsIDApKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RDb3VudCA9IHRoaXMuZ2V0U2lkZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBzaWRlLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFJheS5pbnRlcnNlY3Qoc2lkZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RDb3VudCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGNvbGxpZGFibGUpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaWRhYmxlIGluc3RhbmNlb2YgU0FUQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjb2xsaWRhYmxlO1xuICAgICAgICAgICAgICAgIHZhciBheGVzID0gdGhpcy5nZXRBeGVzKCk7XG4gICAgICAgICAgICAgICAgYXhlcyA9IG90aGVyLmdldEF4ZXMoKS5jb25jYXQoYXhlcyk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbk92ZXJsYXAgPSA5OTk5OTtcbiAgICAgICAgICAgICAgICB2YXIgbWluQXhpcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9qMSA9IHRoaXMucHJvamVjdChheGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2oyID0gb3RoZXIucHJvamVjdChheGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBwcm9qMS5nZXRPdmVybGFwKHByb2oyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPD0gbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkF4aXMgPSBheGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtaW5BeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5BeGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1pbk92ZXJsYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3VwcGxpZWQgcG9pbnRzIGFuZCBjb250cnVjdCBhICdwb2x5Z29uJ1xuICAgICAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSB0aGlzLl9wb2ludHNbMF07XG4gICAgICAgICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZXguQ29sb3IuQmx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU0FUQm91bmRpbmdCb3g7XG4gICAgfSkoKTtcbiAgICBleC5TQVRCb3VuZGluZ0JveCA9IFNBVEJvdW5kaW5nQm94O1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudHMudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEV4Y2FsaWJ1ciBiYXNlIGNsYXNzXG4gICAgICogQGNsYXNzIENsYXNzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIENsYXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MoKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBleC5FdmVudERpc3BhdGNoZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxuICAgICAgICAgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuc3Vic2NyaWJlKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLiBJZiBvbmx5IHRoZSBldmVudE5hbWUgaXMgc3BlY2lmaWVkXG4gICAgICAgICAqIGl0IHdpbGwgcmVtb3ZlIGFsbCBoYW5kbGVycyByZWdpc3RlcmVkIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50LiBJZiB0aGUgZXZlbnROYW1lXG4gICAgICAgICAqIGFuZCB0aGUgaGFuZGxlciBpbnN0YW5jZSBhcmUgc3BlY2lmaWVkIGp1c3QgdGhhdCBoYW5kbGVyIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gW2hhbmRsZXI9dW5kZWZpbmVkXSB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIudW5zdWJzY3JpYmUoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBcImFkZEV2ZW50TGlzdGVuZXJcIi4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxuICAgICAgICAgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cbiAgICAgICAgICogQG1ldGhvZCBvblxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIge2V2ZW50PT52b2lkfSBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBDbGFzcy5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5zdWJzY3JpYmUoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIi4gSWYgb25seSB0aGUgZXZlbnROYW1lIGlzIHNwZWNpZmllZFxuICAgICAgICAgKiBpdCB3aWxsIHJlbW92ZSBhbGwgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgdGhhdCBzcGVjaWZpYyBldmVudC4gSWYgdGhlIGV2ZW50TmFtZVxuICAgICAgICAgKiBhbmQgdGhlIGhhbmRsZXIgaW5zdGFuY2UgYXJlIHNwZWNpZmllZCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gW2hhbmRsZXI9dW5kZWZpbmVkXSB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci51bnN1YnNjcmliZShldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogWW91IG1heSB3aXNoIHRvIGV4dGVuZCBuYXRpdmUgRXhjYWxpYnVyIGZ1bmN0aW9uYWxpdHkuIEFueSBtZXRob2Qgb25cbiAgICAgICAgICogYWN0b3IgbWF5IGJlIGV4dGVuZGVkIHRvIHN1cHBvcnQgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXkuIEluIHRoZVxuICAgICAgICAgKiBleGFtcGxlIGJlbG93IHdlIGNyZWF0ZSBhIG5ldyB0eXBlIGNhbGxlZCBcIk15QWN0b3JcIlxuICAgICAgICAgKiA8YnIvPjxiPkV4YW1wbGU8L2I+PHByZT52YXIgTXlBY3RvciA9IEFjdG9yLmV4dGVuZCh7XG4gICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5uZXdwcm9wID0gJ3NvbWV0aGluZyc7XG4gICAgICAgIEFjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgIH0sXG4gICAgIHVwZGF0ZSA6IGZ1bmN0aW9uKGVuZ2luZSwgZGVsdGEpe1xuICAgICAgICAvLyBJbXBsZW1lbnQgY3VzdG9tIHVwZGF0ZVxuICBcbiAgICAgICAgICAgLy8gQ2FsbCBzdXBlciBjb25zdHJ1Y3RvciB1cGRhdGVcbiAgICAgICAgICAgQWN0b3IucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNvbWV0aGluZyBjb29sIVwiKTtcbiAgICAgfVxuICB9KTtcbiAgdmFyIG15QWN0b3IgPSBuZXcgTXlBY3RvcigxMDAsIDEwMCwgMTAwLCAxMDAsIENvbG9yLkF6dXJlKTs8L3ByZT5cbiAgICAgICAgICogQG1ldGhvZCBleHRlbmRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gbWV0aG9kcyB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgbWV0aG9kcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbWV0aG9kcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzaW5nIGNvbnN0cnVjdG9yIGFsbG93cyBKUyB0byBsYXppbHkgaW5zdGFudGlhdGUgc3VwZXIgY2xhc3Nlc1xuICAgICAgICAgICAgdmFyIFN1cGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTdXBlci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cGVyO1xuICAgICAgICAgICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZVtwcm9wXSA9IG1ldGhvZHNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1YmNsYXNzZXMgZXh0ZW5kYWJsZVxuICAgICAgICAgICAgY2hpbGQuZXh0ZW5kID0gQ2xhc3MuZXh0ZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2xhc3M7XG4gICAgfSkoKTtcbiAgICBleC5DbGFzcyA9IENsYXNzO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgVGltZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEV4Y2FsaWJ1ciB0aW1lciBob29rcyBpbnRvIHRoZSBpbnRlcm5hbCB0aW1lciBhbmQgZmlyZXMgY2FsbGJhY2tzLCBhZnRlciBhIGNlcnRhaW4gaW50ZXJ2YWwsIG9wdGlvbmFsbHkgcmVwZWF0aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgVGltZXJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB7Y2FsbGJhY2t9IFRoZSBjYWxsYmFjayB0byBiZSBmaXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgaXMgY29tcGxldGUuXG4gICAgICAgICAqIEBwYXJhbSBbcmVwZWF0cz1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoaXMgY2FsbCBiYWNrIHNob3VsZCBiZSBmaXJlZCBvbmx5IG9uY2UsIG9yIHJlcGVhdCBhZnRlciBldmVyeSBpbnRlcnZhbCBhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBUaW1lcihmY24sIGludGVydmFsLCByZXBlYXRzKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuZmNuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWVBbGl2ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBUaW1lci5pZCsrO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsIHx8IHRoaXMuaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLmZjbiA9IGZjbiB8fCB0aGlzLmZjbjtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IHJlcGVhdHMgfHwgdGhpcy5yZXBlYXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB0aW1lciBhZnRlciBhIGNlcnRhaW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBlbmdpbmUuXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBOdW1iZXIgb2YgZWxhcHNlZCBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgVGltZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lQWxpdmUgKz0gZGVsdGE7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxhcHNlZFRpbWUgPiB0aGlzLmludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mY24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUaW1lci5wcm90b3R5cGUuZ2V0VGltZVJ1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxUaW1lQWxpdmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWxzIHRoZSB0aW1lciwgcHJldmVudGluZyBhbnkgZnVydGhlciBleGVjdXRpb25zLlxuICAgICAgICAgKiBAbWV0aG9kIGNhbmNlbFxuICAgICAgICAgKi9cbiAgICAgICAgVGltZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5jYW5jZWxUaW1lcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVGltZXIuaWQgPSAwO1xuICAgICAgICByZXR1cm4gVGltZXI7XG4gICAgfSkoKTtcbiAgICBleC5UaW1lciA9IFRpbWVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9BY3Rvci50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTaWRlLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIklDb2xsaXNpb25SZXNvbHZlci50c1wiLz4gXG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOYWl2ZUNvbGxpc2lvblJlc29sdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgLy8gcGFzc1xuICAgICAgICB9O1xuICAgICAgICBOYWl2ZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodGFydGV0KSB7XG4gICAgICAgICAgICAvLyBwYXNzXG4gICAgICAgIH07XG4gICAgICAgIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIHBvdGVudGlhbCBjb2xsaWRlcnMsIGV4Y2x1ZGUga2lsbGVkLCBwcmV2ZW50ZWQsIGFuZCBzZWxmXG4gICAgICAgICAgICB2YXIgcG90ZW50aWFsQ29sbGlkZXJzID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdGhlci5pc0tpbGxlZCgpICYmIG90aGVyLmNvbGxpc2lvblR5cGUgIT09IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGFjdG9yMTtcbiAgICAgICAgICAgIHZhciBhY3RvcjI7XG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gcG90ZW50aWFsQ29sbGlkZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgIGFjdG9yMSA9IHBvdGVudGlhbENvbGxpZGVyc1tqXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaiArIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyID0gcG90ZW50aWFsQ29sbGlkZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluaW11bVRyYW5zbGF0aW9uVmVjdG9yID0gYWN0b3IxLmNvbGxpZGVzKGFjdG9yMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gYWN0b3IxLmdldFNpZGVGcm9tSW50ZXJzZWN0KG1pbmltdW1UcmFuc2xhdGlvblZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpciA9IG5ldyBleC5Db2xsaXNpb25QYWlyKGFjdG9yMSwgYWN0b3IyLCBtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25QYWlycy5zb21lKGZ1bmN0aW9uIChjcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcC5lcXVhbHMoY29sbGlzaW9uUGFpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvblBhaXJzLnB1c2goY29sbGlzaW9uUGFpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsaXNpb25QYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmV2YWx1YXRlKCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvblBhaXJzO1xuICAgICAgICB9O1xuICAgICAgICBOYWl2ZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgICAgIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOYWl2ZUNvbGxpc2lvblJlc29sdmVyO1xuICAgIH0pKCk7XG4gICAgZXguTmFpdmVDb2xsaXNpb25SZXNvbHZlciA9IE5haXZlQ29sbGlzaW9uUmVzb2x2ZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkJvdW5kaW5nQm94LnRzXCIvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBUcmVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyZWVOb2RlKHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy5hY3RvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyBleC5Cb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmxlZnQgJiYgIXRoaXMucmlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJlZU5vZGU7XG4gICAgfSkoKTtcbiAgICBleC5UcmVlTm9kZSA9IFRyZWVOb2RlO1xuICAgIHZhciBEeW5hbWljVHJlZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIER5bmFtaWNUcmVlKCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBub2RlcyBpbiB0aGUgdHJlZSwgbWFrZSB0aGlzIHRoZSByb290IGxlYWZcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBsZWFmO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlYXJjaCB0aGUgdHJlZSBmb3IgYSBub2RlIHRoYXQgaXMgbm90IGEgbGVhZiBhbmQgZmluZCB0aGUgYmVzdCBwbGFjZSB0byBpbnNlcnRcbiAgICAgICAgICAgIHZhciBsZWFmQUFCQiA9IGxlYWYuYm91bmRzO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJyZW50Um9vdC5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gY3VycmVudFJvb3QubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBjdXJyZW50Um9vdC5yaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgYXJlYSA9IGN1cnJlbnRSb290LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRBQUJCID0gY3VycmVudFJvb3QuYm91bmRzLmNvbWJpbmUobGVhZkFBQkIpO1xuICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZEFyZWEgPSBjb21iaW5lZEFBQkIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNvc3QgaGV1cmlzdGljIGZvciBjcmVhdGluZyBhIG5ldyBwYXJlbnQgYW5kIGxlYWZcbiAgICAgICAgICAgICAgICB2YXIgY29zdCA9IDIgKiBjb21iaW5lZEFyZWE7XG4gICAgICAgICAgICAgICAgLy8gTWluaW11bSBjb3N0IG9mIHB1c2hpbmcgdGhlIGxlYWYgZG93biB0aGUgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBpbmhlcml0YW5jZUNvc3QgPSAyICogKGNvbWJpbmVkQXJlYSAtIGFyZWEpO1xuICAgICAgICAgICAgICAgIC8vIENvc3Qgb2YgZGVzY2VuZGluZ1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q29zdCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRDb21iaW5lZCA9IGxlYWZBQUJCLmNvbWJpbmUobGVmdC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdBcmVhO1xuICAgICAgICAgICAgICAgIHZhciBvbGRBcmVhO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDb3N0ID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJlYSA9IGxlZnQuYm91bmRzLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICBuZXdBcmVhID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q29zdCA9IChuZXdBcmVhIC0gb2xkQXJlYSkgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByaWdodENvc3QgPSAwO1xuICAgICAgICAgICAgICAgIHZhciByaWdodENvbWJpbmVkID0gbGVhZkFBQkIuY29tYmluZShyaWdodC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodENvc3QgPSByaWdodENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJlYSA9IHJpZ2h0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJlYSA9IHJpZ2h0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q29zdCA9IChuZXdBcmVhIC0gb2xkQXJlYSkgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvc3QgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgIGlmIChjb3N0IDwgbGVmdENvc3QgJiYgY29zdCA8IHJpZ2h0Q29zdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGVzY2VuZCB0byB0aGUgZGVwdGhzXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRDb3N0IDwgcmlnaHRDb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb290ID0gbGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb290ID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgcGFyZW50IG5vZGUgYW5kIGluc2VydCBpbnRvIHRoZSB0cmVlXG4gICAgICAgICAgICB2YXIgb2xkUGFyZW50ID0gY3VycmVudFJvb3QucGFyZW50O1xuICAgICAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ldyBUcmVlTm9kZShvbGRQYXJlbnQpO1xuICAgICAgICAgICAgbmV3UGFyZW50LmJvdW5kcyA9IGxlYWZBQUJCLmNvbWJpbmUoY3VycmVudFJvb3QuYm91bmRzKTtcbiAgICAgICAgICAgIG5ld1BhcmVudC5oZWlnaHQgPSBjdXJyZW50Um9vdC5oZWlnaHQgKyAxO1xuICAgICAgICAgICAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIG5vZGUgd2FzIG5vdCB0aGUgcm9vdFxuICAgICAgICAgICAgICAgIGlmIChvbGRQYXJlbnQubGVmdCA9PT0gY3VycmVudFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50LmxlZnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQucmlnaHQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um9vdC5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyBub2RlIHdhcyB0aGUgcm9vdFxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um9vdC5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FsayB1cCB0aGUgdHJlZSBmaXhpbmcgaGVpZ2h0cyBhbmQgQUFCQnNcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGxlYWYucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLmJhbGFuY2UoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgb2YgY3VycmVudCBsZWFmIGNhbm5vdCBoYXZlIGEgbnVsbCBsZWZ0IGNoaWxkXCIgKyBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IG9mIGN1cnJlbnQgbGVhZiBjYW5ub3QgaGF2ZSBhIG51bGwgcmlnaHQgY2hpbGRcIiArIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGN1cnJlbnROb2RlLmxlZnQuaGVpZ2h0LCBjdXJyZW50Tm9kZS5yaWdodC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcyA9IGN1cnJlbnROb2RlLmxlZnQuYm91bmRzLmNvbWJpbmUoY3VycmVudE5vZGUucmlnaHQuYm91bmRzKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgICAgICBpZiAobGVhZiA9PT0gdGhpcy5yb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbGVhZi5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgZ3JhbmRQYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgdmFyIHNpYmxpbmc7XG4gICAgICAgICAgICBpZiAocGFyZW50LmxlZnQgPT09IGxlYWYpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50LmxlZnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5sZWZ0ID0gc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LnJpZ2h0ID0gc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBncmFuZFBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBncmFuZFBhcmVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLmJhbGFuY2UoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMgPSBjdXJyZW50Tm9kZS5sZWZ0LmJvdW5kcy5jb21iaW5lKGN1cnJlbnROb2RlLnJpZ2h0LmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChjdXJyZW50Tm9kZS5sZWZ0LmhlaWdodCwgY3VycmVudE5vZGUucmlnaHQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gc2libGluZztcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5yZWdpc3RlckFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBUcmVlTm9kZSgpO1xuICAgICAgICAgICAgbm9kZS5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgbm9kZS5ib3VuZHMgPSBhY3Rvci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLmxlZnQgLT0gMjtcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLnRvcCAtPSAyO1xuICAgICAgICAgICAgbm9kZS5ib3VuZHMucmlnaHQgKz0gMjtcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLmJvdHRvbSArPSAyO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1thY3Rvci5pZF0gPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQobm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS51cGRhdGVBY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2FjdG9yLmlkXTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgYiA9IGFjdG9yLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgaWYgKG5vZGUuYm91bmRzLmNvbnRhaW5zKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICBiLmxlZnQgLT0gNTtcbiAgICAgICAgICAgIGIudG9wIC09IDU7XG4gICAgICAgICAgICBiLnJpZ2h0ICs9IDU7XG4gICAgICAgICAgICBiLmJvdHRvbSArPSA1O1xuICAgICAgICAgICAgdmFyIG11bHRkeCA9IGFjdG9yLmR4ICogMjtcbiAgICAgICAgICAgIHZhciBtdWx0ZHkgPSBhY3Rvci5keSAqIDI7XG4gICAgICAgICAgICBpZiAobXVsdGR4IDwgMCkge1xuICAgICAgICAgICAgICAgIGIubGVmdCArPSBtdWx0ZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiLnJpZ2h0ICs9IG11bHRkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdWx0ZHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgYi50b3AgKz0gbXVsdGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYi5ib3R0b20gKz0gbXVsdGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5ib3VuZHMgPSBiO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJlbW92ZUFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbYWN0b3IuaWRdO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1thY3Rvci5pZF0gPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbYWN0b3IuaWRdO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuYmFsYW5jZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBiYWxhbmNlIGF0IG51bGwgbm9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpIHx8IG5vZGUuaGVpZ2h0IDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGEgPSBub2RlO1xuICAgICAgICAgICAgdmFyIGIgPSBsZWZ0O1xuICAgICAgICAgICAgdmFyIGMgPSByaWdodDtcbiAgICAgICAgICAgIHZhciBkID0gbGVmdC5sZWZ0O1xuICAgICAgICAgICAgdmFyIGUgPSBsZWZ0LnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGYgPSByaWdodC5sZWZ0O1xuICAgICAgICAgICAgdmFyIGcgPSByaWdodC5yaWdodDtcbiAgICAgICAgICAgIHZhciBiYWxhbmNlID0gYy5oZWlnaHQgLSBiLmhlaWdodDtcbiAgICAgICAgICAgIC8vIFJvdGF0ZSBjIG5vZGUgdXBcbiAgICAgICAgICAgIGlmIChiYWxhbmNlID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFN3YXAgdGhlIHJpZ2h0IG5vZGUgd2l0aCBpdCdzIHBhcmVudFxuICAgICAgICAgICAgICAgIGMubGVmdCA9IGE7XG4gICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBhLnBhcmVudDtcbiAgICAgICAgICAgICAgICBhLnBhcmVudCA9IGM7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIG5vZGUncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byB0aGUgcmlnaHQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbWVnYSBjb25mdXNpbmdcbiAgICAgICAgICAgICAgICBpZiAoYy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMucGFyZW50LmxlZnQgPT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucGFyZW50LmxlZnQgPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQucmlnaHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSb3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoZi5oZWlnaHQgPiBnLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjLnJpZ2h0ID0gZjtcbiAgICAgICAgICAgICAgICAgICAgYS5yaWdodCA9IGc7XG4gICAgICAgICAgICAgICAgICAgIGcucGFyZW50ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBiLmJvdW5kcy5jb21iaW5lKGcuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYy5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGYuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYi5oZWlnaHQsIGcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYy5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGYuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSBnO1xuICAgICAgICAgICAgICAgICAgICBhLnJpZ2h0ID0gZjtcbiAgICAgICAgICAgICAgICAgICAgZi5wYXJlbnQgPSBhO1xuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGIuYm91bmRzLmNvbWJpbmUoZi5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBjLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZy5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChiLmhlaWdodCwgZi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJvdGF0ZSBsZWZ0IG5vZGUgdXBcbiAgICAgICAgICAgIGlmIChiYWxhbmNlIDwgLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwXG4gICAgICAgICAgICAgICAgYi5sZWZ0ID0gYTtcbiAgICAgICAgICAgICAgICBiLnBhcmVudCA9IGEucGFyZW50O1xuICAgICAgICAgICAgICAgIGEucGFyZW50ID0gYjtcbiAgICAgICAgICAgICAgICAvLyBub2RlJ3Mgb2xkIHBhcmVudCBzaG91bGQgcG9pbnQgdG8gYlxuICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQubGVmdCA9PT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5wYXJlbnQubGVmdCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQucmlnaHQgIT09IGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvciByb3RhdGluZyBEeW5hbWljIFRyZWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucGFyZW50LnJpZ2h0ID0gYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcm90YXRlXG4gICAgICAgICAgICAgICAgaWYgKGQuaGVpZ2h0ID4gZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5yaWdodCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGEubGVmdCA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGUucGFyZW50ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBjLmJvdW5kcy5jb21iaW5lKGUuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYi5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGQuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYy5oZWlnaHQsIGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIucmlnaHQgPSBlO1xuICAgICAgICAgICAgICAgICAgICBhLmxlZnQgPSBkO1xuICAgICAgICAgICAgICAgICAgICBkLnBhcmVudCA9IGE7XG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYy5ib3VuZHMuY29tYmluZShkLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGIuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShlLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGMuaGVpZ2h0LCBkLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGIuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LmhlaWdodDtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGFjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZS5ib3VuZHMuY29sbGlkZXMoYm91bmRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkgJiYgY3VycmVudE5vZGUuYWN0b3IgIT09IGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChhY3RvciwgY3VycmVudE5vZGUuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpIHx8IGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGVscGVyKHRoaXMucm9vdCk7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKHJheSwgbWF4KSB7XG4gICAgICAgICAgICAvLyB0b2RvIGltcGxlbWVudFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjdXJyZW50Tm9kZV0uY29uY2F0KGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIodGhpcy5yb290KTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBkcmF3IGFsbCB0aGUgbm9kZXMgaW4gdGhlIER5bmFtaWMgVHJlZVxuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcy5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIoY3VycmVudE5vZGUubGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRHluYW1pY1RyZWU7XG4gICAgfSkoKTtcbiAgICBleC5EeW5hbWljVHJlZSA9IER5bmFtaWNUcmVlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJQ29sbGlzaW9uUmVzb2x2ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRHluYW1pY1RyZWUudHNcIi8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyKCkge1xuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUgPSBuZXcgZXguRHluYW1pY1RyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnJlZ2lzdGVyQWN0b3IodGFyZ2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucmVtb3ZlQWN0b3IodGFyZ2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgcG90ZW50aWFsIGNvbGxpZGVycywgZXhjbHVkZSBraWxsZWQsIHByZXZlbnRlZCwgYW5kIHNlbGZcbiAgICAgICAgICAgIHZhciBwb3RlbnRpYWxDb2xsaWRlcnMgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW90aGVyLmlzS2lsbGVkKCkgJiYgb3RoZXIuY29sbGlzaW9uVHlwZSAhPT0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYWN0b3I7XG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gcG90ZW50aWFsQ29sbGlkZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgIGFjdG9yID0gcG90ZW50aWFsQ29sbGlkZXJzW2pdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnF1ZXJ5KGFjdG9yLCBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLmNvbGxpc2lvblR5cGUgPT09IDAgLyogUHJldmVudENvbGxpc2lvbiAqLyB8fCBvdGhlci5pc0tpbGxlZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluaW11bVRyYW5zbGF0aW9uVmVjdG9yID0gYWN0b3IuY29sbGlkZXMob3RoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IGFjdG9yLmdldFNpZGVGcm9tSW50ZXJzZWN0KG1pbmltdW1UcmFuc2xhdGlvblZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpciA9IG5ldyBleC5Db2xsaXNpb25QYWlyKGFjdG9yLCBvdGhlciwgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sbGlzaW9uUGFpcnMuc29tZShmdW5jdGlvbiAoY3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3AuZXF1YWxzKGNvbGxpc2lvblBhaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25QYWlycy5wdXNoKGNvbGxpc2lvblBhaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sbGlzaW9uUGFpcnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5ldmFsdWF0ZSgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb25QYWlycztcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZCA9IDA7XG4gICAgICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnVwZGF0ZUFjdG9yKGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUuZGVidWdEcmF3KGN0eCwgZGVsdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlcjtcbiAgICB9KSgpO1xuICAgIGV4LkR5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIgPSBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb24gcGFpcnMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSBFeGNhbGlidXIgdG8gcmVzb2x2ZSBjb2xsaXNpb24gYmV0d2VlbiBhY3RvcnMuIFRoZVxuICAgICAqIFBhaXIgcHJldmVudHMgY29sbGlzaW9ucyBmcm9tIGJlaW5nIGV2YWx1YXRlZCBtb3JlIHRoYW4gb25lIHRpbWVcbiAgICAgKiBAY2xhc3MgQ29sbGlzaW9uUGFpclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBsZWZ0IHtBY3Rvcn0gVGhlIGZpcnN0IGFjdG9yIGluIHRoZSBjb2xsaXNpb24gcGFpclxuICAgICAqIEBwYXJhbSByaWdodCB7QWN0b3J9IFRoZSBzZWNvbmQgYWN0b3IgaW4gdGhlIGNvbGxpc2lvbiBwYWlyXG4gICAgICogQHBhcmFtIGludGVyc2VjdCB7VmVjdG9yfSBUaGUgbWluaW11bSB0cmFuc2xhdGlvbiB2ZWN0b3IgdG8gc2VwYXJhdGUgdGhlIGFjdG9ycyBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiB0aGUgbGVmdCBhY3RvclxuICAgICAqIEBwYXJhbSBzaWRlIHtTaWRlfSBUaGUgc2lkZSBvbiB3aGljaCB0aGUgY29sbGlzaW9uIG9jY3VyZWQgZnJvbSB0aGUgcGVyc3BlY3RpdmUgb2YgdGhlIGxlZnQgYWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ29sbGlzaW9uUGFpciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvblBhaXIobGVmdCwgcmlnaHQsIGludGVyc2VjdCwgc2lkZSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0ID0gaW50ZXJzZWN0O1xuICAgICAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIGNvbGxpc2lvbiBwYWlyIGFuZCBhbm90aGVyIGFyZSBlcXVpdmFsZW50LlxuICAgICAgICAgKiBAbWV0aG9kIGVxdWFsc1xuICAgICAgICAgKiBAcGFyYW0gY29sbGlzaW9uUGFpciB7Q29sbGlzaW9uUGFpcn1cbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uUGFpci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGNvbGxpc2lvblBhaXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29sbGlzaW9uUGFpci5sZWZ0ID09PSB0aGlzLmxlZnQgJiYgY29sbGlzaW9uUGFpci5yaWdodCA9PT0gdGhpcy5yaWdodCkgfHwgKGNvbGxpc2lvblBhaXIucmlnaHQgPT09IHRoaXMubGVmdCAmJiBjb2xsaXNpb25QYWlyLmxlZnQgPT09IHRoaXMucmlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZhbHVhdGVzIHRoZSBjb2xsaXNpb24gcGFpciwgcGVyZm9ybWluZyBjb2xsaXNpb24gcmVzb2x1dGlvbiBhbmQgZXZlbnQgcHVibGlzaGluZyBhcHByb3ByaWF0ZSB0byBlYWNoIGNvbGxpc2lvbiB0eXBlLlxuICAgICAgICAgKiBAbWV0aG9kIGV2YWx1YXRlXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25QYWlyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gZmlyZSBjb2xsaXNpb24gZXZlbnRzIG9uIGxlZnQgYW5kIHJpZ2h0IGFjdG9yXG4gICAgICAgICAgICAvLyB0b2RvIHJlc29sdmUgY29sbGlzaW9ucyAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXG4gICAgICAgICAgICB0aGlzLmxlZnQuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2NvbGxpc2lvbicsIG5ldyBleC5Db2xsaXNpb25FdmVudCh0aGlzLmxlZnQsIHRoaXMucmlnaHQsIHRoaXMuc2lkZSwgdGhpcy5pbnRlcnNlY3QpKTtcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2NvbGxpc2lvbicsIG5ldyBleC5Db2xsaXNpb25FdmVudCh0aGlzLnJpZ2h0LCB0aGlzLmxlZnQsIGV4LlV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHRoaXMuc2lkZSksIHRoaXMuaW50ZXJzZWN0LnNjYWxlKC0xLjApKSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYWN0b3IgaXMgYWN0aXZlIHB1c2ggdGhlIGFjdG9yIG91dCBpZiBpdHMgbm90IHBhc3NpdmVcbiAgICAgICAgICAgIHZhciBsZWZ0U2lkZSA9IHRoaXMuc2lkZTtcbiAgICAgICAgICAgIGlmICgodGhpcy5sZWZ0LmNvbGxpc2lvblR5cGUgPT09IDIgLyogQWN0aXZlICovIHx8IHRoaXMubGVmdC5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8pICYmIHRoaXMucmlnaHQuY29sbGlzaW9uVHlwZSAhPT0gMSAvKiBQYXNzaXZlICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnkgKz0gdGhpcy5pbnRlcnNlY3QueTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQueCArPSB0aGlzLmludGVyc2VjdC54O1xuICAgICAgICAgICAgICAgIC8vIE5haXZlIGVsYXN0aWMgYm91bmNlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdC5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRTaWRlID09PSAzIC8qIExlZnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5keCA9IE1hdGguYWJzKHRoaXMubGVmdC5keCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdFNpZGUgPT09IDQgLyogUmlnaHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5keCA9IC1NYXRoLmFicyh0aGlzLmxlZnQuZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRTaWRlID09PSAxIC8qIFRvcCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmR5ID0gTWF0aC5hYnModGhpcy5sZWZ0LmR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsZWZ0U2lkZSA9PT0gMiAvKiBCb3R0b20gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5keSA9IC1NYXRoLmFicyh0aGlzLmxlZnQuZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJpZ2h0U2lkZSA9IGV4LlV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHRoaXMuc2lkZSk7XG4gICAgICAgICAgICB2YXIgcmlnaHRJbnRlcnNlY3QgPSB0aGlzLmludGVyc2VjdC5zY2FsZSgtMS4wKTtcbiAgICAgICAgICAgIGlmICgodGhpcy5yaWdodC5jb2xsaXNpb25UeXBlID09PSAyIC8qIEFjdGl2ZSAqLyB8fCB0aGlzLnJpZ2h0LmNvbGxpc2lvblR5cGUgPT09IDMgLyogRWxhc3RpYyAqLykgJiYgdGhpcy5sZWZ0LmNvbGxpc2lvblR5cGUgIT09IDEgLyogUGFzc2l2ZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQueSArPSByaWdodEludGVyc2VjdC55O1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQueCArPSByaWdodEludGVyc2VjdC54O1xuICAgICAgICAgICAgICAgIC8vIE5haXZlIGVsYXN0aWMgYm91bmNlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQuY29sbGlzaW9uVHlwZSA9PT0gMyAvKiBFbGFzdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT09IDMgLyogTGVmdCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5keCA9IE1hdGguYWJzKHRoaXMucmlnaHQuZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0U2lkZSA9PT0gNCAvKiBSaWdodCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5keCA9IC1NYXRoLmFicyh0aGlzLnJpZ2h0LmR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFNpZGUgPT09IDEgLyogVG9wICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmR5ID0gTWF0aC5hYnModGhpcy5yaWdodC5keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRTaWRlID09PSAyIC8qIEJvdHRvbSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5keSA9IC1NYXRoLmFicyh0aGlzLnJpZ2h0LmR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvblBhaXI7XG4gICAgfSkoKTtcbiAgICBleC5Db2xsaXNpb25QYWlyID0gQ29sbGlzaW9uUGFpcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRW5naW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAqIEEgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGNhbWVyYS4gVGhpcyBjbGFzcyBpcyBtZWFudCB0byBiZSBleHRlbmRlZC5cbiAgICAqIEBjbGFzcyBDYW1lcmFcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW5naW5lXG4gICAgKi9cbiAgICB2YXIgQmFzZUNhbWVyYSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJhc2VDYW1lcmEoKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzID0gbmV3IGV4LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgdGhpcy5sZXJwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxICogMTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgICAgICAgICB0aGlzLl90b3RhbExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbnVsbDtcbiAgICAgICAgICAgIC8vY2FtZXJhIGVmZmVjdHNcbiAgICAgICAgICAgIHRoaXMuaXNTaGFraW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWSA9IDA7XG4gICAgICAgICAgICB0aGlzLnNoYWtlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkU2hha2VUaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMuaXNab29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRab29tU2NhbGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5tYXhab29tU2NhbGUgPSAxO1xuICAgICAgICAgICAgdGhpcy56b29tRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkWm9vbVRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy56b29tSW5jcmVtZW50ID0gMC4wMTtcbiAgICAgICAgfVxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5lYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC09IDI7XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDIpICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogU2V0cyB0aGUge3sjY3Jvc3NMaW5rIEFjdG9yfX17ey9jcm9zc0xpbmt9fSB0byBmb2xsb3cgd2l0aCB0aGUgY2FtZXJhXG4gICAgICAgICogQG1ldGhvZCBzZXRBY3RvclRvRm9sbG93XG4gICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRvIGZvbGxvd1xuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5zZXRBY3RvclRvRm9sbG93ID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmZvbGxvdyA9IGFjdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBmb2NhbCBwb2ludCBvZiB0aGUgY2FtZXJhXG4gICAgICAgICogQG1ldGhvZCBnZXRGb2N1c1xuICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmdldEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFNldHMgdGhlIGZvY2FsIHBvaW50IG9mIHRoZSBjYW1lcmEuIFRoaXMgdmFsdWUgY2FuIG9ubHkgYmUgc2V0IGlmIHRoZXJlIGlzIG5vIGFjdG9yIHRvIGJlIGZvbGxvd2VkLlxuICAgICAgICAqIEBtZXRob2Qgc2V0Rm9jdXNcbiAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBmb2NhbCBwb2ludFxuICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGZvY2FsIHBvaW50XG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnNldEZvY3VzID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb2xsb3cgJiYgIXRoaXMubGVycCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxlcnApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSB0aGlzLmZvY3VzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBleC5Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFNldHMgdGhlIGNhbWVyYSB0byBzaGFrZSBhdCB0aGUgc3BlY2lmaWVkIG1hZ25pdHVkZXMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb25cbiAgICAgICAgKiBAbWV0aG9kIHNoYWtlXG4gICAgICAgICogQHBhcmFtIG1hZ25pdHVkZVgge251bWJlcn0gdGhlIHggbWFnbml0dWRlIG9mIHRoZSBzaGFrZVxuICAgICAgICAqIEBwYXJhbSBtYWduaXR1ZGVZIHtudW1iZXJ9IHRoZSB5IG1hZ25pdHVkZSBvZiB0aGUgc2hha2VcbiAgICAgICAgKiBAcGFyYW0gZHVyYXRpb24ge251bWJlcn0gdGhlIGR1cmF0aW9uIG9mIHRoZSBzaGFrZVxuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5zaGFrZSA9IGZ1bmN0aW9uIChtYWduaXR1ZGVYLCBtYWduaXR1ZGVZLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5pc1NoYWtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaGFrZU1hZ25pdHVkZVggPSBtYWduaXR1ZGVYO1xuICAgICAgICAgICAgdGhpcy5zaGFrZU1hZ25pdHVkZVkgPSBtYWduaXR1ZGVZO1xuICAgICAgICAgICAgdGhpcy5zaGFrZUR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFpvb21zIHRoZSBjYW1lcmEgaW4gb3Igb3V0IGJ5IHRoZSBzcGVjaWZpZWQgc2NhbGUgb3ZlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICAgICAgICAqIElmIG5vIGR1cmF0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCB6b29tIGJ5IGEgc2V0IGFtb3VudCB1bnRpbCB0aGUgc2NhbGUgaXMgcmVhY2hlZC5cbiAgICAgICAgKiBAbWV0aG9kIHpvb21cbiAgICAgICAgKiBAcGFyYW0gc2NhbGUge251bWJlcn0gdGhlIHNjYWxlIG9mIHRoZSB6b29tXG4gICAgICAgICogQHBhcmFtIFtkdXJhdGlvbl0ge251bWJlcn0gdGhlIGR1cmF0aW9uIG9mIHRoZSB6b29tXG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbiAoc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heFpvb21TY2FsZSA9IHNjYWxlO1xuICAgICAgICAgICAgdGhpcy56b29tRHVyYXRpb24gPSBkdXJhdGlvbiB8IDA7XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21JbmNyZW1lbnQgPSBNYXRoLmFicyh0aGlzLm1heFpvb21TY2FsZSAtIHRoaXMuY3VycmVudFpvb21TY2FsZSkgLyBkdXJhdGlvbiAqIDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhab29tU2NhbGUgPCAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbUluY3JlbWVudCA9IC0xICogdGhpcy56b29tSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50Wm9vbVNjYWxlKHRoaXMubWF4Wm9vbVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNab29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFpvb21TY2FsZSh0aGlzLm1heFpvb21TY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ6b29tIGluY3JlbWVudDogXCIgKyB0aGlzLnpvb21JbmNyZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBnZXRzIHRoZSBjdXJyZW50IHpvb20gc2NhbGVcbiAgICAgICAgKiBAbWV0aG9kIGdldFpvb21cbiAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY3VycmVudCB6b29tIHNjYWxlXG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Wm9vbVNjYWxlO1xuICAgICAgICB9O1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5zZXRDdXJyZW50Wm9vbVNjYWxlID0gZnVuY3Rpb24gKHpvb21TY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Wm9vbVNjYWxlID0gem9vbVNjYWxlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBBcHBsaWVzIHRoZSByZWxldmFudCB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGdhbWUgY2FudmFzIHRvIFwibW92ZVwiIG9yIGFwcGx5IGVmZmVjdHMgdG8gdGhlIENhbWVyYVxuICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5nZXRGb2N1cygpO1xuICAgICAgICAgICAgdmFyIHhTaGFrZSA9IDA7XG4gICAgICAgICAgICB2YXIgeVNoYWtlID0gMDtcbiAgICAgICAgICAgIHZhciBjYW52YXNXaWR0aCA9IGN0eC5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbmV3Q2FudmFzV2lkdGggPSBjYW52YXNXaWR0aCAqIHRoaXMuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgdmFyIG5ld0NhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodCAqIHRoaXMuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVycCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24gJiYgdGhpcy5fY2FtZXJhTW92aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnggPCB0aGlzLl9sZXJwU3RhcnQueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cy54ID0gdGhpcy5fbGVycFN0YXJ0LnggLSAodGhpcy5lYXNlSW5PdXRDdWJpYyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLngpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cy54ID0gdGhpcy5lYXNlSW5PdXRDdWJpYyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueSA8IHRoaXMuX2xlcnBTdGFydC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLnkgPSB0aGlzLl9sZXJwU3RhcnQueSAtICh0aGlzLmVhc2VJbk91dEN1YmljKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLnkgPSB0aGlzLmVhc2VJbk91dEN1YmljKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycER1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb25lU2hha2luZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NoYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRTaGFrZVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hha2VNYWduaXR1ZGVYID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFrZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFNoYWtlVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB4U2hha2UgPSAoTWF0aC5yYW5kb20oKSAqIHRoaXMuc2hha2VNYWduaXR1ZGVYIHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIHlTaGFrZSA9IChNYXRoLnJhbmRvbSgpICogdGhpcy5zaGFrZU1hZ25pdHVkZVkgfCAwKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1mb2N1cy54ICsgeFNoYWtlICsgKG5ld0NhbnZhc1dpZHRoIC8gMiksIC1mb2N1cy55ICsgeVNoYWtlICsgKG5ld0NhbnZhc0hlaWdodCAvIDIpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRG9uZVpvb21pbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNab29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkWm9vbVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRab29tU2NhbGUodGhpcy5tYXhab29tU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkWm9vbVRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50Wm9vbVNjYWxlKHRoaXMuZ2V0Wm9vbSgpICsgdGhpcy56b29tSW5jcmVtZW50ICogZGVsdGEgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLmdldFpvb20oKSwgdGhpcy5nZXRab29tKCkpO1xuICAgICAgICB9O1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmdldEZvY3VzKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKGZvY3VzLngsIGZvY3VzLnksIDE1LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9O1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5pc0RvbmVTaGFraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEodGhpcy5pc1NoYWtpbmcpIHx8ICh0aGlzLmVsYXBzZWRTaGFrZVRpbWUgPj0gdGhpcy5zaGFrZUR1cmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuaXNEb25lWm9vbWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnpvb21EdXJhdGlvbiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmVsYXBzZWRab29tVGltZSA+PSB0aGlzLnpvb21EdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhab29tU2NhbGUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jdXJyZW50Wm9vbVNjYWxlIDw9IHRoaXMubWF4Wm9vbVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jdXJyZW50Wm9vbVNjYWxlID49IHRoaXMubWF4Wm9vbVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCYXNlQ2FtZXJhO1xuICAgIH0pKCk7XG4gICAgZXguQmFzZUNhbWVyYSA9IEJhc2VDYW1lcmE7XG4gICAgLyoqXG4gICAgKiBBbiBleHRlbnNpb24gb2YgQmFzZUNhbWVyYSB0aGF0IGlzIGxvY2tlZCB2ZXJ0aWNhbGx5OyBpdCB3aWxsIG9ubHkgbW92ZSBzaWRlIHRvIHNpZGUuXG4gICAgKiBAY2xhc3MgU2lkZUNhbWVyYVxuICAgICogQGV4dGVuZHMgQmFzZUNhbWVyYVxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBlbmdpbmVcbiAgICAqL1xuICAgIHZhciBTaWRlQ2FtZXJhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFNpZGVDYW1lcmEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNpZGVDYW1lcmEoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTaWRlQ2FtZXJhLnByb3RvdHlwZS5nZXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbGxvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQodGhpcy5mb2xsb3cueCArIHRoaXMuZm9sbG93LmdldFdpZHRoKCkgLyAyLCB0aGlzLmZvY3VzLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTaWRlQ2FtZXJhO1xuICAgIH0pKEJhc2VDYW1lcmEpO1xuICAgIGV4LlNpZGVDYW1lcmEgPSBTaWRlQ2FtZXJhO1xuICAgIC8qKlxuICAgICogQW4gZXh0ZW5zaW9uIG9mIEJhc2VDYW1lcmEgdGhhdCBpcyBsb2NrZWQgdG8gYW4gYWN0b3Igb3IgZm9jYWwgcG9pbnQ7IHRoZSBhY3RvciB3aWxsIGFwcGVhciBpbiB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4uXG4gICAgKiBAY2xhc3MgVG9wQ2FtZXJhXG4gICAgKiBAZXh0ZW5kcyBCYXNlQ2FtZXJhXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVuZ2luZVxuICAgICovXG4gICAgdmFyIFRvcENhbWVyYSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUb3BDYW1lcmEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFRvcENhbWVyYSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFRvcENhbWVyYS5wcm90b3R5cGUuZ2V0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2xsb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KHRoaXMuZm9sbG93LnggKyB0aGlzLmZvbGxvdy5nZXRXaWR0aCgpIC8gMiwgdGhpcy5mb2xsb3cueSArIHRoaXMuZm9sbG93LmdldEhlaWdodCgpIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRvcENhbWVyYTtcbiAgICB9KShCYXNlQ2FtZXJhKTtcbiAgICBleC5Ub3BDYW1lcmEgPSBUb3BDYW1lcmE7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNsYXNzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUaW1lci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uL05haXZlQ29sbGlzaW9uUmVzb2x2ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uL0R5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uUGFpci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ2FtZXJhLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBY3RvcnMgYXJlIGNvbXBvc2VkIHRvZ2V0aGVyIGludG8gZ3JvdXBpbmdzIGNhbGxlZCBTY2VuZXMgaW5cbiAgICAgKiBFeGNhbGlidXIuIFRoZSBtZXRhcGhvciBtb2RlbHMgdGhlIHNhbWUgaWRlYSBiZWhpbmQgcmVhbCB3b3JsZFxuICAgICAqIGFjdG9ycyBpbiBhIHNjZW5lLiBPbmx5IGFjdG9ycyBpbiBzY2VuZXMgd2lsbCBiZSB1cGRhdGVkIGFuZCBkcmF3bi5cbiAgICAgKiBAY2xhc3MgU2NlbmVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgU2NlbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU2NlbmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNjZW5lKGVuZ2luZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBhY3RvcnMgaW4gdGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBjaGlsZHJlbiB7QWN0b3JbXX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy50aWxlTWFwcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy51aUFjdG9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIgPSBuZXcgZXguRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlcigpO1xuICAgICAgICAgICAgdGhpcy5fa2lsbFF1ZXVlID0gW107XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlID0gW107XG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBleC5CYXNlQ2FtZXJhKCk7XG4gICAgICAgICAgICBpZiAoZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0Rm9jdXMoZW5naW5lLndpZHRoIC8gMiwgZW5naW5lLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBtYWRlIGFjdGl2ZSBhbmQgc3RhcnRlZC4gSXQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuLFxuICAgICAgICAgKiB0aGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgc2V0dXAgYW55IERPTSBVSSBvciBldmVudCBoYW5kbGVycyBuZWVkZWQgZm9yIHRoZSBzY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBvbkFjdGl2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2NlbmUgaXMgbWFkZSB0cmFuc2l0aW9uZWQgYXdheSBmcm9tIGFuZCBzdG9wcGVkLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4sXG4gICAgICAgICAqIHRoaXMgaXMgd2hlcmUgeW91IHNob3VsZCBjbGVhbnVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXG4gICAgICAgICAqIEBtZXRob2Qgb25EZWFjdGl2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXG4gICAgICAgICAqIG92ZXJyaWRkZW4uIFRoaXMgaXMgd2hlcmUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGQgYWN0b3JzIHNob3VsZCB0YWtlIHBsYWNlLlxuICAgICAgICAgKiBAbWV0aG9kIG9uSW5pdGlhbGl6ZVxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIGFsbCBhY3RvcnMgaW4gdGhlIHNjZW5lXG4gICAgICAgICAqIEBtZXRob2QgcHVibGlzaFxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBwdWJsaXNoXG4gICAgICAgICAqIEBwYXJhbSBldmVudCB7R2FtZUV2ZW50fSBUaGUgZXZlbnQgb2JqZWN0IHRvIHNlbmRcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBhY3Rvci50cmlnZ2VyRXZlbnQoZXZlbnRUeXBlLCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIHRoZSBhY3RvcnMgYW5kIHRpbWVycyBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgRW5naW5lLlxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBFbmdpbmVcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZShlbmdpbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2luaXRpYWxpemUnLCBuZXcgZXguSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh1aSkge1xuICAgICAgICAgICAgICAgIHVpLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5mb3JFYWNoKGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgIGNtLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWd5XG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25SZXNvbHZlci51cGRhdGUodGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIuZXZhbHVhdGUodGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWN0b3JzIGZyb20gc2NlbmUgZ3JhcGggYWZ0ZXIgYmVpbmcga2lsbGVkXG4gICAgICAgICAgICB2YXIgYWN0b3JJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fa2lsbFF1ZXVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWN0b3JJbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZih0aGlzLl9raWxsUXVldWVbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChhY3RvckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoYWN0b3JJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fa2lsbFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGltZXJzIGluIHRoZSBjYW5jZWwgcXVldWUgYmVmb3JlIHVwZGF0aW5nIHRoZW1cbiAgICAgICAgICAgIHZhciB0aW1lckluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9jYW5jZWxRdWV1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIodGhpcy5fY2FuY2VsUXVldWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggdGltZXJzIHVwZGF0aW5nIHRpbWVyc1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fdGltZXJzID0gdGhpcy5fdGltZXJzLmZpbHRlcihmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aW1lci51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGltZXIuY29tcGxldGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgYWN0b3JzIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBFbmdpbmUuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBkcmF3XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlKGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5mb3JFYWNoKGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgIGNtLmRyYXcoY3R4LCBkZWx0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHZhciBlbmQgPSAwO1xuICAgICAgICAgICAgdmFyIGFjdG9yO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY3RvciA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgLy8gb25seSBkcmF3IGFjdG9ycyB0aGF0IGFyZSB2aXNpYmxlXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kcmF3KGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZSAmJiB0aGlzLmVuZ2luZS5pc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3llbGxvdyc7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB0aGlzLnVpQWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHVpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVpLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkuZHJhdyhjdHgsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZSAmJiB0aGlzLmVuZ2luZS5pc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh1aSkge1xuICAgICAgICAgICAgICAgICAgICB1aS5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgYWN0b3JzJyBkZWJ1ZyBpbmZvcm1hdGlvbiBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgRW5naW5lLlxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZU1hcHMuZm9yRWFjaChmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYWN0b3IuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRvZG8gcG9zc2libHkgZW5hYmxlIHRoaXMgd2l0aCBleGNhbGlidXIgZmxhZ3MgZmVhdHVyZXM/XG4gICAgICAgICAgICAvL3RoaXMuX2NvbGxpc2lvblJlc29sdmVyLmRlYnVnRHJhdyhjdHgsIDIwKTtcbiAgICAgICAgICAgIC8vdGhpcy5jYW1lcmEuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgIH07XG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVUlBY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVUlBY3RvcihlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5BY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGltZXIoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaWxlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaWxlTWFwKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVUlBY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVUlBY3RvcihlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5BY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblJlc29sdmVyLnJlbW92ZShlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaWxlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlTWFwKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIGFjdCBhcyBhIHBpZWNlIG9mIFVJLCBtZWFuaW5nIGl0IGlzIGFsd2F5cyBwb3NpdGlvbmVkXG4gICAgICAgICAqIGluIHNjcmVlbiBjb29yZGluYXRlcy4gVUkgYWN0b3JzIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zXG4gICAgICAgICAqIEBtZXRob2QgYWRkVUlBY3RvclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZFVJQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudWlBY3RvcnMucHVzaChhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGFzIGEgcGllYyBvZiBVSVxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVVJQWN0b3JcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVVSUFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnVpQWN0b3JzLmluZGV4T2YoYWN0b3IpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIHRoZSBTY2VuZSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIGFjdG9yIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgYWRkQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIucmVnaXN0ZXIoYWN0b3IpO1xuICAgICAgICAgICAgYWN0b3Iuc2NlbmUgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFjdG9yKTtcbiAgICAgICAgICAgIGFjdG9yLnBhcmVudCA9IHRoaXMuYWN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgVGlsZU1hcCB0byB0aGUgU2NlbmUsIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBUaWxlTWFwIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgYWRkVGlsZU1hcFxuICAgICAgICAgKiBAcGFyYW0gdGlsZU1hcCB7VGlsZU1hcH1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcbiAgICAgICAgICAgIHRoaXMudGlsZU1hcHMucHVzaCh0aWxlTWFwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBUaWxlTWFwIGZyb20gdGhlIFNjZW5lLCBpdCB3aWxsbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlVGlsZU1hcFxuICAgICAgICAgKiBAcGFyYW0gdGlsZU1hcCB7VGlsZU1hcH1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMudGlsZU1hcHMuaW5kZXhPZih0aWxlTWFwKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBmcm9tIHRoZSBTY2VuZSwgaXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gcmVtb3ZlXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblJlc29sdmVyLnJlbW92ZShhY3Rvcik7XG4gICAgICAgICAgICB0aGlzLl9raWxsUXVldWUucHVzaChhY3Rvcik7XG4gICAgICAgICAgICBhY3Rvci5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIHRpbWVyIHRvIHRoZSBTY2VuZVxuICAgICAgICAgKiBAbWV0aG9kIGFkZFRpbWVyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byBhZGRcbiAgICAgICAgICogQHJldHVybnMgVGltZXJcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgdGhpcy5fdGltZXJzLnB1c2godGltZXIpO1xuICAgICAgICAgICAgdGltZXIuc2NlbmUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIHRpbWVyIHRvIHRoZSBTY2VuZSwgY2FuIGJlIGRhbmdlcm91c1xuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVRpbWVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byByZW1vdmVcbiAgICAgICAgICogQHJldHVybnMgVGltZXJcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl90aW1lcnMuaW5kZXhPZih0aW1lcik7XG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuY2VscyBhIHRpbWVyLCByZW1vdmluZyBpdCBmcm9tIHRoZSBzY2VuZSBuaWNlbHlcbiAgICAgICAgICogQG1ldGhvZCBjYW5jZWxUaW1lclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIge1RpbWVyfSBUaGUgdGltZXIgdG8gY2FuY2VsXG4gICAgICAgICAqIEByZXR1cm5zIFRpbWVyXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuY2FuY2VsVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlLnB1c2godGltZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgd2hldGhlciBhIHRpbWVyIGlzIGFjdGl2ZSBpbiB0aGUgc2NlbmVcbiAgICAgICAgICogQG1ldGhvZCBpc1RpbWVyQWN0aXZlXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9XG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5pc1RpbWVyQWN0aXZlID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3RpbWVycy5pbmRleE9mKHRpbWVyKSA+IC0xKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNjZW5lO1xuICAgIH0pKGV4LkNsYXNzKTtcbiAgICBleC5TY2VuZSA9IFNjZW5lO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgSW50ZXJuYWw7XG4gICAgKGZ1bmN0aW9uIChJbnRlcm5hbCkge1xuICAgICAgICB2YXIgQWN0aW9ucztcbiAgICAgICAgKGZ1bmN0aW9uIChBY3Rpb25zKSB7XG4gICAgICAgICAgICB2YXIgRWFzZVRvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBFYXNlVG8oYWN0b3IsIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhc2luZ0ZjbiA9IGVhc2luZ0ZjbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gMSAqIDEwMDA7IC8vIDUgc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBuZXcgZXguUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgZXguUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBleC5Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbmV3IGV4LlBvaW50KHRoaXMuYWN0b3IueCwgdGhpcy5hY3Rvci55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sZXJwU3RhcnQudG9WZWN0b3IoKS5kaXN0YW5jZSh0aGlzLl9sZXJwRW5kLnRvVmVjdG9yKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRWFzZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdYID0gdGhpcy5hY3Rvci54O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WSA9IHRoaXMuYWN0b3IueTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueCA8IHRoaXMuX2xlcnBTdGFydC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WCA9IHRoaXMuX2xlcnBTdGFydC54IC0gKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdYID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueSA8IHRoaXMuX2xlcnBTdGFydC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WSA9IHRoaXMuX2xlcnBTdGFydC55IC0gKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdZID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gbmV3WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IG5ld1k7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnggPSB0aGlzLl9sZXJwRW5kLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSB0aGlzLl9sZXJwRW5kLnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEVhc2VUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAobmV3IGV4LlZlY3RvcihhY3Rvci54LCBhY3Rvci55KSkuZGlzdGFuY2UodGhpcy5fbGVycFN0YXJ0LnRvVmVjdG9yKCkpID49IHRoaXMuX2Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEVhc2VUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRWFzZVRvO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuRWFzZVRvID0gRWFzZVRvO1xuICAgICAgICAgICAgdmFyIE1vdmVUbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTW92ZVRvKGFjdG9yLCBkZXN0eCwgZGVzdHksIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IGV4LlZlY3RvcihkZXN0eCwgZGVzdHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE1vdmVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IGV4LlZlY3Rvcih0aGlzLmFjdG9yLngsIHRoaXMuYWN0b3IueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy5zdGFydC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuZW5kLm1pbnVzKHRoaXMuc3RhcnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5kaXIuc2NhbGUodGhpcy5zcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSBtLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSBtLnk7XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gdGhpcy5lbmQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IHRoaXMuZW5kLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBleC5WZWN0b3IoYWN0b3IueCwgYWN0b3IueSkpLmRpc3RhbmNlKHRoaXMuc3RhcnQpID49IHRoaXMuZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTW92ZVRvO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuTW92ZVRvID0gTW92ZVRvO1xuICAgICAgICAgICAgdmFyIE1vdmVCeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTW92ZUJ5KGFjdG9yLCBkZXN0eCwgZGVzdHksIHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgZXguVmVjdG9yKGRlc3R4LCBkZXN0eSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKFwiQXR0ZW1wdGVkIHRvIG1vdmVCeSB0aW1lIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvIDogXCIgKyB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGluIHRpbWUgPD0gMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBleC5WZWN0b3IodGhpcy5hY3Rvci54LCB0aGlzLmFjdG9yLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMuc3RhcnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmVuZC5taW51cyh0aGlzLnN0YXJ0KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSB0aGlzLmRpc3RhbmNlIC8gKHRoaXMudGltZSAvIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5kaXIuc2NhbGUodGhpcy5zcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSBtLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSBtLnk7XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gdGhpcy5lbmQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IHRoaXMuZW5kLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBleC5WZWN0b3IoYWN0b3IueCwgYWN0b3IueSkpLmRpc3RhbmNlKHRoaXMuc3RhcnQpID49IHRoaXMuZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTW92ZUJ5O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuTW92ZUJ5ID0gTW92ZUJ5O1xuICAgICAgICAgICAgdmFyIEZvbGxvdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRm9sbG93KGFjdG9yLCBhY3RvclRvRm9sbG93LCBmb2xsb3dEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yVG9Gb2xsb3cgPSBhY3RvclRvRm9sbG93O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgZXguVmVjdG9yKHRoaXMuYWN0b3IueCwgdGhpcy5hY3Rvci55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgZXguVmVjdG9yKGFjdG9yVG9Gb2xsb3cueCwgYWN0b3JUb0ZvbGxvdy55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhpbXVtRGlzdGFuY2UgPSAoZm9sbG93RGlzdGFuY2UgIT0gdW5kZWZpbmVkKSA/IGZvbGxvd0Rpc3RhbmNlIDogdGhpcy5jdXJyZW50LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEZvbGxvdy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlQmV0d2VlbiA9IHRoaXMuY3VycmVudC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuZW5kLm1pbnVzKHRoaXMuY3VycmVudCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yVG9Gb2xsb3dTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLmFjdG9yVG9Gb2xsb3cuZHgsIDIpICsgTWF0aC5wb3codGhpcy5hY3RvclRvRm9sbG93LmR5LCAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RvclRvRm9sbG93U3BlZWQgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IGFjdG9yVG9Gb2xsb3dTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmFjdG9yLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kLnggPSB0aGlzLmFjdG9yVG9Gb2xsb3cueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQueSA9IHRoaXMuYWN0b3JUb0ZvbGxvdy55O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlQmV0d2VlbiA9IHRoaXMuY3VycmVudC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyID0gdGhpcy5lbmQubWludXModGhpcy5jdXJyZW50KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzdGFuY2VCZXR3ZWVuID49IHRoaXMubWF4aW11bURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuZGlyLnNjYWxlKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IG0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSBtLnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgbmV2ZXIgb2NjdXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueCA9IHRoaXMuZW5kLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSB0aGlzLmVuZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRm9sbG93LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRm9sbG93LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3RvciBmb2xsb3dpbmcgc2hvdWxkIG5ldmVyIHN0b3AgdW5sZXNzIHNwZWNpZmllZCB0byBkbyBzb1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZvbGxvdy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBGb2xsb3c7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5Gb2xsb3cgPSBGb2xsb3c7XG4gICAgICAgICAgICB2YXIgTWVldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTWVldChhY3RvciwgYWN0b3JUb01lZXQsIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JUb01lZXQgPSBhY3RvclRvTWVldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IGV4LlZlY3Rvcih0aGlzLmFjdG9yLngsIHRoaXMuYWN0b3IueSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IGV4LlZlY3RvcihhY3RvclRvTWVldC54LCBhY3RvclRvTWVldC55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVlZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNZWV0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5jdXJyZW50LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyID0gdGhpcy5lbmQubWludXModGhpcy5jdXJyZW50KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3JUb01lZXRTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLmFjdG9yVG9NZWV0LmR4LCAyKSArIE1hdGgucG93KHRoaXMuYWN0b3JUb01lZXQuZHksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChhY3RvclRvTWVldFNwZWVkICE9IDApICYmICghdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gYWN0b3JUb01lZXRTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmFjdG9yLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kLnggPSB0aGlzLmFjdG9yVG9NZWV0Lng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kLnkgPSB0aGlzLmFjdG9yVG9NZWV0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5jdXJyZW50LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmVuZC5taW51cyh0aGlzLmN1cnJlbnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuZGlyLnNjYWxlKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gbS54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gbS55O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1lZXRpbmcgaXMgY29tcGxldGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueCA9IHRoaXMuZW5kLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSB0aGlzLmVuZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWVldC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5kaXN0YW5jZUJldHdlZW4gPD0gMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNZWV0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWVldC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNZWV0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuTWVldCA9IE1lZXQ7XG4gICAgICAgICAgICB2YXIgUm90YXRlVG8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFJvdGF0ZVRvKGFjdG9yLCBhbmdsZVJhZGlhbnMsIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gYW5nbGVSYWRpYW5zO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLmFjdG9yLnJvdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IE1hdGguYWJzKHRoaXMuZW5kIC0gdGhpcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IHRoaXMuc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yb3RhdGlvbiA9IHRoaXMuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChNYXRoLmFicyh0aGlzLmFjdG9yLnJvdGF0aW9uIC0gdGhpcy5zdGFydCkgPj0gdGhpcy5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUm90YXRlVG87XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5Sb3RhdGVUbyA9IFJvdGF0ZVRvO1xuICAgICAgICAgICAgdmFyIFJvdGF0ZUJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSb3RhdGVCeShhY3RvciwgYW5nbGVSYWRpYW5zLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gYW5nbGVSYWRpYW5zO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gKHRoaXMuZW5kIC0gdGhpcy5hY3Rvci5yb3RhdGlvbikgLyB0aW1lICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuYWN0b3Iucm90YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gTWF0aC5hYnModGhpcy5lbmQgLSB0aGlzLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gdGhpcy5zcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5sb2coXCJQb3MgeDogXCIgKyB0aGlzLmFjdG9yLnggK1wiICB5OlwiICsgdGhpcy5hY3Rvci55LCBMb2cuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJvdGF0aW9uID0gdGhpcy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKE1hdGguYWJzKHRoaXMuYWN0b3Iucm90YXRpb24gLSB0aGlzLnN0YXJ0KSA+PSB0aGlzLmRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBSb3RhdGVCeTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlJvdGF0ZUJ5ID0gUm90YXRlQnk7XG4gICAgICAgICAgICB2YXIgU2NhbGVUbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2NhbGVUbyhhY3Rvciwgc2NhbGVYLCBzY2FsZVksIHNwZWVkWCwgc3BlZWRZKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRZID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkWCA9IHNwZWVkWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZFkgPSBzcGVlZFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFggPSB0aGlzLmFjdG9yLnNjYWxlLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0WSA9IHRoaXMuYWN0b3Iuc2NhbGUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VYID0gTWF0aC5hYnModGhpcy5lbmRYIC0gdGhpcy5zdGFydFgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLmVuZFkgLSB0aGlzLnN0YXJ0WSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnModGhpcy5hY3Rvci5zY2FsZS54IC0gdGhpcy5zdGFydFgpID49IHRoaXMuZGlzdGFuY2VYKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblggPSB0aGlzLmVuZFkgPCB0aGlzLnN0YXJ0WSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSB0aGlzLnNwZWVkWCAqIGRpcmVjdGlvblg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnkgLSB0aGlzLnN0YXJ0WSkgPj0gdGhpcy5kaXN0YW5jZVkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRoaXMuZW5kWSA8IHRoaXMuc3RhcnRZID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IHRoaXMuc3BlZWRZICogZGlyZWN0aW9uWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zY2FsZS54ID0gdGhpcy5lbmRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zY2FsZS55ID0gdGhpcy5lbmRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2NhbGVUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoKE1hdGguYWJzKHRoaXMuYWN0b3Iuc2NhbGUueSAtIHRoaXMuc3RhcnRYKSA+PSB0aGlzLmRpc3RhbmNlWCkgJiYgKE1hdGguYWJzKHRoaXMuYWN0b3Iuc2NhbGUueSAtIHRoaXMuc3RhcnRZKSA+PSB0aGlzLmRpc3RhbmNlWSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2NhbGVUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2NhbGVUbztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlNjYWxlVG8gPSBTY2FsZVRvO1xuICAgICAgICAgICAgdmFyIFNjYWxlQnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNjYWxlQnkoYWN0b3IsIHNjYWxlWCwgc2NhbGVZLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRZID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkWCA9ICh0aGlzLmVuZFggLSB0aGlzLmFjdG9yLnNjYWxlLngpIC8gdGltZSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWRZID0gKHRoaXMuZW5kWSAtIHRoaXMuYWN0b3Iuc2NhbGUueSkgLyB0aW1lICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0WCA9IHRoaXMuYWN0b3Iuc2NhbGUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRZID0gdGhpcy5hY3Rvci5zY2FsZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZVggPSBNYXRoLmFicyh0aGlzLmVuZFggLSB0aGlzLnN0YXJ0WCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlWSA9IE1hdGguYWJzKHRoaXMuZW5kWSAtIHRoaXMuc3RhcnRZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWCA9IHRoaXMuZW5kWCA8IHRoaXMuc3RhcnRYID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRoaXMuZW5kWSA8IHRoaXMuc3RhcnRZID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gdGhpcy5zcGVlZFggKiBkaXJlY3Rpb25YO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gdGhpcy5zcGVlZFkgKiBkaXJlY3Rpb25ZO1xuICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIlBvcyB4OiBcIiArIHRoaXMuYWN0b3IueCArXCIgIHk6XCIgKyB0aGlzLmFjdG9yLnksIExvZy5ERUJVRyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc2NhbGUueCA9IHRoaXMuZW5kWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc2NhbGUueSA9IHRoaXMuZW5kWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKChNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnggLSB0aGlzLnN0YXJ0WCkgPj0gdGhpcy5kaXN0YW5jZVgpICYmIChNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnkgLSB0aGlzLnN0YXJ0WSkgPj0gdGhpcy5kaXN0YW5jZVkpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNjYWxlQnk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5TY2FsZUJ5ID0gU2NhbGVCeTtcbiAgICAgICAgICAgIHZhciBEZWxheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRGVsYXkoYWN0b3IsIGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIERlbGF5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLmFjdG9yLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuYWN0b3IueTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIERlbGF5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLmVsYXBzZWRUaW1lID49IHRoaXMuZGVsYXkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGVsYXkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGVsYXkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbGF5O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuRGVsYXkgPSBEZWxheTtcbiAgICAgICAgICAgIHZhciBCbGluayA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQmxpbmsoYWN0b3IsIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1CbGlua3MgPT09IHZvaWQgMCkgeyBudW1CbGlua3MgPSAxOyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZVZpc2libGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVOb3RWaXNpYmxlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lVmlzaWJsZSA9IHRpbWVWaXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVOb3RWaXNpYmxlID0gdGltZU5vdFZpc2libGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSAodGltZVZpc2libGUgKyB0aW1lTm90VmlzaWJsZSkgKiBudW1CbGlua3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEJsaW5rLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0b3IudmlzaWJsZSAmJiB0aGlzLmVsYXBzZWRUaW1lID49IHRoaXMudGltZVZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjdG9yLnZpc2libGUgJiYgdGhpcy5lbGFwc2VkVGltZSA+PSB0aGlzLnRpbWVOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmxpbmsucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMudG90YWxUaW1lID49IHRoaXMuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmxpbmsucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmxpbmsucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmxpbms7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5CbGluayA9IEJsaW5rO1xuICAgICAgICAgICAgdmFyIEZhZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZhZGUoYWN0b3IsIGVuZE9wYWNpdHksIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbHllciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kT3BhY2l0eSA9IGVuZE9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZE9wYWNpdHkgPCBhY3Rvci5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGx5ZXIgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBGYWRlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iub3BhY2l0eSArPSB0aGlzLm11bHRpcGx5ZXIgKiAoTWF0aC5hYnModGhpcy5hY3Rvci5vcGFjaXR5IC0gdGhpcy5lbmRPcGFjaXR5KSAqIGRlbHRhKSAvIHRoaXMuc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgZXguTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoXCJhY3RvciBvcGFjaXR5OiBcIiArIHRoaXMuYWN0b3Iub3BhY2l0eSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iub3BhY2l0eSA9IHRoaXMuZW5kT3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmFkZS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoTWF0aC5hYnModGhpcy5hY3Rvci5vcGFjaXR5IC0gdGhpcy5lbmRPcGFjaXR5KSA8IDAuMDUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmFkZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGYWRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhZGU7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5GYWRlID0gRmFkZTtcbiAgICAgICAgICAgIHZhciBEaWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIERpZShhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBEaWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmFjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmtpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEaWUucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGllLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGllLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBEaWU7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5EaWUgPSBEaWU7XG4gICAgICAgICAgICB2YXIgQ2FsbE1ldGhvZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQ2FsbE1ldGhvZChhY3RvciwgbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRob2QuY2FsbCh0aGlzLl9hY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzQmVlbkNhbGxlZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBDYWxsTWV0aG9kO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuQ2FsbE1ldGhvZCA9IENhbGxNZXRob2Q7XG4gICAgICAgICAgICB2YXIgUmVwZWF0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSZXBlYXQoYWN0b3IsIHJlcGVhdCwgYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25RdWV1ZShhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0ID0gcmVwZWF0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsUmVwZWF0ID0gcmVwZWF0O1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3Rpb25RdWV1ZS5hZGQoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJlcGVhdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5hY3Rvci55O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aW9uUXVldWUuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMucmVwZWF0IDw9IDApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVwZWF0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0ID0gdGhpcy5vcmlnaW5hbFJlcGVhdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBSZXBlYXQ7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5SZXBlYXQgPSBSZXBlYXQ7XG4gICAgICAgICAgICB2YXIgUmVwZWF0Rm9yZXZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUmVwZWF0Rm9yZXZlcihhY3RvciwgYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25RdWV1ZShhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGlvblF1ZXVlLmFkZChhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5hY3Rvci55O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY3Rpb25RdWV1ZS5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVwZWF0Rm9yZXZlcjtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlJlcGVhdEZvcmV2ZXIgPSBSZXBlYXRGb3JldmVyO1xuICAgICAgICAgICAgdmFyIEFjdGlvblF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBBY3Rpb25RdWV1ZShhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2FjdGlvbnMuaW5kZXhPZihhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuY2xlYXJBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuY29uY2F0KHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMgPSB0aGlzLmdldEFjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gdGhpcy5fYWN0aW9uc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24udXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aW9uLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIkFjdGlvbiBjb21wbGV0ZSFcIiwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9ucy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFjdGlvblF1ZXVlO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuQWN0aW9uUXVldWUgPSBBY3Rpb25RdWV1ZTtcbiAgICAgICAgfSkoQWN0aW9ucyA9IEludGVybmFsLkFjdGlvbnMgfHwgKEludGVybmFsLkFjdGlvbnMgPSB7fSkpO1xuICAgIH0pKEludGVybmFsID0gZXguSW50ZXJuYWwgfHwgKGV4LkludGVybmFsID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIEVhc2luZ0Z1bmN0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEVhc2luZ0Z1bmN0aW9ucygpIHtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdCB9LFxuICAgICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogKDIgLSB0KSB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdCB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogdCB9LFxuICAgICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKC0tdCkgKiB0ICogdCArIDEgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDEgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gKC0tdCkgKiB0ICogdCAqIHQgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAoLS10KSAqIHQgKiB0ICogdCB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxICsgKC0tdCkgKiB0ICogdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogKC0tdCkgKiB0ICogdCAqIHQgKiB0IH1cbiAgICAgICAgKi9cbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkxpbmVhciA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgLyBkdXJhdGlvbiArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5RdWFkID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlT3V0UXVhZCA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvL2VuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiAtZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICAgICAgY3VycmVudFRpbWUtLTtcbiAgICAgICAgICAgIHJldHVybiAtZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgLSAxKSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5DdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZU91dEN1YmljID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIChjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyAxKSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC09IDI7XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDIpICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVhc2luZ0Z1bmN0aW9ucztcbiAgICB9KSgpO1xuICAgIGV4LkVhc2luZ0Z1bmN0aW9ucyA9IEVhc2luZ0Z1bmN0aW9ucztcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW50ZXJmYWNlcy9JRHJhd2FibGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vZHVsZXMvTW92ZW1lbnRNb2R1bGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vZHVsZXMvT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9kdWxlcy9DYXB0dXJlUG9pbnRlck1vZHVsZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9kdWxlcy9Db2xsaXNpb25EZXRlY3Rpb25Nb2R1bGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbGxpc2lvbi9TaWRlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVdGlsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUaWxlTWFwLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb2xsaXNpb24vQm91bmRpbmdCb3gudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNjZW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rpb24udHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVhc2luZ0Z1bmN0aW9ucy50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlcyBvZiBjb2xsaXNpb25zIGFjdG9ycyBjYW4gcGFydGljaXBhdGUgaW5cbiAgICAgKiBAY2xhc3MgQ29sbGlzaW9uVHlwZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoQ29sbGlzaW9uVHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIFByZXZlbnRDb2xsaXNpb24gc2V0dGluZyBkbyBub3QgcGFydGljaXBhdGUgaW4gYW55XG4gICAgICAgICAqIGNvbGxpc2lvbnMgYW5kIGRvIG5vdCByYWlzZSBjb2xsaXNpb24gZXZlbnRzLlxuICAgICAgICAgKiBAcHJvcGVydHkgUHJldmVudENvbGxpc2lvbiB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiUHJldmVudENvbGxpc2lvblwiXSA9IDBdID0gXCJQcmV2ZW50Q29sbGlzaW9uXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgUGFzc2l2ZSBzZXR0aW5nIG9ubHkgcmFpc2UgY29sbGlzaW9uIGV2ZW50cywgYnV0IGFyZSBub3RcbiAgICAgICAgICogaW5mbHVlbmNlZCBvciBtb3ZlZCBieSBvdGhlciBhY3RvcnMgYW5kIGRvIG5vdCBpbmZsdWVuY2Ugb3IgbW92ZSBvdGhlciBhY3RvcnMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBQYXNzaXZlIHtDb2xsaXNpb25UeXBlfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJQYXNzaXZlXCJdID0gMV0gPSBcIlBhc3NpdmVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBBY3RpdmUgc2V0dGluZyByYWlzZSBjb2xsaXNpb24gZXZlbnRzIGFuZCBwYXJ0aWNpcGF0ZVxuICAgICAgICAgKiBpbiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYWN0b3JzIGFuZCB3aWxsIGJlIHB1c2ggb3IgbW92ZWQgYnkgYWN0b3JzIHNoYXJpbmdcbiAgICAgICAgICogdGhlIEFjdGl2ZSBvciBGaXhlZCBzZXR0aW5nLlxuICAgICAgICAgKiBAcHJvcGVydHkgQWN0aXZlIHtDb2xsaXNpb25UeXBlfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJBY3RpdmVcIl0gPSAyXSA9IFwiQWN0aXZlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgRWxhc3RpYyBzZXR0aW5nIHdpbGwgYmVoYXZlIHRoZSBzYW1lIGFzIEFjdGl2ZSwgZXhjZXB0IHRoYXQgdGhleSB3aWxsXG4gICAgICAgICAqIFwiYm91bmNlXCIgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBnaXZlbiB0aGVpciB2ZWxvY2l0eSBkeC9keS4gVGhpcyBpcyBhIG5haXZlIGltcGxlbWVudGF0aW9uIG1lYW50IGZvclxuICAgICAgICAgKiBwcm90b3R5cGluZywgZm9yIGEgbW9yZSByb2J1c3QgZWxhc3RpYyBjb2xsaXNpb24gbGlzdGVuIHRvIHRoZSBcImNvbGxpc2lvblwiIGV2ZW50IGFuZCBwZXJmb3JtIHlvdXIgY3VzdG9tIGxvZ2ljLlxuICAgICAgICAgKiBAcHJvcGVydHkgRWxhc3RpYyB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiRWxhc3RpY1wiXSA9IDNdID0gXCJFbGFzdGljXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgRml4ZWQgc2V0dGluZyByYWlzZSBjb2xsaXNpb24gZXZlbnRzIGFuZCBwYXJ0aWNpcGF0ZSBpblxuICAgICAgICAgKiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYWN0b3JzLiBBY3RvcnMgd2l0aCB0aGUgRml4ZWQgc2V0dGluZyB3aWxsIG5vdCBiZVxuICAgICAgICAgKiBwdXNoZWQgb3IgbW92ZWQgYnkgb3RoZXIgYWN0b3JzIHNoYXJpbmcgdGhlIEZpeGVkIG9yIEFjdG9ycy4gVGhpbmsgb2YgRml4ZWRcbiAgICAgICAgICogYWN0b3JzIGFzIFwiaW1tb3ZhYmxlL29uc3RvcHBhYmxlXCIgb2JqZWN0cy4gSWYgdHdvIEZpeGVkIGFjdG9ycyBtZWV0IHRoZXkgd2lsbFxuICAgICAgICAgKiBub3QgYmUgcHVzaGVkIG9yIG1vdmVkIGJ5IGVhY2ggb3RoZXIsIHRoZXkgd2lsbCBub3QgaW50ZXJhY3QgZXhjZXB0IHRvIHRocm93XG4gICAgICAgICAqIGNvbGxpc2lvbiBldmVudHMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGaXhlZCB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiRml4ZWRcIl0gPSA0XSA9IFwiRml4ZWRcIjtcbiAgICB9KShleC5Db2xsaXNpb25UeXBlIHx8IChleC5Db2xsaXNpb25UeXBlID0ge30pKTtcbiAgICB2YXIgQ29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGU7XG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgaW1wb3J0YW50IHByaW1pdGl2ZSBpbiBFeGNhbGlidXIgaXMgYW4gXCJBY3Rvci5cIiBBbnl0aGluZyB0aGF0XG4gICAgICogY2FuIG1vdmUgb24gdGhlIHNjcmVlbiwgY29sbGlkZSB3aXRoIGFub3RoZXIgQWN0b3IsIHJlc3BvbmQgdG8gZXZlbnRzLFxuICAgICAqIG9yIGludGVyYWN0IHdpdGggdGhlIGN1cnJlbnQgc2NlbmUsIG11c3QgYmUgYW4gYWN0b3IuIEFuIEFjdG9yIDxiPm11c3Q8L2I+XG4gICAgICogYmUgcGFydCBvZiBhIHt7I2Nyb3NzTGluayBcIlNjZW5lXCJ9fXt7L2Nyb3NzTGlua319IGZvciBpdCB0byBiZSBkcmF3biB0byB0aGUgc2NyZWVuLlxuICAgICAqIEBjbGFzcyBBY3RvclxuICAgICAqIEBleHRlbmRzIENsYXNzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt4PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHggY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW3k9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgeSBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbd2lkdGg9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgd2lkdGggb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFtoZWlnaHQ9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgaGVpZ2h0IG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbY29sb3I9dW5kZWZpbmVkXSB7Q29sb3J9IFRoZSBzdGFydGluZyBjb2xvciBvZiB0aGUgYWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQWN0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYWN0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pZCA9IEFjdG9yLm1heElkKys7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yIChsZWZ0IGVkZ2UpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgeCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBhY3RvciAodG9wIGVkZ2UpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgeSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFuc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHJvdGF0aW9uIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwOyAvLyByYWRpYW5zXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiByYWRpYW5zL3NlY29uZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHJ4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucnggPSAwOyAvL3JhZGlvbnMvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBzY2FsZSB2ZWN0b3Igb2YgdGhlIGFjdG9yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgc2NhbGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBleC5WZWN0b3IoMSwgMSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB4IHNjYWxhciB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gc2NhbGUvc2Vjb25kXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgc3gge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zeCA9IDA7IC8vc2NhbGUvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB5IHNjYWxhciB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gc2NhbGUvc2Vjb25kXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgc3kge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zeSA9IDA7IC8vc2NhbGUvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB4IHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5keCA9IDA7IC8vIHBpeGVscy9zZWNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHggdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkeCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmR5ID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHggYWNjZWxlcmF0aW9uIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXjJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBheCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmF4ID0gMDsgLy8gcGl4ZWxzL3NlYy9zZWNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHkgYWNjZWxlcmF0aW9uIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXjJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBheSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmF5ID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdldGhlciB0aGUgYWN0b3IgaXMgcGh5c2ljYWxseSBpbiB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpc09mZlNjcmVlbiB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc09mZlNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHZpc2libGUge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBvcGFjaXR5IG9mIGFuIGFjdG9yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgb3BhY2l0eSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c09wYWNpdHkgPSAxO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBsb2dnZXJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBsb2dnZXIge0xvZ2dlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBUaGUgc2NlbmUgdGhhdCB0aGUgYWN0b3IgaXMgaW5cbiAgICAgICAgICAgICogQHByb3BlcnR5IHNjZW5lIHtTY2VuZX1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDsgLy9mb3JtZXJseSBcInBhcmVudFwiXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogVGhlIHBhcmVudCBvZiB0aGlzIGFjdG9yXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSBwYXJlbnQge0FjdG9yfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IGNvbGxpc2lvbiB0eXBlIG9mIHRoaXMgYWN0b3IuIEJ5XG4gICAgICAgICAgICAgKiBkZWZhdWx0IGFsbCBhY3RvcnMgcGFydGljaXBhdGUgaW4gQWN0aXZlIGNvbGxpc2lvbnMuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uVHlwZSB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25UeXBlID0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZyYW1lcyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBY2Nlc3MgdG8gdGhlIGN1cnJlbnQgZHJhd2luZyBvbiBmb3IgdGhlIGFjdG9yLCB0aGlzIGNhbiBiZSBhbiB7eyNjcm9zc0xpbmsgXCJBbmltYXRpb25cIn19e3svY3Jvc3NMaW5rfX0sXG4gICAgICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVcIn19e3svY3Jvc3NMaW5rfX0sIG9yIHt7I2Nyb3NzTGluayBcIlBvbHlnb25cIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICAgICAgICAgKiBTZXQgZHJhd2luZ3Mgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiQWN0b3Ivc2V0RHJhd2luZzptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY3VycmVudERyYXdpbmcge0lEcmF3YWJsZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNlbnRlckRyYXdpbmdYID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNlbnRlckRyYXdpbmdZID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1vZGlmeSB0aGUgY3VycmVudCBhY3RvciB1cGRhdGUgcGlwZWxpbmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZSA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBlbmFibGUgdGhlIENhcHR1cmVQb2ludGVyIHRyYWl0IHRoYXQgcHJvcG9nYXRlcyBwb2ludGVyIGV2ZW50cyB0byB0aGlzIGFjdG9yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2VuYWJsZUNhcHR1cmVQb2ludGVyPWZhbHNlXSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25maWd1cmF0aW9uIGZvciBDYXB0dXJlUG9pbnRlciB0cmFpdFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGNhcHR1cmVQb2ludGVyIHtJQ2FwdHVyZVBvaW50ZXJDb25maWd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZVBvaW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZU1vdmVFdmVudHM6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5faXNLaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICAgICAgICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBjb2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IG9wYWNpdHkgb2YgYW4gYWN0b3IgdG8gdGhlIGNvbG9yXG4gICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gY29sb3IuYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1aWxkIGRlZmF1bHQgcGlwZWxpbmVcbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUucHVzaChuZXcgZXguTW92ZW1lbnRNb2R1bGUoKSk7XG4gICAgICAgICAgICAvL3RoaXMucGlwZWxpbmUucHVzaChuZXcgZXguQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlKCkpO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5PZmZzY3JlZW5DdWxsaW5nTW9kdWxlKCkpO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5DYXB0dXJlUG9pbnRlck1vZHVsZSgpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUgPSBuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5BY3Rpb25RdWV1ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVOb2RlID0gbmV3IGV4LlNjZW5lKCk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lTm9kZS5hY3RvciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG5ldyBleC5Qb2ludCguNSwgLjUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXG4gICAgICAgICAqIG92ZXJyaWRkZW4uIFRoaXMgaXMgd2hlcmUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGQgYWN0b3JzIHNob3VsZCB0YWtlIHBsYWNlLlxuICAgICAgICAgKiBAbWV0aG9kIG9uSW5pdGlhbGl6ZVxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICB9O1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuX2NoZWNrRm9yUG9pbnRlck9wdEluID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAmJiAoZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwb2ludGVyZG93bicgfHwgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwb2ludGVyZG93bicgfHwgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwb2ludGVybW92ZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAncG9pbnRlcm1vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZU1vdmVFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyLiBZb3UgY2FuIGxpc3RlbiBmb3IgYSB2YXJpZXR5IG9mXG4gICAgICAgICogZXZlbnRzIG9mZiBvZiB0aGUgZW5naW5lOyBzZWUgdGhlIGV2ZW50cyBzZWN0aW9uIGJlbG93IGZvciBhIGNvbXBsZXRlIGxpc3QuXG4gICAgICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgICogQHBhcmFtIGhhbmRsZXIge2V2ZW50PT52b2lkfSBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG4gICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JQb2ludGVyT3B0SW4oZXZlbnROYW1lKTtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgXCJhZGRFdmVudExpc3RlbmVyXCIuIFlvdSBjYW4gbGlzdGVuIGZvciBhIHZhcmlldHkgb2ZcbiAgICAgICAgICogZXZlbnRzIG9mZiBvZiB0aGUgZW5naW5lOyBzZWUgdGhlIGV2ZW50cyBzZWN0aW9uIGJlbG93IGZvciBhIGNvbXBsZXRlIGxpc3QuXG4gICAgICAgICAqIEBtZXRob2Qgb25cbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyIHtldmVudD0+dm9pZH0gRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JQb2ludGVyT3B0SW4oZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnN1YnNjcmliZShldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGN1cnJlbnQgYWN0b3JzIGlzIGEgbWVtYmVyIG9mIHRoZSBzY2VuZS4gVGhpcyB3aWxsIHJlbW92ZVxuICAgICAgICAgKiBpdCBmcm9tIHRoZSBzY2VuZSBncmFwaC4gSXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCBraWxsXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0tpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQ2Fubm90IGtpbGwgYWN0b3IsIGl0IHdhcyBuZXZlciBhZGRlZCB0byB0aGUgU2NlbmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2V0aGVyIHRoZSBhY3RvciBoYXMgYmVlbiBraWxsZWQuXG4gICAgICAgICAqIEBtZXRob2QgaXNLaWxsZWRcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmlzS2lsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzS2lsbGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGNoaWxkIGFjdG9yIHRvIHRoaXMgYWN0b3IuIEFsbCBtb3ZlbWVudCBvZiB0aGUgY2hpbGQgYWN0b3Igd2lsbCBiZVxuICAgICAgICAgKiByZWxhdGl2ZSB0byB0aGUgcGFyZW50IGFjdG9yLiBNZWFuaW5nIGlmIHRoZSBwYXJlbnQgbW92ZXMgdGhlIGNoaWxkIHdpbGxcbiAgICAgICAgICogbW92ZSB3aXRoXG4gICAgICAgICAqIEBtZXRob2QgYWRkQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGNoaWxkIGFjdG9yIHRvIGFkZFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICBhY3Rvci5jb2xsaXNpb25UeXBlID0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgdGhpcy5zY2VuZU5vZGUuYWRkQ2hpbGQoYWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIGNoaWxkIGFjdG9yIGZyb20gdGhpcyBhY3Rvci5cbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgY2hpbGQgYWN0b3IgdG8gcmVtb3ZlXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVOb2RlLnJlbW92ZUNoaWxkKGFjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGN1cnJlbnQgZHJhd2luZyBvZiB0aGUgYWN0b3IgdG8gdGhlIGRyYXdpbmcgY29ycmVzcG9kaW5nIHRvXG4gICAgICAgICAqIHRoZSBrZXkuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0RHJhd2luZ1xuICAgICAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9IFRoZSBrZXkgb2YgdGhlIGRyYXdpbmdcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zZXREcmF3aW5nID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcgIT0gdGhpcy5mcmFtZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2tleV0ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSB0aGlzLmZyYW1lc1trZXldO1xuICAgICAgICB9O1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuYWRkRHJhd2luZyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnREcmF3aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIGV4LlNwcml0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERyYXdpbmcoXCJkZWZhdWx0XCIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBleC5UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRHJhd2luZyhcImRlZmF1bHRcIiwgYXJndW1lbnRzWzBdLmFzU3ByaXRlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFydGlmaWNpYWxseSB0cmlnZ2VyIGFuIGV2ZW50IG9uIGFuIGFjdG9yLCB1c2VmdWwgd2hlbiBjcmVhdGluZyBjdXN0b20gZXZlbnRzLlxuICAgICAgICAgKiBAbWV0aG9kIHRyaWdnZXJFdmVudFxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmlnZ2VyXG4gICAgICAgICAqIEBwYXJhbSBbZXZlbnQ9dW5kZWZpbmVkXSB7R2FtZUV2ZW50fSBUaGUgZXZlbnQgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIGEgY29sbGlzaW9uIGdyb3VwLiBBY3RvcnMgd2l0aCBubyBuYW1lZCBjb2xsaXNpb24gZ3JvdXAgYXJlXG4gICAgICAgICAqIGNvbnNpZGVyZWQgdG8gYmUgaW4gZXZlcnkgY29sbGlzaW9uIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbmNlIGluIGEgY29sbGlzaW9uIGdyb3VwKHMpIGFjdG9ycyB3aWxsIG9ubHkgY29sbGlkZSB3aXRoIG90aGVyIGFjdG9ycyBpblxuICAgICAgICAgKiB0aGF0IGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGFkZENvbGxpc2lvbkdyb3VwXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hZGRDb2xsaXNpb25Hcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5wdXNoKG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFuIGFjdG9yIGZyb20gYSBjb2xsaXNpb24gZ3JvdXAuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQ29sbGlzaW9uR3JvdXBcbiAgICAgICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJlbW92ZUNvbGxpc2lvbkdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29sbGlzaW9uR3JvdXBzLmluZGV4T2YobmFtZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2VudGVyIHBvaW50IG9mIGFuIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Q2VudGVyXG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9nZXRDYWxjdWxhdGVkQW5jaG9yKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlZlY3Rvcih0aGlzLnggKyB0aGlzLmdldFdpZHRoKCkgLyAyLCB0aGlzLnkgKyB0aGlzLmdldEhlaWdodCgpIC8gMik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIGFuIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0V2lkdGhcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuc2NhbGUueDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHdpZHRoIG9mIGFuIGFjdG9yLCBmYWN0b3JpbmcgaW4gdGhlIGN1cnJlbnQgc2NhbGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRXaWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggLyB0aGlzLnNjYWxlLng7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiBhbiBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldEhlaWdodFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQgKiB0aGlzLnNjYWxlLnk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgYW4gYWN0b3IsIGZhY3RvcmluZyBpbiB0aGUgY3VycmVudCBzY2FsZVxuICAgICAgICAgKiBAbWV0aG9kIHNldEhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gdGhpcy5zY2FsZS55O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2VudGVycyB0aGUgYWN0b3IncyBkcmF3aW5nIGFyb3VuZCB0aGUgY2VudGVyIG9mIHRoZSBhY3RvcidzIGJvdW5kaW5nIGJveFxuICAgICAgICAgKiBAbWV0aG9kIHNldENlbnRlckRyYXdpbmdcbiAgICAgICAgICogQHBhcmFtIGNlbnRlciB7Ym9vbGVhbn0gSW5kaWNhdGVzIHRvIGNlbnRlciB0aGUgZHJhd2luZyBhcm91bmQgdGhlIGFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2V0Q2VudGVyRHJhd2luZyA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyRHJhd2luZ1kgPSBjZW50ZXI7XG4gICAgICAgICAgICB0aGlzLmNlbnRlckRyYXdpbmdYID0gY2VudGVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldExlZnRcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSByaWdodCBlZGdlIG9mIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldFJpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHRvcCBlZGdlIG9mIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldFRvcFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Qm90dG9tXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBHZXRzIHRoZSB4IHZhbHVlIG9mIHRoZSBBY3RvciBpbiBnbG9iYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgKiBAbWV0aG9kIGdldEdsb2JhbFhcbiAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEdsb2JhbFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy5wYXJlbnQuc2NhbGUueSArIHRoaXMucGFyZW50LmdldEdsb2JhbFgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogR2V0cyB0aGUgeSB2YWx1ZSBvZiB0aGUgQWN0b3IgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICAgICogQG1ldGhvZCBnZXRHbG9iYWxZXG4gICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRHbG9iYWxZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSAqIHRoaXMucGFyZW50LnNjYWxlLnkgKyB0aGlzLnBhcmVudC5nZXRHbG9iYWxZKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBnbG9iYWwgc2NhbGUgb2YgdGhlIEFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0R2xvYmFsU2NhbGVcbiAgICAgICAgICogQHJldHVybnMgUG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludCh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XG4gICAgICAgICAgICB2YXIgcGFyZW50U2NhbGUgPSB0aGlzLnBhcmVudC5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludCh0aGlzLnNjYWxlLnggKiBwYXJlbnRTY2FsZS54LCB0aGlzLnNjYWxlLnkgKiBwYXJlbnRTY2FsZS55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFjdG9yJ3MgYm91bmRpbmcgYm94IGNhbGN1bGF0ZWQgZm9yIHRoaXMgaW5zdGFudC5cbiAgICAgICAgICogQG1ldGhvZCBnZXRCb3VuZHNcbiAgICAgICAgICogQHJldHVybnMgQm91bmRpbmdCb3hcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZEFuY2hvcigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Cb3VuZGluZ0JveCh0aGlzLmdldEdsb2JhbFgoKSAtIGFuY2hvci54LCB0aGlzLmdldEdsb2JhbFkoKSAtIGFuY2hvci55LCB0aGlzLmdldEdsb2JhbFgoKSArIHRoaXMuZ2V0V2lkdGgoKSAtIGFuY2hvci54LCB0aGlzLmdldEdsb2JhbFkoKSArIHRoaXMuZ2V0SGVpZ2h0KCkgLSBhbmNob3IueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyB3aGV0aGVyIHRoZSB4L3kgc3BlY2lmaWVkIGFyZSBjb250YWluZWQgaW4gdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgY29udGFpbnNcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn0gWCBjb29yZGluYXRlIHRvIHRlc3QgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBZIGNvb3JkaW5hdGUgdG8gdGVzdCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMobmV3IGV4LlBvaW50KHgsIHkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNpZGUgb2YgdGhlIGNvbGxpc2lvbiBiYXNlZCBvbiB0aGUgaW50ZXJzZWN0aW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2lkZUZyb21JbnRlcnNlY3RcbiAgICAgICAgICogQHBhcmFtIGludGVyc2VjdCB7VmVjdG9yfSBUaGUgZGlzcGxhY2VtZW50IHZlY3RvciByZXR1cm5lZCBieSBhIGNvbGxpc2lvblxuICAgICAgICAgKiBAcmV0dXJucyBTaWRlXG4gICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRTaWRlRnJvbUludGVyc2VjdCA9IGZ1bmN0aW9uIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW50ZXJzZWN0LngpID4gTWF0aC5hYnMoaW50ZXJzZWN0LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3QueCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIFJpZ2h0ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIExlZnQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0LnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBCb3R0b20gKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogVG9wICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGFjdG9yIGhhcyBjb2xsaWRlZCB3aXRoIGFub3RoZXIgYWN0b3IsIHJldHVybnMgdGhlIHNpZGUgb2YgdGhlIGN1cnJlbnQgYWN0b3IgdGhhdCBjb2xsaWRlZC5cbiAgICAgICAgICogQG1ldGhvZCBjb2xsaWRlc1xuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgb3RoZXIgYWN0b3IgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyBTaWRlXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY29sbGlkZXNXaXRoU2lkZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb25WZWN0b3IgPSB0aGlzLmNvbGxpZGVzKGFjdG9yKTtcbiAgICAgICAgICAgIGlmICghc2VwYXJhdGlvblZlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc2VwYXJhdGlvblZlY3Rvci54KSA+IE1hdGguYWJzKHNlcGFyYXRpb25WZWN0b3IueSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy54IDwgYWN0b3IueCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNCAvKiBSaWdodCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIExlZnQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMueSA8IGFjdG9yLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQm90dG9tICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogVG9wICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGFjdG9yIGhhcyBjb2xsaWRlZCB3aXRoIGFub3RoZXIgYWN0b3IsIHJldHVybnMgdGhlIGludGVyc2VjdGlvbiB2ZWN0b3Igb24gY29sbGlzaW9uLiBSZXR1cm5zXG4gICAgICAgICAqIG51bGwgd2hlbiB0aGVyZSBpcyBubyBjb2xsaXNpb247XG4gICAgICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIG90aGVyIGFjdG9yIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgdmFyIG90aGVyQm91bmRzID0gYWN0b3IuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gYm91bmRzLmNvbGxpZGVzKG90aGVyQm91bmRzKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Q7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgdG8gZmlyZSB3aGVuIHRoaXMgYWN0b3IgY29sbGlkZXMgd2l0aCBhbm90aGVyIGluIGEgc3BlY2lmaWVkIGdyb3VwXG4gICAgICAgICAqIEBtZXRob2Qgb25Db2xsaWRlc1dpdGhcbiAgICAgICAgICogQHBhcmFtIGdyb3VwIHtzdHJpbmd9IFRoZSBncm91cCBuYW1lIHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIGZ1bmMge2NhbGxiYWNrfSBUaGUgY2FsbGJhY2sgdG8gZmlyZSBvbiBjb2xsaXNpb24gd2l0aCBhbm90aGVyIGFjdG9yIGZyb20gdGhlIGdyb3VwLiBUaGUgY2FsbGJhY2sgaXMgcGFzc2VkIHRoZSBvdGhlciBhY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5vbkNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uIChncm91cCwgZnVuYykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXS5wdXNoKGZ1bmMpO1xuICAgICAgICB9O1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlzaW9uSGFuZGxlcnM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBjb2xsaXNpb24gaGFuZGxlcnMgZm9yIHRoaXMgZ3JvdXAgb24gdGhpcyBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbGxpZGVzV2l0aFxuICAgICAgICAgKiBAcGFyYW0gZ3JvdXAge3N0cmluZ30gR3JvdXAgdG8gcmVtb3ZlIGFsbCBoYW5kbGVycyBmb3Igb24gdGhpcyBhY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yZW1vdmVDb2xsaWRlc1dpdGggPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXSA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gYWN0b3JzIGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGRpc3RhbmNlIHNwZWNpZmllZCBmcm9tIGVhY2ggb3RoZXJcbiAgICAgICAgICogQG1ldGhvZCB3aXRoaW5cbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gQWN0b3IgdG8gdGVzdFxuICAgICAgICAgKiBAcGFyYW0gZGlzdGFuY2Uge251bWJlcn0gRGlzdGFuY2UgaW4gcGl4ZWxzIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uIChhY3RvciwgZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0gYWN0b3IueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSBhY3Rvci55LCAyKSkgPD0gZGlzdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIHF1ZXVlZCBhY3Rpb25zIGZyb20gdGhlIEFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJBY3Rpb25zXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY2xlYXJBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmVhc2VUbyA9IGZ1bmN0aW9uICh4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSB7XG4gICAgICAgICAgICBpZiAoZWFzaW5nRmNuID09PSB2b2lkIDApIHsgZWFzaW5nRmNuID0gZXguRWFzaW5nRnVuY3Rpb25zLkxpbmVhcjsgfVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuRWFzZVRvKHRoaXMsIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtb3ZlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBhdCB0aGVcbiAgICAgICAgICogc3BlZWQgc3BlY2lmaWVkIChpbiBwaXhlbHMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xuICAgICAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgbW92ZVRvXG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSB4IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZVxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5LCBzcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuTW92ZVRvKHRoaXMsIHgsIHksIHNwZWVkKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbW92ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gYnkgYVxuICAgICAgICAgKiBjZXJ0YWluIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yXG4gICAgICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIG1vdmVCeVxuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xuICAgICAgICAgKiBAcGFyYW0gdGltZSB7bnVtYmVyfSBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0aGUgYWN0b3IgdG8gbW92ZSB0byB0aGUgbmV3IGxvY2F0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uICh4LCB5LCB0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5Nb3ZlQnkodGhpcywgeCwgeSwgdGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGF0IHRoZSBzcGVlZFxuICAgICAgICAgKiBzcGVjaWZpZWQgKGluIHJhZGlhbnMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xuICAgICAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2Qgcm90YXRlVG9cbiAgICAgICAgICogQHBhcmFtIGFuZ2xlUmFkaWFucyB7bnVtYmVyfSBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcbiAgICAgICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSByb3RhdGlvbiBzcGVjaWZpZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucm90YXRlVG8gPSBmdW5jdGlvbiAoYW5nbGVSYWRpYW5zLCBzcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuUm90YXRlVG8odGhpcywgYW5nbGVSYWRpYW5zLCBzcGVlZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGJ5IGEgY2VydGFpblxuICAgICAgICAgKiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnRcbiAgICAgICAgICogb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHJvdGF0ZUJ5XG4gICAgICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnMge251bWJlcn0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0byBpbiByYWRpYW5zXG4gICAgICAgICAqIEBwYXJhbSB0aW1lIHtudW1iZXJ9IFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRoZSBhY3RvciB0byBjb21wbGV0ZSB0aGUgcm90YXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucm90YXRlQnkgPSBmdW5jdGlvbiAoYW5nbGVSYWRpYW5zLCB0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5Sb3RhdGVCeSh0aGlzLCBhbmdsZVJhZGlhbnMsIHRpbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBzY2FsZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHNpemUgYXQgdGhlIHNwZWVkXG4gICAgICAgICAqIHNwZWNpZmllZCAoaW4gbWFnbml0dWRlIGluY3JlYXNlIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGVcbiAgICAgICAgICogYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmdcbiAgICAgICAgICogYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHNjYWxlVG9cbiAgICAgICAgICogQHBhcmFtIHNpemUge251bWJlcn0gVGhlIHNjYWxpbmcgZmFjdG9yIHRvIGFwcGx5XG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgc3BlZWQgb2Ygc2NhbGluZyBzcGVjaWZpZWQgaW4gbWFnbml0dWRlIGluY3JlYXNlIHBlciBzZWNvbmRcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zY2FsZVRvID0gZnVuY3Rpb24gKHNpemVYLCBzaXplWSwgc3BlZWRYLCBzcGVlZFkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLlNjYWxlVG8odGhpcywgc2l6ZVgsIHNpemVZLCBzcGVlZFgsIHNwZWVkWSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNjYWxlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgc2l6ZSBieSBhIGNlcnRhaW4gdGltZVxuICAgICAgICAgKiAoaW4gbWlsbGlzZWNvbmRzKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZVxuICAgICAgICAgKiBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBzY2FsZUJ5XG4gICAgICAgICAqIEBwYXJhbSBzaXplIHtudW1iZXJ9IFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseVxuICAgICAgICAgKiBAcGFyYW0gdGltZSB7bnVtYmVyfSBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0byBjb21wbGV0ZSB0aGUgc2NhbGluZyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zY2FsZUJ5ID0gZnVuY3Rpb24gKHNpemVYLCBzaXplWSwgdGltZSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuU2NhbGVCeSh0aGlzLCBzaXplWCwgc2l6ZVksIHRpbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvciB0byBibGluayAoYmVjb21lIHZpc2libGUgYW5kIG5vdFxuICAgICAgICAgKiB2aXNpYmxlKS4gT3B0aW9uYWxseSwgeW91IG1heSBzcGVjaWZ5IHRoZSBudW1iZXIgb2YgYmxpbmtzLiBTcGVjaWZ5IHRoZSBhbW91bnQgb2YgdGltZVxuICAgICAgICAgKiB0aGUgYWN0b3Igc2hvdWxkIGJlIHZpc2libGUgcGVyIGJsaW5rLCBhbmQgdGhlIGFtb3VudCBvZiB0aW1lIG5vdCB2aXNpYmxlLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBibGlua1xuICAgICAgICAgKiBAcGFyYW0gdGltZVZpc2libGUge251bWJlcn0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEBwYXJhbSB0aW1lTm90VmlzaWJsZSB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSBub3QgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEBwYXJhbSBbbnVtQmxpbmtzXSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGJsaW5rXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuYmxpbmsgPSBmdW5jdGlvbiAodGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpIHtcbiAgICAgICAgICAgIGlmIChudW1CbGlua3MgPT09IHZvaWQgMCkgeyBudW1CbGlua3MgPSAxOyB9XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5CbGluayh0aGlzLCB0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yJ3Mgb3BhY2l0eSB0byBjaGFuZ2UgZnJvbSBpdHMgY3VycmVudCB2YWx1ZVxuICAgICAgICAgKiB0byB0aGUgcHJvdmlkZWQgdmFsdWUgYnkgYSBzcGVjaWZpZWQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXNcbiAgICAgICAgICogcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgZmFkZVxuICAgICAgICAgKiBAcGFyYW0gb3BhY2l0eSB7bnVtYmVyfSBUaGUgZW5kaW5nIG9wYWNpdHlcbiAgICAgICAgICogQHBhcmFtIHRpbWUge251bWJlcn0gVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gZmFkZSB0aGUgYWN0b3IgKGluIG1pbGxpc2Vjb25kcylcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5mYWRlID0gZnVuY3Rpb24gKG9wYWNpdHksIHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkZhZGUodGhpcywgb3BhY2l0eSwgdGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBmcm9tIGV4ZWN1dGluZyBmb3IgYSBjZXJ0YWluXG4gICAgICAgICAqIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxuICAgICAgICAgKiAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBkZWxheVxuICAgICAgICAgKiBAcGFyYW0gdGltZSB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIG5leHQgYWN0aW9uIGluIHRoZSBxdWV1ZSBmcm9tIGV4ZWN1dGluZyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5EZWxheSh0aGlzLCB0aW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIGFuIGFjdGlvbiB0byB0aGUgcXVldWUgdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWN0b3IgZnJvbSB0aGVcbiAgICAgICAgICogc2NlbmUgb25jZSBpdCBoYXMgY29tcGxldGVkIGl0cyBwcmV2aW91cyBhY3Rpb25zLiBBbnkgYWN0aW9ucyBvbiB0aGVcbiAgICAgICAgICogYWN0aW9uIHF1ZXVlIGFmdGVyIHRoaXMgYWN0aW9uIHdpbGwgbm90IGJlIGV4ZWN1dGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGRpZVxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmRpZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkRpZSh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gY2FsbCBhbiBhcmJpdHJhcnkgbWV0aG9kIGFzIHRoZSBuZXh0IGFjdGlvbiBpbiB0aGVcbiAgICAgICAgICogYWN0aW9uIHF1ZXVlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBleGVjdXRlIGNvZGUgaW4gYWZ0ZXIgYSBzcGVjaWZpY1xuICAgICAgICAgKiBhY3Rpb24sIGkuZSBBbiBhY3RvciBhcnJpdmVzIGF0IGEgZGVzdGluYXRpbm8gYWZ0ZXIgdHJhdmVyc2luZyBhIHBhdGhcbiAgICAgICAgICogQG1ldGhvZCBjYWxsTWV0aG9kXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkNhbGxNZXRob2QodGhpcywgbWV0aG9kKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIHByZXZpb3VzbHlcbiAgICAgICAgICogY2FsbGVkIGFjdGlvbnMgYSBjZXJ0YWluIG51bWJlciBvZiB0aW1lcy4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXG4gICAgICAgICAqIGlzIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCByZXBlYXQgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZlxuICAgICAgICAgKiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmdcbiAgICAgICAgICogQG1ldGhvZCByZXBlYXRcbiAgICAgICAgICogQHBhcmFtIFt0aW1lcz11bmRlZmluZWRdIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGFsbCB0aGUgcHJldmlvdXMgYWN0aW9ucyBpbiB0aGUgYWN0aW9uIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHNwZWNpZmllZCB0aGUgYWN0aW9ucyB3aWxsIHJlcGVhdCBmb3JldmVyXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgICAgICBpZiAoIXRpbWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRGb3JldmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5SZXBlYXQodGhpcywgdGltZXMsIHRoaXMuYWN0aW9uUXVldWUuZ2V0QWN0aW9ucygpKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIHByZXZpb3VzbHlcbiAgICAgICAgICogY2FsbGVkIGFjdGlvbnMgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbidcbiAgICAgICAgICogZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgcmVwZWF0Rm9yZXZlclxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJlcGVhdEZvcmV2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5SZXBlYXRGb3JldmVyKHRoaXMsIHRoaXMuYWN0aW9uUXVldWUuZ2V0QWN0aW9ucygpKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIGZvbGxvdyBhbm90aGVyIGF0IGEgc3BlY2lmaWVkIGRpc3RhbmNlXG4gICAgICAgICAqIEBtZXRob2QgZm9sbG93XG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0byBmb2xsb3dcbiAgICAgICAgICogQHBhcmFtIFtmb2xsb3dEaXN0YW5jZT1jdXJyZW50RGlzdGFuY2VdIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSB0byBtYWludGFpbiB3aGVuIGZvbGxvd2luZywgaWYgbm90IHNwZWNpZmllZCB0aGUgYWN0b3Igd2lsbCBmb2xsb3cgYXQgdGhlIGN1cnJlbnQgZGlzdGFuY2UuXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZm9sbG93ID0gZnVuY3Rpb24gKGFjdG9yLCBmb2xsb3dEaXN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGZvbGxvd0Rpc3RhbmNlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkZvbGxvdyh0aGlzLCBhY3RvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuRm9sbG93KHRoaXMsIGFjdG9yLCBmb2xsb3dEaXN0YW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byBtb3ZlIHRvd2FyZHMgYW5vdGhlciB1bnRpbCB0aGV5XG4gICAgICAgICAqIGNvbGxpZGUgXCJtZWV0XCIgYXQgYSBzcGVjaWZpZWQgc3BlZWQuXG4gICAgICAgICAqIEBtZXRob2QgbWVldFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gbWVldFxuICAgICAgICAgKiBAcGFyYW0gW3NwZWVkPTBdIHtudW1iZXJ9IFRoZSBzcGVlZCBpbiBwaXhlbHMgcGVyIHNlY29uZCB0byBtb3ZlLCBpZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgbWF0Y2ggdGhlIHNwZWVkIG9mIHRoZSBvdGhlciBhY3RvclxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm1lZXQgPSBmdW5jdGlvbiAoYWN0b3IsIHNwZWVkKSB7XG4gICAgICAgICAgICBpZiAoc3BlZWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuTWVldCh0aGlzLCBhY3RvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuTWVldCh0aGlzLCBhY3Rvciwgc3BlZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjdXJyZW50IGFjdGlvbiBxdWV1ZSB1cCB0byBub3dcbiAgICAgICAgICogaXMgZmluaXNoZWQuXG4gICAgICAgICAqIEBtZXRob2QgYXNQcm9taXNlXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hc1Byb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdGhpcy5jYWxsTWV0aG9kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLl9nZXRDYWxjdWxhdGVkQW5jaG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludCh0aGlzLmdldFdpZHRoKCkgKiB0aGlzLmFuY2hvci54LCB0aGlzLmdldEhlaWdodCgpICogdGhpcy5hbmNob3IueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgdXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gVGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIGVuZ2luZVxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplKGVuZ2luZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaCgnaW5pdGlhbGl6ZScsIG5ldyBleC5Jbml0aWFsaXplRXZlbnQoZW5naW5lKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXZlbnREaXNwYXRjaGVyID0gdGhpcy5ldmVudERpc3BhdGNoZXI7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aW9uIHF1ZXVlXG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGlwZWxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpcGVsaW5lW2ldLnVwZGF0ZSh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKGV4LkV2ZW50VHlwZVs1IC8qIFVwZGF0ZSAqL10sIG5ldyBleC5VcGRhdGVFdmVudChkZWx0YSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIGRyYXdzIHRoZSBhY3RvciB0byB0aGUgc2NyZWVuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZHJhdyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT2ZmU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFuY2hvclBvaW50ID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZEFuY2hvcigpO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgY2hhbmdpbmcgb3BhY2l0eVxuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNPcGFjaXR5ICE9IHRoaXMub3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRyYXdpbmcgaW4gdGhpcy5mcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZHJhd2luZ10uYWRkRWZmZWN0KG5ldyBleC5FZmZlY3RzLk9wYWNpdHkodGhpcy5vcGFjaXR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgeERpZmYgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB5RGlmZiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyRHJhd2luZ1gpIHtcbiAgICAgICAgICAgICAgICAgICAgeERpZmYgPSAodGhpcy5jdXJyZW50RHJhd2luZy53aWR0aCAqIHRoaXMuY3VycmVudERyYXdpbmcuZ2V0U2NhbGVYKCkgLSB0aGlzLmdldFdpZHRoKCkpIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyRHJhd2luZ1kpIHtcbiAgICAgICAgICAgICAgICAgICAgeURpZmYgPSAodGhpcy5jdXJyZW50RHJhd2luZy5oZWlnaHQgKiB0aGlzLmN1cnJlbnREcmF3aW5nLmdldFNjYWxlWSgpIC0gdGhpcy5nZXRIZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nLmRyYXcoY3R4LCAteERpZmYgLSBhbmNob3JQb2ludC54LCAteURpZmYgLSBhbmNob3JQb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgtYW5jaG9yUG9pbnQueCwgLWFuY2hvclBvaW50LnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lTm9kZS5kcmF3KGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCBkcmF3cyB0aGUgYWN0b3JzIGRlYnVnZ2luZyB0byB0aGUgc2NyZWVuXG4gICAgICAgICAqIEBtZXRob2QgZGVidWdEcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIGJiLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGV4LkNvbG9yLlllbGxvdy50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgMywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGUgbmV4dCBpZCB0byBiZSBzZXRcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLm1heElkID0gMDtcbiAgICAgICAgcmV0dXJuIEFjdG9yO1xuICAgIH0pKGV4LkNsYXNzKTtcbiAgICBleC5BY3RvciA9IEFjdG9yO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBMb2dnaW5nIGxldmVsIHRoYXQgRXhjYWxpYnVyIHdpbGwgdGFnXG4gICAgICogQGNsYXNzIExvZ0xldmVsXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgIEBwcm9wZXJ0eSBEZWJ1ZyB7TG9nTGV2ZWx9XG4gICAgICAgICBAc3RhdGljXG4gICAgICAgICBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgSW5mbyB7TG9nTGV2ZWx9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgV2FybiB7TG9nTGV2ZWx9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgRXJyb3Ige0xvZ0xldmVsfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEZhdGFsIHtMb2dMZXZlbH1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJEZWJ1Z1wiXSA9IDBdID0gXCJEZWJ1Z1wiO1xuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAxXSA9IFwiSW5mb1wiO1xuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5cIl0gPSAyXSA9IFwiV2FyblwiO1xuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVycm9yXCJdID0gM10gPSBcIkVycm9yXCI7XG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA0XSA9IFwiRmF0YWxcIjtcbiAgICB9KShleC5Mb2dMZXZlbCB8fCAoZXguTG9nTGV2ZWwgPSB7fSkpO1xuICAgIHZhciBMb2dMZXZlbCA9IGV4LkxvZ0xldmVsO1xuICAgIC8qKlxuICAgICAqIFN0YXRpYyBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzIHRoZSBsb2dnaW5nIGZhY2lsaXR5IGZvciBFeGNhbGlidXIuXG4gICAgICogRXhjYWxpYnVyIGNvbWVzIGJ1aWx0LWluIHdpdGggYSBDb25zb2xlQXBwZW5kZXIgYW5kIFNjcmVlbkFwcGVuZGVyLlxuICAgICAqIERlcml2ZSBmcm9tIElBcHBlbmRlciB0byBjcmVhdGUgeW91ciBvd24gbG9nZ2luZyBhcHBlbmRlcnMuXG4gICAgICogQGNsYXNzIExvZ2dlclxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YXIgTG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG9nZ2VyKCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRlcnMgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBkZWZhdWx0IGxvZ2dpbmcgbGV2ZWwuIEV4Y2FsaWJ1ciB3aWxsIG9ubHkgbG9nXG4gICAgICAgICAgICAgKiBtZXNzYWdlcyBpZiBlcXVhbCB0byBvciBhYm92ZSB0aGlzIGxldmVsLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRMZXZlbCB7TG9nTGV2ZWx9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExldmVsID0gMSAvKiBJbmZvICovO1xuICAgICAgICAgICAgaWYgKExvZ2dlci5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dnZXIgaXMgYSBzaW5nbGV0b25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2dnZXIuX2luc3RhbmNlID0gdGhpcztcbiAgICAgICAgICAgIC8vIERlZmF1bHQgY29uc29sZSBhcHBlbmRlclxuICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZS5hZGRBcHBlbmRlcihuZXcgQ29uc29sZUFwcGVuZGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIExvZ2dlci5faW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGljIGluc3RhbmNlIG9mIExvZ2dlclxuICAgICAgICAgKiBAbWV0aG9kIGdldEluc3RhbmNlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHJldHVybnMgTG9nZ2VyXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoTG9nZ2VyLl9pbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZSA9IG5ldyBMb2dnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBMb2dnZXIuX2luc3RhbmNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG5ldyBJQXBwZW5kZXIgdG8gdGhlIGxpc3Qgb2YgYXBwZW5kZXJzIHRvIHdyaXRlIHRvXG4gICAgICAgICAqIEBtZXRob2QgYWRkQXBwZW5kZXJcbiAgICAgICAgICogQHBhcmFtIGFwcGVuZGVyIHtJQXBwZW5kZXJ9IEFwcGVuZGVyIHRvIGFkZFxuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5hZGRBcHBlbmRlciA9IGZ1bmN0aW9uIChhcHBlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRlcnMucHVzaChhcHBlbmRlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIGFwcGVuZGVycyBmcm9tIHRoZSBsb2dnZXJcbiAgICAgICAgICogQG1ldGhvZCBjbGVhckFwcGVuZGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5jbGVhckFwcGVuZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIExvZ0xldmVsXG4gICAgICAgICAqIEBtZXRob2QgX2xvZ1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gbGV2ZWwge0xvZ0xldmVsfVRoZSBMb2dMZXZlbGB0byBsb2cgdGhlIG1lc3NhZ2UgYXRcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHdyaXRlIHRvIGFuIGFwcGVuZGVyXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldmVsID0gdGhpcy5kZWZhdWx0TGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChhcHBlbmRlcikge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSBfdGhpcy5kZWZhdWx0TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kZXIubG9nKGxldmVsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBMb2dMZXZlbC5EZWJ1ZyBsZXZlbFxuICAgICAgICAgKiBAbWV0aG9kIGRlYnVnXG4gICAgICAgICAqIEBwYXJhbSAuLi5hcmdzIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nKDAgLyogRGVidWcgKi8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIExvZ0xldmVsLkluZm8gbGV2ZWxcbiAgICAgICAgICogQG1ldGhvZCBpbmZvXG4gICAgICAgICAqIEBwYXJhbSAuLi5hcmdzIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2coMSAvKiBJbmZvICovLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBMb2dMZXZlbC5XYXJuIGxldmVsXG4gICAgICAgICAqIEBtZXRob2Qgd2FyblxuICAgICAgICAgKiBAcGFyYW0gLi4uYXJncyBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nKDIgLyogV2FybiAqLywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgTG9nTGV2ZWwuRXJyb3IgbGV2ZWxcbiAgICAgICAgICogQG1ldGhvZCBlcnJvclxuICAgICAgICAgKiBAcGFyYW0gLi4uYXJncyBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvZygzIC8qIEVycm9yICovLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBMb2dMZXZlbC5GYXRhbCBsZXZlbFxuICAgICAgICAgKiBAbWV0aG9kIGZhdGFsXG4gICAgICAgICAqIEBwYXJhbSAuLi5hcmdzIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nKDQgLyogRmF0YWwgKi8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBMb2dnZXIuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIExvZ2dlcjtcbiAgICB9KSgpO1xuICAgIGV4LkxvZ2dlciA9IExvZ2dlcjtcbiAgICAvKipcbiAgICAgKiBDb25zb2xlIGFwcGVuZGVyIGZvciBicm93c2VycyAoaS5lLiBjb25zb2xlLmxvZylcbiAgICAgKiBAY2xhc3MgQ29uc29sZUFwcGVuZGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgSUFwcGVuZGVyXG4gICAgICovXG4gICAgdmFyIENvbnNvbGVBcHBlbmRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbnNvbGVBcHBlbmRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBDb25zb2xlQXBwZW5kZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbnNvbGUgc3VwcG9ydFxuICAgICAgICAgICAgaWYgKCFjb25zb2xlICYmICFjb25zb2xlLmxvZyAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8gbWF5YmUgZG8gc29tZXRoaW5nIGJldHRlciB0aGFuIG5vdGhpbmdcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29uc29sZSBhcmdzIGFycmF5XG4gICAgICAgICAgICB2YXIgY29uc29sZUFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGNvbnNvbGVBcmdzLnVuc2hpZnQuYXBwbHkoY29uc29sZUFyZ3MsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc29sZUFyZ3MudW5zaGlmdChcIltcIiArIExvZ0xldmVsW2xldmVsXSArIFwiXSA6IFwiKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IDIgLyogV2FybiAqLykge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgLmxvZyBmb3IgRGVidWcvSW5mb1xuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIG9uIHNvbWUgb2xkZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGFwcGx5IG9uIGNvbnNvbGUubG9nIDooXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGV2ZWwgPCAzIC8qIEVycm9yICovKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCAud2FybiBmb3IgV2FyblxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4uYXBwbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihjb25zb2xlQXJncy5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgLmVycm9yIGZvciBFcnJvci9GYXRhbFxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihjb25zb2xlQXJncy5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbnNvbGVBcHBlbmRlcjtcbiAgICB9KSgpO1xuICAgIGV4LkNvbnNvbGVBcHBlbmRlciA9IENvbnNvbGVBcHBlbmRlcjtcbiAgICAvKipcbiAgICAgKiBPbi1zY3JlZW4gKGNhbnZhcykgYXBwZW5kZXJcbiAgICAgKiBAdG9kbyBDbGVhbiB0aGlzIHVwXG4gICAgICogQGNsYXNzIFNjcmVlbkFwcGVuZGVyXG4gICAgICogQGV4dGVuZHMgSUFwcGVuZGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IFdpZHRoIG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBIZWlnaHQgb2YgdGhlIHNjcmVlbiBhcHBlbmRlciBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICB2YXIgU2NyZWVuQXBwZW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTY3JlZW5BcHBlbmRlcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGggfHwgd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgfHwgd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgU2NyZWVuQXBwZW5kZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXMudW5zaGlmdChcIltcIiArIExvZ0xldmVsW2xldmVsXSArIFwiXSA6IFwiICsgbWVzc2FnZSk7XG4gICAgICAgICAgICB2YXIgcG9zID0gMTA7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IDEuMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwnICsgb3BhY2l0eS50b0ZpeGVkKDIpICsgJyknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KHRoaXMuX21lc3NhZ2VzW2ldLCAyMDAsIHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zICs9IDEwO1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5ID4gMCA/IG9wYWNpdHkgLSAuMDUgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2NyZWVuQXBwZW5kZXI7XG4gICAgfSkoKTtcbiAgICBleC5TY3JlZW5BcHBlbmRlciA9IFNjcmVlbkFwcGVuZGVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2cudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEFuIGVudW0gcmVwcmVzZW50aW5nIGFsbCBvZiB0aGUgYnVpbHQgaW4gZXZlbnQgdHlwZXMgZm9yIEV4Y2FsaWJ1clxuICAgICAqIEBjbGFzcyBFdmVudFR5cGVcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFVzZXJFdmVudCB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEJsdXIge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBGb2N1cyB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFVwZGF0ZSB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEVudGVyVmlld1BvcnQge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBFeGl0Vmlld1BvcnQge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBBY3RpdmF0ZSB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IERlYWN0aXZhdGUge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBJbml0aWFsaXplIHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJDb2xsaXNpb25cIl0gPSAwXSA9IFwiQ29sbGlzaW9uXCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJFbnRlclZpZXdQb3J0XCJdID0gMV0gPSBcIkVudGVyVmlld1BvcnRcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkV4aXRWaWV3UG9ydFwiXSA9IDJdID0gXCJFeGl0Vmlld1BvcnRcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkJsdXJcIl0gPSAzXSA9IFwiQmx1clwiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiRm9jdXNcIl0gPSA0XSA9IFwiRm9jdXNcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIlVwZGF0ZVwiXSA9IDVdID0gXCJVcGRhdGVcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkFjdGl2YXRlXCJdID0gNl0gPSBcIkFjdGl2YXRlXCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJEZWFjdGl2YXRlXCJdID0gN10gPSBcIkRlYWN0aXZhdGVcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkluaXRpYWxpemVcIl0gPSA4XSA9IFwiSW5pdGlhbGl6ZVwiO1xuICAgIH0pKGV4LkV2ZW50VHlwZSB8fCAoZXguRXZlbnRUeXBlID0ge30pKTtcbiAgICB2YXIgRXZlbnRUeXBlID0gZXguRXZlbnRUeXBlO1xuICAgIC8qKlxuICAgICAqIEJhc2UgZXZlbnQgdHlwZSBpbiBFeGNhbGlidXIgdGhhdCBhbGwgb3RoZXIgZXZlbnQgdHlwZXMgZGVyaXZlIGZyb20uXG4gICAgICpcbiAgICAgKiBAY2xhc3MgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHRhcmdldCB7YW55fSBFdmVudHMgY2FuIGhhdmUgdGFyZ2V0IGdhbWUgb2JqZWN0LCBsaWtlIHRoZSBFbmdpbmUsIG9yIGFuIEFjdG9yLlxuICAgICAqL1xuICAgIHZhciBHYW1lRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBHYW1lRXZlbnQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdhbWVFdmVudDtcbiAgICB9KSgpO1xuICAgIGV4LkdhbWVFdmVudCA9IEdhbWVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCByZWNlaXZlZCBieSB0aGUgRW5naW5lIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqIEBjbGFzcyBWaXNpYmxlRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVmlzaWJsZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFZpc2libGVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVmlzaWJsZUV2ZW50KCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFZpc2libGVFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LlZpc2libGVFdmVudCA9IFZpc2libGVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCByZWNlaXZlZCBieSB0aGUgRW5naW5lIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIGhpZGRlblxuICAgICAqXG4gICAgICogQGNsYXNzIEhpZGRlbkV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEhpZGRlbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEhpZGRlbkV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBIaWRkZW5FdmVudCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIaWRkZW5FdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkhpZGRlbkV2ZW50ID0gSGlkZGVuRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIGFjdG9yIHdoZW4gYSBjb2xsaXNpb24gaGFzIG9jY3VyZWRcbiAgICAgKlxuICAgICAqIEBjbGFzcyBDb2xsaXNpb25FdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0aGUgZXZlbnQgd2FzIHRocm93biBvblxuICAgICAqIEBwYXJhbSBvdGhlciB7QWN0b3J9IFRoZSBhY3RvciB0aGF0IHdhcyBjb2xsaWRlZCB3aXRoXG4gICAgICogQHBhcmFtIHNpZGUge1NpZGV9IFRoZSBzaWRlIHRoYXQgd2FzIGNvbGxpZGVkIHdpdGhcbiAgICAgKi9cbiAgICB2YXIgQ29sbGlzaW9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQ29sbGlzaW9uRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvbkV2ZW50KGFjdG9yLCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcbiAgICAgICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5Db2xsaXNpb25FdmVudCA9IENvbGxpc2lvbkV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIGdhbWUgb2JqZWN0IG9uIEV4Y2FsaWJ1ciB1cGRhdGVcbiAgICAgKlxuICAgICAqIEBjbGFzcyBVcGRhdGVFdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcbiAgICAgKi9cbiAgICB2YXIgVXBkYXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVXBkYXRlRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFVwZGF0ZUV2ZW50KGRlbHRhKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXBkYXRlRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5VcGRhdGVFdmVudCA9IFVwZGF0ZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBBY3RvciBvbmx5IG9uY2UgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgY2FsbFxuICAgICAqXG4gICAgICogQGNsYXNzIEluaXRpYWxpemVFdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gVGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBlbmdpbmVcbiAgICAgKi9cbiAgICB2YXIgSW5pdGlhbGl6ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEluaXRpYWxpemVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW5pdGlhbGl6ZUV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguSW5pdGlhbGl6ZUV2ZW50ID0gSW5pdGlhbGl6ZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIFNjZW5lIG9uIGFjdGl2YXRpb25cbiAgICAgKlxuICAgICAqIEBjbGFzcyBBY3RpdmF0ZUV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIG9sZFNjZW5lIHtTY2VuZX0gVGhlIHJlZmVyZW5jZSB0byB0aGUgb2xkIHNjZW5lXG4gICAgICovXG4gICAgdmFyIEFjdGl2YXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQWN0aXZhdGVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQWN0aXZhdGVFdmVudChvbGRTY2VuZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9sZFNjZW5lID0gb2xkU2NlbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFjdGl2YXRlRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5BY3RpdmF0ZUV2ZW50ID0gQWN0aXZhdGVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYSBTY2VuZSBvbiBkZWFjdGl2YXRpb25cbiAgICAgKlxuICAgICAqIEBjbGFzcyBEZWFjdGl2YXRlRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gbmV3U2NlbmUge1NjZW5lfSBUaGUgcmVmZXJlbmNlIHRvIHRoZSBuZXcgc2NlbmVcbiAgICAgKi9cbiAgICB2YXIgRGVhY3RpdmF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERlYWN0aXZhdGVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGVhY3RpdmF0ZUV2ZW50KG5ld1NjZW5lKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubmV3U2NlbmUgPSBuZXdTY2VuZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVhY3RpdmF0ZUV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguRGVhY3RpdmF0ZUV2ZW50ID0gRGVhY3RpdmF0ZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBBY3RvciB3aGVuIGl0IGNvbXBsZXRlbHkgbGVhdmVzIHRoZSBzY3JlZW4uXG4gICAgICogQGNsYXNzIEV4aXRWaWV3UG9ydEV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEV4aXRWaWV3UG9ydEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEV4aXRWaWV3UG9ydEV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFeGl0Vmlld1BvcnRFdmVudCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFeGl0Vmlld1BvcnRFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkV4aXRWaWV3UG9ydEV2ZW50ID0gRXhpdFZpZXdQb3J0RXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIEFjdG9yIHdoZW4gaXQgY29tcGxldGVseSBsZWF2ZXMgdGhlIHNjcmVlbi5cbiAgICAgKiBAY2xhc3MgRW50ZXJWaWV3UG9ydEV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEVudGVyVmlld1BvcnRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhFbnRlclZpZXdQb3J0RXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVudGVyVmlld1BvcnRFdmVudCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFbnRlclZpZXdQb3J0RXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5FbnRlclZpZXdQb3J0RXZlbnQgPSBFbnRlclZpZXdQb3J0RXZlbnQ7XG4gICAgLyoqXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBtb3VzZSBidXR0b25zXG4gICAgICogQGNsYXNzIE1vdXNlQnV0dG9uXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChNb3VzZUJ1dHRvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IExlZnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlQnV0dG9uW01vdXNlQnV0dG9uW1wiTWlkZGxlXCJdID0gMV0gPSBcIk1pZGRsZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IExlZnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXCJSaWdodFwiXSA9IDJdID0gXCJSaWdodFwiO1xuICAgIH0pKGV4Lk1vdXNlQnV0dG9uIHx8IChleC5Nb3VzZUJ1dHRvbiA9IHt9KSk7XG4gICAgdmFyIE1vdXNlQnV0dG9uID0gZXguTW91c2VCdXR0b247XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50cy50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogRXhjYWxpYnVyJ3MgaW50ZXJuYWwgZXZlbnQgZGlzcGF0Y2hlciBpbXBsZW1lbnRhdGlvbi4gQ2FsbGJhY2tzIGFyZSBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciBhbiBldmVudCBpcyBwdWJsaXNoZWRcbiAgICAgKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHRhcmdldCB7YW55fSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGUgcmVjaXBpZW50IG9mIGV2ZW50cyBmcm9tIHRoaXMgZXZlbnQgZGlzcGF0Y2hlclxuICAgICAqL1xuICAgIHZhciBFdmVudERpc3BhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2cgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IGZvciB0YXJnZXRcbiAgICAgICAgICogQG1ldGhvZCBwdWJsaXNoXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICAgICAgICogQHBhcmFtIFtldmVudD11bmRlZmluZWRdIHtHYW1lRXZlbnR9IE9wdGlvbmFsbHkgcGFzcyBhbiBldmVudCBkYXRhIG9iamVjdCB0byB0aGUgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8ga2V5IG5vdCBtYXBwZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBleC5HYW1lRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXIgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWUsIG11bHRpcGxlIGhhbmRsZXJzIHBlciBldmVudCBuYW1lIGFyZSBhbGxvd2VkLlxuICAgICAgICAgKiBAbWV0aG9kIHN1YnNjcmliZVxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG9cbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIge0dhbWVFdmVudD0+dm9pZH0gVGhlIGhhbmRsZXIgY2FsbGJhY2sgdG8gZmlyZSBvbiB0aGlzIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5zdWJzY3JpYmUgYSBldmVudCBoYW5kbGVyKHMpIGZyb20gYW4gZXZlbnQuIElmIGEgc3BlY2lmaWMgaGFuZGxlclxuICAgICAgICAgKiBpcyBzcGVjaWZpZWQgZm9yIGFuIGV2ZW50LCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogT3RoZXJ3aXNlIGFsbCBoYW5kbGVycyB3aWxsIGJlIHVuc3Vic2NyaWJlZCBmb3IgdGhhdCBldmVudC5cbiAgICAgICAgICogQG1ldGhvZCB1bnN1YnNjcmliZVxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB1bnN1YnNjcmliZVxuICAgICAgICAgKiBAcGFyYW0gW2hhbmRsZXI9dW5kZWZpbmVkXSBPcHRpb25hbGx5IHRoZSBzcGVjaWZpYyBoYW5kbGVyIHRvIHVuc3Vic2NyaWJlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGV4cGxpY2l0IGhhbmRsZXIgaXMgZ2l2ZSB3aXRoIHRoZSBldmVudCBuYW1lIGNsZWFyIGFsbCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudERpc3BhdGNoZXI7XG4gICAgfSkoKTtcbiAgICBleC5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBDb2xvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYW4gciwgZywgYiwgYVxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgQ29sb3JcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSByIHtudW1iZXJ9IFRoZSByZWQgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcbiAgICAgICAgICogQHBhcmFtIGcge251bWJlcn0gVGhlIGdyZWVuIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBiIHtudW1iZXJ9IFRoZSBibHVlIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBbYT0xXSB7bnVtYmVyfSBUaGUgYWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICgwLTEuMClcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENvbG9yKHIsIGcsIGIsIGEpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLmcgPSBnO1xuICAgICAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgICAgICB0aGlzLmEgPSAoYSAhPSBudWxsID8gYSA6IDEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYW4gciwgZywgYiwgYVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGZyb21SR0JcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gciB7bnVtYmVyfSBUaGUgcmVkIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBnIHtudW1iZXJ9IFRoZSBncmVlbiBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxuICAgICAgICAgKiBAcGFyYW0gYiB7bnVtYmVyfSBUaGUgYmx1ZSBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxuICAgICAgICAgKiBAcGFyYW0gW2E9MV0ge251bWJlcn0gVGhlIGFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAoMC0xLjApXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5mcm9tUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2NhbmNlIG9mIENvbG9yIGZyb20gYSBoZXggc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZnJvbUhleFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSBoZXgge3N0cmluZ30gQ1NTIGNvbG9yIHN0cmluZyBvZiB0aGUgZm9ybSAjZmZmZmZmLCB0aGUgYWxwaGEgY29tcG9uZW50IGlzIG9wdGlvbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5mcm9tSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgICAgICAgICAgdmFyIGhleFJlZ0V4ID0gL14jPyhbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSk/JC9pO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9IGhleC5tYXRjaChoZXhSZWdFeCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBwYXJzZUludChtYXRjaFs0XSwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBoZXggc3RyaW5nOiBcIiArIGhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxuICAgICAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICAgICAqIEByZXR1cm5zIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFN0cmluZyh0aGlzLnIudG9GaXhlZCgwKSkgKyBcIiwgXCIgKyBTdHJpbmcodGhpcy5nLnRvRml4ZWQoMCkpICsgXCIsIFwiICsgU3RyaW5nKHRoaXMuYi50b0ZpeGVkKDApKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmEgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmVzdWx0ICsgXCIsIFwiICsgU3RyaW5nKHRoaXMuYSkgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcInJnYihcIiArIHJlc3VsdCArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cbiAgICAgICAgICogQG1ldGhvZCBmaWxsU3R5bGVcbiAgICAgICAgICogQHJldHVybnMgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5wcm90b3R5cGUuZmlsbFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBjb2xvci5cbiAgICAgICAgICogQG1ldGhvZCBjbG9uZVxuICAgICAgICAgKiBAcmV0dXJucyBDb2xvclxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEJsYWNrIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkJsYWNrID0gQ29sb3IuZnJvbUhleCgnIzAwMDAwMCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFdoaXRlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLldoaXRlID0gQ29sb3IuZnJvbUhleCgnI0ZGRkZGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEdyYXkge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuR3JheSA9IENvbG9yLmZyb21IZXgoJyM4MDgwODAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBMaWdodEdyYXkge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuTGlnaHRHcmF5ID0gQ29sb3IuZnJvbUhleCgnI0QzRDNEMycpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IERhcmtHcmF5IHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkRhcmtHcmF5ID0gQ29sb3IuZnJvbUhleCgnI0E5QTlBOScpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFllbGxvdyB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5ZZWxsb3cgPSBDb2xvci5mcm9tSGV4KCcjRkZGRjAwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgT3JhbmdlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLk9yYW5nZSA9IENvbG9yLmZyb21IZXgoJyNGRkE1MDAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBSZWQge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuUmVkID0gQ29sb3IuZnJvbUhleCgnI0ZGMDAwMCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFZlcm1pbGxpb24ge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuVmVybWlsbGlvbiA9IENvbG9yLmZyb21IZXgoJyNGRjVCMzEnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBSb3NlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLlJvc2UgPSBDb2xvci5mcm9tSGV4KCcjRkYwMDdGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgTWFnZW50YSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5NYWdlbnRhID0gQ29sb3IuZnJvbUhleCgnI0ZGMDBGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFZpb2xldCB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5WaW9sZXQgPSBDb2xvci5mcm9tSGV4KCcjN0YwMEZGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgQmx1ZSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5CbHVlID0gQ29sb3IuZnJvbUhleCgnIzAwMDBGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEF6dXJlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkF6dXJlID0gQ29sb3IuZnJvbUhleCgnIzAwN0ZGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEN5YW4ge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuQ3lhbiA9IENvbG9yLmZyb21IZXgoJyMwMEZGRkYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBWaXJpZGlhbiB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5WaXJpZGlhbiA9IENvbG9yLmZyb21IZXgoJyM1OTk3OEYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBHcmVlbiB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5HcmVlbiA9IENvbG9yLmZyb21IZXgoJyMwMEZGMDAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBDaGFydHJldXNlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkNoYXJ0cmV1c2UgPSBDb2xvci5mcm9tSGV4KCcjN0ZGRjAwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgVHJhbnNwYXJlbnQge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuVHJhbnNwYXJlbnQgPSBDb2xvci5mcm9tSGV4KCcjRkZGRkZGMDAnKTtcbiAgICAgICAgcmV0dXJuIENvbG9yO1xuICAgIH0pKCk7XG4gICAgZXguQ29sb3IgPSBDb2xvcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBBY3RvciBwcmltaXRpdmUgZm9yIGRyYXdpbmcgVUkncywgb3B0aW1pemVkIGZvciBVSSBkcmF3aW5nLiBEb2VzXG4gICAgICogbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMuXG4gICAgICogQGNsYXNzIFVJQWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBBY3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbeD0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyB4IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFt5PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHkgY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW3dpZHRoPTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHdpZHRoIG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbaGVpZ2h0PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIGhlaWdodCBvZiB0aGUgYWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVUlBY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhVSUFjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBVSUFjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5Nb3ZlbWVudE1vZHVsZSgpKTtcbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUucHVzaChuZXcgZXguQ2FwdHVyZVBvaW50ZXJNb2R1bGUoKSk7XG4gICAgICAgICAgICB0aGlzLmFuY2hvci5zZXRUbygwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2FwdHVyZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFVJQWN0b3IucHJvdG90eXBlLm9uSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfTtcbiAgICAgICAgVUlBY3Rvci5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSwgdXNlV29ybGQpIHtcbiAgICAgICAgICAgIGlmICh1c2VXb3JsZCA9PT0gdm9pZCAwKSB7IHVzZVdvcmxkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHVzZVdvcmxkKVxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbnRhaW5zLmNhbGwodGhpcywgeCwgeSk7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5fZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhuZXcgZXguUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29udGFpbnMuY2FsbCh0aGlzLCBjb29yZHMueCwgY29vcmRzLnkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVUlBY3RvcjtcbiAgICB9KShleC5BY3Rvcik7XG4gICAgZXguVUlBY3RvciA9IFVJQWN0b3I7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgbWV0aG9kIG9mIGZpcmluZyBhcmJpdHJhcnkgY29kZSBvbiBjb2xsaXNpb24uIFRoZXNlIGFyZSB1c2VmdWxcbiAgICAgKiBhcyAnYnV0dG9ucycsICdzd2l0Y2hlcycsIG9yIHRvIHRyaWdnZXIgZWZmZWN0cyBpbiBhIGdhbWUuIEJ5IGRlZnVhbHQgdHJpZ2dlcnNcbiAgICAgKiBhcmUgaW52aXNpYmxlLCBhbmQgY2FuIG9ubHkgYmUgc2VlbiB3aXRoIGRlYnVnIG1vZGUgZW5hYmxlZCBvbiB0aGUgRW5naW5lLlxuICAgICAqIEBjbGFzcyBUcmlnZ2VyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt4PTBdIHtudW1iZXJ9IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIFt5PTBdIHtudW1iZXJ9IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIFt3aWR0aD0wXSB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0gW2hlaWdodD0wXSB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIFthY3Rpb249bnVsbF0geygpPT52b2lkfSBDYWxsYmFjayB0byBmaXJlIHdoZW4gdHJpZ2dlciBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAcGFyYW0gW3JlcGVhdHM9MV0ge251bWJlcn0gVGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoaXMgdHJpZ2dlciBzaG91bGQgZmlyZSwgYnkgZGVmYXVsdCBpdCBpcyAxLCBpZiAtMSBpcyBzdXBwbGllZCBpdCB3aWxsIGZpcmUgaW5kZWZpbml0ZWx5XG4gICAgICovXG4gICAgdmFyIFRyaWdnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVHJpZ2dlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVHJpZ2dlcih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBhY3Rpb24sIHJlcGVhdHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRzID0gMTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IHJlcGVhdHMgfHwgdGhpcy5yZXBlYXRzO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb24gfHwgdGhpcy5hY3Rpb247XG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblR5cGUgPSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBleC5FdmVudERpc3BhdGNoZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlID0gbmV3IGV4LkludGVybmFsLkFjdGlvbnMuQWN0aW9uUXVldWUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpb24gcXVldWVcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwbGFjZW1lbnRzIGJhc2VkIG9uIGxpbmVhciBhbGdlYnJhXG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy5keCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLmR5ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiArPSB0aGlzLnJ4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy5zY2FsZS54ICs9IHRoaXMuc3ggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgKz0gdGhpcy5zeSAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0cmlnZ2VyIGNvbGxpc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpZGVzKHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoQWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmdpbmUuY3VycmVudFNjZW5lLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGVuZ2luZS5jdXJyZW50U2NlbmUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlciAhPT0gdGhpcyAmJiBvdGhlci5jb2xsaXNpb25UeXBlICE9PSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi8gJiYgdGhpcy5jb2xsaWRlcyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hBY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmlnZ2VyIGlmIGl0cyBkb25lLCAtMSByZXBlYXQgZm9yZXZlclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMua2lsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS5kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdHMtLTtcbiAgICAgICAgfTtcbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBkb2VzIG5vdCBkcmF3XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcbiAgICAgICAgICAgIC8vIE1lYW50IHRvIGRyYXcgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgYWN0b3JzXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgYmIubGVmdCA9IGJiLmxlZnQgLSB0aGlzLmdldEdsb2JhbFgoKTtcbiAgICAgICAgICAgIGJiLnJpZ2h0ID0gYmIucmlnaHQgLSB0aGlzLmdldEdsb2JhbFgoKTtcbiAgICAgICAgICAgIGJiLnRvcCA9IGJiLnRvcCAtIHRoaXMuZ2V0R2xvYmFsWSgpO1xuICAgICAgICAgICAgYmIuYm90dG9tID0gYmIuYm90dG9tIC0gdGhpcy5nZXRHbG9iYWxZKCk7XG4gICAgICAgICAgICAvLyBDdXJyZW50bHkgY29sbGlzaW9uIHByaW1pdGl2ZXMgY2Fubm90IHJvdGF0ZSBcbiAgICAgICAgICAgIC8vIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZXguQ29sb3IuVmlvbGV0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBleC5Db2xvci5WaW9sZXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnVHJpZ2dlcicsIDEwLCAxMCk7XG4gICAgICAgICAgICBiYi5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUcmlnZ2VyO1xuICAgIH0pKGV4LkFjdG9yKTtcbiAgICBleC5UcmlnZ2VyID0gVHJpZ2dlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRW5naW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVdGlsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQW4gZW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHR5cGVzIG9mIGVtaXR0ZXIgbm96emxlc1xuICAgICAqIEBjbGFzcyBFbWl0dGVyVHlwZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoRW1pdHRlclR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IGZvciB0aGUgY2lyY3VsYXIgZW1pdHRlciB0eXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBDaXJjbGUge0VtaXR0ZXJUeXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJDaXJjbGVcIl0gPSAwXSA9IFwiQ2lyY2xlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCBmb3IgdGhlIHJlY3Rhbmd1bGFyIGVtaXR0ZXIgdHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkgUmVjdGFuZ2xlIHtFbWl0dGVyVHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIEVtaXR0ZXJUeXBlW0VtaXR0ZXJUeXBlW1wiUmVjdGFuZ2xlXCJdID0gMV0gPSBcIlJlY3RhbmdsZVwiO1xuICAgIH0pKGV4LkVtaXR0ZXJUeXBlIHx8IChleC5FbWl0dGVyVHlwZSA9IHt9KSk7XG4gICAgdmFyIEVtaXR0ZXJUeXBlID0gZXguRW1pdHRlclR5cGU7XG4gICAgdmFyIFBhcnRpY2xlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGUoZW1pdHRlciwgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgZXguVmVjdG9yKDAsIDApO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBleC5WZWN0b3IoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBleC5WZWN0b3IoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gMDtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBleC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5lbmRDb2xvciA9IGV4LkNvbG9yLldoaXRlLmNsb25lKCk7XG4gICAgICAgICAgICAvLyBMaWZlIGlzIGNvdW50ZWQgaW4gbXNcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IDMwMDtcbiAgICAgICAgICAgIHRoaXMuZmFkZUZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENvbG9yIHRyYW5zaXRpb25zXG4gICAgICAgICAgICB0aGlzLnJSYXRlID0gMTtcbiAgICAgICAgICAgIHRoaXMuZ1JhdGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5iUmF0ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmFSYXRlID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yID0gZXguQ29sb3IuV2hpdGUuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IDU7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2l6ZVJhdGUgPSAwO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IDA7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgICAgICAgICAgdGhpcy5saWZlID0gbGlmZSB8fCB0aGlzLmxpZmU7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5IHx8IHRoaXMub3BhY2l0eTtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sb3IgPSBlbmRDb2xvciB8fCB0aGlzLmVuZENvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBiZWdpbkNvbG9yIHx8IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IgPSB0aGlzLmJlZ2luQ29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5IHx8IHRoaXMudmVsb2NpdHk7XG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGFjY2VsZXJhdGlvbiB8fCB0aGlzLmFjY2VsZXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuclJhdGUgPSAodGhpcy5lbmRDb2xvci5yIC0gdGhpcy5iZWdpbkNvbG9yLnIpIC8gdGhpcy5saWZlO1xuICAgICAgICAgICAgdGhpcy5nUmF0ZSA9ICh0aGlzLmVuZENvbG9yLmcgLSB0aGlzLmJlZ2luQ29sb3IuZykgLyB0aGlzLmxpZmU7XG4gICAgICAgICAgICB0aGlzLmJSYXRlID0gKHRoaXMuZW5kQ29sb3IuYiAtIHRoaXMuYmVnaW5Db2xvci5iKSAvIHRoaXMubGlmZTtcbiAgICAgICAgICAgIHRoaXMuYVJhdGUgPSB0aGlzLm9wYWNpdHkgLyB0aGlzLmxpZmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2l6ZSA9IHN0YXJ0U2l6ZSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5lbmRTaXplID0gZW5kU2l6ZSB8fCAwO1xuICAgICAgICAgICAgaWYgKCh0aGlzLmVuZFNpemUgPiAwKSAmJiAodGhpcy5zdGFydFNpemUgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZVJhdGUgPSAodGhpcy5lbmRTaXplIC0gdGhpcy5zdGFydFNpemUpIC8gdGhpcy5saWZlO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gdGhpcy5zdGFydFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUGFydGljbGUucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlUGFydGljbGUodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IHRoaXMubGlmZSAtIGRlbHRhO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgKyBkZWx0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpZmUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5raWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mYWRlRmxhZykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGV4LlV0aWwuY2xhbXAodGhpcy5hUmF0ZSAqIHRoaXMubGlmZSwgMC4wMDAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5zdGFydFNpemUgPiAwKSAmJiAodGhpcy5lbmRTaXplID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IGV4LlV0aWwuY2xhbXAodGhpcy5zaXplUmF0ZSAqIGRlbHRhICsgdGhpcy5wYXJ0aWNsZVNpemUsIE1hdGgubWluKHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpLCBNYXRoLm1heCh0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvci5yID0gZXguVXRpbC5jbGFtcCh0aGlzLmN1cnJlbnRDb2xvci5yICsgdGhpcy5yUmF0ZSAqIGRlbHRhLCAwLCAyNTUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IuZyA9IGV4LlV0aWwuY2xhbXAodGhpcy5jdXJyZW50Q29sb3IuZyArIHRoaXMuZ1JhdGUgKiBkZWx0YSwgMCwgMjU1KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yLmIgPSBleC5VdGlsLmNsYW1wKHRoaXMuY3VycmVudENvbG9yLmIgKyB0aGlzLmJSYXRlICogZGVsdGEsIDAsIDI1NSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvci5hID0gZXguVXRpbC5jbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1cykge1xuICAgICAgICAgICAgICAgIHZhciBhY2NlbCA9IHRoaXMuZm9jdXMubWludXModGhpcy5wb3NpdGlvbikubm9ybWFsaXplKCkuc2NhbGUodGhpcy5mb2N1c0FjY2VsKS5zY2FsZShkZWx0YSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZChhY2NlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eS5hZGQodGhpcy5hY2NlbGVyYXRpb24uc2NhbGUoZGVsdGEgLyAxMDAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5hZGQodGhpcy52ZWxvY2l0eS5zY2FsZShkZWx0YSAvIDEwMDApKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Um90YXRpb24gPSAodGhpcy5jdXJyZW50Um90YXRpb24gKyB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICogZGVsdGEgLyAxMDAwKSAlICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFydGljbGVTcHJpdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLnNldFJvdGF0aW9uKHRoaXMuY3VycmVudFJvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLnNldFNjYWxlWCh0aGlzLnBhcnRpY2xlU2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5zZXRTY2FsZVkodGhpcy5wYXJ0aWNsZVNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUuZHJhdyhjdHgsIHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvci5hID0gZXguVXRpbC5jbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50Q29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIHRoaXMucGFydGljbGVTaXplLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGFydGljbGU7XG4gICAgfSkoKTtcbiAgICBleC5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xuICAgIC8qKlxuICAgICAqIFVzaW5nIGEgcGFydGljbGUgZW1pdHRlciBpcyBhIGdyZWF0IHdheSB0byBjcmVhdGUgaW50ZXJlc3RpbmcgZWZmZWN0c1xuICAgICAqIGluIHlvdXIgZ2FtZSwgbGlrZSBzbW9rZSwgZmlyZSwgd2F0ZXIsIGV4cGxvc2lvbnMsIGV0Yy4gUGFydGljbGUgRW1pdHRlcnNcbiAgICAgKiBleHRlbmQgQWN0b3IgYWxsb3dpbmcgeW91IHRvIHVzZSBhbGwgb2YgdGhlIGZlYXR1cmVzIHRoYXQgY29tZSB3aXRoIEFjdG9yXG4gICAgICogQGNsYXNzIFBhcnRpY2xlRW1pdHRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbeD0wXSB7bnVtYmVyfSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgZW1pdHRlclxuICAgICAqIEBwYXJhbSBbeT0wXSB7bnVtYmVyfSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgZW1pdHRlclxuICAgICAqIEBwYXJhbSBbd2lkdGg9MF0ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBlbWl0dGVyXG4gICAgICogQHBhcmFtIFtoZWlnaHQ9MF0ge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgZW1pdHRlclxuICAgICAqL1xuICAgIHZhciBQYXJ0aWNsZUVtaXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUGFydGljbGVFbWl0dGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBQYXJ0aWNsZUVtaXR0ZXIoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIGhlaWdodCwgZXguQ29sb3IuV2hpdGUpO1xuICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ID0gMDtcbiAgICAgICAgICAgIHRoaXMubnVtUGFydGljbGVzID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBpc0VtaXR0aW5nIGZsYWdcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpc0VtaXR0aW5nIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzRW1pdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgcGFydGljbGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHBhcnRpY2xlcyB7VXRpbC5Db2xsZWN0aW9uJmx0O1BhcnRpY2xlJmd0O31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgZGVhZFBhcnRpY2xlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBwYXJ0aWNsZXMge1V0aWwuQ29sbGVjdGlvbiZsdDtQYXJ0aWNsZSZndDt9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcyA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBwYXJ0aWNhbCB2ZWxvY2l0eVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFttaW5WZWw9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5taW5WZWwgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gcGFydGljYWwgdmVsb2NpdHlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWF4VmVsPTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWF4VmVsID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIGZvciBhbGwgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2FjY2VsZXJhdGlvbj1uZXcgVmVjdG9yKDAsMCldIHtWZWN0b3J9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IGV4LlZlY3RvcigwLCAwKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWluQW5nbGU9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5taW5BbmdsZSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBhbmdsZSBpbiByYWRpYW5zXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW21heEFuZ2xlPTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWF4QW5nbGUgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXNzaW9uIHJhdGUgZm9yIHBhcnRpY2xlcyAocGFydGljbGVzL3NlYylcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZW1pdFJhdGU9MV0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbWl0UmF0ZSA9IDE7IC8vcGFydGljbGVzL3NlY1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxpZmUgb2YgZWFjaCBwYXJ0aWNsZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcGFydGljbGVMaWZlPTIwMDBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFydGljbGVMaWZlID0gMjAwMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcGFjaXR5IG9mIGVhY2ggcGFydGljbGUgZnJvbSAwIHRvIDEuMFxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtvcGFjaXR5PTEuMF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBmYWRlIGZsYWcgd2hpY2ggY2F1c2VzIHBhcnRpY2xlcyB0byBncmFkdWFsbHkgZmFkZSBvdXQgb3ZlciB0aGUgY291cnNlIG9mIHRoZWlyIGxpZmUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2ZhZGU9ZmFsc2VdIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZhZGVGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgZm9jdXMgd2hlcmUgYWxsIHBhcnRpY2xlcyBzaG91bGQgYWNjZWxlcmF0ZSB0b3dhcmRzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2ZvY3VzPW51bGxdIHtWZWN0b3J9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGFjY2VsZXJhdGlvbiBmb3IgZm9jdXNpbmcgcGFydGljbGVzIGlmIGEgZm9jdXMgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2ZvY3VzQWNjZWw9MV0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gMTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIHN0YXJ0aW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbc3RhcnRTaXplPW51bGxdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaXplID0gbnVsbDtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIGVuZGluZyBzaXplIGZvciB0aGUgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2VuZFNpemU9bnVsbF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbmRTaXplID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFttaW5TaXplPTVdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWluU2l6ZSA9IDU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBzaXplIG9mIGFsbCBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWF4U2l6ZT01XSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1heFNpemUgPSA1O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJlZ2lubmluZyBjb2xvciBvZiBhbGwgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2JlZ2luQ29sb3I9Q29sb3IuV2hpdGVdIHtDb2xvcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gZXguQ29sb3IuV2hpdGU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW5kaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZW5kQ29sb3I9Q29sb3IuV2hpdGVdIHtDb2xvcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbmRDb2xvciA9IGV4LkNvbG9yLldoaXRlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHNwcml0ZSB0aGF0IGEgcGFydGljbGUgc2hvdWxkIHVzZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtwYXJ0aWNsZVNwcml0ZT1udWxsXSB7U3ByaXRlfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWl0dGVyIHR5cGUgZm9yIHRoZSBwYXJ0aWNsZSBlbWl0dGVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2VtaXR0ZXJUeXBlPUVtaXR0ZXJUeXBlLlJlY3RhbmdsZV0ge0VtaXR0ZXJUeXBlfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXJUeXBlID0gMSAvKiBSZWN0YW5nbGUgKi87XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pdHRlciByYWRpdXMsIG9ubHkgdGFrZXMgZWZmZWN0IHdoZW4gdGhlIGVtaXR0ZXJUeXBlIGlzIENpcmNsZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtyYWRpdXM9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHBhcnRpY2xlIHJvdGF0aW9uYWwgc3BlZWQgdmVsb2NpdHlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHk9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHBhcnRpY2xlcyBzaG91bGQgc3RhcnQgd2l0aCBhIHJhbmRvbSByb3RhdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtyYW5kb21Sb3RhdGlvbj1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmFuZG9tUm90YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzID0gbmV3IGV4LlV0aWwuQ29sbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzID0gbmV3IGV4LlV0aWwuQ29sbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlUGFydGljbGUgPSBmdW5jdGlvbiAocGFydGljbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcy5wdXNoKHBhcnRpY2xlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdXNlcyB0aGUgZW1pdHRlciB0byBlbWl0IHBhcnRpY2xlc1xuICAgICAgICAgKiBAbWV0aG9kIGVtaXRcbiAgICAgICAgICogQHBhcmFtIHBhcnRpY2xlQ291bnQge251bWJlcn0gTnVtYmVyIG9mIHBhcnRpY2xlcyB0byBlbWl0IHJpZ2h0IG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHBhcnRpY2xlQ291bnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGljbGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaCh0aGlzLmNyZWF0ZVBhcnRpY2xlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmNsZWFyUGFydGljbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuY2xlYXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5ldyBwYXJ0aWNsZSBnaXZlbiB0aGUgY29udHJhaW50cyBvZiB0aGUgZW1pdHRlclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmNyZWF0ZVBhcnRpY2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdG9kbyBpbXBsZW1lbnQgZW1pdHRlciBjb250cmFpbnRzO1xuICAgICAgICAgICAgdmFyIHJhblggPSAwO1xuICAgICAgICAgICAgdmFyIHJhblkgPSAwO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gZXguVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluQW5nbGUsIHRoaXMubWF4QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHZlbCA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLm1pblZlbCwgdGhpcy5tYXhWZWwpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnN0YXJ0U2l6ZSB8fCBleC5VdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5taW5TaXplLCB0aGlzLm1heFNpemUpO1xuICAgICAgICAgICAgdmFyIGR4ID0gdmVsICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgdmFyIGR5ID0gdmVsICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW1pdHRlclR5cGUgPT09IDEgLyogUmVjdGFuZ2xlICovKSB7XG4gICAgICAgICAgICAgICAgcmFuWCA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLngsIHRoaXMueCArIHRoaXMuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgcmFuWSA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLnksIHRoaXMueSArIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gMCAvKiBDaXJjbGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gZXguVXRpbC5yYW5kb21JblJhbmdlKDAsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgICAgICAgICByYW5YID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpICsgdGhpcy54O1xuICAgICAgICAgICAgICAgIHJhblkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkgKyB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQYXJ0aWNsZSh0aGlzLCB0aGlzLnBhcnRpY2xlTGlmZSwgdGhpcy5vcGFjaXR5LCB0aGlzLmJlZ2luQ29sb3IsIHRoaXMuZW5kQ29sb3IsIG5ldyBleC5WZWN0b3IocmFuWCwgcmFuWSksIG5ldyBleC5WZWN0b3IoZHgsIGR5KSwgdGhpcy5hY2NlbGVyYXRpb24sIHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpO1xuICAgICAgICAgICAgcC5mYWRlRmxhZyA9IHRoaXMuZmFkZUZsYWc7XG4gICAgICAgICAgICBwLnBhcnRpY2xlU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xuICAgICAgICAgICAgICAgIHAucGFydGljbGVTcHJpdGUgPSB0aGlzLnBhcnRpY2xlU3ByaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5kb21Sb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHAuY3VycmVudFJvdGF0aW9uID0gZXguVXRpbC5yYW5kb21JblJhbmdlKDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgcC5mb2N1cyA9IHRoaXMuZm9jdXMuYWRkKG5ldyBleC5WZWN0b3IodGhpcy54LCB0aGlzLnkpKTtcbiAgICAgICAgICAgICAgICBwLmZvY3VzQWNjZWwgPSB0aGlzLmZvY3VzQWNjZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZW5naW5lLCBkZWx0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VtaXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ICs9IHRoaXMuZW1pdFJhdGUgKiAoZGVsdGEgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtUGFydGljbGVzID0gTWF0aC5jZWlsKHRoaXMuZW1pdFJhdGUgKiBkZWx0YSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPiAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA9IHRoaXMuX3BhcnRpY2xlc1RvRW1pdCAtIE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydGljbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFydGljbGVzLnJlbW92ZUVsZW1lbnQocGFydGljbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMuY2xlYXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8gaXMgdGhlcmUgYSBtb3JlIGVmZmljaWVudCB0byBkcmF3IFxuICAgICAgICAgICAgICAgIC8vIHBvc3NpYmx5IHVzZSBhIHdlYmdsIG9mZnNjcmVlbiBjYW52YXMgYW5kIHNoYWRlcnMgdG8gZG8gcGFydGljbGVzP1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBleC5Db2xvci5CbGFjay50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiUGFydGljbGVzOiBcIiArIHRoaXMucGFydGljbGVzLmNvdW50KCksIHRoaXMueCwgdGhpcy55ICsgMjApO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodGhpcy5mb2N1cy54ICsgdGhpcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnksIDMsIDMpO1xuICAgICAgICAgICAgICAgIGV4LlV0aWwuZHJhd0xpbmUoY3R4LCBcInllbGxvd1wiLCB0aGlzLmZvY3VzLnggKyB0aGlzLngsIHRoaXMuZm9jdXMueSArIHRoaXMueSwgX3N1cGVyLnByb3RvdHlwZS5nZXRDZW50ZXIuY2FsbCh0aGlzKS54LCBfc3VwZXIucHJvdG90eXBlLmdldENlbnRlci5jYWxsKHRoaXMpLnkpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIkZvY3VzXCIsIHRoaXMuZm9jdXMueCArIHRoaXMueCwgdGhpcy5mb2N1cy55ICsgdGhpcy55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlRW1pdHRlcjtcbiAgICB9KShleC5BY3Rvcik7XG4gICAgZXguUGFydGljbGVFbWl0dGVyID0gUGFydGljbGVFbWl0dGVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBbmltYXRpb25zIGFsbG93IHlvdSB0byBkaXNwbGF5IGEgc2VyaWVzIG9mIGltYWdlcyBvbmUgYWZ0ZXIgYW5vdGhlcixcbiAgICAgKiBjcmVhdGluZyB0aGUgaWxsdXNpb24gb2YgY2hhbmdlLiBHZW5lcmFsbHkgdGhlc2UgaW1hZ2VzIHdpbGwgY29tZSBmcm9tIGEgc3ByaXRlIHNoZWV0IHNvdXJjZS5cbiAgICAgKiBAY2xhc3MgQW5pbWF0aW9uXG4gICAgICogQGV4dGVuZHMgSURyYXdhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcbiAgICAgKiBAcGFyYW0gaW1hZ2VzIHtTcHJpdGVbXX0gQW4gYXJyYXkgb2Ygc3ByaXRlcyB0byBjcmVhdGUgdGhlIGZyYW1lcyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBbbG9vcD1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3AgYWZ0ZXIgaXQgaXMgY29tcGxldGVkXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQsIGxvb3ApIHtcbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMub2xkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSAxLjA7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IDEuMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcCBhZnRlciBpdCBpcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbG9vcD1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZSA9IC0xO1xuICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gaW1hZ2VzO1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgICAgICBpZiAobG9vcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaW1hZ2VzWzBdID8gaW1hZ2VzWzBdLmhlaWdodCA6IDA7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gaW1hZ2VzWzBdID8gaW1hZ2VzWzBdLndpZHRoIDogMDtcbiAgICAgICAgfVxuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmFkZEVmZmVjdChlZmZlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnJlbW92ZUVmZmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0ucmVtb3ZlRWZmZWN0KHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5jbGVhckVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5jbGVhckVmZmVjdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS50cmFuc2Zvcm1BYm91dFBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS50cmFuc2Zvcm1BYm91dFBvaW50KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIChyYWRpYW5zKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gcmFkaWFucztcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnNldFJvdGF0aW9uKHJhZGlhbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb247XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2V0U2NhbGVYID0gZnVuY3Rpb24gKHNjYWxlWCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5zZXRTY2FsZVgoc2NhbGVYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRTY2FsZVkgPSBmdW5jdGlvbiAoc2NhbGVZKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnNldFNjYWxlWShzY2FsZVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmdldFNjYWxlWCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWDtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRTY2FsZVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGFuaW1hdGlvbiB0byBmaXJzdCBmcmFtZS5cbiAgICAgICAgICogQG1ldGhvZCByZXNldFxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUsIGFuaW1hdGlvbnMgdGhhdCBsb29wIGFyZSBuZXZlciBjb21wbGV0ZS5cbiAgICAgICAgICogQG1ldGhvZCBpc0RvbmVcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmxvb3AgJiYgdGhpcy5jdXJySW5kZXggPj0gdGhpcy5zcHJpdGVzLmxlbmd0aCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGdhbWUgZGV2ZWxvcGVycy4gVGlja3MgdGhlIGFuaW1hdGlvbiBmb3J3YXJkIGludGVybmFsbHkgYW5cbiAgICAgICAgICogY2FsY3VsYXRlcyB3aGV0aGVyIHRvIGNoYW5nZSB0byB0ZWggZnJhbWUuXG4gICAgICAgICAqIEBtZXRob2QgdGlja1xuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKCh0aW1lIC0gdGhpcy5vbGRUaW1lKSA+IHRoaXMuc3BlZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJJbmRleCA9ICh0aGlzLmxvb3AgPyAodGhpcy5jdXJySW5kZXggKyAxKSAlIHRoaXMuc3ByaXRlcy5sZW5ndGggOiB0aGlzLmN1cnJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2xkVGltZSA9IHRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTa2lwcyBhaGVhZCBhIHNwZWNpZmllZCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZCBza2lwXG4gICAgICAgICAqIEBwYXJhbSBmcmFtZXMge251bWJlcn0gRnJhbWVzIHRvIHNraXAgYWhlYWRcbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIChmcmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gKHRoaXMuY3VyckluZGV4ICsgZnJhbWVzKSAlIHRoaXMuc3ByaXRlcy5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyckluZGV4IDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyU3ByaXRlID0gdGhpcy5zcHJpdGVzW3RoaXMuY3VyckluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyclNwcml0ZS5mbGlwVmVydGljYWwgPSB0aGlzLmZsaXBWZXJ0aWNhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxpcEhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyclNwcml0ZS5mbGlwSG9yaXpvbnRhbCA9IHRoaXMuZmxpcEhvcml6b250YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZHJhdyhjdHgsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZnJlZXplRnJhbWUgIT09IC0xICYmIHRoaXMuY3VyckluZGV4ID49IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclNwcml0ZSA9IHRoaXMuc3ByaXRlc1tleC5VdGlsLmNsYW1wKHRoaXMuZnJlZXplRnJhbWUsIDAsIHRoaXMuc3ByaXRlcy5sZW5ndGggLSAxKV07XG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGN0eCwgeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGF5cyBhbiBhbmltYXRpb24gYXQgYW4gYXJiaXRyYXJ5IGxvY2F0aW9uIGluIHRoZSBnYW1lLlxuICAgICAgICAgKiBAbWV0aG9kIHBsYXlcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn0gVGhlIHggcG9zaXRpb24gaW4gdGhlIGdhbWUgdG8gcGxheVxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB0byBwbGF5XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUucGxheUFuaW1hdGlvbih0aGlzLCB4LCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbjtcbiAgICB9KSgpO1xuICAgIGV4LkFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9ua2V5UGF0Y2gudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlV0aWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvZy50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIEludGVybmFsO1xuICAgIChmdW5jdGlvbiAoSW50ZXJuYWwpIHtcbiAgICAgICAgdmFyIEZhbGxiYWNrQXVkaW8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRmFsbGJhY2tBdWRpbyhwYXRoLCB2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJVc2luZyBuZXcgV2ViIEF1ZGlvIEFwaSBmb3IgXCIgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwgPSBuZXcgV2ViQXVkaW8ocGF0aCwgdm9sdW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwiRmFsbGluZyBiYWNrIHRvIEF1ZGlvIEVsZW1lbnQgZm9yIFwiICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsID0gbmV3IEF1ZGlvVGFnKHBhdGgsIHZvbHVtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLnNldFZvbHVtZSh2b2x1bWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLnNldExvb3AobG9vcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5vbmxvYWQgPSB0aGlzLm9ubG9hZDtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwubG9hZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZEltcGwuaXNQbGF5aW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZEltcGwucGxheSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLnBhdXNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5zdG9wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrQXVkaW87XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEludGVybmFsLkZhbGxiYWNrQXVkaW8gPSBGYWxsYmFja0F1ZGlvO1xuICAgICAgICB2YXIgQXVkaW9UYWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQXVkaW9UYWcocGF0aCwgdm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50cyA9IG5ldyBBcnJheSg1KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZWRBdWRpbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXVkaW9FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvRWxlbWVudHNbaV0gPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWb2x1bWUoZXguVXRpbC5jbGFtcCh2b2x1bWUsIDAsIDEuMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWb2x1bWUoMS4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLmF1ZGlvTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYS52b2x1bWUgPSB2b2x1bWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEubG9vcCA9IGxvb3A7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLmdldExvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubG9vcDsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgYXVkaW8gcmVzb3VyY2UgXCIsIF90aGlzLnBhdGgsIFwiIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlXCIsIHJlcXVlc3Quc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2FkZWRBdWRpbyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5zcmMgPSBfdGhpcy5fbG9hZGVkQXVkaW87XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmxvYWQoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50c1t0aGlzLmluZGV4XS5sb2FkKCk7XG4gICAgICAgICAgICAgICAgLy90aGlzLmF1ZGlvRWxlbWVudHNbdGhpcy5pbmRleF0uY3VycmVudFRpbWUgPSB0aGlzLl9jdXJyZW50T2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50c1t0aGlzLmluZGV4XS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdldExvb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHNbdGhpcy5pbmRleF0uYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gKHRoaXMuaW5kZXggKyAxKSAlIHRoaXMuYXVkaW9FbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAodGhpcy5pbmRleCAtIDEgKyB0aGlzLmF1ZGlvRWxlbWVudHMubGVuZ3RoKSAlIHRoaXMuYXVkaW9FbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IHRoaXMuYXVkaW9FbGVtZW50c1t0aGlzLmluZGV4XS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBhLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICAvL2EuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBBdWRpb1RhZztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgSW50ZXJuYWwuQXVkaW9UYWcgPSBBdWRpb1RhZztcbiAgICAgICAgaWYgKHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb0NvbnRleHQgPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBXZWJBdWRpbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBXZWJBdWRpbyhzb3VuZFBhdGgsIHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHNvdW5kUGF0aDtcbiAgICAgICAgICAgICAgICBpZiAodm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLmdhaW4udmFsdWUgPSBleC5VdGlsLmNsYW1wKHZvbHVtZSwgMCwgMS4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLmdhaW4udmFsdWUgPSAxLjA7IC8vIG1heCB2b2x1bWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLmdhaW4udmFsdWUgPSB2b2x1bWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGF1ZGlvIHJlc291cmNlIFwiLCBfdGhpcy5wYXRoLCBcIiBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZVwiLCByZXF1ZXN0LnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YShyZXF1ZXN0LnJlc3BvbnNlLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmxvYWQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSBcIiArIF90aGlzLnBhdGggKyBcIiB0aGlzIGJyb3dzZXIgbWF5IG5vdCBmdWxseSBzdXBwb3J0IHRoaXMgZm9ybWF0LCBvciB0aGUgZmlsZSBtYXkgYmUgY29ycnVwdCwgXCIgKyBcImlmIHRoaXMgaXMgYW4gbXAzIHRyeSByZW1vdmluZyBpZDMgdGFncyBhbmQgYWxidW0gYXJ0IGZyb20gdGhlIGZpbGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9ubG9hZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHNvdW5kISBJZiB0aGlzIGlzIGEgY3Jvc3Mgb3JpZ2luIGVycm9yLCB5b3UgbXVzdCBob3N0IHlvdXIgc291bmQgd2l0aCB5b3VyIGh0bWwgYW5kIGphdmFzY3JpcHQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLmxvb3AgPSB0aGlzLmxvb3A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQuY29ubmVjdCh0aGlzLnZvbHVtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5zdGFydCgwLCB0aGlzLl9jdXJyZW50T2Zmc2V0ICUgdGhpcy5idWZmZXIuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQgfHwgIXRoaXMuX3BsYXlQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0aGlzLl9wbGF5UHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5vbmVuZGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxheVByb21pc2UgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleC5Qcm9taXNlLndyYXAodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3BsYXlpbmdUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLnN0b3AoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGUgc291bmQgY2xpcFwiLCB0aGlzLnBhdGgsIFwiaGFzIGFscmVhZHkgYmVlbiBwYXVzZWQhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3BsYXlpbmdUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc3RvcCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoZSBzb3VuZCBjbGlwXCIsIHRoaXMucGF0aCwgXCJoYXMgYWxyZWFkeSBiZWVuIHN0b3BwZWQhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBXZWJBdWRpbztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgSW50ZXJuYWwuV2ViQXVkaW8gPSBXZWJBdWRpbztcbiAgICB9KShJbnRlcm5hbCA9IGV4LkludGVybmFsIHx8IChleC5JbnRlcm5hbCA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvZy50c1wiIC8+XG4vLyBQcm9taXNlcy9BKyBTcGVjIGh0dHA6Ly9wcm9taXNlcy1hcGx1cy5naXRodWIuaW8vcHJvbWlzZXMtc3BlYy9cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCBzdGF0ZXMgZm9yIGEgcHJvbWlzZSB0byBiZSBpblxuICAgICAqIEBjbGFzcyBQcm9taXNlU3RhdGVcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKFByb21pc2VTdGF0ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFJlc29sdmVkIHtQcm9taXNlU3RhdGV9XG4gICAgICAgICovXG4gICAgICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJSZXNvbHZlZFwiXSA9IDBdID0gXCJSZXNvbHZlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFJlamVjdGVkIHtQcm9taXNlU3RhdGV9XG4gICAgICAgICovXG4gICAgICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJSZWplY3RlZFwiXSA9IDFdID0gXCJSZWplY3RlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFBlbmRpbmcge1Byb21pc2VTdGF0ZX1cbiAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlBlbmRpbmdcIl0gPSAyXSA9IFwiUGVuZGluZ1wiO1xuICAgIH0pKGV4LlByb21pc2VTdGF0ZSB8fCAoZXguUHJvbWlzZVN0YXRlID0ge30pKTtcbiAgICB2YXIgUHJvbWlzZVN0YXRlID0gZXguUHJvbWlzZVN0YXRlO1xuICAgIC8qKlxuICAgICAqIFByb21pc2VzL0ErIHNwZWMgaW1wbGVtZW50YXRpb24gb2YgcHJvbWlzZXNcbiAgICAgKiBAY2xhc3MgUHJvbWlzZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUHJvbWlzZSgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMiAvKiBQZW5kaW5nICovO1xuICAgICAgICAgICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICB0aGlzLnJlamVjdENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXAgYSB2YWx1ZSBpbiBhIHJlc29sdmVkIHByb21pc2VcbiAgICAgICAgICogQG1ldGhvZCB3cmFwPFQ+XG4gICAgICAgICAqIEBwYXJhbSBbdmFsdWU9dW5kZWZpbmVkXSB7VH0gQW4gb3B0aW9uYWwgdmFsdWUgdG8gd3JhcCBpbiBhIHJlc29sdmVkIHByb21pc2VcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtUJmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS53cmFwID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IChuZXcgUHJvbWlzZSgpKS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgdGhlIHByb21pc2VzIHBhc3NlZCB0byBpdCByZXNvbHZlLCBvciByZWplY3RzXG4gICAgICAgICAqIHdoZW4gYXQgbGVhc3QgMSBwcm9taXNlIHJlamVjdHMuXG4gICAgICAgICAqIEBwYXJhbSBwcm9taXNlcyB7UHJvbWlzZVtdfVxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlXG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLmpvaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgam9pbmVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XG4gICAgICAgICAgICBpZiAoIXByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpvaW5lZFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvdGFsID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NlcyA9IDA7XG4gICAgICAgICAgICB2YXIgcmVqZWN0cyA9IDA7XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICBwcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2VzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgPT09IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdWNjZXNzZXMgKyByZWplY3RzICsgZXJyb3JzLmxlbmd0aCA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdHMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIHJlamVjdHMgKyBlcnJvcnMubGVuZ3RoID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGVycm9ycy5sZW5ndGggKyBzdWNjZXNzZXMgKyByZWplY3RzKSA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW5lZFByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFpbiBzdWNjZXNzIGFuZCByZWplY3QgY2FsbGJhY2tzIGFmdGVyIHRoZSBwcm9taXNlIGlzIHJlc292bGVkXG4gICAgICAgICAqIEBtZXRob2QgdGhlblxuICAgICAgICAgKiBAcGFyYW0gc3VjY2Vzc0NhbGxiYWNrIHtUPT5hbnl9IENhbGwgb24gcmVzb2x1dGlvbiBvZiBwcm9taXNlXG4gICAgICAgICAqIEBwYXJhbSByZWplY3RDYWxsYmFjayB7YW55PT5hbnl9IENhbGwgb24gcmVqZWN0aW9uIG9mIHByb21pc2VcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtUJmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChzdWNjZXNzQ2FsbGJhY2ssIHJlamVjdENhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2tzLnB1c2goc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc292bGVkIGNhbGwgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID09PSAwIC8qIFJlc29sdmVkICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWplY3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0Q2FsbGJhY2sgPSByZWplY3RDYWxsYmFjaztcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlamVjdGVkIGNhbGwgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID09PSAxIC8qIFJlamVjdGVkICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW4gZXJyb3IgY2FsbGJhY2sgdG8gdGhlIHByb21pc2VcbiAgICAgICAgICogQG1ldGhvZCBlcnJvclxuICAgICAgICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFjayB7YW55PT5hbnl9IENhbGwgaWYgdGhlcmUgd2FzIGFuIGVycm9yIGluIGEgY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtUJmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yQ2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlIHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcbiAgICAgICAgICogQG1ldGhvZCByZXNvbHZlXG4gICAgICAgICAqIEBwYXJhbSBbdmFsdWU9dW5kZWZpbmVkXSB7VH0gVmFsdWUgdG8gcGFzcyB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcbiAgICAgICAgICovXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDIgLyogUGVuZGluZyAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDAgLyogUmVzb2x2ZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChfdGhpcywgX3RoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB0aGF0IGlzIG5vdCBpbiBhIHBlbmRpbmcgc3RhdGUhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlamVjdCB0aGUgcHJvbWlzZSBhbmQgcGFzcyBhbiBvcHRpb24gdmFsdWUgdG8gdGhlIHJlamVjdCBjYWxsYmFja3NcbiAgICAgICAgICogQG1ldGhvZCByZWplY3RcbiAgICAgICAgICogQHBhcmFtIFt2YWx1ZT11bmRlZmluZWRdIHtUfSBWYWx1ZSB0byBwYXNzIHRvIHRoZSByZWplY3QgY2FsbGJhY2tzXG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMiAvKiBQZW5kaW5nICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBSZWplY3RlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlamVjdCBhIHByb21pc2UgdGhhdCBpcyBub3QgaW4gYSBwZW5kaW5nIHN0YXRlIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnBlY3QgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBwcm9taXNlXG4gICAgICAgICAqIEBtZXRob2Qgc3RhdGVcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVN0YXRlXG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JDYWxsYmFjay5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2U7XG4gICAgfSkoKTtcbiAgICBleC5Qcm9taXNlID0gUHJvbWlzZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW50ZXJmYWNlcy9JTG9hZGFibGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBSZXNvdXJjZSB0eXBlIGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBnZW5lcmljIHJlc291cmNlcy5cbiAgICAgKiBGb3IgYW55IHR5cGUgb2YgcmVtb3RlIHJlc291cmNlIGl0IGlzIHJlY29tZVxuICAgICAqIEBjbGFzcyBSZXNvdXJjZVxuICAgICAqIEBleHRlbmQgSUxvYWRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gUGF0aCB0byB0aGUgcmVtb3RlIHJlc291cmNlXG4gICAgICovXG4gICAgdmFyIFJlc291cmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVzb3VyY2UocGF0aCwgcmVzcG9uc2VUeXBlLCBidXN0Q2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChidXN0Q2FjaGUgPT09IHZvaWQgMCkgeyBidXN0Q2FjaGUgPSB0cnVlOyB9XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICAgICAgICB0aGlzLmJ1c3RDYWNoZSA9IGJ1c3RDYWNoZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFJlc291cmNlIGlzIGNvbXBsZXRlbHkgbG9hZGVkIGFuZCBpcyByZWFkeVxuICAgICAgICAgKiB0byBiZSBkcmF3bi5cbiAgICAgICAgICogQG1ldGhvZCBpc0xvYWRlZFxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICB9O1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuY2FjaGVCdXN0ID0gZnVuY3Rpb24gKHVyaSkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gL1xcP1xcdyo9XFx3Ki87XG4gICAgICAgICAgICBpZiAocXVlcnkudGVzdCh1cmkpKSB7XG4gICAgICAgICAgICAgICAgdXJpICs9IChcIiZfXz1cIiArIERhdGUubm93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJpICs9IChcIj9fXz1cIiArIERhdGUubm93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVyaTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN0YXJ0ZWQgbG9hZGluZyByZXNvdXJjZSBcIiArIHRoaXMucGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWdpbiBsb2FkaW5nIHRoZSByZXNvdXJjZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDthbnkmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB0aGlzLmJ1c3RDYWNoZSA/IHRoaXMuY2FjaGVCdXN0KHRoaXMucGF0aCkgOiB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2Fkc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdGFydChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcmVzb3VyY2UgXCIsIF90aGlzLnBhdGgsIFwiIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlXCIsIHJlcXVlc3Quc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRhID0gX3RoaXMucHJvY2Vzc0Rvd25sb2FkKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoXCJDb21wbGV0ZWQgbG9hZGluZyByZXNvdXJjZVwiLCBfdGhpcy5wYXRoKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLmRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbG9hZGVkIGRhdGEgb25jZSB0aGUgcmVzb3VyY2UgaXMgbG9hZGVkXG4gICAgICAgICAqIEBtZXRob2QgR2V0RGF0YVxuICAgICAgICAgKiBAcmV0dXJucyBhbnlcbiAgICAgICAgICovXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiB0byBoYW5kbGUgYW55IGFkZGl0aW9uYWxcbiAgICAgICAgICogcHJvY2Vzc2luZy4gU3VjaCBhcyBkZWNvZGluZyBkb3dubG9hZGVkIGF1ZGlvIGJpdHMuXG4gICAgICAgICAqIEBtZXRob2QgUHJvY2Vzc0Rvd25sb2FkXG4gICAgICAgICAqL1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUucHJvY2Vzc0Rvd25sb2FkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhbnkgYWRkaXRpb25hbCBsb2FkaW5nIGFmdGVyIHRoZSB4aHIgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVzb3VyY2U7XG4gICAgfSkoKTtcbiAgICBleC5SZXNvdXJjZSA9IFJlc291cmNlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTb3VuZC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVXRpbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUHJvbWlzZXMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlc291cmNlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJbnRlcmZhY2VzL0lMb2FkYWJsZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogVGhlIFRleHR1cmUgb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBpbWFnZSByZXNvdXJjZXMuXG4gICAgICogSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkIHRvIHByZWxvYWQgaW1hZ2VzIHVzaW5nIHRoZSBcIlRleHR1cmVcIiBvYmplY3QuXG4gICAgICogQGNsYXNzIFRleHR1cmVcbiAgICAgKiBAZXh0ZW5kIFJlc291cmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gUGF0aCB0byB0aGUgaW1hZ2UgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0gW2J1c3RDYWNoZT10cnVlXSB7Ym9vbGVhbn0gT3B0aW9uYWxseSBsb2FkIHRleHR1cmUgd2l0aCBjYWNoZSBidXN0aW5nXG4gICAgICovXG4gICAgdmFyIFRleHR1cmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVGV4dHVyZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVGV4dHVyZShwYXRoLCBidXN0Q2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChidXN0Q2FjaGUgPT09IHZvaWQgMCkgeyBidXN0Q2FjaGUgPSB0cnVlOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBwYXRoLCAnYmxvYicsIGJ1c3RDYWNoZSk7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZSA9IG5ldyBleC5TcHJpdGUodGhpcywgMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVGV4dHVyZSBpcyBjb21wbGV0ZWx5IGxvYWRlZCBhbmQgaXMgcmVhZHlcbiAgICAgICAgICogdG8gYmUgZHJhd24uXG4gICAgICAgICAqIEBtZXRob2QgaXNMb2FkZWRcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMb2FkZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgdGV4dHVyZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtIVE1MSW1hZ2VFbGVtZW50Jmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IF9zdXBlci5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgbG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy53aWR0aCA9IF90aGlzLl9zcHJpdGUuc3dpZHRoID0gX3RoaXMuX3Nwcml0ZS53aWR0aCA9IF90aGlzLmltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZS5zaGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZS5oZWlnaHQgPSBfdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2FkZWQucmVzb2x2ZShfdGhpcy5pbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuaW1hZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlLnNyYyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YS5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZWplY3QoXCJFcnJvciBsb2FkaW5nIHRleHR1cmUuXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIFRleHR1cmUucHJvdG90eXBlLmFzU3ByaXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nwcml0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRleHR1cmU7XG4gICAgfSkoZXguUmVzb3VyY2UpO1xuICAgIGV4LlRleHR1cmUgPSBUZXh0dXJlO1xuICAgIC8qKlxuICAgICAqIFRoZSBTb3VuZCBvYmplY3QgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGF1ZGlvXG4gICAgICogY29tcG9uZW50cywgZnJvbSBzb3VuZHRyYWNrcyB0byBzb3VuZCBlZmZlY3RzLiBJdCBpcyBnZW5lcmFsbHlcbiAgICAgKiByZWNvbW1lbmRlZCB0byBsb2FkIHNvdW5kIHJlc291cmNlcyB3aGVuIHVzaW5nIEV4Y2FsaWJ1clxuICAgICAqIEBjbGFzcyBTb3VuZFxuICAgICAqIEBleHRlbmQgUmVzb3VyY2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gLi4ucGF0aHMge3N0cmluZ1tdfSBBIGxpc3Qgb2YgYXVkaW8gc291cmNlcyAoY2xpcC53YXYsIGNsaXAubXAzLCBjbGlwLm9nZykgZm9yIHRoaXMgYXVkaW8gY2xpcC4gVGhpcyBpcyBkb25lIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgdmFyIFNvdW5kID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU291bmQoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIENocm9tZSA6IE1QMywgV0FWLCBPZ2dcbiAgICAgICAgICAgICAqIEZpcmVmb3ggOiBXQVYsIE9nZyxcbiAgICAgICAgICAgICAqIElFIDogTVAzLCBXQVYgY29taW5nIHNvb25cbiAgICAgICAgICAgICAqIFNhZmFyaSBNUDMsIFdBViwgT2dnXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsZSA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFNvdW5kLmNhblBsYXlGaWxlKHBhdGhzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEZpbGUgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RlZEZpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYW55IG9mIHRoZSBmaWxlcyBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWxlID0gcGF0aHNbMF07IC8vIHNlbGVjdCB0aGUgZmlyc3Qgc3BlY2lmaWVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvdW5kID0gbmV3IGV4LkludGVybmFsLkZhbGxiYWNrQXVkaW8odGhpcy5fc2VsZWN0ZWRGaWxlLCAxLjApO1xuICAgICAgICB9XG4gICAgICAgIFNvdW5kLmNhblBsYXlGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXR5cGUgPSAvLipcXC4oW0EtWmEtejAtOV0rKSQvO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmlsZS5tYXRjaChmaWxldHlwZSlbMV07XG4gICAgICAgICAgICAgICAgaWYgKGEuY2FuUGxheVR5cGUoJ2F1ZGlvLycgKyB0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKFwiQ2Fubm90IGRldGVybWluZSBhdWRpbyBzdXBwb3J0LCBhc3N1bWluZyBubyBzdXBwb3J0IGZvciB0aGUgQXVkaW8gVGFnXCIsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU291bmQucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGVuZ2luZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ2hpZGRlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2luZS5wYXVzZUF1ZGlvV2hlbkhpZGRlbiAmJiBfdGhpcy5pc1BsYXlpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCd2aXNpYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5naW5lLnBhdXNlQXVkaW9XaGVuSGlkZGVuICYmIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdm9sdW1lIG9mIHRoZSBzb3VuZCBjbGlwXG4gICAgICAgICAqIEBtZXRob2Qgc2V0Vm9sdW1lXG4gICAgICAgICAqIEBwYXJhbSB2b2x1bWUge251bWJlcn0gQSB2b2x1bWUgdmFsdWUgYmV0d2VlbiAwLTEuMFxuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2b2x1bWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2xpcCBzaG91bGQgbG9vcCB3aGVuIGNvbXBsZXRlXG4gICAgICAgICAqIEBtZXRob2Qgc2V0TG9vcFxuICAgICAgICAgKiBAcGFyYW0gbG9vcCB7Ym9vbGVhbn0gU2V0IHRoZSBsb29waW5nIGZsYWdcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc2V0TG9vcChsb29wKTtcbiAgICAgICAgfTtcbiAgICAgICAgU291bmQucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdW5kLmlzUGxheWluZygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxheSB0aGUgc291bmQsIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc291bmQgaXMgZG9uZSBwbGF5aW5nXG4gICAgICAgICAqIEBtZXRob2QgcGxheVxuICAgICAgICAgKiBAcmV0dXJuIGV4LlByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291bmQucGxheSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCB0aGUgc291bmQsIGFuZCBkbyBub3QgcmV3aW5kXG4gICAgICAgICAqIEBtZXRob2QgcGF1c2VcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuc291bmQucGF1c2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgdGhlIHNvdW5kIGFuZCByZXdpbmRcbiAgICAgICAgICogQG1ldGhvZCBzdG9wXG4gICAgICAgICAqL1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc3RvcCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzb3VuZCBpcyBsb2FkZWRcbiAgICAgICAgICogQG1ldGhvZCBpc0xvYWRlZFxuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHNvdW5kIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXG4gICAgICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlJmx0O1NvdW5kJmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3RhcnRlZCBsb2FkaW5nIHNvdW5kXCIsIHRoaXMuX3NlbGVjdGVkRmlsZSk7XG4gICAgICAgICAgICB0aGlzLnNvdW5kLm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICB0aGlzLnNvdW5kLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoXCJDb21wbGV0ZWQgbG9hZGluZyBzb3VuZFwiLCBfdGhpcy5fc2VsZWN0ZWRGaWxlKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLnNvdW5kKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNvdW5kLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNvdW5kLmxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNvdW5kO1xuICAgIH0pKCk7XG4gICAgZXguU291bmQgPSBTb3VuZDtcbiAgICAvKipcbiAgICAgKiBUaGUgbG9hZGVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHByZWxvYWQgbXVsdGlwbGUgcmVzb3VyY2VzIGF0XG4gICAgICogb25lIHRpbWUuIFRoZSBsb2FkZXIgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGVuZ2luZSBpbiBvcmRlciB0b1xuICAgICAqIHRyaWdnZXIgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgYmFyXG4gICAgICogQGNsYXNzIExvYWRlclxuICAgICAqIEBleHRlbmQgSUxvYWRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFtsb2FkYWJsZXM9dW5kZWZpbmVkXSB7SUxvYWRhYmxlW119IE9wdGlvbmFsbHkgcHJvdmlkZSB0aGUgbGlzdCBvZiByZXNvdXJjZXMgeW91IHdhbnQgdG8gbG9hZCBhdCBjb25zdHJ1Y3RvciB0aW1lXG4gICAgICovXG4gICAgdmFyIExvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExvYWRlcihsb2FkYWJsZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VMaXN0ID0gW107XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLm51bUxvYWRlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzQ291bnRzID0ge307XG4gICAgICAgICAgICB0aGlzLnRvdGFsQ291bnRzID0ge307XG4gICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobG9hZGFibGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRSZXNvdXJjZXMobG9hZGFibGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSByZXNvdXJjZSB0byB0aGUgbG9hZGVyIHRvIGxvYWRcbiAgICAgICAgICogQG1ldGhvZCBhZGRSZXNvdXJjZVxuICAgICAgICAgKiBAcGFyYW0gbG9hZGFibGUge0lMb2FkYWJsZX0gUmVzb3VyY2UgdG8gYWRkXG4gICAgICAgICAqL1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmFkZFJlc291cmNlID0gZnVuY3Rpb24gKGxvYWRhYmxlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUxpc3QucHVzaChsb2FkYWJsZSk7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzQ291bnRzW2tleV0gPSAwO1xuICAgICAgICAgICAgdGhpcy50b3RhbENvdW50c1trZXldID0gMTtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VDb3VudCsrO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgbGlzdCBvZiByZXNvdXJjZXMgdG8gdGhlIGxvYWRlciB0byBsb2FkXG4gICAgICAgICAqIEBtZXRob2QgYWRkUmVzb3VyY2VzXG4gICAgICAgICAqIEBwYXJhbSBsb2FkYWJsZXMge0lMb2FkYWJsZVtdfSBUaGUgbGlzdCBvZiByZXNvdXJjZXMgdG8gbG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5hZGRSZXNvdXJjZXMgPSBmdW5jdGlvbiAobG9hZGFibGVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgbG9hZGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRSZXNvdXJjZShsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLnN1bUNvdW50cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgdmFyIHByZXYgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gb2JqW2ldIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxvYWRlciBoYXMgY29tcGxldGVseSBsb2FkZWQgYWxsIHJlc291cmNlc1xuICAgICAgICAgKiBAbWV0aG9kIGlzTG9hZGVkXG4gICAgICAgICAqL1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtTG9hZGVkID09PSB0aGlzLnJlc291cmNlQ291bnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWdpbiBsb2FkaW5nIGFsbCBvZiB0aGUgc3VwcGxpZWQgcmVzb3VyY2VzLCByZXR1cm5pbmcgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIG9mIGFsbCBpcyBjb21wbGV0ZVxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHJldHVybnMgUHJvbXNpZSZsdDthbnkmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvdXJjZUxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUub25jb21wbGV0ZS5jYWxsKG1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NBcnJheSA9IG5ldyBBcnJheSh0aGlzLnJlc291cmNlTGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzQ2h1bmtzID0gdGhpcy5yZXNvdXJjZUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHIud2lyZUVuZ2luZShfdGhpcy5fZW5naW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0FycmF5W2ldID0geyBsb2FkZWQ6ICgobG9hZGVkIC8gdG90YWwpICogKDEwMCAvIHByb2dyZXNzQ2h1bmtzKSksIHRvdGFsOiAxMDAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzUmVzdWx0ID0gcHJvZ3Jlc3NBcnJheS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsb2FkZWQ6IChhY2N1bS5sb2FkZWQgKyBuZXh0LmxvYWRlZCksIHRvdGFsOiAxMDAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgeyBsb2FkZWQ6IDAsIHRvdGFsOiAxMDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLm9ucHJvZ3Jlc3MuY2FsbChtZSwgcHJvZ3Jlc3NSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgci5vbmNvbXBsZXRlID0gci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5udW1Mb2FkZWQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLm51bUxvYWRlZCA9PT0gbWUucmVzb3VyY2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUub25wcm9ncmVzcy5jYWxsKG1lLCB7IGxvYWRlZDogMTAwLCB0b3RhbDogMTAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUub25jb21wbGV0ZS5jYWxsKG1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWROZXh0KGxpc3QsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0W2luZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxpc3RbaW5kZXhdLmxvYWQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZE5leHQobGlzdCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWROZXh0KHRoaXMucmVzb3VyY2VMaXN0LCAwKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIExvYWRlcjtcbiAgICB9KSgpO1xuICAgIGV4LkxvYWRlciA9IExvYWRlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUHJvbWlzZXMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvYWRlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTG9nLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBFeGNhbGlidXIncyBidWlsdCBpbiB0ZW1wbGF0aW5nIGNsYXNzLCBpdCBpcyBhIGxvYWRhYmxlIHRoYXQgd2lsbCBsb2FkXG4gICAgICogYW5kIGh0bWwgZnJhZ21lbnQgZnJvbSBhIHVybC4gRXhjYWxpYnVyIHRlbXBsYXRpbmcgaXMgdmVyeSBiYXNpYyBvbmx5XG4gICAgICogYWxsb3dpbmcgYmluZGluZ3Mgb2YgdGhlIHR5cGUgZGF0YS10ZXh0PVwidGhpcy5vYmouc29tZXByb3BcIixcbiAgICAgKiBkYXRhLXN0eWxlPVwiY29sb3I6dGhpcy5vYmouY29sb3IudG9TdHJpbmcoKVwiLiBCaW5kaW5ncyBhbGxvdyBhbGwgdmFsaWRcbiAgICAgKiBqYXZhc2NyaXB0IGV4cHJlc3Npb25zLlxuICAgICAqIEBjbGFzcyBUZW1wbGF0ZVxuICAgICAqIEBleHRlbmRzIElMb2FkYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBwYXRoIHtzdHJpbmd9IExvY2F0aW9uIG9mIHRoZSBodG1sIHRlbXBsYXRlXG4gICAgICovXG4gICAgdmFyIFRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGUocGF0aCkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5faW5uZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9pbm5lckVsZW1lbnQuY2xhc3NOYW1lID0gXCJleGNhbGlidXItdGVtcGxhdGVcIjtcbiAgICAgICAgfVxuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUud2lyZUVuZ2luZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZ1bGwgaHRtbCB0ZW1wbGF0ZSBzdHJpbmcgb25jZSBsb2FkZWQuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0VGVtcGxhdGVTdHJpbmdcbiAgICAgICAgICogQHJldHVybnMgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuZ2V0VGVtcGxhdGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzTG9hZGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2h0bWxTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9odG1sU3RyaW5nO1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVFbGVtZW50cyA9IHRoaXMuX2lubmVyRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zdHlsZV0nKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRFbGVtZW50cyA9IHRoaXMuX2lubmVyRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10ZXh0XScpO1xuICAgICAgICB9O1xuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuX2V2YWx1YXRlRXhwcmVzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGN0eCkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIgKyBleHByZXNzaW9uICsgXCI7XCIpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IGZ1bmMuY2FsbChjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgYW55IGN0eCBvYmplY3QgeW91IHdpc2ggYW5kIGV2YWx1YXRlcyB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAqIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvIGluY2x1ZGUgeW91ciBmYXZvcml0ZSB0ZW1wbGF0ZSBsaWJyYXJ5LlxuICAgICAgICAgKiBZb3UgbWF5IHJldHVybiBlaXRoZXIgYW4gSFRNTCBzdHJpbmcgb3IgYSBEb20gbm9kZS5cbiAgICAgICAgICogQG1ldGhvZCBhcHBseVxuICAgICAgICAgKiBAcGFyYW0gY3R4IHthbnl9IEFueSBvYmplY3QgeW91IHdpc2ggdG8gYXBwbHkgdG8gdGhlIHRlbXBsYXRlXG4gICAgICAgICAqIEByZXR1cm5zIGFueVxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc3R5bGVFbGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBvb3IgbWFuJ3MganNvbiBwYXJzZSBmb3IgdGhpbmdzIHRoYXQgYXJlbid0IGV4YWN0bHkganNvbiA6KFxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHN0eWxlIGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0eWxlRWxlbWVudHNbal0uZGF0YXNldFtcInN0eWxlXCJdLnNwbGl0KFwiO1wiKS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxzID0gcy5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3ZhbHNbMF0udHJpbSgpXSA9IHZhbHNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3R5bGVFbGVtZW50c1tqXS5zdHlsZVtzdHlsZV0gPSBfdGhpcy5fZXZhbHVhdGVFeHByZXNpb24oZXhwcmVzc2lvbiwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXh0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0ZXh0IGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gX3RoaXMuX3RleHRFbGVtZW50c1tpXS5kYXRhc2V0W1widGV4dFwiXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFbGVtZW50c1tpXS5pbm5lclRleHQgPSBfdGhpcy5fZXZhbHVhdGVFeHByZXNpb24oZXhwcmVzc2lvbiwgY3R4KTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHRlbXBsYXRlIEhUTUwgaGFzIGEgcm9vdCBlbGVtZW50IHJldHVybiB0aGF0LCBvdGhlcndpc2UgdXNlIGNvbnN0cnVjdGVkIHJvb3RcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbm5lckVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5uZXJFbGVtZW50ID0gdGhpcy5faW5uZXJFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJFbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHRlbXBsYXRlLiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHRlbXBsYXRlIHN0cmluZyB3aGVuIGxvYWRlZC5cbiAgICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdGhpcy5wYXRoLCB0cnVlKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgaHRtbCB0ZW1wbGF0ZSByZXNvdXJjZSBcIiwgX3RoaXMucGF0aCwgXCIgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIGNvZGVcIiwgcmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9odG1sU3RyaW5nID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiQ29tcGxldGVkIGxvYWRpbmcgdGVtcGxhdGVcIiwgX3RoaXMucGF0aCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuX2h0bWxTdHJpbmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRlbXBsYXRlIGhhcyBiZWVuIGxvYWRlZFxuICAgICAgICAgKiBAbWV0aG9kIGlzTG9hZGVkXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGVtcGxhdGU7XG4gICAgfSkoKTtcbiAgICBleC5UZW1wbGF0ZSA9IFRlbXBsYXRlO1xuICAgIC8qKlxuICAgICAqIEV4Y2FsaWJ1cidzIGJpbmRpbmcgbGlicmFyeSB0aGF0IGFsbG93cyB5b3UgdG8gYmluZCBhbiBodG1sXG4gICAgICogdGVtcGxhdGUgdG8gdGhlIGRvbSBnaXZlbiBhIGNlcnRhaW4gY29udGV4dC4gRXhjYWxpYnVyIGJpbmRpbmdzIGFyZSBvbmx5IHVwZGF0ZWRcbiAgICAgKiB3aGVuIHRoZSB1cGRhdGUoKSBtZXRob2QgaXMgY2FsbGVkXG4gICAgICogQGNsYXNzIEJpbmRpbmdcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcGFyZW50RWxlbWVudElkIHtzdHJpbmd9IFRoZSBpZCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgZG9tIHRvIGF0dGFjaCB0aGUgdGVtcGxhdGUgYmluZGluZ1xuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSB7VGVtcGxhdGV9IFRoZSB0ZW1wbGF0ZSB5b3Ugd2lzaCB0byBiaW5kXG4gICAgICogQHBhcmFtIGN0eCB7YW55fSBUaGUgY29udGV4dCBvZiB0aGUgYmluZGluZywgd2hpY2ggY2FuIGJlIGFueSBvYmplY3RcbiAgICAgKi9cbiAgICB2YXIgQmluZGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJpbmRpbmcocGFyZW50RWxlbWVudElkLCB0ZW1wbGF0ZSwgY3R4KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudEVsZW1lbnRJZCk7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW4gdG8gYW55IGFyYml0cmFyeSBvYmplY3QncyBldmVudHMgdG8gdXBkYXRlIHRoaXMgYmluZGluZ1xuICAgICAgICAgKiBAbWV0aG9kIGxpc3RlblxuICAgICAgICAgKiBAcGFyYW0gb2JqIHthbnl9IEFueSBvYmplY3QgdGhhdCBzdXBwb3J0cyBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSBldmVudHMge3N0cmluZ1tdfSBBIGxpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIFtoYW5kZXI9ZGVmYXVsdEhhbmRsZXJdIHtjYWxsYmFja30gQSBvcHRpb25hbCBoYW5kbGVyIHRvIGZpcmUgb24gYW55IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBCaW5kaW5nLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAob2JqLCBldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyB0b2RvXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhpcyB0ZW1wbGF0ZSBiaW5kaW5nIHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSB0aGUgY3R4IHJlZmVyZW5jZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBCaW5kaW5nLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IHRoaXMuX2FwcGx5VGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgdGhpcy5fY3R4KTtcbiAgICAgICAgICAgIGlmIChodG1sIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChodG1sIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5sYXN0Q2hpbGQgIT09IGh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQoaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCaW5kaW5nLnByb3RvdHlwZS5fYXBwbHlUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGUuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5hcHBseShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQmluZGluZztcbiAgICB9KSgpO1xuICAgIGV4LkJpbmRpbmcgPSBCaW5kaW5nO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50c1xuICAgICAqIEBjbGFzcyBUZXh0QWxpZ25cbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKFRleHRBbGlnbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgaXMgbGVmdC1hbGlnbmVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBpcyByaWdodC1hbGlnbmVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgUmlnaHRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBjZW50ZXJlZC5cbiAgICAgICAgICogQHByb3BlcnR5IENlbnRlclxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiQ2VudGVyXCJdID0gMl0gPSBcIkNlbnRlclwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIHN0YXJ0IG9mIHRoZSBsaW5lIChsZWZ0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcywgcmlnaHQtYWxpZ25lZCBmb3IgcmlnaHQtdG8tbGVmdCBsb2NhbGVzKS5cbiAgICAgICAgICogQHByb3BlcnR5IFN0YXJ0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJTdGFydFwiXSA9IDNdID0gXCJTdGFydFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIGVuZCBvZiB0aGUgbGluZSAocmlnaHQtYWxpZ25lZCBmb3IgbGVmdC10by1yaWdodCBsb2NhbGVzLCBsZWZ0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBFbmRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIkVuZFwiXSA9IDRdID0gXCJFbmRcIjtcbiAgICB9KShleC5UZXh0QWxpZ24gfHwgKGV4LlRleHRBbGlnbiA9IHt9KSk7XG4gICAgdmFyIFRleHRBbGlnbiA9IGV4LlRleHRBbGlnbjtcbiAgICAvKipcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGJhc2VsaW5lIHRleHQgYWxpZ25tZW50c1xuICAgICAqIEBjbGFzcyBCYXNlQWxpZ25cbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKEJhc2VBbGlnbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIHRvcCBvZiB0aGUgZW0gc3F1YXJlLlxuICAgICAgICAgKiBAcHJvcGVydHkgVG9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJUb3BcIl0gPSAwXSA9IFwiVG9wXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgaGFuZ2luZyBiYXNlbGluZS4gIEN1cnJlbnRseSB1bnN1cHBvcnRlZDsgdGhpcyB3aWxsIGFjdCBsaWtlIGFscGhhYmV0aWMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBIYW5naW5nXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJIYW5naW5nXCJdID0gMV0gPSBcIkhhbmdpbmdcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBtaWRkbGUgb2YgdGhlIGVtIHNxdWFyZS5cbiAgICAgICAgICogQHByb3BlcnR5IE1pZGRsZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiTWlkZGxlXCJdID0gMl0gPSBcIk1pZGRsZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIG5vcm1hbCBhbHBoYWJldGljIGJhc2VsaW5lLlxuICAgICAgICAgKiBAcHJvcGVydHkgQWxwaGFiZXRpY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiQWxwaGFiZXRpY1wiXSA9IDNdID0gXCJBbHBoYWJldGljXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgaWRlb2dyYXBoaWMgYmFzZWxpbmU7IHRoaXMgaXMgdGhlIGJvdHRvbSBvZlxuICAgICAgICAgKiB0aGUgYm9keSBvZiB0aGUgY2hhcmFjdGVycywgaWYgdGhlIG1haW4gYm9keSBvZiBjaGFyYWN0ZXJzIHByb3RydWRlc1xuICAgICAgICAgKiBiZW5lYXRoIHRoZSBhbHBoYWJldGljIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGxcbiAgICAgICAgICogYWN0IGxpa2UgYWxwaGFiZXRpYy5cbiAgICAgICAgICogQHByb3BlcnR5IElkZW9ncmFwaGljXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJJZGVvZ3JhcGhpY1wiXSA9IDRdID0gXCJJZGVvZ3JhcGhpY1wiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgYm91bmRpbmcgYm94LiAgVGhpcyBkaWZmZXJzXG4gICAgICAgICAqIGZyb20gdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lIGluIHRoYXQgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lXG4gICAgICAgICAqIGRvZXNuJ3QgY29uc2lkZXIgZGVzY2VuZGVycy5cbiAgICAgICAgICogQHByb3BlcnR5IEJvdHRvbVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiQm90dG9tXCJdID0gNV0gPSBcIkJvdHRvbVwiO1xuICAgIH0pKGV4LkJhc2VBbGlnbiB8fCAoZXguQmFzZUFsaWduID0ge30pKTtcbiAgICB2YXIgQmFzZUFsaWduID0gZXguQmFzZUFsaWduO1xuICAgIC8qKlxuICAgICAqIExhYmVscyBhcmUgdGhlIHdheSB0byBkcmF3IHNtYWxsIGFtb3VudHMgb2YgdGV4dCB0byB0aGUgc2NyZWVuIGluIEV4Y2FsaWJ1ci4gVGhleSBhcmVcbiAgICAgKiBhY3RvcnMgYW5kIGluaGVyaXQgYWxsIG9mIHRoZSBiZW5pZml0cyBhbmQgY2FwYWJpbGl0aWVzLlxuICAgICAqIEBjbGFzcyBMYWJlbFxuICAgICAqIEBleHRlbmRzIEFjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt0ZXh0PWVtcHR5XSB7c3RyaW5nfSBUaGUgdGV4dCBvZiB0aGUgbGFiZWxcbiAgICAgKiBAcGFyYW0gW3g9MF0ge251bWJlcn0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGxhYmVsXG4gICAgICogQHBhcmFtIFt5PTBdIHtudW1iZXJ9IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBsYWJlbFxuICAgICAqIEBwYXJhbSBbZm9udD1zYW5zLXNlcmlmXSB7c3RyaW5nfSBVc2UgYW55IHZhbGlkIGNzcyBmb250IHN0cmluZyBmb3IgdGhlIGxhYmVsJ3MgZm9udC4gRGVmYXVsdCBpcyBcIjEwcHggc2Fucy1zZXJpZlwiLlxuICAgICAqIEBwYXJhbSBbc3ByaXRlRm9udD11bmRlZmluZWRdIHtTcHJpdGVGb250fSBVc2UgYW4gRXhjYWxpYnVyIHNwcml0ZSBmb250IGZvciB0aGUgbGFiZWwncyBmb250LCBpZiBhIFNwcml0ZUZvbnQgaXMgcHJvdmlkZWQgaXQgd2lsbCB0YWtlIHByZWNlbmRlbmNlIG92ZXIgYSBjc3MgZm9udC5cbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBMYWJlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhMYWJlbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTGFiZWwodGV4dCwgeCwgeSwgZm9udCwgc3ByaXRlRm9udCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeCwgeSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGV0dGVyIHNwYWNpbmcgb24gYSBMYWJlbC4gT25seSBzdXBwb3J0ZWQgd2l0aCBTcHJpdGUgRm9udHMuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2xldHRlclNwYWNpbmc9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5sZXR0ZXJTcGFjaW5nID0gMDsgLy9weFxuICAgICAgICAgICAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSAwO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3IgPSBleC5Db2xvci5CbGFjay5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3JEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fdGV4dFNwcml0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Nwcml0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gZXguQ29sb3IuQmxhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQgfHwgXCJcIjtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBleC5Db2xvci5CbGFjay5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVGb250ID0gc3ByaXRlRm9udDtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMuZm9udCA9IGZvbnQgfHwgXCIxMHB4IHNhbnMtc2VyaWZcIjsgLy8gY29hbGxlc2NlIHRvIGRlZmF1bHQgY2FudmFzIGZvbnRcbiAgICAgICAgICAgIGlmIChzcHJpdGVGb250KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNwcml0ZXMgPSBzcHJpdGVGb250LmdldFRleHRTcHJpdGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGluIHRoZSBsYWJlbCAoaW4gcGl4ZWxzKTtcbiAgICAgICAgICogQG1ldGhvZCBnZXRUZXh0V2lkdGgge251bWJlcn1cbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBSZW5kaW5nIGNvbnRleHQgdG8gbWVhc3VyZSB0aGUgc3RyaW5nIHdpdGhcbiAgICAgICAgICovXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5nZXRUZXh0V2lkdGggPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgb2xkRm9udCA9IGN0eC5mb250O1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgIGN0eC5mb250ID0gb2xkRm9udDtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgc3RyaW5nIGVudW1zIDooXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5fbG9va3VwVGV4dEFsaWduID0gZnVuY3Rpb24gKHRleHRBbGlnbikge1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogTGVmdCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGVmdFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogUmlnaHQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBDZW50ZXIgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNlbnRlclwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogRW5kICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFN0YXJ0ICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLl9sb29rdXBCYXNlQWxpZ24gPSBmdW5jdGlvbiAoYmFzZUFsaWduKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGJhc2VBbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBBbHBoYWJldGljICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhbHBoYWJldGljXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBCb3R0b20gKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJvdHRvbVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogSGFuZ2luZyAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaGFuZ2luXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBJZGVvZ3JhcGhpYyAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaWRlb2dyYXBoaWNcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIE1pZGRsZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibWlkZGxlXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBUb3AgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRvcFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhbHBoYWJldGljXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdGV4dCBzaGFkb3cgZm9yIHNwcml0ZSBmb250c1xuICAgICAgICAgKiBAbWV0aG9kIHNldFRleHRTaGFkb3dcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFgge251bWJlcn0gVGhlIHggb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXRZIHtudW1iZXJ9IFRoZSB5IG9mZnNldCBpbiBwaXhsZXMgdG8gcGxhY2UgdGhlIHNoYWRvd1xuICAgICAgICAgKiBAcGFyYW0gc2hhZG93Q29sb3Ige0NvbG9yfSBUaGUgY29sb3Igb2YgdGhlIHRleHQgc2hhZG93XG4gICAgICAgICAqL1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuc2V0VGV4dFNoYWRvdyA9IGZ1bmN0aW9uIChvZmZzZXRYLCBvZmZzZXRZLCBzaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSBvZmZzZXRYO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGNoYXJhY3RlciBpbiB0aGlzLl90ZXh0U3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXSA9IHRoaXMuX3RleHRTcHJpdGVzW2NoYXJhY3Rlcl0uY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyB0aGUgY3VycmVudCB0ZXh0IHNoYWRvd1xuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyVGV4dFNoYWRvd1xuICAgICAgICAgKi9cbiAgICAgICAgTGFiZWwucHJvdG90eXBlLmNsZWFyVGV4dFNoYWRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NvbG9yID0gZXguQ29sb3IuQmxhY2suY2xvbmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlRm9udCAmJiB0aGlzLl9jb2xvciAhPT0gdGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXJhY3RlciBpbiB0aGlzLl90ZXh0U3ByaXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U3ByaXRlc1tjaGFyYWN0ZXJdLmNsZWFyRWZmZWN0cygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U3ByaXRlc1tjaGFyYWN0ZXJdLmFkZEVmZmVjdChuZXcgZXguRWZmZWN0cy5GaWxsKHRoaXMuY29sb3IuY2xvbmUoKSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlRm9udCAmJiB0aGlzLl90ZXh0U2hhZG93T24gJiYgdGhpcy5fc2hhZG93Q29sb3JEaXJ0eSAmJiB0aGlzLl9zaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXJhY3RlciBpbiB0aGlzLl9zaGFkb3dTcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5jbGVhckVmZmVjdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLmFkZEVmZmVjdChuZXcgZXguRWZmZWN0cy5GaWxsKHRoaXMuX3NoYWRvd0NvbG9yLmNsb25lKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3JEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0U2hhZG93T24pIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5fc2hhZG93T2Zmc2V0WCwgdGhpcy5fc2hhZG93T2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udERyYXcoY3R4LCBkZWx0YSwgdGhpcy5fc2hhZG93U3ByaXRlcyk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZvbnREcmF3KGN0eCwgZGVsdGEsIHRoaXMuX3RleHRTcHJpdGVzKTtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMsIGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLl9mb250RHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhLCBzcHJpdGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVGb250KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJYID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gdGhpcy50ZXh0W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhclNwcml0ZSA9IHNwcml0ZXNbY2hhcmFjdGVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzT3BhY2l0eSAhPT0gdGhpcy5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhclNwcml0ZS5jbGVhckVmZmVjdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLmFkZEVmZmVjdChuZXcgZXguRWZmZWN0cy5PcGFjaXR5KHRoaXMub3BhY2l0eSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhclNwcml0ZS5kcmF3KGN0eCwgY3VyclgsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyclggKz0gKGNoYXJTcHJpdGUuc3dpZHRoICsgdGhpcy5sZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXguTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoXCJTcHJpdGVGb250IEVycm9yIGRyYXdpbmcgY2hhciBcIiArIGNoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNPcGFjaXR5ICE9PSB0aGlzLm9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c09wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEFsaWduID0gY3R4LnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVGV4dEJhc2VsaW5lID0gY3R4LnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy5fbG9va3VwVGV4dEFsaWduKHRoaXMudGV4dEFsaWduKTtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy5fbG9va3VwQmFzZUFsaWduKHRoaXMuYmFzZUFsaWduKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yLmEgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgMCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IG9sZEFsaWduO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvbGRUZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlYnVnRHJhdy5jYWxsKHRoaXMsIGN0eCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMYWJlbDtcbiAgICB9KShleC5BY3Rvcik7XG4gICAgZXguTGFiZWwgPSBMYWJlbDtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnRzLnRzXCIvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBJbnB1dDtcbiAgICAoZnVuY3Rpb24gKElucHV0KSB7XG4gICAgICAgIChmdW5jdGlvbiAoUG9pbnRlclR5cGUpIHtcbiAgICAgICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiVG91Y2hcIl0gPSAwXSA9IFwiVG91Y2hcIjtcbiAgICAgICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiTW91c2VcIl0gPSAxXSA9IFwiTW91c2VcIjtcbiAgICAgICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiUGVuXCJdID0gMl0gPSBcIlBlblwiO1xuICAgICAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJVbmtub3duXCJdID0gM10gPSBcIlVua25vd25cIjtcbiAgICAgICAgfSkoSW5wdXQuUG9pbnRlclR5cGUgfHwgKElucHV0LlBvaW50ZXJUeXBlID0ge30pKTtcbiAgICAgICAgdmFyIFBvaW50ZXJUeXBlID0gSW5wdXQuUG9pbnRlclR5cGU7XG4gICAgICAgIChmdW5jdGlvbiAoUG9pbnRlckJ1dHRvbikge1xuICAgICAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJNaWRkbGVcIl0gPSAxXSA9IFwiTWlkZGxlXCI7XG4gICAgICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJSaWdodFwiXSA9IDJdID0gXCJSaWdodFwiO1xuICAgICAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XG4gICAgICAgIH0pKElucHV0LlBvaW50ZXJCdXR0b24gfHwgKElucHV0LlBvaW50ZXJCdXR0b24gPSB7fSkpO1xuICAgICAgICB2YXIgUG9pbnRlckJ1dHRvbiA9IElucHV0LlBvaW50ZXJCdXR0b247XG4gICAgICAgIHZhciBQb2ludGVyRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFBvaW50ZXJFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBvaW50ZXJFdmVudCh4LCB5LCBpbmRleCwgcG9pbnRlclR5cGUsIGJ1dHRvbiwgZXYpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ID0gZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUG9pbnRlckV2ZW50O1xuICAgICAgICB9KShleC5HYW1lRXZlbnQpO1xuICAgICAgICBJbnB1dC5Qb2ludGVyRXZlbnQgPSBQb2ludGVyRXZlbnQ7XG4gICAgICAgIDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgcG9pbnRlciBldmVudHMgKG1vdXNlLCB0b3VjaCwgc3R5bHVzLCBldGMuKSBhbmQgbm9ybWFsaXplcyB0byBXM0MgUG9pbnRlciBFdmVudHMuXG4gICAgICAgICAqIFRoZXJlIGlzIGFsd2F5cyBhdCBsZWFzdCBvbmUgcG9pbnRlciBhdmFpbGFibGUgKHByaW1hcnkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgUG9pbnRlcnNcbiAgICAgICAgICogQGV4dGVuZHMgQ2xhc3NcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgUG9pbnRlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFBvaW50ZXJzLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUG9pbnRlcnMoZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlckRvd24gPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyVXAgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyTW92ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJzLnB1c2gobmV3IFBvaW50ZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnMgPSBbLTFdO1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbWFyeSA9IHRoaXMuX3BvaW50ZXJzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyBwb2ludGVyIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBUb3VjaCBFdmVudHNcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlVG91Y2hFdmVudChcImRvd25cIiwgdGhpcy5fcG9pbnRlckRvd24pKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoXCJ1cFwiLCB0aGlzLl9wb2ludGVyVXApKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KFwibW92ZVwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5faGFuZGxlVG91Y2hFdmVudChcImNhbmNlbFwiLCB0aGlzLl9wb2ludGVyQ2FuY2VsKSk7XG4gICAgICAgICAgICAgICAgLy8gVzNDIFBvaW50ZXIgRXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gQ3VycmVudDogSUUxMSwgSUUxMFxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFMTFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcImRvd25cIiwgdGhpcy5fcG9pbnRlckRvd24pKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwidXBcIiwgdGhpcy5fcG9pbnRlclVwKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwibW92ZVwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwiY2FuY2VsXCIsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRTEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5jYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJEb3duJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwiZG93blwiLCB0aGlzLl9wb2ludGVyRG93bikpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJVcCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcInVwXCIsIHRoaXMuX3BvaW50ZXJVcCkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJNb3ZlJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwibW92ZVwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJDYW5jZWwnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJjYW5jZWxcIiwgdGhpcy5fcG9pbnRlck1vdmUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdXNlIEV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KFwiZG93blwiLCB0aGlzLl9wb2ludGVyRG93bikpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VFdmVudChcInVwXCIsIHRoaXMuX3BvaW50ZXJVcCkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KFwibW92ZVwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlclVwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlckRvd24ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyTW92ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNhZmVseSBnZXRzIGEgUG9pbnRlciBhdCBhIHNwZWNpZmljIGluZGV4IGFuZCBpbml0aWFsaXplcyBvbmUgaWYgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBUaGUgcG9pbnRlciBpbmRleCB0byByZXRyaWV2ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fcG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9wb2ludGVycy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnMucHVzaCgtMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzW2luZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBudW1iZXIgb2YgcG9pbnRlcnMgYmVpbmcgd2F0Y2hlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BvZ2F0ZXMgZXZlbnRzIHRvIGFjdG9yIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUucHJvcG9nYXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVUlBY3RvciA9IGFjdG9yIGluc3RhbmNlb2YgZXguVUlBY3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyVXAuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnMoZS54LCBlLnksICFpc1VJQWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIucHVibGlzaChcInBvaW50ZXJ1cFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJEb3duLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKGUueCwgZS55LCAhaXNVSUFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJwb2ludGVyZG93blwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jYXB0dXJlUG9pbnRlci5jYXB0dXJlTW92ZUV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyTW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnMoZS54LCBlLnksICFpc1VJQWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJwb2ludGVybW92ZVwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnMoZS54LCBlLnksICFpc1VJQWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIucHVibGlzaChcInBvaW50ZXJjYW5jZWxcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZU1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gZXguVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBlLnBhZ2VZIC0gZXguVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgZXguUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCAwLCAxIC8qIE1vdXNlICovLCBlLmJ1dHRvbiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdCgwKS5ldmVudERpc3BhdGNoZXIucHVibGlzaChldmVudE5hbWUsIHBlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlVG91Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyBfdGhpcy5fZ2V0UG9pbnRlckluZGV4KGUuY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcikgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWCAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGUuY2hhbmdlZFRvdWNoZXNbaV0ucGFnZVkgLSBleC5VdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgZXguUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlID0gbmV3IFBvaW50ZXJFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgaW5kZXgsIDAgLyogVG91Y2ggKi8sIDMgLyogVW5rbm93biAqLywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5ldmVudERpc3BhdGNoZXIucHVibGlzaChldmVudE5hbWUsIHBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcInVwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiZG93blwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIElEIHRvIGdpdmVuIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSBlLmNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZVBvaW50ZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGZvciB0aGlzIHBvaW50ZXIgSUQgaWYgbXVsdGktcG9pbnRlciBpcyBhc2tlZCBmb3JcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyBfdGhpcy5fZ2V0UG9pbnRlckluZGV4KGUucG9pbnRlcklkKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KHgsIHkpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlID0gbmV3IFBvaW50ZXJFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgaW5kZXgsIF90aGlzLl9zdHJpbmdUb1BvaW50ZXJUeXBlKGUucG9pbnRlclR5cGUpLCBlLmJ1dHRvbiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goZXZlbnROYW1lLCBwZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJ1cFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiZG93blwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgSUQgdG8gZ2l2ZW4gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5wb2ludGVySWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgc3BlY2lmaWVkIGZvciB0aGUgZ2l2ZW4gcG9pbnRlciBJRCBvciBmaW5kcyB0aGUgbmV4dCBlbXB0eSBwb2ludGVyIHNsb3QgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIElFMTAvMTEgdXNlcyBpbmNyZW1lbnRpbmcgcG9pbnRlciBJRHMgc28gd2UgbmVlZCB0byBzdG9yZSBhIG1hcHBpbmcgb2YgSUQgPT4gaWR4XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2dldFBvaW50ZXJJbmRleCA9IGZ1bmN0aW9uIChwb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4O1xuICAgICAgICAgICAgICAgIGlmICgoaWR4ID0gdGhpcy5fYWN0aXZlUG9pbnRlcnMuaW5kZXhPZihwb2ludGVySWQpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlUG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVBvaW50ZXJzW2ldID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgcG9pbnRlciBiZWNhdXNlIGdhbWUgaXNuJ3Qgd2F0Y2hpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9zdHJpbmdUb1BvaW50ZXJUeXBlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvdWNoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBUb3VjaCAqLztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBNb3VzZSAqLztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBlblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogUGVuICovO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogVW5rbm93biAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJzO1xuICAgICAgICB9KShleC5DbGFzcyk7XG4gICAgICAgIElucHV0LlBvaW50ZXJzID0gUG9pbnRlcnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXB0dXJlcyBhbmQgZGlzcGF0Y2hlcyBQb2ludGVyRXZlbnRzXG4gICAgICAgICAqIEBjbGFzcyBQb2ludGVyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBDbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFBvaW50ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFBvaW50ZXIsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBQb2ludGVyKCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXI7XG4gICAgICAgIH0pKGV4LkNsYXNzKTtcbiAgICAgICAgSW5wdXQuUG9pbnRlciA9IFBvaW50ZXI7XG4gICAgfSkoSW5wdXQgPSBleC5JbnB1dCB8fCAoZXguSW5wdXQgPSB7fSkpO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgSW5wdXQ7XG4gICAgKGZ1bmN0aW9uIChJbnB1dCkge1xuICAgICAgICAvKipcbiAgICAgICAgKiBFbnVtIHJlcHJlc2VudGluZyBpbnB1dCBrZXkgY29kZXNcbiAgICAgICAgKiBAY2xhc3MgS2V5c1xuICAgICAgICAqXG4gICAgICAgICovXG4gICAgICAgIChmdW5jdGlvbiAoS2V5cykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtMSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW0yIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTMge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtNCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW01IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTYge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtNyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW04IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTkge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtMCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW0xXCJdID0gOTddID0gXCJOdW0xXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW0yXCJdID0gOThdID0gXCJOdW0yXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW0zXCJdID0gOTldID0gXCJOdW0zXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW00XCJdID0gMTAwXSA9IFwiTnVtNFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtNVwiXSA9IDEwMV0gPSBcIk51bTVcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTZcIl0gPSAxMDJdID0gXCJOdW02XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW03XCJdID0gMTAzXSA9IFwiTnVtN1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtOFwiXSA9IDEwNF0gPSBcIk51bThcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTlcIl0gPSAxMDVdID0gXCJOdW05XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW0wXCJdID0gOTZdID0gXCJOdW0wXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW1sb2NrIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bWxvY2tcIl0gPSAxNDRdID0gXCJOdW1sb2NrXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBTZW1pY29sb24ge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiU2VtaWNvbG9uXCJdID0gMTg2XSA9IFwiU2VtaWNvbG9uXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBBIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEIge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgQyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBEIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEUge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgRiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBHIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEgge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgSSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBKIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEsge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBNIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE4ge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBQIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFEge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgUiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBTIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgVSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBWIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFcge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgWCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBZIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFoge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiQVwiXSA9IDY1XSA9IFwiQVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiQlwiXSA9IDY2XSA9IFwiQlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiQ1wiXSA9IDY3XSA9IFwiQ1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRFwiXSA9IDY4XSA9IFwiRFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRVwiXSA9IDY5XSA9IFwiRVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRlwiXSA9IDcwXSA9IFwiRlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiR1wiXSA9IDcxXSA9IFwiR1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiSFwiXSA9IDcyXSA9IFwiSFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiSVwiXSA9IDczXSA9IFwiSVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiSlwiXSA9IDc0XSA9IFwiSlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiS1wiXSA9IDc1XSA9IFwiS1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTFwiXSA9IDc2XSA9IFwiTFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTVwiXSA9IDc3XSA9IFwiTVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTlwiXSA9IDc4XSA9IFwiTlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiT1wiXSA9IDc5XSA9IFwiT1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiUFwiXSA9IDgwXSA9IFwiUFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiUVwiXSA9IDgxXSA9IFwiUVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiUlwiXSA9IDgyXSA9IFwiUlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiU1wiXSA9IDgzXSA9IFwiU1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiVFwiXSA9IDg0XSA9IFwiVFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiVVwiXSA9IDg1XSA9IFwiVVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiVlwiXSA9IDg2XSA9IFwiVlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiV1wiXSA9IDg3XSA9IFwiV1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiWFwiXSA9IDg4XSA9IFwiWFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiWVwiXSA9IDg5XSA9IFwiWVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiWlwiXSA9IDkwXSA9IFwiWlwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgU2hpZnQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgQWx0IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFVwIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IERvd24ge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTGVmdCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBSaWdodCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBTcGFjZSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBFc2Mge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiU2hpZnRcIl0gPSAxNl0gPSBcIlNoaWZ0XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJBbHRcIl0gPSAxOF0gPSBcIkFsdFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiVXBcIl0gPSAzOF0gPSBcIlVwXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJEb3duXCJdID0gNDBdID0gXCJEb3duXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJMZWZ0XCJdID0gMzddID0gXCJMZWZ0XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJSaWdodFwiXSA9IDM5XSA9IFwiUmlnaHRcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRXNjXCJdID0gMjddID0gXCJFc2NcIjtcbiAgICAgICAgfSkoSW5wdXQuS2V5cyB8fCAoSW5wdXQuS2V5cyA9IHt9KSk7XG4gICAgICAgIHZhciBLZXlzID0gSW5wdXQuS2V5cztcbiAgICAgICAgO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgdGhyb3duIG9uIGEgZ2FtZSBvYmplY3QgZm9yIGEga2V5IGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBLZXlFdmVudFxuICAgICAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBrZXkge0lucHV0S2V5fSBUaGUga2V5IHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyB0aGUgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBLZXlFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoS2V5RXZlbnQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBLZXlFdmVudChrZXkpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBLZXlFdmVudDtcbiAgICAgICAgfSkoZXguR2FtZUV2ZW50KTtcbiAgICAgICAgSW5wdXQuS2V5RXZlbnQgPSBLZXlFdmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbmFnZXMgS2V5Ym9hcmQgaW5wdXQgZXZlbnRzIHRoYXQgeW91IGNhbiBxdWVyeSBvciBsaXN0ZW4gZm9yIGV2ZW50cyBvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgS2V5Ym9hcmRcbiAgICAgICAgICogQGV4dGVuZHMgQ2xhc3NcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgS2V5Ym9hcmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEtleWJvYXJkLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gS2V5Ym9hcmQoZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXNVcCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXNEb3duID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplIEtleWJvYXJkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLmxlbmd0aCA9IDA7IC8vIGVtcHRpZXMgYXJyYXkgZWZmaWNpZW50bHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBrZXkgdXAgaXMgb24gd2luZG93IGJlY2F1c2UgY2FudmFzIGNhbm5vdCBoYXZlIGZvY3VzXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfdGhpcy5fa2V5cy5pbmRleE9mKGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXNVcC5wdXNoKGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5RXZlbnQgPSBuZXcgS2V5RXZlbnQoZXYua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwidXBcIiwga2V5RXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGtleSBkb3duIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fa2V5cy5pbmRleE9mKGV2LmtleUNvZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXMucHVzaChldi5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzRG93bi5wdXNoKGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleUV2ZW50ID0gbmV3IEtleUV2ZW50KGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJkb3duXCIsIGtleUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBrZXlzRG93biBhbmQga2V5c1VwIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXNEb3duLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5c1VwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIGxpc3Qgb2Yga2V5cyBiZWluZyBwcmVzc2VkIGRvd25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgVGVzdHMgaWYgYSBjZXJ0YWluIGtleSBpcyBkb3duLlxuICAgICAgICAgICAgICogQG1ldGhvZCBpc0tleURvd25cbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkge0tleXN9IFRlc3Qgd2V0aGVyIGEga2V5IGlzIGRvd25cbiAgICAgICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmlzS2V5RG93biA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5c0Rvd24uaW5kZXhPZihrZXkpID4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgVGVzdHMgaWYgYSBjZXJ0YWluIGtleSBpcyBwcmVzc2VkLlxuICAgICAgICAgICAgICogQG1ldGhvZCBpc0tleVByZXNzZWRcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkge0tleXN9IFRlc3Qgd2V0aGVyIGEga2V5IGlzIHByZXNzZWRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmlzS2V5UHJlc3NlZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5cy5pbmRleE9mKGtleSkgPiAtMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IGlzIHVwLlxuICAgICAgICAgICAgICogQG1ldGhvZCBpc0tleVVwXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5IHtLZXlzfSBUZXN0IHdldGhlciBhIGtleSBpcyB1cFxuICAgICAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuaXNLZXlVcCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5c1VwLmluZGV4T2Yoa2V5KSA+IC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBLZXlib2FyZDtcbiAgICAgICAgfSkoZXguQ2xhc3MpO1xuICAgICAgICBJbnB1dC5LZXlib2FyZCA9IEtleWJvYXJkO1xuICAgIH0pKElucHV0ID0gZXguSW5wdXQgfHwgKGV4LklucHV0ID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIElucHV0O1xuICAgIChmdW5jdGlvbiAoSW5wdXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbmFnZXMgR2FtZXBhZCBBUEkgaW5wdXQuIFlvdSBjYW4gcXVlcnkgdGhlIGdhbWVwYWRzIHRoYXQgYXJlIGNvbm5lY3RlZFxuICAgICAgICAgKiBvciBsaXN0ZW4gdG8gZXZlbnRzIChcImJ1dHRvblwiIGFuZCBcImF4aXNcIikuXG4gICAgICAgICAqIEBjbGFzcyBHYW1lcGFkc1xuICAgICAgICAgKiBAZXh0ZW5kcyBDbGFzc1xuICAgICAgICAgKiBAcGFyYW0gcGFkcyB7R2FtZXBhZFtdfSBUaGUgY29ubmVjdGVkIGdhbWVwYWRzLlxuICAgICAgICAgKiBAcGFyYW0gc3VwcG9ydGVkIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgR2FtZXBhZCBBUEkgaXMgcHJlc2VudFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEdhbWVwYWRzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkcywgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRzKGVuZ2luZSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHBvbGwgZm9yIEdhbWVwYWQgaW5wdXQgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkIHtib29sZWFufVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IEdhbWVwYWQgQVBJIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzdXBwb3J0ZWQge2Jvb2xlYW59XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdXBwb3J0ZWQgPSAhIW5hdmlnYXRvci5nZXRHYW1lcGFkcztcbiAgICAgICAgICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wcyA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmF2aWdhdG9yID0gbmF2aWdhdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5pdFN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBJbiBDaHJvbWUsIHRoaXMgd2lsbCByZXR1cm4gNCB1bmRlZmluZWQgaXRlbXMgdW50aWwgYSBidXR0b24gaXMgcHJlc3NlZFxuICAgICAgICAgICAgICAgIC8vIEluIEZGLCB0aGlzIHdpbGwgbm90IHJldHVybiBhbnkgaXRlbXMgdW50aWwgYSBidXR0b24gaXMgcHJlc3NlZFxuICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHMgPSB0aGlzLl9jbG9uZVBhZHModGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbGRQYWRzLmxlbmd0aCAmJiB0aGlzLl9vbGRQYWRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGVzIEdhbWVwYWQgc3RhdGUgYW5kIHB1Ymxpc2hlcyBHYW1lcGFkIGV2ZW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuc3VwcG9ydGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGdhbWVwYWRzID0gdGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lcGFkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdhbWVwYWRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBjb25uZWN0aW9uIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnRlZCBpbiBDaHJvbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLnRpbWVzdGFtcCAmJiBnYW1lcGFkc1tpXS50aW1lc3RhbXAgPT09IHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSA9IGdhbWVwYWRzW2ldLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0dG9uc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiwgYSwgdmFsdWUsIGJ1dHRvbkluZGV4LCBheGVzSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoYiBpbiBCdXR0b25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEJ1dHRvbnNbYl0gIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25JbmRleCA9IEJ1dHRvbnNbYl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdhbWVwYWRzW2ldLmJ1dHRvbnNbYnV0dG9uSW5kZXhdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vbGRQYWRzW2ldLmdldEJ1dHRvbihidXR0b25JbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0uYnV0dG9uc1tidXR0b25JbmRleF0ucHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihidXR0b25JbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwiYnV0dG9uXCIsIG5ldyBHYW1lcGFkQnV0dG9uRXZlbnQoYnV0dG9uSW5kZXgsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihidXR0b25JbmRleCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSBpbiBBeGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEF4ZXNbYV0gIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGVzSW5kZXggPSBBeGVzW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnYW1lcGFkc1tpXS5heGVzW2F4ZXNJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX29sZFBhZHNbaV0uZ2V0QXhlcyhheGVzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS51cGRhdGVBeGVzKGF4ZXNJbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJheGlzXCIsIG5ldyBHYW1lcGFkQXhpc0V2ZW50KGF4ZXNJbmRleCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzW2ldID0gdGhpcy5fY2xvbmVQYWQoZ2FtZXBhZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNhZmVseSByZXRyaWV2ZXMgYSBHYW1lcGFkIGF0IGEgc3BlY2lmaWMgaW5kZXggYW5kIGNyZWF0ZXMgb25lIGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9wYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fcGFkcy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHNbaW5kZXhdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbm5lY3RlZCBnYW1lcGFkc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmNvbm5lY3RlZDsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5fY2xvbmVQYWRzID0gZnVuY3Rpb24gKHBhZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5fY2xvbmVQYWQocGFkc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFzdGVzdCB3YXkgdG8gY2xvbmUgYSBrbm93biBvYmplY3QgaXMgdG8gZG8gaXQgeW91cnNlbGZcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9jbG9uZVBhZCA9IGZ1bmN0aW9uIChwYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbGVuO1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWRQYWQgPSBuZXcgR2FtZXBhZCgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFkO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhZC5idXR0b25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVCdXR0b24oaSwgcGFkLmJ1dHRvbnNbaV0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYXhlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWRQYWQudXBkYXRlQXhlcyhpLCBwYWQuYXhlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbWluaW11bSB2YWx1ZSBhbiBheGlzIGhhcyB0byBtb3ZlIGJlZm9yZSBjb25zaWRlcmluZyBpdCBhIGNoYW5nZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IE1pbkF4aXNNb3ZlVGhyZXNob2xkIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkID0gMC4wNTtcbiAgICAgICAgICAgIHJldHVybiBHYW1lcGFkcztcbiAgICAgICAgfSkoZXguQ2xhc3MpO1xuICAgICAgICBJbnB1dC5HYW1lcGFkcyA9IEdhbWVwYWRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaXZpZHVhbCBzdGF0ZSBmb3IgYSBHYW1lcGFkXG4gICAgICAgICAqIEBjbGFzcyBHYW1lcGFkXG4gICAgICAgICAqIEBleHRlbmRzIENsYXNzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgR2FtZXBhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdhbWVwYWQoKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25zID0gbmV3IEFycmF5KDE2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9heGVzID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9idXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvbnNbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9heGVzW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBidXR0b24gaXMgcHJlc3NlZFxuICAgICAgICAgICAgICogQHBhcmFtIGJ1dHRvbiB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBwYXJhbSBbdGhyZXNob2xkPTFdIHtudW1iZXJ9IFRoZSB0aHJlc2hvbGQgb3ZlciB3aGljaCB0aGUgYnV0dG9uIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc3NlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5pc0J1dHRvblByZXNzZWQgPSBmdW5jdGlvbiAoYnV0dG9uLCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHsgdGhyZXNob2xkID0gMTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idXR0b25zW2J1dHRvbl0gPj0gdGhyZXNob2xkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgZ2l2ZW4gYnV0dG9uIHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gYnV0dG9uIHtCdXR0b25zfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5nZXRCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGdpdmVuIGF4aXMgdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBheGVzIHtBeGVzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9heGVzW2F4ZXNdO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCBHYW1lcGFkcy5NaW5BeGlzTW92ZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUudXBkYXRlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbkluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvbnNbYnV0dG9uSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUudXBkYXRlQXhlcyA9IGZ1bmN0aW9uIChheGVzSW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhlc1theGVzSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEdhbWVwYWQ7XG4gICAgICAgIH0pKGV4LkNsYXNzKTtcbiAgICAgICAgSW5wdXQuR2FtZXBhZCA9IEdhbWVwYWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHYW1lcGFkIEJ1dHRvbnMgZW51bWVyYXRpb25cbiAgICAgICAgICogQGNsYXNzIEJ1dHRvbnNcbiAgICAgICAgICovXG4gICAgICAgIChmdW5jdGlvbiAoQnV0dG9ucykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYWNlIDEgYnV0dG9uIChlLmcuIEEpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRmFjZTEge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFjZSAyIGJ1dHRvbiAoZS5nLiBCKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IEZhY2UyIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZhY2UgMyBidXR0b24gKGUuZy4gWClcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBGYWNlMyB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYWNlIDQgYnV0dG9uIChlLmcuIFkpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRmFjZTQge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UxXCJdID0gMF0gPSBcIkZhY2UxXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlMlwiXSA9IDFdID0gXCJGYWNlMlwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTNcIl0gPSAyXSA9IFwiRmFjZTNcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2U0XCJdID0gM10gPSBcIkZhY2U0XCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlZnQgYnVtcGVyIGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IExlZnRCdW1wZXIge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmlnaHQgYnVtcGVyIGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFJpZ2h0QnVtcGVyIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0QnVtcGVyXCJdID0gNF0gPSBcIkxlZnRCdW1wZXJcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0QnVtcGVyXCJdID0gNV0gPSBcIlJpZ2h0QnVtcGVyXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlZnQgdHJpZ2dlciBidXR0b25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0VHJpZ2dlciB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaWdodCB0cmlnZ2VyIGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFJpZ2h0VHJpZ2dlciB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdFRyaWdnZXJcIl0gPSA2XSA9IFwiTGVmdFRyaWdnZXJcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0VHJpZ2dlclwiXSA9IDddID0gXCJSaWdodFRyaWdnZXJcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VsZWN0IGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFNlbGVjdCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGFydCBidXR0b25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBTdGFydCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiU2VsZWN0XCJdID0gOF0gPSBcIlNlbGVjdFwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiU3RhcnRcIl0gPSA5XSA9IFwiU3RhcnRcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVmdCBhbmFsb2cgc3RpY2sgcHJlc3MgKGUuZy4gTDMpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFN0aWNrIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJpZ2h0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBSMylcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBTdGFydCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdFN0aWNrXCJdID0gMTBdID0gXCJMZWZ0U3RpY2tcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0U3RpY2tcIl0gPSAxMV0gPSBcIlJpZ2h0U3RpY2tcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRC1wYWQgdXBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBEcGFkVXAge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRC1wYWQgZG93blxuICAgICAgICAgICAgICogQHByb3BlcnR5IERwYWREb3duIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEQtcGFkIGxlZnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBEcGFkTGVmdCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBELXBhZCByaWdodFxuICAgICAgICAgICAgICogQHByb3BlcnR5IERwYWRSaWdodCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZFVwXCJdID0gMTJdID0gXCJEcGFkVXBcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWREb3duXCJdID0gMTNdID0gXCJEcGFkRG93blwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZExlZnRcIl0gPSAxNF0gPSBcIkRwYWRMZWZ0XCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkUmlnaHRcIl0gPSAxNV0gPSBcIkRwYWRSaWdodFwiO1xuICAgICAgICB9KShJbnB1dC5CdXR0b25zIHx8IChJbnB1dC5CdXR0b25zID0ge30pKTtcbiAgICAgICAgdmFyIEJ1dHRvbnMgPSBJbnB1dC5CdXR0b25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2FtZXBhZCBBeGVzIGVudW1lcmF0aW9uXG4gICAgICAgICAqIEBjbGFzcyBBeGVzXG4gICAgICAgICAqL1xuICAgICAgICAoZnVuY3Rpb24gKEF4ZXMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVmdCBhbmFsb2d1ZSBzdGljayBYIGRpcmVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IExlZnRTdGlja1gge0F4ZXN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVmdCBhbmFsb2d1ZSBzdGljayBZIGRpcmVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IExlZnRTdGlja1kge0F4ZXN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmlnaHQgYW5hbG9ndWUgc3RpY2sgWCBkaXJlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBSaWdodFN0aWNrWCB7QXhlc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaWdodCBhbmFsb2d1ZSBzdGljayBZIGRpcmVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFJpZ2h0U3RpY2tZIHtBeGVzfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBeGVzW0F4ZXNbXCJMZWZ0U3RpY2tYXCJdID0gMF0gPSBcIkxlZnRTdGlja1hcIjtcbiAgICAgICAgICAgIEF4ZXNbQXhlc1tcIkxlZnRTdGlja1lcIl0gPSAxXSA9IFwiTGVmdFN0aWNrWVwiO1xuICAgICAgICAgICAgQXhlc1tBeGVzW1wiUmlnaHRTdGlja1hcIl0gPSAyXSA9IFwiUmlnaHRTdGlja1hcIjtcbiAgICAgICAgICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tZXCJdID0gM10gPSBcIlJpZ2h0U3RpY2tZXCI7XG4gICAgICAgIH0pKElucHV0LkF4ZXMgfHwgKElucHV0LkF4ZXMgPSB7fSkpO1xuICAgICAgICB2YXIgQXhlcyA9IElucHV0LkF4ZXM7XG4gICAgICAgIHZhciBHYW1lcGFkQnV0dG9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEdhbWVwYWRCdXR0b25FdmVudCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRCdXR0b25FdmVudChidXR0b24sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24gPSBidXR0b247XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdhbWVwYWRCdXR0b25FdmVudDtcbiAgICAgICAgfSkoZXguR2FtZUV2ZW50KTtcbiAgICAgICAgSW5wdXQuR2FtZXBhZEJ1dHRvbkV2ZW50ID0gR2FtZXBhZEJ1dHRvbkV2ZW50O1xuICAgICAgICB2YXIgR2FtZXBhZEF4aXNFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZEF4aXNFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRBeGlzRXZlbnQoYXhpcywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF4aXMgPSBheGlzO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBHYW1lcGFkQXhpc0V2ZW50O1xuICAgICAgICB9KShleC5HYW1lRXZlbnQpO1xuICAgICAgICBJbnB1dC5HYW1lcGFkQXhpc0V2ZW50ID0gR2FtZXBhZEF4aXNFdmVudDtcbiAgICB9KShJbnB1dCA9IGV4LklucHV0IHx8IChleC5JbnB1dCA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vbmtleVBhdGNoLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudHMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50RGlzcGF0Y2hlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ2xhc3MudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2cudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbGxpc2lvbi9TaWRlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTY2VuZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlVJQWN0b3IudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRyaWdnZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlBhcnRpY2xlcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQW5pbWF0aW9uLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDYW1lcmEudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNvdW5kLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2FkZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlByb21pc2VzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVdGlsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJCaW5kaW5nLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUaWxlTWFwLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMYWJlbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUG9zdFByb2Nlc3NpbmcvSVBvc3RQcm9jZXNzb3IudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW5wdXQvSUVuZ2luZUlucHV0LnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIklucHV0L1BvaW50ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW5wdXQvS2V5Ym9hcmQudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW5wdXQvR2FtZXBhZC50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGRpc3BsYXkgbW9kZXMgYXZhaWxhYmxlIHRvIEV4Y2FsaWJ1clxuICAgICAqIEBjbGFzcyBEaXNwbGF5TW9kZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoRGlzcGxheU1vZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGdhbWUgYXMgZnVsbCBzY3JlZW5cbiAgICAgICAgICogQHByb3BlcnR5IEZ1bGxTY3JlZW4ge0Rpc3BsYXlNb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJGdWxsU2NyZWVuXCJdID0gMF0gPSBcIkZ1bGxTY3JlZW5cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIHRoZSBnYW1lIHRvIHRoZSBwYXJlbnQgRE9NIGNvbnRhaW5lclxuICAgICAgICAgKiBAcHJvcGVydHkgQ29udGFpbmVyIHtEaXNwbGF5TW9kZX1cbiAgICAgICAgICovXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiQ29udGFpbmVyXCJdID0gMV0gPSBcIkNvbnRhaW5lclwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZ2FtZSBhcyBhIGZpeGVkIHNpemVcbiAgICAgICAgICogQFByb3BlcnR5IEZpeGVkIHtEaXNwbGF5TW9kZX1cbiAgICAgICAgICovXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiRml4ZWRcIl0gPSAyXSA9IFwiRml4ZWRcIjtcbiAgICB9KShleC5EaXNwbGF5TW9kZSB8fCAoZXguRGlzcGxheU1vZGUgPSB7fSkpO1xuICAgIHZhciBEaXNwbGF5TW9kZSA9IGV4LkRpc3BsYXlNb2RlO1xuICAgIC8vIGludGVybmFsXG4gICAgdmFyIEFuaW1hdGlvbk5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Ob2RlKGFuaW1hdGlvbiwgeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uTm9kZTtcbiAgICB9KSgpO1xuICAgIC8qKlxuICAgICAqIFRoZSAnRW5naW5lJyBpcyB0aGUgbWFpbiBkcml2ZXIgZm9yIGEgZ2FtZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yXG4gICAgICogc3RhcnRpbmcvc3RvcHBpbmcgdGhlIGdhbWUsIG1haW50YWluaW5nIHN0YXRlLCB0cmFuc21pdHRpbmcgZXZlbnRzLFxuICAgICAqIGxvYWRpbmcgcmVzb3VyY2VzLCBhbmQgbWFuYWdpbmcgdGhlIHNjZW5lLlxuICAgICAqXG4gICAgICogQGNsYXNzIEVuZ2luZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbd2lkdGhdIHtudW1iZXJ9IFRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgdGhlIEV4Y2FsaWJ1ciBnYW1lIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIFtoZWlnaHRdIHtudW1iZXJ9IFRoZSBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBFeGNhbGlidXIgZ2FtZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBbY2FudmFzRWxlbWVudElkXSB7c3RyaW5nfSBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gYSBuZXcgY2FudmFzIHdpbGwgYmUgY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgaW50byB0aGUgYm9keS5cbiAgICAgKiBAcGFyYW0gW2Rpc3BsYXlNb2RlXSB7RGlzcGxheU1vZGV9IElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlbiBpdCB3aWxsIGZhbGwgYmFjayB0byBmaXhlZCBpZiBhIGhlaWdodCBhbmQgd2lkdGggYXJlIHNwZWNpZmllZCwgZWxzZSB0aGUgZGlzcGxheSBtb2RlIHdpbGwgYmUgRnVsbFNjcmVlbi5cbiAgICAgKi9cbiAgICB2YXIgRW5naW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVuZ2luZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRW5naW5lKHdpZHRoLCBoZWlnaHQsIGNhbnZhc0VsZW1lbnRJZCwgZGlzcGxheU1vZGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGNvbGxpc2lvbiBzdHJhdGVneSBmb3IgRXhjYWxpYnVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uU3RyYXRlZ3kge0NvbGxpc2lvblN0cmF0ZWd5fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblN0cmF0ZWd5ID0gMSAvKiBEeW5hbWljQUFCQlRyZWUgKi87XG4gICAgICAgICAgICB0aGlzLmhhc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZnBzID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVIYXNoID0ge307XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBpcyBzZXQgdG8gZnVsbHNjcmVlbiBvciBub3RcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpc0Z1bGxzY3JlZW4ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB0aGUgY3VycmVudCBEaXNwbGF5TW9kZSBvZiB0aGUgZW5naW5lLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtkaXNwbGF5TW9kZT1GdWxsU2NyZWVuXSB7RGlzcGxheU1vZGV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheU1vZGUgPSAwIC8qIEZ1bGxTY3JlZW4gKi87XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGF1ZGlvIHNob3VsZCBiZSBwYXVzZWQgd2hlbiB0aGUgZ2FtZSBpcyBubyBsb25nZXIgdmlzaWJsZS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcGF1c2VBdWRpb1doZW5IaWRkZW49dHJ1ZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGF1c2VBdWRpb1doZW5IaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZW5naW5lIHNob3VsZCBkcmF3IHdpdGggZGVidWcgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbaXNEZWJ1Zz1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNEZWJ1ZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z0NvbG9yID0gbmV3IGV4LkNvbG9yKDI1NSwgMjU1LCAyNTUpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgZW5naW5lLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtiYWNrZ3JvdW5kQ29sb3I9bmV3IENvbG9yKDAsIDAsIDEwMCldIHtDb2xvcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgZXguQ29sb3IoMCwgMCwgMTAwKTtcbiAgICAgICAgICAgIHRoaXMuaXNTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHRoaXMudG90YWwgPSAxO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJQb3dlcmVkIGJ5IEV4Y2FsaWJ1ci5qcyB2aXNpdFwiLCBcImh0dHA6Ly9leGNhbGlidXJqcy5jb21cIiwgXCJmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIik7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkJ1aWxkaW5nIGVuZ2luZS4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzRWxlbWVudElkID0gY2FudmFzRWxlbWVudElkO1xuICAgICAgICAgICAgaWYgKGNhbnZhc0VsZW1lbnRJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiVXNpbmcgQ2FudmFzIGVsZW1lbnQgc3BlY2lmaWVkOiBcIiArIGNhbnZhc0VsZW1lbnRJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNFbGVtZW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJVc2luZyBnZW5lcmF0ZWQgY2FudmFzIGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheU1vZGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU1vZGUgPSAyIC8qIEZpeGVkICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkVuZ2luZSB2aWV3cG9ydCBpcyBzaXplIFwiICsgd2lkdGggKyBcIiB4IFwiICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGlzcGxheU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkVuZ2luZSB2aWV3cG9ydCBpcyBmdWxsc2NyZWVuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU1vZGUgPSAwIC8qIEZ1bGxTY3JlZW4gKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBleC5Mb2FkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yb290U2NlbmUgPSB0aGlzLmN1cnJlbnRTY2VuZSA9IG5ldyBleC5TY2VuZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkU2NlbmUoJ3Jvb3QnLCB0aGlzLnJvb3RTY2VuZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYXlzIGEgc3ByaXRlIGFuaW1hdGlvbiBvbiB0aGUgc2NyZWVuIGF0IHRoZSBzcGVjaWZpZWQgeCBhbmQgeVxuICAgICAgICAgKiAoaW4gZ2FtZSBjb29yZGluYXRlcywgbm90IHNjcmVlbiBwaXhlbHMpLiBUaGVzZSBhbmltYXRpb25zIHBsYXlcbiAgICAgICAgICogaW5kZXBlbmRlbnQgb2YgYWN0b3JzLCBhbmQgd2lsbCBiZSBjbGVhbmVkIHVwIGludGVybmFsbHkgYXMgc29vblxuICAgICAgICAgKiBhcyB0aGV5IGFyZSBjb21wbGV0ZS4gTm90ZSBhbmltYXRpb25zIHRoYXQgbG9vcCB3aWxsIG5ldmVyIGJlXG4gICAgICAgICAqIGNsZWFuZWQgdXAuXG4gICAgICAgICAqIEBtZXRob2QgcGxheUFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIHtBbmltYXRpb259IEFuaW1hdGlvbiB0byBwbGF5XG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IHggZ2FtZSBjb29yZGluYXRlIHRvIHBsYXkgdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSB5IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb24sIHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKG5ldyBBbmltYXRpb25Ob2RlKGFuaW1hdGlvbiwgeCwgeSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byB0aGUgY3VycmVudCBzY2VuZSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyBzeW5vbnltb3VzXG4gICAgICAgICAqIHRvIGNhbGxpbmcgZW5naW5lLmN1cnJlbnRTY2VuZS5hZGRDaGlsZChhY3RvciA6IEFjdG9yKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQWN0b3JzIGNhbiBvbmx5IGJlIGRyYXduIGlmIHRoZXkgYXJlIGEgbWVtYmVyIG9mIGEgc2NlbmUsIGFuZCBvbmx5XG4gICAgICAgICAqIHRoZSAnY3VycmVudFNjZW5lJyBtYXkgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gYWRkIHRvIHRoZSBjdXJyZW50IHNjZW5lXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRDaGlsZChhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gdGhlIGN1cnJlbnRTY2VuZSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyBzeW5vbnltb3VzXG4gICAgICAgICAqIHRvIGNhbGxpbmcgZW5naW5lLmN1cnJlbnRTY2VuZS5yZW1vdmVDaGlsZChhY3RvciA6IEFjdG9yKS5cbiAgICAgICAgICogQWN0b3JzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBhIHNjZW5lIHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRvIHJlbW92ZSBmcm9tIHRoZSBjdXJyZW50IHNjZW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlQ2hpbGQoYWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIFRpbGVNYXAgdG8gdGhlIFNjZW5lLCBvbmNlIHRoaXMgaXMgZG9uZSB0aGUgVGlsZU1hcCB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGFkZFRpbGVNYXBcbiAgICAgICAgICogQHBhcmFtIHRpbGVNYXAge1RpbGVNYXB9XG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZFRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuYWRkVGlsZU1hcCh0aWxlTWFwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBUaWxlTWFwIGZyb20gdGhlIFNjZW5lLCBpdCB3aWxsbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlVGlsZU1hcFxuICAgICAgICAgKiBAcGFyYW0gdGlsZU1hcCB7VGlsZU1hcH1cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVUaWxlTWFwKHRpbGVNYXApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBleGNhbGlidXIgdGltZXIgdG8gdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byBhZGQgdG8gdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgICAgICAqIEBtZXRob2QgYWRkVGltZXJcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5hZGRUaW1lcih0aW1lcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGV4Y2FsaWJ1ciB0aW1lciBmcm9tIHRoZSBjdXJyZW50IHNjZW5lLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVRpbWVyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byByZW1vdmUgdG8gdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVGltZXIodGltZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIHNjZW5lIHRvIHRoZSBlbmdpbmUsIHRoaW5rIG9mIHNjZW5lcyBpbiBleGNhbGlidXIgYXMgeW91XG4gICAgICAgICAqIHdvdWxkIHNjZW5lcyBpbiBhIHBsYXkuXG4gICAgICAgICAqIEBtZXRob2QgYWRkU2NlbmVcbiAgICAgICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHNjZW5lLCBtdXN0IGJlIHVuaXF1ZVxuICAgICAgICAgKiBAcGFyYW0gc2NlbmUge1NjZW5lfSBUaGUgc2NlbmUgdG8gYWRkIHRvIHRoZSBlbmdpbmVcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkU2NlbmUgPSBmdW5jdGlvbiAobmFtZSwgc2NlbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lSGFzaFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJTY2VuZVwiLCBuYW1lLCBcImFscmVhZHkgZXhpc3RzIG92ZXJ3cml0aW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2VuZUhhc2hbbmFtZV0gPSBzY2VuZTtcbiAgICAgICAgICAgIHNjZW5lLmVuZ2luZSA9IHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlU2NlbmUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguU2NlbmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zY2VuZUhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVIYXNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lSGFzaFtrZXldID09PSBlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2VuZUhhc2hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50aXR5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNjZW5lXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVIYXNoW2VudGl0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlVJQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRVSUFjdG9yKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LkFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaW1lcihlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbGVNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbGVNYXAoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2VuZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlVJQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVVSUFjdG9yKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LkFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcihlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbGVNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGVNYXAoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5TY2VuZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NlbmUoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50aXR5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgY3VycmVudGx5IHVwZGF0aW5nIGFuZCBkcmF3aW5nIHNjZW5lIHRvIGEgZGlmZmVyZW50LFxuICAgICAgICAgKiBuYW1lZCBzY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBnb1RvU2NlbmVcbiAgICAgICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHNjZW5lIHRvIHRyYXNpdGlvbiB0by5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ29Ub1NjZW5lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lSGFzaFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRGVhY3RpdmF0ZS5jYWxsKHRoaXMuY3VycmVudFNjZW5lKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU2NlbmUgPSB0aGlzLmN1cnJlbnRTY2VuZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9IHRoaXMuc2NlbmVIYXNoW25hbWVdO1xuICAgICAgICAgICAgICAgIG9sZFNjZW5lLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdkZWFjdGl2YXRlJywgbmV3IGV4LkRlYWN0aXZhdGVFdmVudCh0aGlzLmN1cnJlbnRTY2VuZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uQWN0aXZhdGUuY2FsbCh0aGlzLmN1cnJlbnRTY2VuZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2FjdGl2YXRlJywgbmV3IGV4LkFjdGl2YXRlRXZlbnQob2xkU2NlbmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2NlbmVcIiwgbmFtZSwgXCJkb2VzIG5vdCBleGlzdCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZW5naW5lcyBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzLlxuICAgICAgICAgKiBAbWV0aG9kIGdldFdpZHRoXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlciBUaGUgd2lkdGggb2YgdGhlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoIC8gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldFpvb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmVzIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0SGVpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlciBUaGUgaGVpZ2h0IG9mIHRoZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0IC8gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldFpvb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybXMgdGhlIGN1cnJlbnQgeCwgeSBmcm9tIHNjcmVlbiBjb29yZGluYXRlcyB0byB3b3JsZCBjb29yZGluYXRlc1xuICAgICAgICAgKiBAbWV0aG9kIHNjcmVlblRvV29ybGRDb29yZGluYXRlc1xuICAgICAgICAgKiBAcGFyYW0gcG9pbnQge1BvaW50fSBzY3JlZW4gY29vcmRpbmF0ZSB0byBjb252ZXJ0XG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgLy8gdG9kbyBzZXQgdGhlc2UgYmFjayB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aFxuICAgICAgICAgICAgdmFyIG5ld1ggPSBwb2ludC54O1xuICAgICAgICAgICAgdmFyIG5ld1kgPSBwb2ludC55O1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRGb2N1cygpO1xuICAgICAgICAgICAgICAgIG5ld1ggPSBmb2N1cy54ICsgKHBvaW50LnggLSAodGhpcy5nZXRXaWR0aCgpIC8gMikpO1xuICAgICAgICAgICAgICAgIG5ld1kgPSBmb2N1cy55ICsgKHBvaW50LnkgLSAodGhpcy5nZXRIZWlnaHQoKSAvIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ggPSBNYXRoLmZsb29yKChuZXdYIC8gdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpICogdGhpcy5nZXRXaWR0aCgpKTtcbiAgICAgICAgICAgIG5ld1kgPSBNYXRoLmZsb29yKChuZXdZIC8gdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KSAqIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludChuZXdYLCBuZXdZKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybXMgYSB3b3JsZCBjb29yZGluYXRlLCB0byBhIHNjcmVlbiBjb29yZGluYXRlXG4gICAgICAgICAqIEBtZXRob2Qgd29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCB7UG9pbnR9IHdvcmxkIGNvb3JkaW5hdGUgdG8gY29udmVydFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gc2V0IHRoZXNlIGJhY2sgdGhpcy5jYW52YXMuY2xpZW50V2lkdGhcbiAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgY29ycmVjdCBvbiB6b29tXG4gICAgICAgICAgICB2YXIgc2NyZWVuWCA9IHBvaW50Lng7XG4gICAgICAgICAgICB2YXIgc2NyZWVuWSA9IHBvaW50Lnk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldEZvY3VzKCk7XG4gICAgICAgICAgICAgICAgc2NyZWVuWCA9IChwb2ludC54IC0gZm9jdXMueCkgKyAodGhpcy5nZXRXaWR0aCgpIC8gMik7IC8vKHRoaXMuZ2V0V2lkdGgoKSAvIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgICAgICBzY3JlZW5ZID0gKHBvaW50LnkgLSBmb2N1cy55KSArICh0aGlzLmdldEhlaWdodCgpIC8gMik7IC8vICh0aGlzLmdldEhlaWdodCgpIC8gdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcmVlblggPSBNYXRoLmZsb29yKChzY3JlZW5YIC8gdGhpcy5nZXRXaWR0aCgpKSAqIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgIHNjcmVlblkgPSBNYXRoLmZsb29yKChzY3JlZW5ZIC8gdGhpcy5nZXRIZWlnaHQoKSkgKiB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludChzY3JlZW5YLCBzY3JlZW5ZKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGludGVybmFsIGNhbnZhcyBoZWlnaHQgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGRpc3BsYXkgbW9kZS5cbiAgICAgICAgICogQG1ldGhvZCBzZXRIZWlnaHRCeURpc3BsYXlNb2RlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNldEhlaWdodEJ5RGlzcGxheU1vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gMSAvKiBDb250YWluZXIgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IDAgLyogRnVsbFNjcmVlbiAqLykge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzBweCc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCA9IHBhcmVudC5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGFyZW50LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGNhbnZhcywgcmVuZGVyaW5nIGNvbnRleHQsIGRpc3BsYXltb2RlLCBhbmQgbmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gMCAvKiBGdWxsU2NyZWVuICovIHx8IHRoaXMuZGlzcGxheU1vZGUgPT09IDEgLyogQ29udGFpbmVyICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmRpc3BsYXlNb2RlID09PSAxIC8qIENvbnRhaW5lciAqLyA/ICh0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpIDogd2luZG93KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodEJ5RGlzcGxheU1vZGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIlZpZXcgcG9ydCByZXNpemVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRIZWlnaHRCeURpc3BsYXlNb2RlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5pbmZvKFwicGFyZW50LmNsaWVudEhlaWdodCBcIiArIHBhcmVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRBbnRpYWxpYXNpbmcoX3RoaXMuaXNTbW9vdGhpbmdFbmFibGVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgaW5wdXRzXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0ge1xuICAgICAgICAgICAgICAgIGtleWJvYXJkOiBuZXcgZXguSW5wdXQuS2V5Ym9hcmQodGhpcyksXG4gICAgICAgICAgICAgICAgcG9pbnRlcnM6IG5ldyBleC5JbnB1dC5Qb2ludGVycyh0aGlzKSxcbiAgICAgICAgICAgICAgICBnYW1lcGFkczogbmV3IGV4LklucHV0LkdhbWVwYWRzKHRoaXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMuaW5pdCgpO1xuICAgICAgICAgICAgLy8gSXNzdWUgIzM4NSBtYWtlIHVzZSBvZiB0aGUgdmlzaWJpbGl0eSBhcGlcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL1VzZXJfZXhwZXJpZW5jZS9Vc2luZ190aGVfUGFnZV9WaXNpYmlsaXR5X0FQSVxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4gfHwgZG9jdW1lbnQubXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2hpZGRlbicsIG5ldyBleC5IaWRkZW5FdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiV2luZG93IGhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCd2aXNpYmxlJywgbmV3IGV4LlZpc2libGVFdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiV2luZG93IHZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBpbiBmYXZvciBvZiB2aXNpYmlsaXR5IGFwaVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKEV2ZW50VHlwZVtFdmVudFR5cGUuQmx1cl0sIG5ldyBCbHVyRXZlbnQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgIFxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaChFdmVudFR5cGVbRXZlbnRUeXBlLkZvY3VzXSwgbmV3IEZvY3VzRXZlbnQoKSk7XG4gICAgICAgICAgICB9KTsqL1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbnZhc0VsZW1lbnRJZCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLCB0aGlzIHdpbGwgc2V0IHRoZSBhbnRpYWxpYXNpbmcgZmxhZyBvbiB0aGVcbiAgICAgICAgICogY2FudmFzLiBTZXQgdGhpcyB0byBmYWxzZSBpZiB5b3Ugd2FudCBhICdqYWdnZWQnIHBpeGVsIGFydCBsb29rIHRvIHlvdXJcbiAgICAgICAgICogaW1hZ2UgcmVzb3VyY2VzLlxuICAgICAgICAgKiBAbWV0aG9kIHNldEFudGlhbGlhc2luZ1xuICAgICAgICAgKiBAcGFyYW0gaXNTbW9vdGgge2Jvb2xlYW59IFNldCBzbW9vdGhpbmcgdG8gdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zZXRBbnRpYWxpYXNpbmcgPSBmdW5jdGlvbiAoaXNTbW9vdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XG4gICAgICAgICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcbiAgICAgICAgICAgIHRoaXMuY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xuICAgICAgICAgICAgdGhpcy5jdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XG4gICAgICAgICAgICB0aGlzLmN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIFJldHVybiB0aGUgY3VycmVudCBzbW9vdGhpbmcgc3RhdHVzIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICogQG1ldGhvZCBnZXRBbnRpYWxpYXNpbmdcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nZXRBbnRpYWxpYXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IHRoaXMuY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCB0aGlzLmN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgdGhpcy5jdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBlbnRpcmUgc3RhdGUgb2YgdGhlIGdhbWVcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gc3VzcGVuZCB1cGRhdGVzIHVudGlsbCBsb2FkaW5nIGlzIGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvY2VzcyBlbmdpbmUgbGV2ZWwgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS51cGRhdGUodGhpcywgZGVsdGEpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWEuYW5pbWF0aW9uLmlzRG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgaW5wdXQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICAvLyBQdWJsaXNoIHVwZGF0ZSBldmVudFxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaChleC5FdmVudFR5cGVbNSAvKiBVcGRhdGUgKi9dLCBuZXcgZXguVXBkYXRlRXZlbnQoZGVsdGEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIHRoZSBlbnRpcmUgZ2FtZVxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIGRyYXcge251bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGRyYXcuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnYmxhY2snO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TG9hZGluZ0JhcihjdHgsIHRoaXMucHJvZ3Jlc3MsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgICAgIC8vIERyYXdpbmcgbm90aGluZyBlbHNlIHdoaWxlIGxvYWRpbmdcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvci50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmRyYXcodGhpcy5jdHgsIGRlbHRhKTtcbiAgICAgICAgICAgIC8vIHRvZG8gbmVlZHMgdG8gYmUgYSBiZXR0ZXIgd2F5IG9mIGRvaW5nIHRoaXNcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgYS5hbmltYXRpb24uZHJhdyhjdHgsIGEueCwgYS55KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mcHMgPSAxLjAgLyAoZGVsdGEgLyAxMDAwKTtcbiAgICAgICAgICAgIC8vIERyYXcgZGVidWcgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5mb250ID0gXCJDb25zb2xhc1wiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuZGVidWdDb2xvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5pbnB1dC5rZXlib2FyZC5nZXRLZXlzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KGtleXNbal0udG9TdHJpbmcoKSArIFwiIDogXCIgKyAoZXguSW5wdXQuS2V5c1trZXlzW2pdXSA/IGV4LklucHV0LktleXNba2V5c1tqXV0gOiBcIk5vdCBNYXBwZWRcIiksIDEwMCwgMTAgKiBqICsgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChcIkZQUzpcIiArIHRoaXMuZnBzLnRvRml4ZWQoMikudG9TdHJpbmcoKSwgMTAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnNbaV0ucHJvY2Vzcyh0aGlzLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCB0aGlzLmN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2N0eC5kcmF3SW1hZ2UoY3VycmVudEltYWdlLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgdGhlIGludGVybmFsIGdhbWUgbG9vcCBmb3IgRXhjYWxpYnVyIGFmdGVyIGxvYWRpbmdcbiAgICAgICAgICogYW55IHByb3ZpZGVkIGFzc2V0cy5cbiAgICAgICAgICogQG1ldGhvZCBzdGFydFxuICAgICAgICAgKiBAcGFyYW0gW2xvYWRlcj11bmRlZmluZWRdIHtJTG9hZGFibGV9IE9wdGlvbmFsIHJlc291cmNlcyB0byBsb2FkIGJlZm9yZVxuICAgICAgICAgKiBzdGFydGluZyB0aGUgbWFpbmxvb3AuIFNvbWUgbG9hZGFibGUgc3VjaCBhcyBhIExvYWRlciBjb2xsZWN0aW9uLCBTb3VuZCwgb3IgVGV4dHVyZS5cbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgICAgIHZhciBsb2FkaW5nQ29tcGxldGU7XG4gICAgICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyLndpcmVFbmdpbmUodGhpcyk7XG4gICAgICAgICAgICAgICAgbG9hZGluZ0NvbXBsZXRlID0gdGhpcy5sb2FkKGxvYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nQ29tcGxldGUgPSBleC5Qcm9taXNlLndyYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN0YXJ0aW5nIGdhbWUuLi5cIik7XG4gICAgICAgICAgICAgICAgLy8gTWFpbmxvb3BcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHZhciBnYW1lID0gdGhpcztcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gbWFpbmxvb3AoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2FtZS5oYXNTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtYWlubG9vcCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGltZSB0byBjYWxjdWxhdGUgdGltZS1lbGFwc2VkXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZCA9IE1hdGguZmxvb3Iobm93IC0gbGFzdFRpbWUpIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmVzIGlzc3VlICMxMzggaWYgdGhlIGdhbWUgaGFzIGJlZW4gcGF1c2VkLCBvciBibHVycmVkIGZvciBcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSB0aGFuIGEgMjAwIG1pbGxpc2Vjb25kcywgcmVzZXQgZWxhcHNlZCB0aW1lIHRvIDEuIFRoaXMgaW1wcm92ZXMgcmVsaWFiaWxpdHkgXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm92aWRlcyBtb3JlIGV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSBjb21lcyBiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gZm9jdXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsYXBzZWQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdhbWUudXBkYXRlKGVsYXBzZWQpO1xuICAgICAgICAgICAgICAgICAgICBnYW1lLmRyYXcoZWxhcHNlZCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gbm93O1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJHYW1lIHN0YXJ0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2FkaW5nQ29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyBFeGNhbGlidXIncyBtYWlubG9vcCwgdXNlZnVsIGZvciBwYXVzaW5nIHRoZSBnYW1lLlxuICAgICAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdhbWUgc3RvcHBlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgc2NyZWVuIHNob3Qgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQgYW5kIHJldHVybnMgaXQgYXMgYW5cbiAgICAgICAgICogSFRNTCBJbWFnZSBFbGVtZW50LlxuICAgICAgICAgKiBAbWV0aG9kIHNjcmVlbnNob3RcbiAgICAgICAgICogQHJldHVybnMgSFRNTEltYWdlRWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zY3JlZW5zaG90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgIHJlc3VsdC5zcmMgPSByYXc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgdGhlIEV4Y2FsaWJ1ciBsb2FkaW5nIGJhclxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdMb2FkaW5nQmFyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVkIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyBsb2FkZWRcbiAgICAgICAgICogQHBhcmFtIHRvdGFsIHtudW1iZXJ9IFRvdGFsIG51bWJlciBvZiBieXRlcyB0byBsb2FkXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmRyYXdMb2FkaW5nQmFyID0gZnVuY3Rpb24gKGN0eCwgbG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGluZ0RyYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdEcmF3KGN0eCwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyAzO1xuICAgICAgICAgICAgdmFyIHggPSB3aWR0aDtcbiAgICAgICAgICAgIC8vIGxvYWRpbmcgaW1hZ2VcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgLy8gNjQgYml0IHN0cmluZyBlbmNvZGluZyBvZiB0aGUgZXhjYWxpYnVyIGxvZ29cbiAgICAgICAgICAgIGltYWdlLnNyYyA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQXlBQUFBRXNDQVlBQUFBN0xkYzZBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVpkRVZZZEZOdlpuUjNZWEpsQUZCaGFXNTBMazVGVkNCMk15NDFMamVuaEozTUFBQTZZMGxFUVZSNFh1M2RVYWdrV1ozbmNVRUVRWVNpUlhCZG1pMktkUlVaeGdKWmhtVjlxT2Rta1dKWWxtWVloa0tXY1djZnBFRFFGeDlLMk80Rm02VWFWaG9haGk0R0Yyd1doMXBuWWF3SG9YenhwVnU2R2ltYXRxbmkwa3BUaUdMaGd5KyszUG45TWs2a2tYbFBacDRUR1NmaVJPVDNBMzlhcTI1RW5NaTZHZkgvWmNTSi9CQUFBQUFBQUFBQUFBQUFZQXcvKzluUExxbHVxTzZycm9jL0JnQUFBSURoaE5CeFYzVWU2bW40S3dBQUFBQTRua0xHZGRVZGg0MFFPcnAxSi93WUFBQUFBUFNqWUhIVjRVSVZDeDNkdWhvV0FRQUFBSUIwRGhPcTI2cXpFQzRPMVZsWUZBQUFBQUFPVTRpNHJMcnBNQkZDeFlWNjY2MjN6dDk5OTkzejk5OS8vL3lkZDk3cC90M3RzQm9BQUFBQWlGTndhRVBIZ3hBa290V0dqdC84NWplcit2V3ZmNzM5TTl4K0JRQUFBT0FpaFlYMnNibmRKMWhkS0YvaE9EczdXNFdOTm5pMDlmang0KzdQUGdpckJnQUFBSUNHZ3NMQjBQSHpuLzk4Witqb2xuK3VzOXpOc0FrQUFBQUFwMHpoWU45amMxZmxNT0VyR2srZVBJbUdqZTN5ejIydDQzTFlIQUFBQUlCVG8wQnc4TEc1YjcvOTl2bDc3NzJYSERxNnhlMVhBQUFBd0lsVEVEajQyTncyZEh6d3dRZlJZSkZhWGs5bnZUZkNFQUFBQUFBc21aci9yTWZteHNKRWJqbThiRzNqVWhnT0FBQUFnS1ZSdzkvcnNibERsYStnZExaek53d0xBQUFBd0ZLbzBULzZzYmxERmJkZkFRQUFBQXZsQmw4MXlHTnpoNmhmL2VwWDNXMTdnanUzWHdFQUFBQnpwcVorOE1mbURsVytyYXN6amp0aHlBQUFBQURtUk0xODBjZm1EbFdlME40WjAvVXdmQUFBQUFDMVV3TS8ybU56aHloUGFPK003V25ZRFFBQUFBQzFVd1B2dVIzZGhuNWRRejgyZDZqaTlpc0FBQUJnaHRTOFI4TkhqYUdqTFU5dzN4cnYxYkE3QUFBQUFHcWx4bjBqZlBocXgxaFBzRHFtUE1iT3VNL0M3Z0FBQUFDb2xScjNDK0dqaHJrZEtlWHZGK21NL1hiWUpRQUFBQUExVXRNKzIvREI3VmNBQUFEQWpLaGhuMjM0Y1BuN1JqcmpmeEIyQ3dBQUFFQnQxTERQT255NC9LV0huWDI0R1hZTkFBQUFRRTNVck04K2ZQaExEN3Y3b0xvY2RnOEFBQUJBTGRTb3p6NTh1QjQ5ZXRRTkg5eCtCUUFBQU5SR2pmcEcrUEF0VEhNTUh5NS9FM3RuWDI2RVhRUUFBQUJRQXpmcG5ZWjlGVDVxLzQ2UFhlWFExTjBYMWFXd213QUFBQUNtcGdaOU1lSEQ5ZDU3NzNYRHg5Mndtd0FBQUFDbXBnWjlVZUhEeGUxWEFBQUFRSVhjbkhjYTlVV0VqL2ZmZjc4YlBwNnF1UDBLQUFBQW1Kb2E4OFdGRDllNzc3N2JEU0Izd3U0Q0FBQUFtSW9hODBXR0Q1Y2ZHOXpadCt0aGx3RUFBQUJNUVUzNVlzUEg5dTFYWVpjQkFBQUFURUZOK1dMRGgrdWRkOTdwQnBEYlliY0JBQUFBakUwTithTERoL2VsdTMrcXEySFhBUUFBQUl4SnpmaWl3NGZyN095c0d6N093cTREQUFBQUdKT2E4Y1dIRHhlM1h3RUFBQUFUVXlOK0V1SGp5Wk1uM2ZEaHVoeGVBZ0FBQUFCalVCTitFdUhEOWZqeDQyNzRlQkJlQWdBQUFBQmpVQk4rTXVIRDVmM3I3Ty9OOERJQUFBQUFLRTBOK0VtRkQyNi9BZ0FBQUNhaTV2dWt3b2ZyMGFOSDNmQnhQN3dVQUFBQUFFcFM4MzF5NGNQMTl0dHZkd1BJamZCeUFBQUFBQ2pGalhlbkNUK1o4UEhCQng5MHc0ZnJVbmhKQUFBQUFKU2dwdnNrdzRmcnZmZmU2NGFQdStFbEFRQUFBRkNDbXU2VERSOHVicjhDQUFBQVJ1S0d1OU44bjF6NGVQLzk5N3ZoNDJsNFdRQUFBQUFNVFEzM1NZY1AxN3Z2dnRzTklIZkNTd01BQUFCZ1NHcTJUejU4dU41NjY2MXVBTGtlWGg0QUFBQUFRMUdqVGZoUVBYNzh1QnMrdVAwS0FBQUFHSm9hYmNLSDZ1enNyQnMrWExmRFN3UUFBQUJnQ0dxeUNSK3FTUGg0b09LN1B3QUFBSUNocU1FbWZLZ0lId0FBQUVCaGFyQUpIeXJDQndBQUFGQ1lHbXpDaDRyd0FRQUFBQlNtQnB2d29TSjhBQUFBQUlXcHdTWjhxQWdmQUFBQVFHRnFzQWtmS3NJSEFBQUFVSmdhYk1LSGl2QUJBQUFBRktZR20vQ2hJbndBQUFBQWhhbkJ2dDFwdUFrZmZ5ckNCd0FBQURBa05kaDNPZzAzNGVOUFJmZ0FBQUFBaHFRR20vQ2hJbndBQUFBQWhhbkJKbnlvQ0I4QUFBQkFZV3F3Q1I4cXdnY0FBQUJRbUJwc3dvZUs4QUVBQUFBVXBnYWI4S0VpZkFBQUFBQ0ZxY0VtZktnSUh3QUFBRUJoYXJBSkh5ckNCd0FBQUZDWUdtekNoNHJ3QVFBQUFCU21CcHZ3b1NKOEFBQUFBSVdwd1NaOHFBZ2ZBQUFBUUdGcXNBa2ZLc0lIQUFBQVVKZ2FiTUtIaXZBQkFBQUFGS1lHbS9DaElud0FBQUFBaGFuQkpueW9DQjhBQUFCQVlXcXdDUjhxd2djQUFBQlFtQnBzd29lSzhBRUFBQUFVcGdhYjhLRWlmQUFBQUFDRnFjRW1mS2dJSHdBQUFFQmhhckFKSHlyQ0J3QUFBRkNZR216Q2g0cndBUUFBQUJTbUJwdndvU0o4QUFBQUFJV3B3U1o4cUI0OWV0UU5IaTdDQndBQUFEQWtOZGlFRDlXNzc3N2JEUjR1d2djQUFBQXdKRFhZaEE4VjRRTUFBQUFvVEEwMjRVTkYrQUFBQUFBS1U0Tk4rRkFSUGdBQUFJREMxR0FUUGxTRUR3QUFBS0F3TmRpRUR4WGhBd0FBQUNoTURUYmhRMFg0QUFBQUFBcFRnMDM0VUJFK0FBQUFnTUxVWUJNK1ZJUVBBQUFBb0RBMTJJUVBGZUVEQUFBQUtFd05OdUZEUmZnQUFBQUFDbE9EVGZoUUVUNEFBQUNBd3RSZ0V6NVVoQThBQUFDZ01EWFloQThWNFFNQUFBQW9UQTAyNFVORitBQUFBQUFLVTROTitGQVJQZ0FBQUlEQzFHQVRQbFNFRHdBQUFLQXdOZGlFRHhYaEF3QUFBQ2hNRFRiaFEwWDRBQUFBQUFwVGcwMzRVQkUrQUFBQWdNTFVZQk0rVklRUEFBQUFvREExMklRUEZlRURBQUFBS0V3Tk51RkRSZmdBTUhmbjUrZmZVQ1VMaXhXaDFiL1FiQ1hKbTJHeElyVCtlODFta3R3TGl3RUFTbENEVGZoUUVUNEFMSUdhNXlvQ2lGYjlwV1lMV1Y0SWl3OU82eWFBQUVBTjFHQnZoSStIRHg4U1Bwb2FMWHo0Uk5lYzd4YmhHMkczQUV6RTc4UG03WmdtTERZNHJmck5aZ3Zacm9SVkRFcnJKWUFBd05UVVlHK0VEemZoc2VaODZUWDFsUStmNkpyejNTSVFRSUNKK1gzWXZCM1RoTVVHcGRWZWFkYmV5MWZEYWdhbDlSSkFBR0JLYXJBSkg2b2FicnZ5aWE0NTN5MENBUVNZbU4rSHpkc3hUVmhzVUZwdG45dXZXcStFMVF4SzZ5V0FBTUJVMUdBVFBsUTFoQS96aWE0NTN5MENBUVNZbU4rSHpkc3hUVmhzVUZydE1RR2tTUFB2OVRhclQwSUFBWUNocU1FbWZLaHFDUi9tRTExenZsc0VBZ2d3TWI4UG03ZGptckRZb0xSYXJvQUFBQWdmYmRVVVBzd251dVo4dHdnRUVHQmlmaDgyYjhjMFliRkJhYlhNQVFHQVU2Y0dtL0NocWkxOG1FOTB6Zmx1RVFnZ3dNVDhQbXplam1uQ1lvUFRxaDgxVzhqR1U3QUFZTzdVWUJNK1ZEV0dEL09KcmpuZkxRSUJCSmlZMzRmTjJ6Rk5XR3h3V3ZWenpSYXlGRHVHYU4wRUVBQVlneHBzd29lcTF2QmhQdEUxNTd0RklJQUFFL1A3c0hrN3BnbUxGYUhWdjlKc0pRbmZoQTRBYzZjR20vQ2hxamw4bUU5MHpmbHVFUWdnd01UOFBtemVqbW5DWXNWb0V5bmpjVkQ1UkZpa0NLMmZBQUlBSmFuQkpueW9hZzhmNWhOZGM3NWJCQUlJTURHL0Q1dTNZNXF3V0ZIYWpDZWx2NkRxZmp1NjU0ZzRlSHdwL0ZoUjJnNEJCQUJLVVlOTitGRE5JWHlZVDNUTitTNU5XQXdBb25TWXFDNkExRUM3U2dBQmdCTFVZQk0rVkhNSkgrWVRYWE8rU3hNV0E0QW9IU1lJSUJIYVZRSUlBQXhORFRiaFF6V244R0UrMFRYbnV6UmhNUUNJMG1HQ0FCS2hYU1dBQU1DUTFHQVRQbFJ6Q3gvbUUxMXp2a3NURmdPQUtCMG1DQ0FSMmxVQ0NBQU1SUTAyNFVNMXgvQmhQdEUxNTdzMFlURUFpTkpoZ2dBU29WMGxnQURBRU5SZ0V6NVVjdzBmNWhOZGM3NUxFeFlEZ0NnZEpnZ2dFZHBWQWdnQUhFc05OdUZETmVmd1lUN1JOZWU3TkdFeEFJalNZWUlBRXFGZEpZQUF3REhVWUJNK1ZITVBIK1lUWFhPK1N4TVdBNEFvSFNZSUlCSGFWUUlJQVBTbEJwdndvVnBDK0RDZjZKcnpYWnF3R0FCRTZUQkJBSW5RcmhKQUFLQVBOZGlFRDlWU3dvZjVSTmVjNzlLRXhRQWdTb2NKQWtpRWRwVUFBZ0M1MUdBVFBsUkxDaC9tRTExenZrc1RGZ09BS0IwbUNDQVIybFVDQ0FEa1VJTk4rRkJGd3NkOTFXekRoL2xFMTV6djBvVEZBQ0JLaHdrQ1NJUjJsUUFDQUtuVVlCTStWSkh3Y1NlOFJMUG1FMTF6dmtzVEZnT0FLQjBtQ0NBUjJsVUNDSUR5L3VudlBuUlpkUzJoYmlYVUhkWDlUdDBJbXluS1RYYTM2U1o4TEN0OG1FOTB6Zmt1VFZnTUFLSjBtQ0NBUkdoWENTQUFMbEpUN3pDdzNlanZxdk9KNjFZWWRqRnVzcnROTitGamVlSERmS0pyem5kcHdtSUFFS1hEQkFFa1FydWFjNndsZ0FDbndrMzlWcE5mYzkwTnd5N0NUWGEzNlNaOExETjhtRTkwemZrdVRWZ01BS0owbUNDQVJHaFhjNDYxQkJEZ1ZLaXBIelNBL09ockh6Ny82YmMrZHJBZXZ2VE0rUzllL3VUZWV2emRUNjJxcy83N1lkaURjNVBkYmJvSkg4c05IK1lUWFhPK1N4TVdBd2FqWDZzdnFaNVh1WEgxNzZQcmtXb1gvMTM3YzE3R3kzNGhySzU2R3F2Mzk2dGg3TzErdktuYTVYZXEyZXh2R0dPeXNOamlhVmY5NzVkcWtBQ2k5WHhCNWQrWEY3ek9VTHZNNW5jTTg2TGZwU3NxSC9OZVY4V09kZTB4N2hXVmYrNUtXUFEwcUtsZkI1QUhMMTQ2LyszM0x1K3NQLzd3cytmbi8vejVVZXNQUC9qTWFteHRoV0VQeWsxMnQra21mQ3c3ZkZoNDB5Y0xpd0c5NmRmSVRWSGJmQS9ONjZ6bUJLWnhmRUwxbk1vbjFuMGhvdytmdEwzZTU4TG1xcUR4RUVBaXRLczV2Kys5QTRpV2RjRDE3OFcrRUovSzY2anVkd3p6b044Yi95NzJPYzZmMWhWQU5mWHJBT0tyRHJFUU1IVzE0d3QxT1F4OUVHNnl1MDAzNFdQNTRjUDhSbS9lNzJuQ1lyT25YZkVuTW03Z2NqMGZWakVwamNPTmJlNzRKenVvYTl0K3ZmMHA3QkJOVVNvMy9QNGs5eE5oR0tQdzlzSjIvV25mV1B5NnV2RWZkVjlqd2ppU2hjV0swT3B6am05RjN4OWVmN09aSk5sajBUTCtuU3Y1L3ZLNkhlNXIrQjJiOVhsTFE4cDZqOGlYd3FLRDA3b0gvNzNVei9sRHBxeC9veTBFa05yS3QyeTFZMVJkRDBNL21wdnNidE5OK0RpTjhHRitvemZ2OXpSaHNVWFE3dmhrbXV0UldIeFNHb2ViK1J3T0s2TmZGZEEyL1FuWW1JMTRqUGY5RzJGSXhXZ2JEbG4rdExoUHNCMkt0ejFwU05iMkNTQVJYbit6bVNUSlk5SFBsZzRlMjJyNEhadjFlVXREV213QTBjLzBPYTl1TzdrQTRpZGduYnM4M3lJV0FLWXUzeHJXamxFMXlKT3czR1IzbTI3Q3grbUVEL01idlhtL3B3bUxMWVoyS1d2L2crTE43RDdhdmo5ZHl2WFZzUGdvdEQwMzQzMWUyMkxDMEFhblZmZTl6YUFrajJlU1Q2cTFYUUpJaE5mZmJDWkpTcU0zOVh2TVZ4Z25tU2VpN1didGQxaXNHaHJTSWdPSS90NGZ3QXpoNUFMSSt2RzZudWNSQ3dCVDF5OWYvZlJxZktHT25vanVKcnZiZEJNK1RpdDhtTi9vemZzOVRWaHNNYlJMZlpwNWZ3STQyVzBJMm5iV3Y1bU1kakRYdG56N1VlN1ZtVkdFSVE1R3EyeXZlTlRLdjZlak40amFKZ0Vrd3V0dk5wUGtVS1BuZVVWVFhtbHJUWEkxUk51YzlYbExRMXBjQU5IZkRYa3NKSURVVnI5Ly9jcHFmS0dlaHFIMzRpYTcyM1FUUGs0dmZKamY2TTM3UFUxWWJGRzBXN2tuQTNzbExENHFiZGUzVytSd2d6REtyVmZhanNQY21MZUNaQW5ESElSVzErZDNaZ3FqaHhCdGp3QVM0ZlUzbTBteXI5SExQUWFNWWRTcnd0cmVyTTliR3RLaUFvaitmT2dQWWdnZ05aWWY3OXVPVTNVMUREK0xtK3h1MDAzNE9NM3dZWDZqTisvM05HR3h4ZEd1OVhsQzBkaU5YWitKNTZQY2VxWHQxTmdVYlFoRFBacFc1VnV1NW1TMEVHcmFGZ0Vrd3V0dk5wTmtyRVp2U0tOOUtLTnR6ZnE4cFNFdEpvRG96NGFZODdHTkFGSmp2Zkh0ajYvR0dPcG1HSDRTTmRpWFZQYzdEVGZoNDA5MWN1SEQvRVp2M3U5cHdtS0xvMTNyMDFTT2VwRFU5bkp2YlJwbGZOcE96VTNSV2hqdTBiU3F1UVVRZXpNTXZ6aHRpd0FTNGZVM20wa1NhL1J5bTlZcHZCQ0dXNVMyTSt2emxvYTBpQUNpLzkvbkZ1WVVvNTViSjZkbWZoWUJwTzhYRXFyQmR2aDQwR200Q1I5L3FwTU1IK1kzZXZOK1R4TVdXeVR0WHArNUM2TThIMS9ieVQzUWovS3B0N1l4aS9CaFljaEgwNnJtR0VCc2xOdGt2SjFtYzJuQ1lrVm85VG5IdDJvRGlQNS85VmNZTzRyUENkRTJabjNlMHBDV0VrQ0cvbTZqRmdHa3h0citRa0xWcGJBTE82bkJKbnlFSW54czhodTllYituQ1lzdGtuYlB0empsem1FWTViRzgyazdXdjVNVXYvVksyeGd5ZkRndytYRzlQakc3d1krZWNQWG5EbUwrZTEvMjkvYVQvNzNDS282bVZSMGJRRHptZGw4OW1kanJ1L0JRQS85WitEdnZxMzgrOS9hN21ERkNLUUVrd3V0dk5wTmtQUmI5N3o2Zk12dDN6QitvT0xqNGQrakN2N3YvTFB4ZCsxNGE0dmVyVmZUMlZLMS8xdWN0RFduMkFVVC91OFN0VnkwQ1NLMzE0NjkvWkRYT1VEZkNMa1Nwd1NaOGhDSjhYT1EzZXZOK1R4TVdXeXp0b2h2Q1hFV2JmYTAvZDB6RkQ5N2F4bERodytzNTZpcVNsbmNqNVpQaDNqQVNmdnhvV2xXZkFPSUE0V2F3ZHdEUXN1MFhIT2FHNUs3aTkrbHJHd1NRQ0srLzJVeVMxVmowMzV3UFJSd2cvTm9mOHp2bVk4MFEzOXZqTVJkN1VxRFdQZXZ6bG9ZMDZ3Q2kvK2JNUi9Udms0L1BGL1pCZjlaK3lPTGpXdmNESlFKSXJmWHdwV2RXNHd4MU4rekNCV3F3Q1IraENCOXhmcU0zNy9jMFliRkYwMjdtbm9COUlDNXlzdlY2VlRrTnA4ZFM5Rk51clQvMzVCbmpkUXorbW1tZFBwbEZmNmZEanh4TnEwb05JUDUzODRsMzBQMzArbFRIQk1DcWZqL0NZa1ZvOVRuSHR4b0RTTXF4YUJVOFZoc1ppTmJucXk1WjU0YUlZdk5CdE81Wm43YzBwTGtIa0pUeCt4aVZmYXpSTWc3Qm84d2xxa2Fub1YvZDVoUnIvR3VwcmNmeHVxSzNZYW5KdnR0dHVna2ZoSTl0ZXFQZlV5VUxpeTJhZGpQbjA1MVdrUU9tMXB0N29xcnRhc3cyTjFSRkcyRFROaTRFa2ZCWFI5T3FEZ1VRM3hjOXhuM3dmZWNGRkQyNWEvMEVrQWl2djlsTUV2OXN5bnZONzZlU1Z4cU92YzJteUsxWVd1K3N6MXNhMHR3RHlMNFB4ZngzbzMvLzBLeDFHL3BZMDE5YnBkeUdwVWI3VnJmeC92V3ZmeDF0MEpkY2hJLzlkS0M0dHpwa0pBcUxMWjUydFU5ek4yaGo3ZlUxcTAxV3VvSHFFOHhhWG02S0x5enp2K05xek9HUGpxWlY3UW9nUHZHT3VvL2FYbTRqWTc4TGl4ZWg5Uk5BSXJ6K1pqTkpIR0lQWGZrYzZ4SGJ2aHJTOTMxZjVEWDFlcHZWcHdtTFZVTkRtbTBBVWUwTHh2NzdZb0Y0c1RyTmZMVGhyNjIyYnNPS1BnMUx6Ylp2d1hyYU50K1BIajJLTnVsTExjTEhZZUdBa1N3c2RoSzB1MW12alF4NnN2WDZtdFVtY1lOUSt0YWEzTmVqNWJGTjlvbVl0dTNnTk5pL2pkWVZDeUJ1S0NZNThXcTdmZjVkU2pZMEJKQUlyNy9aekNER0RyckhoSkRCZjllMHpxelhNaXhXRFExcHpnRmsxMjJCcjRkVklsZW5tWTgyL0xWVjVHbFlsOE91YkZEVHZiNEs4dFpiYjUzTVZSRENSeG9kTk80MXg0NDBZYkdUb04zMUZZamNrKzRnSndxdEovZFdwMXB2dmZJbnVjVnZ1UnFUOXFjYlFDYS8zY0RiWDQwa1Q3Rkg4bnJkelNiU2hNV0swT3B6am05ekNTQ2pYMGswYmJmUDc1a04vcnA2bmMycTA0VEZxcUVoelRXQTdMb3E1K004Vno3NjZqYnpzWWEveHZycHR6NjJIclBxZHRpVkRXcThUKzRxQ09Fam5RNGE5MWFIai9rcSt0MEdYbit6bVdSSFA1Wlg2OGlkZUY2NmNlcDc2MVh4cXpKVDBENjFBYVRvL2ZjNU5JN2NTZW5GZm1lMGJnSkloTmZmYk9Zb2s0U1BscmJmZDA3STBMZW5acjJXWWJGcWFFaHpEU0F4aXp6T2o2clR5RWViL1Jycmw2OStlajFtMVZQVnJzbm9HM05Cbmp4NUVtM2NsMUNFanp3NmNOeGJIVUxtcS9pWHEya2J1VisyZEZTVG9PVnpUazdGRC81YWYrN0owanl1UlU1RTFINDVnSXh5LzMwcWpTZjdDbFZZZEhCYU5RRWt3dXR2TnROYjhVY29wOUE0K3V6SG9BOCswUHF5eGhBV3E0YUd0S1FBTXNxWDhTNWFwNUdQTnZ1MTF0Wms5SnRoZHk1UUkzN1dOdVh2dlBOT3RIbWZleEUrOHVuZ2NhODVoc3pXR0FFazk5WUROOSs5UGhuWGNya1R6MHZmZXRYMzZnY25wWkhwTmMvOWR5cjFoQ0lDU0lUWDMyeW1GMThScmVWcVc1OWJVd2Q5OElIV2wvVmFoc1dxb1NFdEpZQVVmYytjakU0VEgyMzBhNjFmdlB6SjliaFZaMkYzTGxBemZyM2JuUC9xVjcrS052RnpMY0pIUHo2QU5NZVIyU29lUU16YmFUYVhyTmU0dEZ6T3YwZnhnNysya2J2ZmRsclBjSytFWHZmYzI3Q0tORFZhTHdFa3d1dHZOdE5Mc1FhMEQ0Mm56M0Zoc0E4bHRLNnMxeklzVmcwTmFTa0JoRnV2anFYRy9WS25pWTgyK3JYV0gzLzQyZk1mZmUzRDY3R3JkbjR6dXByeSsyMkQvdmJiYnk5bVFqcmhvejhkUU80MXg1SFpHaXVBNU03THNLeURzMzQrNXpZYWZ3SlovT0N2YmVUdWN6V2YxSjRhdmU2NTkrY1hlZTk0dmMzcTA0VEZpdERxYzQ1dnRRYVE2ajVsMXBoOFBNdzEyQWNUV2xmV2F4a1dxNGFHdElRQVVzVXRnYk9ucHYxYTI4QjdZbmVzMGErNU1xNkNYRmF0SjZTLzk5NTcwWVorVGtYNE9JNE9JbjBQUHJVWUpZQ1l0clhyK3g5MlNYNHNvWDQyTitBVW40T2diZlI1OHRXa2syUlBtVjc3M045UEFzaW1XZ05JVlZjL1docFg3aFczb3gvUTBkSzZzbDdMc0ZnMU5LUWxCQkMrYkhBSWF0cG5IVUFpVjBGdWhWMjdRQTM2eG9UME9kK0tSZmc0bmc0aWZROCt0Umd0Z0ppMlYrUTJGLzFjemdscGxFOUV0WjFkejN2ZlpiQUdBL24wK3VkK0tsM0Z0L2VIeFlyUTZuT09ielVHa09xdWZyUTB0ajZQNVIza3FxM1drL1ZhaHNXcW9TSE5QWUM4R1JiSHNkU3d6enFBdUxhdWd1eDhJcGFwVVgvUU51MXovVzRRd3Njd2RDRHBjL0NweWRnQkpIZFM5c0VEdFg0bVoxTG5XTGRlOWJuRmdxc2ZFd3YvRHFtS05MZGFMd0Vrd3V0dk5wT2w2dmVVeHBkN2krWWc4MEMwbnF6WE1peFdEUTFwN2dHa3FxY0F6cHFhOWRrSGtNaFZrT2ozZ3BpYTlhdXE5YTFZYzNzcUZ1RmpPRHFROURuNDFHVFVBR0xhWnU2dFNYdWJDUDE5enBXR1VRNzgyczd6emVhU2NmV2pBdnAzeUFuSEJKQk5OUWFRcXVkVGFYeTVWNFFIT1Y1clBWbXZaVmlzR2hyUzNBTUl0MThOUmMzNjdBT0k2L0YzUDdYYWgwNWREYnQ0Z1pyMm05MG1maTVmVUVqNEdKWU9KUGVhNDhsc2pSNUFUTnZOQ1EwN0oyYnJ6M1B1MngvdGRneHRLN2V4NE1sWEZkQy9RODc3bVFDeXFiWUFNdHI3dlMrTk1mZURpa0gyeWV0cFZwY21MRllORFduT0FZUVBtNGFrUm4wUkFjVDFrMjkrZExVZm9lNkhYWXhTODM2MzI4elhQaCtFOERFOEhVeHlEejYxbVNxQTVENExQenBPL1hucUxReWozSHJWMHJaeWI2M2dFN0VLNk44aDUvMU1BTmxVV3dDWjVOaVdRMlBNL2Q2aVFacFhyU2ZydFF5TFZVTkRtbk1BU1g2NENoS29VVjlNQVBudDl5NnY5cU5UKzc2YzhKSnFZejdJQng5OEVHMytweTdDUnhrNm1OeHJqaWxwd21JUXZSdzVqejExZ05pNENxTC9uM01TR3UyZVcyMXJrcVlDNmZTYSs4cVpid1gwNzVDdlZ2bDluQk9JalFDeXFiWUFVcXpwSEZJWWE3S3cyRkcwbWxtZnR6U2tPUWVRNm9QeHJLaEpYMHdBY1QxNDhkSnFYMEo1UXZybHNLc1hxSkhmbUEveTg1Ly92S3BKNlI2TDU2aTA0d3RGK0JpSURpWlpCNSt3R0FLOUpEbXYzL3E1NmZyZk9WZFFpalpHMjdTOTNEa3VQQSsrQUwydVE0U01mUWdnbTJvTElMUDRQaDJOTTNlL2pyNlNxM1ZrYlRNc1ZnME5hYzRCWkJiQmVEYlVvTjlvRy9ZM3Z2M3hhRk0vcDRwTVNEOTBLOWJHdDZUWEVrSThCbytsT3pZVjRXTkFPcGhrSFh6Q1lnajBrdVEraW5KMTh0Vi9VK2VRakhycmxXbDd1U2RIbm43VmsxNjcwaUZqSHdMSXBxb0NTRmlzZWhwcTd1TzZqMjVndFk1WnY1WWEwcHdEeUtqbm84VlRnMzZyYmRiOU9OdFlVeiszZXZMYXM2djk2ZFRPN3dZeE5mWTN1bzMrdzRjUG82RmdyQ0o4akVNSGszdk5NU1ZOV0F3ZGVsbHlUaVp1TW5NbW5vLyt1RU50TTdlaFlQN0hBWDZOVkw1bDd3V1YzM05qaFl4OUNDQ2JhZ29ncy9tZUJZMTE5R1phNjVqMWVVdERtbTBBQ1l0aEtHN08yMFo5S1FIRTlmQ2xaMWI3MUtscllaZWozT0IzRzM3UHU0aUZnOUpGK0JpUGppZjNtc05LbXJBWXR1aWxlYk41aFpLa05wK1ROQ0hhTHI4VFI5TEw0dTlSOFJPQ0hPWnFDQnN4QkpCTk5RV1FvbU1aa3NaS0FNbWtJUkZBMEZCanZzZ0E0bHV4dHA2S3RmY0xDczJOZnJmeEh6dUVFRDdHcGVNSkI1OEI2S1hKdWFxUmFwSXJDMkhicVppQTNxSFh3N2RUNVY1Qm1nb0JaQk1CcEFlTk5iZVpQbm9TczlZeDYvT1doalRYQURLYjM4dlpVRk8reUFEaSt2M3JWN2JuZ3p3SXU3MlRHLzV1QUhBSUdXTk9DT0ZqZkQ2Z05NZVZOR0V4Uk9qbDhlMDFRNW5zU1NOaCs2azRJWWxlQjEvdHlIMTA4ZFFJSUpzSUlEMW9yQVNRVEJvU0FRUU5OZVdMRFNDdVg3NzY2ZFcrZGVwZ1UrL0d2eHNFSEF4S2hoREN4elI4UUdtT0sybkNZb2pReStQYmJvWm9RaWU3LzF2YjlqN2tPT2tUa3ZiZlY3N21GanhhQkpCTkJKQWVORllDU0NZTmlRQ0NoaHJ5UlFjUVYyUSt5TjVKNmVZQTBBMEVwVUlJNFdNNlBxQTB4NVUwWVRIc29KY285eEcyTVpOTjZ0YTJjMjhsTzhsdlFOZCtPNmdOZWNWckNnU1FUUVNRSGpSV0FrZ21EWWtBZ29hYjhiWXhYMm9BY2ZrUncrMStocm9SWG9LZEhBUzZ3V0RvTHlza2ZFekxCNVRtdUpJbUxJWTk5RElkTXdkZ3NsdXZUTnZQRFNDVGpuY0sybWVIajV5SERwVGc5NjEvejl6SStQWXYvN3Q1WERudlp3TElKZ0pJRHhvckFTU1Roa1FBUVVPTitEcUErSXNJL1czaWYvakJaNkpOL0p3ck1pbmRsUkpDYm5VRGdrUEkyZGxaTkZEa0ZPRmplajZnTk1lVk5HRXg3S0dYS2ZjMnBxNUp2M3hNMnllQTdLSDk5ZU4weDNpcWxiZmg5NllmMjd3Uk1zSlFvdlQzT2U5bkFzZ21Ba2dQR2lzQkpKT0dSQUJCUTAzNDNhMm1mRjBPSkw1OXlkK3I0UVkrMXRqUHFid1BQLzc2UjdiM015V0ViSHhQaU91WUoyUVJQdXJnQTBwelhFa1RGc01lZXBuOGZROTlUWHBMazdaUEFObEIrK3BnT1hUNDhKV1VObVQ0OXIyakdnMHRuL04rSm9Cc0lvRDBvTEdPM2t4ckhiTStiMmxJQkJBMDFJRGYzMnJJZDVhdklMU0JKTmJnejZFaVQ4WnlwWVNRcTZxbm5jQ3dDaEc1dDJRUlB1cmhBMHB6WEVrVEZzTU9lb2x5dnhrOXB0ako1aEJ2dXhsQ3NsTUtJRVBjZHVWMXVQa284bStzOWVhOG53a2dtd2dnUFdpc0JKQk1HaElCQkEwMTMxZFYxMVcrRmV1T0tqbVFlRjZGbnpJMXQ2c2pSNFNRUzZvSG5lQ3d1aVhyOGVQSDBiQ3hYWVNQdXZpQTBoeFgwb1RGc0lOZW9pR2FWRDlWYVpKYnNiVGQzQUJ5RWljazdlY3hFODc5NyttRzQwcFlYVEhhUnM3N21RQ3lpUURTZzhhYU8rZU5BRUlBd1NGcXlCMU1icWh1cXg2b3p2ZlZneGN2emVyS1NOOFFZZ29OdDdkQ3hQbkRody9Qbnp4NUVnMGVMc0pIZlh4QWFZNHJhY0ppaU5ETGszdFMyV2VTVzdHMFhRTElGdTFqMzZ0YXZsM3IrYkNhVVdoN09lOW5Bc2dtQWtnUEhtc3o1R1JIQjNHdFk5Ym5MUTJKQUlJOGFzNHZxWHlseEZkSnpsVG5zZkljQ3o5TmF3NVhSWGFFa0tSUW9QQndUWFhXQ1JPcmV2VG8wU3BzRUQ3cTV3TktjMXhKRXhiREZyMDB1WTE3aW1Jbm5WMjB6ZHdKOUtjUVFMTGVJNEUvRlI3OUtwYTJtVE5XQXNnbUFrZ1BHbXZXOStDRXhZNmkxY3o2dktVaEVVQndIRFhxdmtMaXF5UFJNT0xHM2xkRmFuK2kxbzZuWS9rMnRFdGhWM2RTaVBBdFdSdVA2blc5L2ZiYjUrKy8vejdobzNJK29EVEhsVFJoTVhUb1pYSFRYdUxMNkNhNUZhdlpkTHF3MkNKcDkvcGMvWGdsTEQ0NmJUdm4vVXdBMlVRQTZTR01OOVh2d21KSDBYcG1mZDdTa0FnZ0dJNmE5V3NxWHhrNWoxWHRRV1JIQ1BGdFoxZkRMdTZsUUJHOUd1TGJzZ2dmOWZJQnBUbXVwQW1Mb1VNdmk1OWlsTW9ubnB5d012cXRXTnBtN3BPZUpuMTBjRW5hdDV4L1c1djBCTzN0TjhOSVFnRFpSQURKcEhGT2NzdW0xcE0xSnlzc1ZnME5pUUNDNGFsaDkyMWFOMVhScXlLMUJ4R1BiMnZNVDFXcDgwSjhOY1RmR2JMeHBLeXRJbnhVeEFlVTVyaVNKaXlHUUM5SnpqZWZ2eG1XOFhjNjVCajFWaXh0TCt0M1FrYS9WV3dzMnJmY01GWjhvdmsrMm43T2VBa2dtd2dnbVRUTzNFZU9EL0tCaXRaVHplOVlIeG9TQVFSbHVYRlhYWmk4N2x1emFwNGo4dmk3bjlvWWJ5aC9WOHJCVzdKTUllT3lnMFluZEJBK0t1VURTbk5jU1JNV2cramx5UDFlaUMrRVJiMXN6dE95UnIwVlM5dksvZFIva1kvaTFYN2xmcm83MmExWHJUQ09WQVNRVFRVRmtFZGhzYXBwbkxuSGlxK0dSWStpOWN3OWdPUStWWThBZ243VXVQdjJyQXRYUkR4WnZkYW5adm5iNENPVDA3MFAxOEp1SGFUQTRlOE51VS80cUpjUEtNMXhKVTFZREtLWEkrZnhreHVmL09uLzV6YTNvOTJLcFczbGZqcTN5Sk9TOWl2M2RYZ3VMRG9KYmY5S000eGtCSkJOTlFXUVdSeHJOY3pjdVcvckQyR09vZlhrdmplcnVrcXI4V1Q5TGdnQkJNZFI4KzRySWhlQ2lMOUxwTWFySVI2VHZ3bCtlN3dxejNWSnVocGlEaUxoZjZJeVBxQTB4NVUwWWJHVHA1Y2k1OVlEWHlXNWNBVkRmNWI3NmVFb0oxRnZwOWxjbHNYTkE5RStaYjAzWk5MWFFOdWY1SDc4YlZvdkFTVEM2MjgyazJ5UVpyMFVqNjhaWnJxdzZORzBxcmtIa054Yk93a2dHSWFhZDMvaG9lZFduTGZscXcyMVhnM3hMVm1ScXlISmMwTlFMeDlRbXVOS21yRFlTZFBMNEUrYWMwNGcwZStDMEovbnJtZTBXN0dheldVWjlmc3V4cUI5eXZsMGQvSmJaalNHM0thTUFMS3B0Z0F5eU8xS3BXaDh1YmNSRGZiNmFsMjV2K3ZWM0NhcXNlUmVxVFFDQ0lhajV2Mnk2c0kzcnRkNk5jUVQ1M2RjRGZFY2wrVGJzbEFYSDFDYTQwcWFzTmhKMDh1UU0zOWo3d0ZiZnovSkpNNUR0SjJzM3d0WjNJa3A3RmVxeWZmZlkyaUdrcXpJbUxWZUFraUUxOTlzSnRucllkRXFhWHk1dDE4TkZxaTBydG5OejJwcExMa1BJVEVDQ05MOHErZit4K1h3UHc5UzgrNHZOdHk0R3VLNUlmNkN3RmdRbUxwMlhBMXhPVXdSUkdiR0I1VG11SkltTEhheTlCTGtmdkoyOEtsSStwbWNRR1BGYnlmUU5uS0RrVlY5eTBnTzdjdXN2cEJSMjg4ZHJ4RkFOdFVXUUt6S1d4czFyajYzYVE1MmZOQzZjcmUvZWdKaERUU1duTG1ETFFJSURsUDR1S1U2RC85Tm1pZWh4dDJQN3Ixd05lU1hyMzQ2R2dLbUxsK2hpVHl1dHkyQ3lJejRnTkljVjlLRXhVNlNkai8zbnVla3kvNzZ1ZHlUYWZGYnNiVCtQcmNKVlBNcDQ3RzBMMVhNcDBpbDdmY0pqQVNRVFRVR2tDcHZiZFM0Y3B2b1FXOVIxUHI2Qk83Snc1ekgwQXdsR3dFRSt5bHdYQS9obzYybnFwdmhydzlTNCs3dkQzRVR2eTQzK3JFUVVFUDVLczJPMjdKY0RpTFh3NjZoVWo2Z05NZVZOR0d4azZOZDk0bWoyS056OWJPNUU5S0wzNHFsYmVSZW1iRkZYQVhSZnN3dGdPVGVEbU1Fa0UwMUJwRHFIc2VyTWZYNWNHTHdPUmhhWis1RTdzbkRuTWFRZXdXOVJRREJiZ29hVjBQZzZBYVF0aDZva3A0RXBhYjlxbXJqU1ZsdThtdjl6aENYSDltN0o0aDRYenpwUHZtMk5JekhCNVRtdUpJbUxIWnl0T3RGbjl1dW4zZkFxZWJKS0tiMTk3bFhlUkVuS08zSGJBS0l0dDNuMzhrSUlKdHFEQ0JXMVZVUWphZlBmZ3orQloxYVorNDRKcDFUbyszM09jYTNDQ0NJVTdpNEZFTEdLbkQ4Ni8vMFAxZlYvdjlPM1ZZZHZDMUx6YnB2eWRyNEFzT2ZmUE9qVlljUTE0RWc0dkpWRVQrS09Qa1J2aWpMQjVUbXVKSW1MSFpTdE51NXpXaXZFNTJXeTcyTnB1aXRXRjYzcXM4SnMrcW45NlRRUHVUZWJqZkpKOVhhcnYrTitsejlNQUxJcGxvRGlOK0RWY3dGMFRpZVc0MG9UNm5mczl3UGhXendJSlJLMis1NzljTUlJSWhUcUxqYkNSbm5YL3pLOTgvL3czLzdmK2VmZS83VmJ2aG9LK2RxaUw5dnc0Mzdxano1dTliSjZkM3lFN044NjlpT3llcHRPWXo0bGpPdWpFeklCNVRtdUpJbUxIWXl0TXU1VGJoL3R2ZEpUc3ZtM3ZaVTlGWXNyYi92U1hQMnQyS0YvY2d4ZW5PamJmWnB3bG9Fa0UyMUJoQ2IvSWxZR2tQZkR5U0tOTTlhYjU4d05NbmplTFZkMzdiVzU3VnJFVUJ3a2NKRU8rbDhWWC8yMTYrZC84Zi8vdi9YNVREeWI2Ny9yMjRBYWV0V1dNVmVvVWwzdzc2cXVZUVFsNi9ZZUNLOXI5NTA5eUZTdmszTFljdFhSL2pTd2hINWdOSWNWOUtFeFU2R2RqbDNzdVZSbi81citkeXJMVmJ5NU5TMzZmQXlzdzRoelc1a0diVzUwZmI2L0s1MEVVQTIxUnhBYk5KYnNiVDlQazl2S3ZhYWF0MCtOdVU2NmdPaXZyVE5QdlBwdWdnZzJLUVFzVEhwL04vOWwxYzJ3a2UzUHY5WGY5OE5IMjNkVjZYY2t1WEczSTM2cXVZVVF0cnlWWkdITHoyemVzUndkMS8ybEsrUTNGWjUvc2cxRmNHa0FCOVFtdU5LbXJEWVNkRHU1bjdDTnNpakhyV2UzRSsxUzkrSzFmY3FpTWMxMlMwUHg5TFlzOTRiNHVabWxGdGx0QjNmSW5iTUo2cEdBTmxVZXdDeDU4THFScVh0NWo0a28xV3NjVGF0djA5alArclZKRzJ2NzJ2WFJRREJueWc0YkV3NjkxVU8zM1lWQ3g5dC9mdi8rbi9Qbi8zeWQ3WkR5Sm5xWUhPdEJuejJJYVF0aHhGL244aUIrU0xSQ2k4SEJ1SURTbk5jU1JNV1d6enRhcDlMNW9OODRxLzE5TG5xVU94V0xLM2I0K2s3ejhEN01lbVZFRzlmbGYzNmVCbFZyakdlVGpaRStEQUN5S1k1QkJEL3V4ZHQ2cmRwZTMwYjZPTE5xcmJSNS9IVE5zclZKRzJuNy9pMkVVRFFVR0M0TU9uOEwvNzJINk9oWTdzY1VueWxwRjAybElQTWpiRDZuZFNBWHdnaHRVOU1UeWxQWHYvRnk1OWNCWklEODBZSUlBUHpBYVU1cnFRSml5MmVkalhyZFpGQkcwK3RyN1p2eXozbWRoODNUWlBjUHFMdHRzMXc5b2xUeS9TNXg5eUs3YXZXUFZUNE1BTElwamtFa05aWURmUXhuOTRYLytCQjIvQUhSWDBWZlEyMS9yNVhqbU1JSUdnb0xGeVlkQjRMRy92S2MwVzY2d2gxOER0RDFJUnZoSkE1UEIwcnQzeUY1TWxyejY1Q3lSdmYvdmg2WDFYM3c4dUFnZmlBMGh4WDBvVEZGazI3bWZ1cGxSdkN3Vys5MFRxei9tMms5SzFZeDB4NE50OURQdFl0U2c1dzNhczJmUUpJbjN2TVc0TTNOMTZuYWwvNDhOL2xoQk1DeUtZNUJSRHorN0hJKzBucmRXTi96SGhIbXcrbGJmV1ptOUlxOFQ3MWNlUFFtSEkvUkNDQTRQQ2s4NXp5TFZtUngvWGVDWnZhU1kzNGhSQVNhK1NYVUw0NjB0bFhBc2pBZkVCcGppdUwwdnNncVdYN2ZNSmM1TDVzcmRkanlWWDZxVmpIVHFiMGErc0d0VVJnODRsL08zaTBldjFPYUxsalBnRWVwQW5UZWxLYlFiK3VPZTluQXNpbW1nS0lmNGRUamtQK3VjR2FhSzNMN3lILysrVWVBN3NHbVF1WFN0czc5bUVNZzMwd292WDRxbW5zK05QbHY4OTZqd2dCNU5RcEhDUlBPazh0MzdvVmVVcFdTZ2paZURwV3pkK1lma3dSUU1yeUFhVTVyaXpLTVFFa3Q4RXUzYlQwdWVwUThtVFZaMjdNTG03dWp3NXZYa2RZMTc1eDlmcDMwbkxITmplOUcwUXQ1MjJuQnFCVjA2Zi81cnlmaS96dWFyMEVrQWl2djlsTUV2OXN6dXU0K2oxVDlXcWt0WnpmMThjR0QvUHlVenhsNnRqem1NZnQvZTgxZGkzbjF6NTFESDVmRTBDUVRxRWdlOUo1YW5rOVBVUEl4dmVFK0pHM3NTWit6a1VBS2NzSGxPYTRzaWg5bTgzY2s0SVZQZGxxL2Y1RU1yY3BjRE5TN0ZZbnJYdkllUWptZGZuMzBLKy93NFJQMEJmRzd6OExmK2VmOGMvbS9PNzJQbkY2MldZVlIvRStPa3k0VWJuUVRPalAybjN6My92bkRuMkt1bTExdjczK084cHJzby9XbS9VK0Nvc1ZvZFZQL25xMHZQNW1NMGxXWTlGLysxeHg5SGI4YitEZnB3dnpNUFJuM2Q4MWY4Qng3RlhOcnFtZTB0WG5hdkV1ZmozYVk5RysxOCszNnZycVNjNnhjSFdGV3YvTmVvOElBZVJVS1F6MG5uU2VXanNtcDZlRUVEK3U5cnl0dVQ0WmExY1JRTXJ5QWFVNXJpeEs5a0ZTeS9pRWttdVUrNXkxSFRjS3VVcmZpalYwQ0NtdDk0bFR5dzdaM0pTdy91NFovZStjOTNPUlprTHJKWUJFZVAzTlpwS3N4cUwvRG5uRnNiU2lrN29QMGZhUG5hTldtb1BONm9NVi9aY0FnalFLQWtkUE9rK3QzQkNpcHZ5U3lsL2tkKzd5OTJ3c2FWSTZBYVFzSDFDYTQ4cWlaQjBrOWZQK1JDdjNFK2RIWWZGUmFIdDkvcDJLbmJSTTY1OVRDRG5xeEtubGN4dUdzYndTaHJpaS81L3plMUtrbWRCNkNTQVJYbit6bVNUcnNlaC8rNVA0MmswYVBsb2F4NUJYYzRiazQrVDZhb3IrTndFRWh5a0FERGJwUExWNmhKQ3JuU1o5OWVTb1dETS94eUtBbE9VRFNuTmNXWlNzZzZSK3ZxcDVGakhhbmo4SnpWWDBWaXpUK2gxQ2NzUGJGSTQrY1dvZHh6eHRwNFFMKytRL2EvNHFTWkZtUXVzbGdFUjQvYzFta215TVJmKy96MVhRc1ZRUlBreGo4WWRKTlg0b3NuRyswUDhuZ0dBL05mNkRUenBQclVnSTJmdUlYalhuRzVQUy9VVi9zWVorYmtVQUtjc0hsT2E0c2lqSkIwbjliSjlQRnpjK2RSNkx0dHZuVS9neHZoalBKLzNhZjQrT1BuRnFIZDdQV2o1aDllc2RteWVUOCs5UXBKblFlZ2tnRVY1L3M1a2tGOGFpUDZzdGhMalJyeVo4dERTbTJxN01YbmlOOUdjRUVPeW1oci9ZcFBPVTJqRXhmZStYRmFwQnY5czI2LzVDUDMrZlJxeXBuMU01U0xYN3BEbzRKd1o1ZkVCcGppdUxrblNRMU0vMStiVE1QMS8wcXNJdTNxNnF6OVdHVWE3V2FEdWVsRm5qcDQ4MnlJbFQ2NmtoaE93TXdQcTduUGR6a1daQzZ5V0FSSGo5eldhU1JNZWlQNjhsaFBnOVVQeUxCdnZ5MkZSVFg1bjFzVEQ2R3VuUENTQ0lVNk5mZk5KNVNrVkNpQVBSMVRETUM5U2dlejdJMDdaaDl6ZUx4NXI2T1pXL2pMRGRIOVd0c0tzWWlBOG96WEZsVVpJT2t2cTVQcmZVckNmOFRrSGI3M1BGcHZpdFdDMXR4N2VLMWZZNzVmRU0rclF5clcrS0NhOXVhUGIrL3VudmMxNTdBc2ltNmdPSTZlK21icTVIKzVMQlkyaWNVMTZaZFVEYmVjelIzeEZBRUtjbWY3Uko1NGZLd1dmcnl3clBWSmZDVUM5UWszNjkwN0N2dmxFODF0alBwUWdnWmZtQTBoeFhGdVhnUVZJL2svdHQ1MWJGd2RmamFJYVRwZml0V0YzYW5wOHFOdlh2bHJkZjhzVHRNRGhXSStoOU9SaWl3cytsS3ZMN3JQVVNRQ0s4L21ZelNmYU9SWC92NW5yc0VPekhReGQ5N0hnSkdyT3ZHbzExWmRiYk9SalEvRE9ybjA1SEFEa0ZhdTVIbjNSK3FQeU42ZDB4cWZiT2hWQ2p2cjRWYSs1UHhTS0FsT1VEU25OY1daUkRKKysrajdhczRwWURqYVBQaEhRYjVWYXNMbTNUbjlZZStwTEFJVGtRdURFYnJWSFN0dHhNbEFvaWZuOG0vN3VGbjA5RkFOazBtd0RTMHMvNVdKRDZaWlY5K0gwN3krRFJwZkU3c1BuM3N0UnhLT3QxMHM4UlFMQkpqZjFrazg0UDFaLy96VDkwQTRoclp6T3VSdjJ5YW4wcmxwdjRXSE0vaHlLQUFNdWdrNWV2R1Bna1BYU3o3dHNkSERvbURZamF2dmN2OTR2Sll0cG1wdHA3N0ZFWC9hNDRpQXdWaE52ZnYrb21tQTlCKzlVZWg0WUlJejcyK0dyNkpQTUNzUkJxNkNlZGRKNVNrU2RqN1pzUGNxdlR1TTkyUWpvQkJGZ2VuYkRkTUxrUmNOUGtwdjJlYXQva2JqZFcvaG1YbC9GSmYvUXJPcWs4dGpCR056cjc5cTNkTC8rY2Y1N1FnYVBvZDhqdkxkOTI1RkMrNzNmUERYajNQZVZsVHVyM3ovdXI4dnV1ZmExY3UzUmZLeCs3Q0IwNG5ocjVLaWFkSHlvSG9tZS8vSjF1QURrMEgyVDlCWVVQWHJ3VWJmQnJMd0lJQUFBQUZrZE5mRFdUemc5VlpEN0k3YkFiRjZoaDM1aVFQc2VySUFRUUFBQUFMSW9hK09vbW5SK3F6Ly9WMzNjRGlHdmZyVmozMndaK2psZEJIcjcwREFFRUFBQUF5NkRHdmRwSjU0ZHE2L3RCSG9SZHVrQk4rN1ZPQXorN3F5RCtMcFBPK0srRjNRSUFBQURtUlUxNzlaUE85MVhrVnF5YllkY3VVT00rMjZzZ0JCQUFBQURNbnByMUM1UE8zZERIR3YyYUsvSXQ2ZEVKNldyY1p6c1hoQUFDQUFDQTJWT2p2akhwL09xTi94TnQ4R3N0WDZtNThwY3ZkOE9IeXdIa2N0akZDOVM4cjUrSU5hZnZCU0dBQUFBQVlOYlVwRzlNT3ZlRTdsaVRYMnY1U3MzV28zaGR2cHF6TTN5WW12Y2JiU1B2YjBlUE5mczFGZ0VFQUFBQXM2VW1mV1BTK2IvOXovODcydVRYV3Y0MmROOHUxdDBIMVIzVnp1OENhYWw1djZSYWZ6djZrOWVlalRiOHRSVUJCQUFBQUxPa0puM1drODQvOS95cjI4SER0WFBpZVl3YStEdHRNLy9HdHo4ZWJmaHJLd0lJQUFBQVprZU4rbXdubmUrWjc3SHp1ejkyVVFOL3RkUE1uLy94aDUrTk52MDFGUUVFQUFBQXM2Tm1mWmFUenZmTTl6aDR5OVV1YXVMWGs5Ri8rZXFubzAxL1RmV2pyMzI0RzBEMnpuTUJBQUFBSnFkbWZaYVR6bmZOOXdpNzFadWErTnR0UXorSDI3RGFzYnJDTGdBQUFBQjFVc00reTBubi9rYjI3cmhEM1FpN2RSUTE4ck82RGFzNzFyQUxBQUFBUUgzVXNNOXUwcm5IdC9YbGdxNWU4ejMyVVRPL3ZnMnI5cWRodGVOMGhlRURBQUFBZFZIRFBydEo1eDVmNUphcm8rWjc3S0ptZm4wYjFvTVhMMFViLzFxcUhhY3JEQjhBQUFDb2k1cjJXVTA2OTN5UDduaERIVDNmWXhjMTg5ZmJwcjcyTHlWc3gra0t3d2NBQUFEcW9jWjlWcFBPUzg3MzJLZmIyUC9oQjUrSk52ODFWSGVjWWVnQUFBQkFIZFM0ejJiUytZNzVIbWVxUWVkNzdLS0cvbjdiMk5mOE9ONTJqSzR3ZEFBQUFHQjZidHhWczVoMHZtTyt4MzNWNFBNOWRsRkRmNnR0N0IrKzlFeTArWis2L0lTdWRveXVNSFFBQUFCZ1dtN2NWYk9ZZEw1anZzZnRzQ3VqVVVPL25nZmlieHVQQllDcDY3ZmZ1OXdOSVBmRDBBRUFBSUJwcVlHdmZ0SzVyOFpFNW52NGlrM3grUjR4YXVndmQ1cjdhQUNZdWdnZ0FBQUFxSTRhK0p1ZGhyN0tTZWQvOGJmL09PbDhqMTNVMUQ5dEcvemZ2MzRsR2dLbUxBSUlBQUFBcXFJRy9scW5vYTl5MHZrWHYvTDl5ZWQ3N09LbXZtM3dhL3hDUWdJSUFBQUFxcUVHL3JLcTZrbm5mL2JYcjIwSEQ5Zm84ejEyVVZPLzhZV0VidmdQMWVQdmZ1cjhGeTkvOG1CNVhzbWgrc2szUDlvTkdJZUtBQUlBQUlCcHFJbXZldEo1YmZNOWRsRlR2MzRTMWd5S0FBSUFBSUJwcUpHLzAybnNxNXAwWHV0OGp4ZzE5ZGUybXZ4YXkzTlZxcmx5QkFBQWdCT2lScjdhU2VjMXovZUlVVlBmRFNCdThqMG41RkRkVWZuS3lhSHlZMzY5L3IwVmhnSUFBQURVUjQxOHRaUE9kOHozdUJXR0RnQUFBR0JPMU14WE9lbDh6M3lQNjJIb0FBQUFBT1pFelh5Vms4NTN6UGZ3T0t1Yjd3RUFBQUFna1JyNjZpYWRld3lSK1I3K1J2WXE1M3NBQUFBQVNLQ0d2cnBKNXg1RGQweWhtTzhCQUFBQXpKbWErcW9tblh1K2g4ZlFIWk9LK1I0QUFBREEzS21wcjJyU3VlZWNNTjhEQUFBQVdDQTE5UnVUemwzK2pvMVlNQmlqbU84QkFBQUFMSmdhKzQxSjV5NEhBTSs5R1BzcUNQTTlBQUFBZ0lWVGcrKzVIdzRoNjF1dzJucjJ5OThaNVNsWWUrWjc4TzNkQUFBQXdCS3AyZmV0V0g0SzFwbHFJd3o0eS85S1hRM1pNOS9qY2hnYUFBQUFnS1ZTNCs4Z2NrdTFjVVhFSVdIb0x5VGNNZC9EVjJPWTd3RUFBQUNjRW9VQVB4bnJmZ2dGcXhyeVc5RS85L3lyM2REUjFzMndlUUFBQUFDblNLSEFWMFBXSWVIWUVPSmJ1YTc4NWN2ZDBPRml2Z2NBQUFBd1YvLzBkeCs2cHJxdXV0V3BteXIvZWZiY0NvV0RHeUVrSEJWQ3ZJd250cmZyQ2NWOER3QUFBR0JPSENwQ3dMaXZPaytvcDZvN3F1UnZGVmRJdUtyYUNDRTVFOVAvL0cvK2dma2VBQUFBd0p3cFFEaDRPRWpFUWtacW5hbHVoRlh1cGJEZ0VMSU9FSjZZSGdzYjI4VjhEd0FBQUdER0ZCZ3VxVzZIQUhHaGZ2ejFqNXovOUZzZk8zLzQwalBudjNqNWs2dDY4T0tsMVovRmZqNlVnOGpCZVJnS0RyNGRheDBrL09XQnNkRGhZcjRIQUFBQU1ITUtDVmRWRDBKb1dOZFB2dm5SODhmZi9kVDVIMzd3bWZQemYvNzgzbnJ5MnJPclFQS2pyMzE0WXgyaGJvZE43YVFBY2JzVEtLTHpRWmp2QVFBQUFNeWN3b0hEaCtkdnJBT0RyM2I4OW51WG8wSGpVUDN4aDU5ZFhSM3ByaStVNTVMc25KdWhFT0h2Q2xsL1lhR3ZjblREeDY3NUhtRnhBQUFBQUxWVElMZ1FQaHdlWXNFaXQzelZ4RmRRdXV0VytTckx2aEJ5clJzd3Z2aVY3Ni9DeDQ3NUhrbHpUQUFBQUFCVVFFRmdJM3o0MXFtK1Z6MzJsVy9MYXJjUmF1OVZDd1VMUDhWcUZUSjhGY1NUMHR2L0g4cnpQYTZHSHdjQUFBQlFPNFVBVHpoZnovbHcrUGo5NjFlaUFXS0lpb1NRblUrclVyand0NlZ2aDQ2MlBOK0RSK3dDQUFBQWM2SUFzUEcwcXhKWFByYnJqVzkvdkJ0QVhEc25qaXRrcksrQ2RJcjVIZ0FBQU1EY3VQSHZCb0doNW53Y0trOU85K1QyenJidmh5RmRvTEN4TVJkRXhYd1BBQUFBWUk3VStLKy9aTkNUeEdOaG9WVDVTa3U3N1ZBN3Y3dERvY05QeEdLK0J3QUFBREJYYXZnM3JuNk1jZXZWZG0xOWNlSE8yNm9VUEs2cm1POEJBQUFBekpVYS9wdHQ4ei8yMVkrMklsZEJDQmtBQUFEQUVxblpYei81eXQ5d0hnc0lZOVRXWEJEbWR3QUFBQUJMMUduNlYxOFVHQXNIWTlURGw1N3BCcERiWVhnQUFBQUFsa0tOL3JXMjZmY1ZpRmd3R0t1ZXZQWnNONERzZkJvV0FBQUFnSmxTbzMramJmbzlFVHdXRE1ZcVgzMXB4K0lLUXdRQUFBQ3dGR3IwYjdVTi8xamYvYkd2MnJHNHdoQUJBQUFBTElVYWZRSUlBQUFBZ0hHbzBTZUFBQUFBQUJpSEd2MTFBUEZUcUdLaFlNeHF4K0lLUXdRQUFBQ3dGR3IwMTAvQm1ub1MrdGFYRVo2RklRSUFBQUJZQ2pYNlY5dW0vMGRmKzNBMEdJeFZ2M3oxMDkwQXdtTjRBUUFBZ0NWU3MvKzBiZngvLy9xVmFEZ1lvOTc0OXNlN0FlUldHQjRBQUFDQUpWR3pmN2R0L0tlYUIvTEhIMzUyZFFXbUhZZnFhaGdlQUFBQWdDVlJzNy8rTWtLSEFJZUJXRWdvV1Z1M1h6SC9Bd0FBQUZneU5mM3IyN0RHZmh5dkE4K1B2LzZSYmdEaDlpc0FBQUJneWR6MHR3SEFWMEgrOElQUFJNTkNpWExnYWJldGNoQzZGSVlGQUFBQVlJbmM5S3ZPUWdnWTdaRzhudlRlYmpNVVZ6OEFBQUNBVTZEbS8zbzNERHg0OFZJME5BeFZ2c3F5TmZIOFFSZ0tBQUFBZ0ZPZ0VIQ25Fd2lLaFJDSGo1OTg4NlBkOE9GYnIzanlGUUFBQUhCcUZBUWVkSUxCS29RTStXUXMzM2ExZGVYRGRTTnNIZ0FBQU1BcFVSandmSkNORU9LckZiLzkzdVZvb01pcHJRbm5iUkUrQUFBQWdGT21VT0FRY3I4VEVsYmxxeUc1MzVidXF5Zitubyt0UisyMlJmZ0FBQUFBMEZCQVdEK2V0MXUrSXVLckdiNHFFcnM5eXlIRm9jT0JKWEs3bGN0UDNHTE9Cd0FBQUlCTkRncXFDMWREZXBZbm16dlU4RjBmQUFBQUFIWlRhTGltdXF1S0JZdERSZkFBQUFBQWtNOGhRblZENVVmMmJreFc3NVFEaDYrYU9IUmNDNHNDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFnMVljKzlDK0N5WUZRc25wanhnQUFBQUJKUlU1RXJrSmdnZz09JztcbiAgICAgICAgICAgIHZhciBpbWFnZUhlaWdodCA9IHdpZHRoICogMyAvIDg7XG4gICAgICAgICAgICB2YXIgb2xkQW50aWFsaWFzID0gdGhpcy5nZXRBbnRpYWxpYXNpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QW50aWFsaWFzaW5nKHRydWUpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgODAwLCAzMDAsIHgsIHkgLSBpbWFnZUhlaWdodCAtIDIwLCB3aWR0aCwgaW1hZ2VIZWlnaHQpO1xuICAgICAgICAgICAgLy8gbG9hZGluZyBib3hcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHgsIHksIHdpZHRoLCAyMCk7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB3aWR0aCAqIChsb2FkZWQgLyB0b3RhbCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcHJvZ3Jlc3MgLSBtYXJnaW4gKiAyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IDIwIC0gbWFyZ2luICogMjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4ICsgbWFyZ2luLCB5ICsgbWFyZ2luLCB3aWR0aCA+IDAgPyB3aWR0aCA6IDAsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnNldEFudGlhbGlhc2luZyhvbGRBbnRpYWxpYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbG9hZGluZyBzY3JlZW4gZHJhdyBmdW5jdGlvbiBpZiB5b3Ugd2FudCB0byBjdXN0b21pemUgdGhlIGRyYXdcbiAgICAgICAgICogQG1ldGhvZCBzZXRMb2FkaW5nRHJhd0Z1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSBmY24ge2N0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBsb2FkZWQ6IG51bWJlciwgdG90YWw6IG51bWJlcikgPT4gdm9pZH1cbiAgICAgICAgICogQ2FsbGJhY2sgdG8gZHJhdyB0aGUgbG9hZGluZyBzY3JlZW4gd2hpY2ggaXMgcGFzc2VkIGEgcmVuZGVyaW5nIGNvbnRleHQsIHRoZSBudW1iZXIgb2YgYnl0ZXMgbG9hZGVkLCBhbmQgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyB0byBsb2FkLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zZXRMb2FkaW5nRHJhd0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZjbikge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nRHJhdyA9IGZjbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFub3RoZXIgb3B0aW9uIGF2YWlsYWJsZSB0byB5b3UgdG8gbG9hZCByZXNvdXJjZXMgaW50byB0aGUgZ2FtZS5cbiAgICAgICAgICogSW1tZWRpYXRlbHkgYWZ0ZXIgY2FsbGluZyB0aGlzIHRoZSBnYW1lIHdpbGwgcGF1c2UgYW5kIHRoZSBsb2FkaW5nIHNjcmVlblxuICAgICAgICAgKiB3aWxsIGFwcGVhci5cbiAgICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICAqIEBwYXJhbSBsb2FkZXIge0lMb2FkYWJsZX0gU29tZSBsb2FkYWJsZSBzdWNoIGFzIGEgTG9hZGVyIGNvbGxlY3Rpb24sIFNvdW5kLCBvciBUZXh0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICBsb2FkZXIub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvZ3Jlc3MgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgICAgICBfdGhpcy50b3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKCdMb2FkaW5nICcgKyAoMTAwICogX3RoaXMucHJvZ3Jlc3MgLyBfdGhpcy50b3RhbCkudG9GaXhlZCgwKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9hZGVyLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2FkZXIubG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRW5naW5lO1xuICAgIH0pKGV4LkNsYXNzKTtcbiAgICBleC5FbmdpbmUgPSBFbmdpbmU7XG4gICAgO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2FsaWJ1ci0wLjIuNS5qcy5tYXBcbjtcbi8vIENvbmNhdGVuYXRlZCBvbnRvIGV4Y2FsaWJ1ciBhZnRlciBidWlsZFxuLy8gRXhwb3J0cyB0aGUgZXhjYWxpYnVyIG1vZHVsZSBzbyBpdCBjYW4gYmUgdXNlZCB3aXRoIGJyb3dzZXJpZnlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvaXNzdWVzLzMxMlxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7bW9kdWxlLmV4cG9ydHMgPSBleDt9IiwiLypqc2xpbnQgbm9kZTp0cnVlLG5vbWVuOnRydWUqL1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyXG4gICAgICAgIHBhcnRzID0gb3B0cy5wYXJ0cyxcbiAgICAgICAgZXggPSBvcHRzLmV4LFxuICAgICAgICBnYW1lID0gb3B0cy5nYW1lLFxuICAgICAgICBjb2xvciA9IG9wdHMuY29sb3IsXG4gICAgICAgIHcgPSBnYW1lLndpZHRoLFxuICAgICAgICBoID0gZ2FtZS5oZWlnaHQsXG4gICAgICAgIHNpemUgPSBvcHRzLnNpemUsXG4gICAgICAgIGZpbmRYID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHggPSBzaXplICogXy5yYW5kb20oMiwgTWF0aC5mbG9vcih3IC8gc2l6ZSkgLSAyKTtcbiAgICAgICAgICAgIHJldHVybiBfLnBsdWNrKHBhcnRzLCAneCcpLmluZGV4T2YoeCkgPT09IC0xID8geCA6IGZpbmRYKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHkgPSBzaXplICogXy5yYW5kb20oMiwgTWF0aC5mbG9vcihoIC8gc2l6ZSkgLSAyKTtcbiAgICAgICAgICAgIHJldHVybiBfLnBsdWNrKHBhcnRzLCAneScpLmluZGV4T2YoeSkgPT09IC0xID8geSA6IGZpbmRZKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFjdG9yID0gbmV3IGV4LkFjdG9yKGZpbmRYKCksIGZpbmRZKCksIHNpemUsIHNpemUsIGNvbG9yKTtcbiAgICB0aGlzLmVhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0b3Iua2lsbCgpO1xuICAgIH07XG4gICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgIGdhbWUuYWRkKGFjdG9yKTtcbn07XG4iLCIvKmpzbGludCBub2RlOnRydWUsbm9tZW46dHJ1ZSovXG4vKmdsb2JhbCB3aW5kb3cqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc25ha2UpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGhhbmRsZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuYmV0YSxcbiAgICAgICAgICAgIHggPSBldmVudC5nYW1tYSxcbiAgICAgICAgICAgIG1heFggPSAzMCxcbiAgICAgICAgICAgIG1heFkgPSAyMDtcbiAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgICBzbmFrZS5kb3duKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IC1tYXhZKSB7XG4gICAgICAgICAgICBzbmFrZS51cCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgICBzbmFrZS5yaWdodCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHggPCAtbWF4WCkge1xuICAgICAgICAgICAgc25ha2UubGVmdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlb3JpZW50YXRpb24nLCBoYW5kbGVPcmllbnRhdGlvbik7XG59O1xuIiwiLypqc2xpbnQgbm9kZTp0cnVlKi9cbi8qZ2xvYmFsIHdpbmRvdyovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGxzID0gd2luZG93LmxvY2FsU3RvcmFnZSxcbiAgICAgICAgc2NvcmUgPSAwLFxuICAgICAgICByZWNvcmQgPSBscy5nZXRJdGVtKCdyZWNvcmQnKSB8fCAwO1xuICAgIHRoaXMuaW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzY29yZSArPSAxO1xuICAgICAgICBpZiAoc2NvcmUgPiByZWNvcmQpIHtcbiAgICAgICAgICAgIHJlY29yZCA9IHNjb3JlO1xuICAgICAgICAgICAgbHMuc2V0SXRlbSgncmVjb3JkJywgcmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC50aXRsZSA9ICdTY29yZTogJyArIHNjb3JlICsgJyBSZWNvcmQ6ICcgKyByZWNvcmQ7XG4gICAgfTtcbiAgICBkb2N1bWVudC50aXRsZSA9ICdTY29yZTogJyArIHNjb3JlICsgJyBSZWNvcmQ6ICcgKyByZWNvcmQ7XG59OyIsIi8qanNsaW50IG5vZGU6dHJ1ZSxub21lbjp0cnVlKi9cbnZhciBGb29kID0gcmVxdWlyZSgnLi9mb29kJyksXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICBTY29yZSA9IHJlcXVpcmUoJy4vc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXJcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHYgPSB7fSxcbiAgICAgICAgcnVubmluZyA9IGZhbHNlLFxuICAgICAgICBzcGVlZCA9IDE1MCxcbiAgICAgICAgc2NvcmUgPSBuZXcgU2NvcmUoKSxcbiAgICAgICAgZ2FtZSA9IG9wdHMuZ2FtZSxcbiAgICAgICAgc2l6ZSA9IE1hdGguZmxvb3IoTWF0aC5taW4oZ2FtZS53aWR0aCwgZ2FtZS5oZWlnaHQpIC8gMjIpLFxuICAgICAgICBleCA9IG9wdHMuZXgsXG4gICAgICAgIGNvbG9yID0gb3B0cy5jb2xvcixcbiAgICAgICAgcGFydCA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvcikge1xuICAgICAgICAgICAgdmFyIGFjdG9yID0gbmV3IGV4LkFjdG9yKHgsIHksIHNpemUsIHNpemUsIGNvbG9yKTtcbiAgICAgICAgICAgIGdhbWUuYWRkKGFjdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBhY3RvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRQbGFjZVJhbmRYID0gXy5yYW5kb20oMiwgTWF0aC5mbG9vcihnYW1lLndpZHRoIC8gc2l6ZSkgLSAyKSxcbiAgICAgICAgc3RhcnRQbGFjZVJhbmRZID0gXy5yYW5kb20oMiwgTWF0aC5mbG9vcihnYW1lLmhlaWdodCAvIHNpemUpIC0gMiksXG4gICAgICAgIHBhcnRzID0gW1xuICAgICAgICAgICAgcGFydCgoc3RhcnRQbGFjZVJhbmRYICsgMSkgKiBzaXplLCBzdGFydFBsYWNlUmFuZFkgKiBzaXplLCBjb2xvci5ib2R5KSxcbiAgICAgICAgICAgIHBhcnQoc3RhcnRQbGFjZVJhbmRYICogc2l6ZSwgc3RhcnRQbGFjZVJhbmRZICogc2l6ZSwgY29sb3IuYm9keSlcbiAgICAgICAgXSxcbiAgICAgICAgZm9vZCA9IG5ldyBGb29kKHtcbiAgICAgICAgICAgIGV4OiBleCxcbiAgICAgICAgICAgIGdhbWU6IGdhbWUsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IuZm9vZCxcbiAgICAgICAgICAgIHBhcnRzOiBwYXJ0cyxcbiAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSksXG4gICAgICAgIGN1dFRhaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHBhcnRzLnBvcCgpLFxuICAgICAgICAgICAgICAgIHByZWxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxhc3QubW92ZVRvKFxuICAgICAgICAgICAgICAgIHByZWxhc3QueCxcbiAgICAgICAgICAgICAgICBwcmVsYXN0LnksXG4gICAgICAgICAgICAgICAgMiAqIHNwZWVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE5lY2sgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0UGFydCA9IHBhcnRzWzBdLFxuICAgICAgICAgICAgICAgIHggPSBmaXJzdFBhcnQueCxcbiAgICAgICAgICAgICAgICB5ID0gIGZpcnN0UGFydC55LFxuICAgICAgICAgICAgICAgIG5ld1BhcnQgPSBwYXJ0KHgsIHksIGNvbG9yLmJvZHkpO1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdChuZXdQYXJ0KTtcbiAgICAgICAgICAgIG5ld1BhcnQubW92ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB2LnggKiBzaXplLFxuICAgICAgICAgICAgICAgIHkgKyB2LnkgKiBzaXplLFxuICAgICAgICAgICAgICAgIHNwZWVkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV3UGFydC5vbignZXhpdHZpZXdwb3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYub25Mb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdQYXJ0O1xuICAgICAgICB9LFxuICAgICAgICBoaVRhaWwgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMjsgaSA8IHBhcnRzLmxlbmd0aCAtIDI7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1tpXSAmJiBhY3Rvci53aXRoaW4ocGFydHNbaV0sIHNpemUgLyAyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZGROZWNrKCkuY2FsbE1ldGhvZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud2l0aGluKGZvb2QuYWN0b3IsIHNpemUgLyAyKSkge1xuICAgICAgICAgICAgICAgICAgICBzcGVlZCArPSA1MDtcbiAgICAgICAgICAgICAgICAgICAgZm9vZC5lYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUuaW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvb2QgPSBuZXcgRm9vZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBleDogZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYW1lOiBnYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLmZvb2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogcGFydHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGVwKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaVRhaWwodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbkxvc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXRUYWlsKCkuY2FsbE1ldGhvZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgdGhpcy5yaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdi54ID0gMTtcbiAgICAgICAgdi55ID0gMDtcbiAgICB9O1xuICAgIHRoaXMubGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdi54ID0gLTE7XG4gICAgICAgIHYueSA9IDA7XG4gICAgfTtcbiAgICB0aGlzLnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2LnggPSAwO1xuICAgICAgICB2LnkgPSAtMTtcbiAgICB9O1xuICAgIHRoaXMuZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdi54ID0gMDtcbiAgICAgICAgdi55ID0gMTtcbiAgICB9O1xuICAgIHRoaXMucnVuID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2LnggPSBvYmoueCB8fCAwO1xuICAgICAgICB2LnkgPSBvYmoueSB8fCAwO1xuICAgICAgICBzdGVwKCk7XG4gICAgfTtcbn07XG4iLCIvKiFcbiAgKiBkb21yZWFkeSAoYykgRHVzdGluIERpYXogMjAxNCAtIExpY2Vuc2UgTUlUXG4gICovXG4hZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnKSBkZWZpbmUoZGVmaW5pdGlvbilcbiAgZWxzZSB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpXG5cbn0oJ2RvbXJlYWR5JywgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmbnMgPSBbXSwgbGlzdGVuZXJcbiAgICAsIGRvYyA9IGRvY3VtZW50XG4gICAgLCBoYWNrID0gZG9jLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbFxuICAgICwgZG9tQ29udGVudExvYWRlZCA9ICdET01Db250ZW50TG9hZGVkJ1xuICAgICwgbG9hZGVkID0gKGhhY2sgPyAvXmxvYWRlZHxeYy8gOiAvXmxvYWRlZHxeaXxeYy8pLnRlc3QoZG9jLnJlYWR5U3RhdGUpXG5cblxuICBpZiAoIWxvYWRlZClcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIpXG4gICAgbG9hZGVkID0gMVxuICAgIHdoaWxlIChsaXN0ZW5lciA9IGZucy5zaGlmdCgpKSBsaXN0ZW5lcigpXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGxvYWRlZCA/IGZuKCkgOiBmbnMucHVzaChmbilcbiAgfVxuXG59KTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuNy4wXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgY29uY2F0ICAgICAgICAgICA9IEFycmF5UHJvdG8uY29uY2F0LFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kO1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS43LjAnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gY3JlYXRlQ2FsbGJhY2sodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXModmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgaXRlcmF0ZWUgPSBjcmVhdGVDYWxsYmFjayhpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gK2xlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBbXTtcbiAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgY3VycmVudEtleTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgdmFyIHJlZHVjZUVycm9yID0gJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnO1xuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICB2YXIga2V5cyA9IG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSAwLCBjdXJyZW50S2V5O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgaWYgKCFsZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleCsrXSA6IGluZGV4KytdO1xuICAgIH1cbiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gKyBvYmoubGVuZ3RoICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBpbmRleCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICBjdXJyZW50S2V5O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgaWYgKCFpbmRleCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzWy0taW5kZXhdIDogLS1pbmRleF07XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLnNvbWUob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShfLml0ZXJhdGVlKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgaW5kZXgsIGN1cnJlbnRLZXk7XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBwcmVkaWNhdGUgPSBfLml0ZXJhdGVlKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIGluZGV4LCBjdXJyZW50S2V5O1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCB0YXJnZXQpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAoaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gb2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGggPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBvYmogJiYgb2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGggPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKDAsIGluZGV4KTtcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBsb3cgKyBoaWdoID4+PiAxO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGggPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgaWYgKG4gPCAwKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGhcbiAgLy8gYF8ubWFwYC5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIG91dHB1dCkge1xuICAgIGlmIChzaGFsbG93ICYmIF8uZXZlcnkoaW5wdXQsIF8uaXNBcnJheSkpIHtcbiAgICAgIHJldHVybiBjb25jYXQuYXBwbHkob3V0cHV0LCBpbnB1dCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoIV8uaXNBcnJheSh2YWx1ZSkgJiYgIV8uaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgIGlmICghc3RyaWN0KSBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNoYWxsb3cpIHtcbiAgICAgICAgcHVzaC5hcHBseShvdXRwdXQsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlLCBbXSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSB2YWx1ZSkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSk7XG4gICAgICAgIGlmIChfLmluZGV4T2Yoc2VlbiwgY29tcHV0ZWQpIDwgMCkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF8uaW5kZXhPZihyZXN1bHQsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIFtdKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCB0cnVlLCB0cnVlLCBbXSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHZhciBsZW5ndGggPSBfLm1heChhcmd1bWVudHMsICdsZW5ndGgnKS5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdHNbaV0gPSBfLnBsdWNrKGFyZ3VtZW50cywgaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcbiAgICAgICAgaSA9IGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGlkeCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGZyb20gPT0gJ251bWJlcicpIHtcbiAgICAgIGlkeCA9IGZyb20gPCAwID8gaWR4ICsgZnJvbSArIDEgOiBNYXRoLm1pbihpZHgsIGZyb20gKyAxKTtcbiAgICB9XG4gICAgd2hpbGUgKC0taWR4ID49IDApIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldXNhYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBwcm90b3R5cGUgc2V0dGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBDdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgdmFyIHNlbGYgPSBuZXcgQ3RvcjtcbiAgICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgYXJncyA9IGJvdW5kQXJncy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0gPT09IF8pIGFyZ3NbaV0gPSBhcmd1bWVudHNbcG9zaXRpb24rK107XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSBoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleTtcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBiZWZvcmUgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBrZXk7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KFtdLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgb2JqID0gbmV3IE9iamVjdChvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmopIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGNvbmNhdC5hcHBseShbXSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAob2JqW3Byb3BdID09PSB2b2lkIDApIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3Rgc1xuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgIGlmIChcbiAgICAgIGFDdG9yICE9PSBiQ3RvciAmJlxuICAgICAgLy8gSGFuZGxlIE9iamVjdC5jcmVhdGUoeCkgY2FzZXNcbiAgICAgICdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIgJiZcbiAgICAgICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuICAgIHZhciBzaXplLCByZXN1bHQ7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBzaXplID0gYS5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09PSBiLmxlbmd0aDtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGVxKGFbc2l6ZV0sIGJbc2l6ZV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIHNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIHJlc3VsdCA9IF8ua2V5cyhiKS5sZW5ndGggPT09IHNpemU7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAgICBrZXkgPSBrZXlzW3NpemVdO1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiLCBbXSwgW10pO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIGFuIElFIDExIGJ1Zy5cbiAgaWYgKHR5cGVvZiAvLi8gIT09ICdmdW5jdGlvbicpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICB2YXIgcGFpcnMgPSBfLnBhaXJzKGF0dHJzKSwgbGVuZ3RoID0gcGFpcnMubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgICBvYmogPSBuZXcgT2JqZWN0KG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV0sIGtleSA9IHBhaXJbMF07XG4gICAgICAgIGlmIChwYWlyWzFdICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBjcmVhdGVDYWxsYmFjayhpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gb2JqZWN0W3Byb3BlcnR5XSgpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIl19
