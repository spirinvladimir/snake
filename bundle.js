(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/a/snake/index.js":[function(require,module,exports){
/*jslint node:true*/
/*global window*/
var domready = require('domready'),
    ex = require('./lib/excalibur'),
    Snake = require('./lib/snake');

domready(function () {
    'use strict';
    var game = new ex.Engine(),
        snake = new Snake({
            ex: ex,
            game: game,
            color: {
                head: ex.Color.Red,
                body: ex.Color.Yellow,
                food: ex.Color.Green
            }
        }),
        replay = function () {
            game.rootScene.children.forEach(function (actor) {
                actor.kill();
            });
            setTimeout(function () {
                snake = new Snake({
                    ex: ex,
                    game: game,
                    color: {
                        head: ex.Color.Red,
                        body: ex.Color.Yellow,
                        food: ex.Color.Green
                    }
                });
                snake.onLose = replay;
                snake.run({x: 1});
            }, 500);
        },
        paused = false;
    game.input.keyboard.on('down', function (k) {
        k = k.key;
        if (k === 37) {
            snake.left();
        } else if (k === 38) {
            snake.up();
        } else if (k === 39) {
            snake.right();
        } else if (k === 40) {
            snake.down();
        } else if (k === 32) {
            if (paused) {
                game.start();
                paused = false;
            } else {
                game.stop();
                paused = true;
            }
        }
    });
    document.addEventListener('click', function () {
        replay();
    });
    game.start();
    snake.onLose = replay;
    snake.run({x: 1});
});

},{"./lib/excalibur":"/home/a/snake/lib/excalibur.js","./lib/snake":"/home/a/snake/lib/snake.js","domready":"/home/a/snake/node_modules/domready/ready.js"}],"/home/a/snake/lib/excalibur.js":[function(require,module,exports){
/*! excalibur - v0.2.5 - 2015-02-04
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2015 ; Licensed BSD*/
if (typeof window == 'undefined') {
    window = { audioContext: function () {
    } };
}
if (typeof window != 'undefined' && !window.requestAnimationFrame) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
        window.setInterval(callback, 1000 / 60);
    };
}
if (typeof window != 'undefined' && !window.AudioContext) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError(' this is null or not defined');
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg */) {
        'use strict';
        if (this === void 0 || this === null)
            throw new TypeError();
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function')
            throw new TypeError();
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t))
                return true;
        }
        return false;
    };
}
// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {
        }, fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
var ex;
(function (ex) {
    var Effects;
    (function (Effects) {
        /**
         * Applies the "Grayscale" effect to a sprite, removing color information.
         * @class Effects.Grayscale
         * @constructor
         * @extends ISpriteEffect
         */
        var Grayscale = (function () {
            function Grayscale() {
            }
            Grayscale.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
                pixel[firstPixel + 0] = avg;
                pixel[firstPixel + 1] = avg;
                pixel[firstPixel + 2] = avg;
            };
            return Grayscale;
        })();
        Effects.Grayscale = Grayscale;
        /**
         * Applies the "Invert" effect to a sprite, inverting the pixel colors.
         * @class Effects.Invert
         * @constructor
         * @extends ISpriteEffect
         */
        var Invert = (function () {
            function Invert() {
            }
            Invert.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
                pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
                pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
            };
            return Invert;
        })();
        Effects.Invert = Invert;
        /**
         * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
         * @class Effects.Opacity
         * @extends ISpriteEffect
         * @constructor
         * @param opacity {number} The new opacity of the sprite from 0-1.0
         */
        var Opacity = (function () {
            function Opacity(opacity) {
                this.opacity = opacity;
            }
            Opacity.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 3] = Math.round(this.opacity * 255);
                }
            };
            return Opacity;
        })();
        Effects.Opacity = Opacity;
        /**
         * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
         * average of the original color and the provided color
         * @class Effects.Colorize
         * @extends ISpriteEffect
         * @constructor
         * @param color {Color} The color to apply to the sprite
         */
        var Colorize = (function () {
            function Colorize(color) {
                this.color = color;
            }
            Colorize.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
                    pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
                    pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
                }
            };
            return Colorize;
        })();
        Effects.Colorize = Colorize;
        /**
         * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
         * a given color
         * @class Effects.Fill
         * @extends ISpriteEffect
         * @constructor
         * @param color {Color} The color to apply to the sprite
         */
        var Fill = (function () {
            function Fill(color) {
                this.color = color;
            }
            Fill.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 0] = this.color.r;
                    pixel[firstPixel + 1] = this.color.g;
                    pixel[firstPixel + 2] = this.color.b;
                }
            };
            return Fill;
        })();
        Effects.Fill = Fill;
    })(Effects = ex.Effects || (ex.Effects = {}));
})(ex || (ex = {}));
/// <reference path="../SpriteEffects.ts" />
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var MovementModule = (function () {
        function MovementModule() {
        }
        MovementModule.prototype.update = function (actor, engine, delta) {
            // Update placements based on linear algebra
            actor.x += actor.dx * delta / 1000;
            actor.y += actor.dy * delta / 1000;
            actor.dx += actor.ax * delta / 1000;
            actor.dy += actor.ay * delta / 1000;
            actor.rotation += actor.rx * delta / 1000;
            actor.scale.x += actor.sx * delta / 1000;
            actor.scale.y += actor.sy * delta / 1000;
        };
        return MovementModule;
    })();
    ex.MovementModule = MovementModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var OffscreenCullingModule = (function () {
        function OffscreenCullingModule() {
        }
        OffscreenCullingModule.prototype.update = function (actor, engine, delta) {
            var eventDispatcher = actor.eventDispatcher;
            var anchor = actor.anchor;
            var globalScale = actor.getGlobalScale();
            var width = globalScale.x * actor.getWidth() / actor.scale.x;
            var height = globalScale.y * actor.getHeight() / actor.scale.y;
            var actorScreenCoords = engine.worldToScreenCoordinates(new ex.Point(actor.getGlobalX() - anchor.x * width, actor.getGlobalY() - anchor.y * height));
            var zoom = 1.0;
            if (actor.scene && actor.scene.camera) {
                zoom = actor.scene.camera.getZoom();
            }
            if (!actor.isOffScreen) {
                if (actorScreenCoords.x + width * zoom < 0 || actorScreenCoords.y + height * zoom < 0 || actorScreenCoords.x > engine.width || actorScreenCoords.y > engine.height) {
                    eventDispatcher.publish('exitviewport', new ex.ExitViewPortEvent());
                    actor.isOffScreen = true;
                }
            }
            else {
                if (actorScreenCoords.x + width * zoom > 0 && actorScreenCoords.y + height * zoom > 0 && actorScreenCoords.x < engine.width && actorScreenCoords.y < engine.height) {
                    eventDispatcher.publish('enterviewport', new ex.EnterViewPortEvent());
                    actor.isOffScreen = false;
                }
            }
        };
        return OffscreenCullingModule;
    })();
    ex.OffscreenCullingModule = OffscreenCullingModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    /**
     * Propogates pointer events to the actor
     */
    var CapturePointerModule = (function () {
        function CapturePointerModule() {
        }
        CapturePointerModule.prototype.update = function (actor, engine, delta) {
            if (!actor.enableCapturePointer)
                return;
            if (actor.isKilled())
                return;
            engine.input.pointers.propogate(actor);
        };
        return CapturePointerModule;
    })();
    ex.CapturePointerModule = CapturePointerModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var CollisionDetectionModule = (function () {
        function CollisionDetectionModule() {
        }
        CollisionDetectionModule.prototype.update = function (actor, engine, delta) {
            var eventDispatcher = actor.eventDispatcher;
            if (actor.collisionType !== 0 /* PreventCollision */) {
                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {
                    var map = engine.currentScene.tileMaps[j];
                    var intersectMap;
                    var side = 0 /* None */;
                    var max = 2;
                    var hasBounced = false;
                    while (intersectMap = map.collides(actor)) {
                        if (max-- < 0) {
                            break;
                        }
                        side = actor.getSideFromIntersect(intersectMap);
                        eventDispatcher.publish('collision', new ex.CollisionEvent(actor, null, side, intersectMap));
                        if ((actor.collisionType === 2 /* Active */ || actor.collisionType === 3 /* Elastic */)) {
                            actor.y += intersectMap.y;
                            actor.x += intersectMap.x;
                            // Naive elastic bounce
                            if (actor.collisionType === 3 /* Elastic */ && !hasBounced) {
                                hasBounced = true;
                                if (side === 3 /* Left */) {
                                    actor.dx = Math.abs(actor.dx);
                                }
                                else if (side === 4 /* Right */) {
                                    actor.dx = -Math.abs(actor.dx);
                                }
                                else if (side === 1 /* Top */) {
                                    actor.dy = Math.abs(actor.dy);
                                }
                                else if (side === 2 /* Bottom */) {
                                    actor.dy = -Math.abs(actor.dy);
                                }
                            }
                        }
                    }
                }
            }
        };
        return CollisionDetectionModule;
    })();
    ex.CollisionDetectionModule = CollisionDetectionModule;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * An enum that describes the sides of an Actor for collision
     * @class Side
     */
    (function (Side) {
        /**
        @property None {Side}
        @static
        @final
        */
        Side[Side["None"] = 0] = "None";
        /**
        @property Top {Side}
        @static
        @final
        */
        Side[Side["Top"] = 1] = "Top";
        /**
        @property Bottom {Side}
        @static
        @final
        */
        Side[Side["Bottom"] = 2] = "Bottom";
        /**
        @property Left {Side}
        @static
        @final
        */
        Side[Side["Left"] = 3] = "Left";
        /**
        @property Right {Side}
        @static
        @final
        */
        Side[Side["Right"] = 4] = "Right";
    })(ex.Side || (ex.Side = {}));
    var Side = ex.Side;
})(ex || (ex = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ex;
(function (ex) {
    /**
     * A simple 2D point on a plane
     * @class Point
     * @constructor
     * @param x {number} X coordinate of the point
     * @param y {number} Y coordinate of the point
     *
     */
    var Point = (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * X Coordinate of the point
         * @property x {number}
         */
        /**
         * Y Coordinate of the point
         * @property y {number}
         */
        /**
         * Convert this point to a vector
         * @method toVector
         * @returns Vector
         */
        Point.prototype.toVector = function () {
            return new Vector(this.x, this.y);
        };
        /**
         * Rotates the current point around another by a certain number of
         * degrees in radians
         * @method rotate
         * @returns Point
         */
        Point.prototype.rotate = function (angle, anchor) {
            if (!anchor) {
                anchor = new ex.Point(0, 0);
            }
            var sinAngle = Math.sin(angle);
            var cosAngle = Math.cos(angle);
            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
            return new Point(x, y);
        };
        /**
         * Translates the current point by a vector
         * @method add
         * @returns Point
         */
        Point.prototype.add = function (vector) {
            return new Point(this.x + vector.x, this.y + vector.y);
        };
        /**
         * Sets the x and y components at once
         * @method setTo
         * @param x {number}
         * @param y {number}
         */
        Point.prototype.setTo = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Clones a new point that is a copy of this one.
         * @method clone
         * @returns Point
         */
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };
        return Point;
    })();
    ex.Point = Point;
    /**
     * A 2D vector on a plane.
     * @class Vector
     * @extends Point
     * @constructor
     * @param x {number} X component of the Vector
     * @param y {number} Y component of the Vector
     */
    var Vector = (function (_super) {
        __extends(Vector, _super);
        function Vector(x, y) {
            _super.call(this, x, y);
            this.x = x;
            this.y = y;
        }
        /**
         * Returns a vector of unit length in the direction of the specified angle.
         * @method fromAngle
         * @static
         * @param angle {number} The angle to generate the vector
         * @returns Vector
         */
        Vector.fromAngle = function (angle) {
            return new Vector(Math.cos(angle), Math.sin(angle));
        };
        /**
         * The distance to another vector
         * @method distance
         * @param v {Vector} The other vector
         * @returns number
         */
        Vector.prototype.distance = function (v) {
            if (!v) {
                v = new Vector(0.0, 0.0);
            }
            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
        };
        /**
         * Normalizes a vector to have a magnitude of 1.
         * @method normalize
         * @return Vector
         */
        Vector.prototype.normalize = function () {
            var d = this.distance();
            if (d > 0) {
                return new Vector(this.x / d, this.y / d);
            }
            else {
                return new Vector(0, 1);
            }
        };
        /**
         * Scales a vector's by a factor of size
         * @method scale
         * @param size {number} The factor to scale the magnitude by
         * @returns Vector
         */
        Vector.prototype.scale = function (size) {
            return new Vector(this.x * size, this.y * size);
        };
        /**
         * Adds one vector to another
         * @method add
         * @param v {Vector} The vector to add
         * @returns Vector
         */
        Vector.prototype.add = function (v) {
            return new Vector(this.x + v.x, this.y + v.y);
        };
        /**
         * Subtracts a vector from the current vector
         * @method minus
         * @param v {Vector} The vector to subtract
         * @returns Vector
         */
        Vector.prototype.minus = function (v) {
            return new Vector(this.x - v.x, this.y - v.y);
        };
        /**
         * Performs a dot product with another vector
         * @method dot
         * @param v {Vector} The vector to dot
         * @returns number
         */
        Vector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        /**
         * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.
         * @method cross
         * @param v {Vector} The vector to cross
         * @returns number
         */
        Vector.prototype.cross = function (v) {
            return this.x * v.y - this.y * v.x;
        };
        /**
         * Returns the perpendicular vector to this one
         * @method perpendicular
         * @return Vector
         */
        Vector.prototype.perpendicular = function () {
            return new Vector(this.y, -this.x);
        };
        /**
         * Returns the normal vector to this one
         * @method normal
         * @return Vector
         */
        Vector.prototype.normal = function () {
            return this.perpendicular().normalize();
        };
        /**
         * Returns the angle of this vector.
         * @method toAngle
         * @returns number
         */
        Vector.prototype.toAngle = function () {
            return Math.atan2(this.y, this.x);
        };
        /**
         * Returns the point represention of this vector
         * @method toPoint
         * @returns Point
         */
        Vector.prototype.toPoint = function () {
            return new Point(this.x, this.y);
        };
        /**
         * Rotates the current vector around a point by a certain number of
         * degrees in radians
         * @method rotate
         * @returns Vector
         */
        Vector.prototype.rotate = function (angle, anchor) {
            return _super.prototype.rotate.call(this, angle, anchor).toVector();
        };
        return Vector;
    })(Point);
    ex.Vector = Vector;
    /**
     * A 2D ray that can be cast into the scene to do collision detection
     * @class Ray
     * @constructor
     * @param pos {Point} The starting position for the ray
     * @param dir {Vector} The vector indicating the direction of the ray
     */
    var Ray = (function () {
        function Ray(pos, dir) {
            this.pos = pos;
            this.dir = dir.normalize();
        }
        /**
         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
         * This number indicates the mathematical intersection time.
         * @method intersect
         * @param line {Line} The line to test
         * @returns number
         */
        Ray.prototype.intersect = function (line) {
            var numerator = line.begin.toVector().minus(this.pos.toVector());
            // Test is line and ray are parallel and non intersecting
            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
                return -1;
            }
            // Lines are parallel
            var divisor = (this.dir.cross(line.getSlope()));
            if (divisor === 0) {
                return -1;
            }
            var t = numerator.cross(line.getSlope()) / divisor;
            if (t >= 0) {
                var u = (numerator.cross(this.dir) / divisor) / line.getLength();
                if (u >= 0 && u <= 1) {
                    return t;
                }
            }
            return -1;
        };
        /**
         * Returns the point of intersection given the intersection time
         * @method getPoint
         * @returns Point
         */
        Ray.prototype.getPoint = function (time) {
            return this.pos.toVector().add(this.dir.scale(time)).toPoint();
        };
        return Ray;
    })();
    ex.Ray = Ray;
    /**
     * A 2D line segment
     * @class Line
     * @constructor
     * @param begin {Point} The starting point of the line segment
     * @param end {Point} The ending point of the line segment
     */
    var Line = (function () {
        function Line(begin, end) {
            this.begin = begin;
            this.end = end;
        }
        /**
         * Returns the slope of the line in the form of a vector
         * @method getSlope
         * @returns Vector
         */
        Line.prototype.getSlope = function () {
            var begin = this.begin.toVector();
            var end = this.end.toVector();
            var distance = begin.distance(end);
            return end.minus(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         * @method getLength
         * @returns number
         */
        Line.prototype.getLength = function () {
            var begin = this.begin.toVector();
            var end = this.end.toVector();
            var distance = begin.distance(end);
            return distance;
        };
        return Line;
    })();
    ex.Line = Line;
    var Projection = (function () {
        function Projection(min, max) {
            this.min = min;
            this.max = max;
        }
        Projection.prototype.overlaps = function (projection) {
            return this.max > projection.min && projection.max > this.min;
        };
        Projection.prototype.getOverlap = function (projection) {
            if (this.overlaps(projection)) {
                if (this.max > projection.max) {
                    return projection.max - this.min;
                }
                else {
                    return this.max - projection.min;
                }
            }
            return 0;
        };
        return Projection;
    })();
    ex.Projection = Projection;
})(ex || (ex = {}));
/// <reference path="Algebra.ts"/>
/// <reference path="Events.ts"/>
var ex;
(function (ex) {
    var Util;
    (function (Util) {
        Util.TwoPI = Math.PI * 2;
        function base64Encode(inputStr) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var outputStr = "";
            var i = 0;
            while (i < inputStr.length) {
                //all three "& 0xff" added below are there to fix a known bug 
                //with bytes returned by xhr.responseText
                var byte1 = inputStr.charCodeAt(i++) & 0xff;
                var byte2 = inputStr.charCodeAt(i++) & 0xff;
                var byte3 = inputStr.charCodeAt(i++) & 0xff;
                var enc1 = byte1 >> 2;
                var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
                var enc3, enc4;
                if (isNaN(byte2)) {
                    enc3 = enc4 = 64;
                }
                else {
                    enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
                    if (isNaN(byte3)) {
                        enc4 = 64;
                    }
                    else {
                        enc4 = byte3 & 63;
                    }
                }
                outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
            }
            return outputStr;
        }
        Util.base64Encode = base64Encode;
        function clamp(val, min, max) {
            return val <= min ? min : (val >= max ? max : val);
        }
        Util.clamp = clamp;
        function drawLine(ctx, color, startx, starty, endx, endy) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.moveTo(startx, starty);
            ctx.lineTo(endx, endy);
            ctx.closePath();
            ctx.stroke();
        }
        Util.drawLine = drawLine;
        function randomInRange(min, max) {
            return min + Math.random() * (max - min);
        }
        Util.randomInRange = randomInRange;
        function randomIntInRange(min, max) {
            return Math.round(randomInRange(min, max));
        }
        Util.randomIntInRange = randomIntInRange;
        function canonicalizeAngle(angle) {
            var tmpAngle = angle;
            if (angle > this.TwoPI) {
                while (tmpAngle > this.TwoPI) {
                    tmpAngle -= this.TwoPI;
                }
            }
            if (angle < 0) {
                while (tmpAngle < 0) {
                    tmpAngle += this.TwoPI;
                }
            }
            return tmpAngle;
        }
        Util.canonicalizeAngle = canonicalizeAngle;
        function toDegrees(radians) {
            return 180 / Math.PI * radians;
        }
        Util.toDegrees = toDegrees;
        function toRadians(degrees) {
            return degrees / 180 * Math.PI;
        }
        Util.toRadians = toRadians;
        function getPosition(el) {
            var oLeft = 0, oTop = 0;
            var calcOffsetLeft = function (parent) {
                oLeft += parent.offsetLeft;
                if (parent.offsetParent) {
                    calcOffsetLeft(parent.offsetParent);
                }
            };
            var calcOffsetTop = function (parent) {
                oTop += parent.offsetTop;
                if (parent.offsetParent) {
                    calcOffsetTop(parent.offsetParent);
                }
            };
            calcOffsetLeft(el);
            calcOffsetTop(el);
            return new ex.Point(oLeft, oTop);
        }
        Util.getPosition = getPosition;
        function getOppositeSide(side) {
            if (side === 1 /* Top */)
                return 2 /* Bottom */;
            if (side === 2 /* Bottom */)
                return 1 /* Top */;
            if (side === 3 /* Left */)
                return 4 /* Right */;
            if (side === 4 /* Right */)
                return 3 /* Left */;
            return 0 /* None */;
        }
        Util.getOppositeSide = getOppositeSide;
        /**
         * Excaliburs dynamically resizing collection
         * @class Collection
         * @constructor
         * @param [initialSize=200] {number} Initial size of the internal backing array
         */
        var Collection = (function () {
            function Collection(initialSize) {
                this.internalArray = null;
                this.endPointer = 0;
                var size = initialSize || Collection.DefaultSize;
                this.internalArray = new Array(size);
            }
            Collection.prototype.resize = function () {
                var newSize = this.internalArray.length * 2;
                var newArray = new Array(newSize);
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    newArray[i] = this.internalArray[i];
                }
                delete this.internalArray;
                this.internalArray = newArray;
            };
            /**
             * Push elements to the end of the collection
             * @method push
             * @param element {T}
             * @returns T
             */
            Collection.prototype.push = function (element) {
                if (this.endPointer === this.internalArray.length) {
                    this.resize();
                }
                return this.internalArray[this.endPointer++] = element;
            };
            /**
             * Removes elements from the end of the collection
             * @method pop
             * @returns T
             */
            Collection.prototype.pop = function () {
                this.endPointer = this.endPointer - 1 < 0 ? 0 : this.endPointer - 1;
                return this.internalArray[this.endPointer];
            };
            /**
             * Returns the count of the collection
             * @method count
             * @returns number
             */
            Collection.prototype.count = function () {
                return this.endPointer;
            };
            /**
             * Empties the collection
             * @method clear
             */
            Collection.prototype.clear = function () {
                this.endPointer = 0;
            };
            /**
             * Returns the size of the internal backing array
             * @method internalSize
             * @returns number
             */
            Collection.prototype.internalSize = function () {
                return this.internalArray.length;
            };
            /**
             * Returns an element at a specific index
             * @method elementAt
             * @param index {number} Index of element to retreive
             * @returns T
             */
            Collection.prototype.elementAt = function (index) {
                if (index >= this.count()) {
                    return;
                }
                return this.internalArray[index];
            };
            /**
             * Inserts an element at a specific index
             * @method insert
             * @param index {number} Index to insert the element
             * @returns T
             */
            Collection.prototype.insert = function (index, value) {
                if (index >= this.count()) {
                    this.resize();
                }
                return this.internalArray[index] = value;
            };
            /**
             * Removes an element at a specific index
             * @method remove
             * @param index {number} Index of element to remove
             * @returns T
             */
            Collection.prototype.remove = function (index) {
                var count = this.count();
                if (count === 0)
                    return;
                // O(n) Shift 
                var removed = this.internalArray[index];
                for (var i = index; i < count; i++) {
                    this.internalArray[i] = this.internalArray[i + 1];
                }
                this.endPointer--;
                return removed;
            };
            /**
             * Removes an element by reference
             * @method removeElement
             * @param element {T} Index of element to retreive
             */
            Collection.prototype.removeElement = function (element) {
                var index = this.internalArray.indexOf(element);
                this.remove(index);
            };
            /**
             * Returns a array representing the collection
             * @method toArray
             * @returns T[]
             */
            Collection.prototype.toArray = function () {
                return this.internalArray.slice(0, this.endPointer);
            };
            /**
             * Iterate over every element in the collection
             * @method forEach
             * @param func {(T,number)=>any} Callback to call for each element passing a reference to the element and its index, returned values are ignored
             */
            Collection.prototype.forEach = function (func) {
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    func.call(this, this.internalArray[i], i);
                }
            };
            /**
             * Mutate every element in the collection
             * @method map
             * @param func {(T,number)=>any} Callback to call for each element passing a reference to the element and its index, any values returned mutate the collection
             */
            Collection.prototype.map = function (func) {
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    this.internalArray[i] = func.call(this, this.internalArray[i], i);
                }
            };
            /**
             * Default collection size
             * @property DefaultSize {number}
             * @static
             * @final
             */
            Collection.DefaultSize = 200;
            return Collection;
        })();
        Util.Collection = Collection;
    })(Util = ex.Util || (ex.Util = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * A Sprite is one of the main drawing primitives. It is responsible for drawing
     * images or parts of images known as Textures to the screen.
     * @class Sprite
     * @constructor
     * @param image {Texture} The backing image texture to build the Sprite
     * @param sx {number} The x position of the sprite
     * @param sy {number} The y position of the sprite
     * @param swidth {number} The width of the sprite in pixels
     * @param sheight {number} The height of the sprite in pixels
     */
    var Sprite = (function () {
        function Sprite(image, sx, sy, swidth, sheight) {
            var _this = this;
            this.sx = sx;
            this.sy = sy;
            this.swidth = swidth;
            this.sheight = sheight;
            this.scaleX = 1.0;
            this.scaleY = 1.0;
            this.rotation = 0.0;
            this.transformPoint = new ex.Point(0, 0);
            this.logger = ex.Logger.getInstance();
            this.flipVertical = false;
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.effects = [];
            this.internalImage = new Image();
            this.spriteCanvas = null;
            this.spriteCtx = null;
            this.pixelData = null;
            this.pixelsLoaded = false;
            this.dirtyEffect = false;
            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {
                this.logger.error("Sprite cannot have any negative dimensions x:", sx, "y:", sy, "width:", swidth, "height:", sheight);
            }
            this.texture = image;
            this.spriteCanvas = document.createElement('canvas');
            this.spriteCanvas.width = swidth;
            this.spriteCanvas.height = sheight;
            this.spriteCtx = this.spriteCanvas.getContext('2d');
            this.texture.loaded.then(function () {
                _this.spriteCanvas.width = _this.spriteCanvas.width || _this.texture.image.naturalWidth;
                _this.spriteCanvas.height = _this.spriteCanvas.height || _this.texture.image.naturalHeight;
                _this.loadPixels();
                _this.dirtyEffect = true;
            }).error(function (e) {
                _this.logger.error("Error loading texture ", _this.texture.path, e);
            });
            this.width = swidth;
            this.height = sheight;
        }
        Sprite.prototype.loadPixels = function () {
            if (this.texture.isLoaded() && !this.pixelsLoaded) {
                var clamp = ex.Util.clamp;
                var naturalWidth = this.texture.image.naturalWidth || 0;
                var naturalHeight = this.texture.image.naturalHeight || 0;
                if (this.swidth > naturalWidth) {
                    this.logger.warn("The sprite width", this.swidth, "exceeds the width", naturalWidth, "of the backing texture", this.texture.path);
                }
                if (this.sheight > naturalHeight) {
                    this.logger.warn("The sprite height", this.sheight, "exceeds the height", naturalHeight, "of the backing texture", this.texture.path);
                }
                this.spriteCtx.drawImage(this.texture.image, clamp(this.sx, 0, naturalWidth), clamp(this.sy, 0, naturalHeight), clamp(this.swidth, 0, naturalWidth), clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
                //this.pixelData = this.spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
                this.internalImage.src = this.spriteCanvas.toDataURL("image/png");
                this.pixelsLoaded = true;
            }
        };
        /**
         * Adds a new {{#crossLink Effects.ISpriteEffect}}{{/crossLink}} to this drawing.
         * @method addEffect
         * @param effect {Effects.ISpriteEffect} Effect to add to the this drawing
         */
        Sprite.prototype.addEffect = function (effect) {
            this.effects.push(effect);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this.texture.isLoaded() || !this.pixelsLoaded) {
                this.dirtyEffect = true;
            }
            else {
                this.applyEffects();
            }
        };
        Sprite.prototype.removeEffect = function (param) {
            var indexToRemove = null;
            if (typeof param === 'number') {
                indexToRemove = param;
            }
            else {
                indexToRemove = this.effects.indexOf(param);
            }
            this.effects.splice(indexToRemove, 1);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this.texture.isLoaded() || !this.pixelsLoaded) {
                this.dirtyEffect = true;
            }
            else {
                this.applyEffects();
            }
        };
        Sprite.prototype.applyEffects = function () {
            var _this = this;
            var clamp = ex.Util.clamp;
            var naturalWidth = this.texture.image.naturalWidth || 0;
            var naturalHeight = this.texture.image.naturalHeight || 0;
            this.spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this.spriteCtx.drawImage(this.texture.image, clamp(this.sx, 0, naturalWidth), clamp(this.sy, 0, naturalHeight), clamp(this.swidth, 0, naturalWidth), clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
            this.pixelData = this.spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
            this.effects.forEach(function (effect) {
                for (var y = 0; y < _this.sheight; y++) {
                    for (var x = 0; x < _this.swidth; x++) {
                        effect.updatePixel(x, y, _this.pixelData);
                    }
                }
            });
            this.spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this.spriteCtx.putImageData(this.pixelData, 0, 0);
            this.internalImage.src = this.spriteCanvas.toDataURL("image/png");
        };
        /**
         * Clears all effects from the drawing and return it to its original state.
         * @method clearEffects
         */
        Sprite.prototype.clearEffects = function () {
            this.effects.length = 0;
            this.applyEffects();
        };
        /**
         * Sets the point about which to apply transformations to the drawing relative to the
         * top left corner of the drawing.
         * @method transformAbotPoint
         * @param point {Point} The point about which to apply transformations
         */
        Sprite.prototype.transformAboutPoint = function (point) {
            this.transformPoint = point;
        };
        /**
         * Sets the current rotation transformation for the drawing.
         * @method setRotation
         * @param radians {number} The rotation to apply to the drawing.
         */
        Sprite.prototype.setRotation = function (radians) {
            this.rotation = radians;
        };
        /**
         * Returns the current rotation for the drawing in radians.
         * @method getRotation
         * @returns number
         */
        Sprite.prototype.getRotation = function () {
            return this.rotation;
        };
        /**
         * Sets the scale trasformation in the x direction
         * @method setScale
         * @param scale {number} The magnitude to scale the drawing in the x direction
         */
        Sprite.prototype.setScaleX = function (scaleX) {
            this.scaleX = scaleX;
        };
        /**
         * Sets the scale trasformation in the x direction
         * @method setScale
         * @param scale {number} The magnitude to scale the drawing in the x direction
         */
        Sprite.prototype.setScaleY = function (scaleY) {
            this.scaleY = scaleY;
        };
        /**
         * Returns the current magnitude of the drawing's scale in the x direction
         * @method getScale
         * @returns number
         */
        Sprite.prototype.getScaleX = function () {
            return this.scaleX;
        };
        /**
         * Returns the current magnitude of the drawing's scale in the y direction
         * @method getScale
         * @returns number
         */
        Sprite.prototype.getScaleY = function () {
            return this.scaleY;
        };
        /**
         * Resets the internal state of the drawing (if any)
         * @method reset
         */
        Sprite.prototype.reset = function () {
            // do nothing
        };
        /**
         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The 2D rendering context
         * @param x {number} The x coordinate of where to draw
         * @param y {number} The y coordinate of where to draw
         */
        Sprite.prototype.draw = function (ctx, x, y) {
            if (this.dirtyEffect) {
                this.applyEffects();
                this.dirtyEffect = false;
            }
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            if (this.flipHorizontal) {
                ctx.translate(this.swidth, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, this.sheight);
                ctx.scale(1, -1);
            }
            if (this.internalImage) {
                ctx.drawImage(this.internalImage, 0, 0, this.swidth, this.sheight, -(this.transformPoint.x * this.swidth) * this.scaleX, -(this.transformPoint.y * this.sheight) * this.scaleY, this.swidth * this.scaleX, this.sheight * this.scaleY);
            }
            ctx.restore();
        };
        /**
         * Produces a copy of the current sprite
         * @method clone
         * @returns Sprite
         */
        Sprite.prototype.clone = function () {
            var result = new Sprite(this.texture, this.sx, this.sy, this.swidth, this.sheight);
            result.scaleX = this.scaleX;
            result.scaleY = this.scaleY;
            result.rotation = this.rotation;
            result.flipHorizontal = this.flipHorizontal;
            result.flipVertical = this.flipVertical;
            this.effects.forEach(function (e) {
                result.addEffect(e);
            });
            return result;
        };
        return Sprite;
    })();
    ex.Sprite = Sprite;
})(ex || (ex = {}));
/// <reference path="Sprite.ts" />
var ex;
(function (ex) {
    /**
     * SpriteSheets are a useful mechanism for slicing up image resources into
     * separate sprites or for generating in game animations. Sprites are organized
     * in row major order in the SpriteSheet.
     * @class SpriteSheet
     * @constructor
     * @param image {Texture} The backing image texture to build the SpriteSheet
     * @param columns {number} The number of columns in the image texture
     * @param rows {number} The number of rows in the image texture
     * @param spWidth {number} The width of each individual sprite in pixels
     * @param spHeight {number} The height of each individual sprite in pixels
     */
    var SpriteSheet = (function () {
        function SpriteSheet(image, columns, rows, spWidth, spHeight) {
            this.image = image;
            this.columns = columns;
            this.rows = rows;
            this.sprites = [];
            this.internalImage = image.image;
            this.sprites = new Array(columns * rows);
            // TODO: Inspect actual image dimensions with preloading
            /*if(spWidth * columns > this.internalImage.naturalWidth){
               throw new Error("SpriteSheet specified is wider than image width");
            }
   
            if(spHeight * rows > this.internalImage.naturalHeight){
               throw new Error("SpriteSheet specified is higher than image height");
            }*/
            var i = 0;
            var j = 0;
            for (i = 0; i < rows; i++) {
                for (j = 0; j < columns; j++) {
                    this.sprites[j + i * columns] = new ex.Sprite(this.image, j * spWidth, i * spHeight, spWidth, spHeight);
                }
            }
        }
        /**
         * Create an animation from the this SpriteSheet by listing out the
         * sprite indices. Sprites are organized in row major order in the SpriteSheet.
         * @method getAnimationByIndices
         * @param engine {Engine} Reference to the current game Engine
         * @param indices {number[]} An array of sprite indices to use in the animation
         * @param speed {number} The number in milliseconds to display each frame in the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationByIndices = function (engine, indices, speed) {
            var _this = this;
            var images = indices.map(function (index) {
                return _this.sprites[index];
            });
            images = images.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, images, speed);
        };
        /**
         * Create an animation from the this SpriteSheet by specifing the range of
         * images with the beginning and ending index
         * @method getAnimationBetween
         * @param engine {Engine} Reference to the current game Engine
         * @param beginIndex {number} The index to start taking frames
         * @param endIndex {number} The index to stop taking frames
         * @param speed {number} The number in milliseconds to display each frame in the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {
            var images = this.sprites.slice(beginIndex, endIndex);
            images = images.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, images, speed);
        };
        /**
         * Treat the entire SpriteSheet as one animation, organizing the frames in
         * row major order.
         * @method getAnimationForAll
         * @param engine {Engine} Reference to the current game Engine
         * @param speed {number} The number in milliseconds to display each frame the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationForAll = function (engine, speed) {
            var sprites = this.sprites.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, sprites, speed);
        };
        /**
         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized
         * in row major order in the SpriteSheet.
         * @method getSprite
         * @param index {number} The index of the sprite
         * @returns Sprite
         */
        SpriteSheet.prototype.getSprite = function (index) {
            if (index >= 0 && index < this.sprites.length) {
                return this.sprites[index];
            }
        };
        return SpriteSheet;
    })();
    ex.SpriteSheet = SpriteSheet;
    /**
     * SpriteFonts are a used in conjunction with a {{#crossLink Label}}{{/crossLink}} to specify
     * a particular bitmap as a font.
     * @class SpriteFont
     * @extends SpriteSheet
     * @constructor
     * @param image {Texture} The backing image texture to build the SpriteFont
     * @param alphabet {string} A string representing all the charaters in the image, in row major order.
     * @param caseInsensitve {boolean} Indicate whether this font takes case into account
     * @param columns {number} The number of columns of characters in the image
     * @param rows {number} The number of rows of characters in the image
     * @param spWdith {number} The width of each character in pixels
     * @param spHeight {number} The height of each character in pixels
     */
    var SpriteFont = (function (_super) {
        __extends(SpriteFont, _super);
        function SpriteFont(image, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            _super.call(this, image, columns, rows, spWidth, spHeight);
            this.image = image;
            this.alphabet = alphabet;
            this.caseInsensitive = caseInsensitive;
            this.spriteLookup = {};
            this.colorLookup = {};
            this._currentColor = ex.Color.Black;
        }
        /**
         * Returns a dictionary that maps each character in the alphabet to the appropriate Sprite.
         * @method getTextSprites
         * @returns {Object}
         */
        SpriteFont.prototype.getTextSprites = function () {
            var lookup = {};
            for (var i = 0; i < this.alphabet.length; i++) {
                var char = this.alphabet[i];
                if (this.caseInsensitive) {
                    char = char.toLowerCase();
                }
                lookup[char] = this.sprites[i].clone();
            }
            return lookup;
        };
        return SpriteFont;
    })(SpriteSheet);
    ex.SpriteFont = SpriteFont;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="SpriteSheet.ts" />
var ex;
(function (ex) {
    var TileSprite = (function () {
        function TileSprite(spriteSheetKey, spriteId) {
            this.spriteSheetKey = spriteSheetKey;
            this.spriteId = spriteId;
        }
        return TileSprite;
    })();
    ex.TileSprite = TileSprite;
    /**
     * A light-weight object that occupies a space in a collision map. Generally
     * created by a CollisionMap.
     * @class Cell
     * @constructor
     * @param x {number}
     * @param y {number}
     * @param width {number}
     * @param height {number}
     * @param index {number}
     * @param [solid=false] {boolean}
     * @param [spriteId=-1] {number}
     */
    var Cell = (function () {
        function Cell(
            /**
             * Gets or sets x coordinate of the cell in world coordinates
             * @property x {number}
             */
            x, 
            /**
             * Gets or sets y coordinate of the cell in world coordinates
             * @property y {number}
             */
            y, 
            /**
             * Gets or sets the width of the cell
             * @property width {number}
             */
            width, 
            /**
             * Gets or sets the height of the cell
             * @property height {number}
             */
            height, 
            /**
             * The index of the cell in row major order
             * @property index {number}
             */
            index, 
            /**
             * Gets or sets whether this cell is solid
             * @property solid {boolean}
             */
            solid, 
            /**
             * The index of the sprite to use from the CollisionMap SpriteSheet, if -1 is specified nothing is drawn.
             * @property number {number}
             */
            sprites) {
            if (solid === void 0) { solid = false; }
            if (sprites === void 0) { sprites = []; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.index = index;
            this.solid = solid;
            this.sprites = sprites;
            this._bounds = new ex.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
        }
        /**
         * Returns the bounding box for this cell
         * @method getBounds
         * @returns BoundingBox
         */
        Cell.prototype.getBounds = function () {
            return this._bounds;
        };
        Cell.prototype.getCenter = function () {
            return new ex.Vector(this.x + this.width / 2, this.y + this.height / 2);
        };
        Cell.prototype.pushSprite = function (tileSprite) {
            this.sprites.push(tileSprite);
        };
        Cell.prototype.removeSprite = function (tileSprite) {
            var index = -1;
            if ((index = this.sprites.indexOf(tileSprite)) > -1) {
                this.sprites.splice(index, 1);
            }
        };
        Cell.prototype.clearSprites = function () {
            this.sprites.length = 0;
        };
        return Cell;
    })();
    ex.Cell = Cell;
    /**
     * The CollisionMap object provides a lightweight way to do large complex scenes with collision
     * without the overhead of actors.
     * @class CollisionMap
     * @constructor
     * @param x {number} The x coordinate to anchor the collision map's upper left corner (should not be changed once set)
     * @param y {number} The y coordinate to anchor the collision map's upper left corner (should not be changed once set)
     * @param cellWidth {number} The individual width of each cell (in pixels) (should not be changed once set)
     * @param cellHeight {number} The individual height of each cell (in pixels) (should not be changed once set)
     * @param rows {number} The number of rows in the collision map (should not be changed once set)
     * @param cols {number} The number of cols in the collision map (should not be changed once set)
     * @param spriteSheet {SpriteSheet} The spriteSheet to use for drawing
     */
    var TileMap = (function () {
        function TileMap(x, y, cellWidth, cellHeight, rows, cols) {
            var _this = this;
            this.x = x;
            this.y = y;
            this.cellWidth = cellWidth;
            this.cellHeight = cellHeight;
            this.rows = rows;
            this.cols = cols;
            this._collidingX = -1;
            this._collidingY = -1;
            this._onScreenXStart = 0;
            this._onScreenXEnd = 9999;
            this._onScreenYStart = 0;
            this._onScreenYEnd = 9999;
            this._spriteSheets = {};
            this.logger = ex.Logger.getInstance();
            this.data = [];
            this.data = new Array(rows * cols);
            for (var i = 0; i < cols; i++) {
                for (var j = 0; j < rows; j++) {
                    (function () {
                        var cd = new Cell(i * cellWidth + x, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                        _this.data[i + j * cols] = cd;
                    })();
                }
            }
        }
        TileMap.prototype.registerSpriteSheet = function (key, spriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        };
        /**
         * Returns the intesection vector that can be used to resolve collisions with actors. If there
         * is no collision null is returned.
         * @method collides
         * @param actor {Actor}
         * @returns Vector
         */
        TileMap.prototype.collides = function (actor) {
            var points = [];
            var width = actor.x + actor.getWidth();
            var height = actor.y + actor.getHeight();
            var actorBounds = actor.getBounds();
            var overlaps = [];
            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {
                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {
                    var cell = this.getCellByPoint(x, y);
                    if (cell && cell.solid) {
                        var overlap = actorBounds.collides(cell.getBounds());
                        var dir = actor.getCenter().minus(cell.getCenter());
                        if (overlap && overlap.dot(dir) > 0) {
                            overlaps.push(overlap);
                        }
                    }
                }
            }
            if (overlaps.length === 0) {
                return null;
            }
            // Return the smallest change other than zero
            var result = overlaps.reduce(function (accum, next) {
                var x = accum.x;
                var y = accum.y;
                if (Math.abs(accum.x) < Math.abs(next.x)) {
                    x = next.x;
                }
                if (Math.abs(accum.y) < Math.abs(next.y)) {
                    y = next.y;
                }
                return new ex.Vector(x, y);
            });
            return result;
        };
        /*
        public collidesActor(actor: Actor): boolean{
           
           var points: Point[] = [];
           var width = actor.x + actor.getWidth();
           var height = actor.y + actor.getHeight();
           for(var x = actor.x; x <= width; x += Math.min(actor.getWidth()/2,this.cellWidth/2)){
              for(var y = actor.y; y <= height; y += Math.min(actor.getHeight()/2, this.cellHeight/2)){
                 points.push(new Point(x,y))
              }
           }
  
           var result = points.some((p) => {
              return this.collidesPoint(p.x, p.y);
           });
  
           return result;
  
        }*/
        /*
        public collidesPoint(x: number, y: number): boolean{
           var x = Math.floor(x/this.cellWidth);// - Math.floor(this.x/this.cellWidth);
           var y = Math.floor(y/this.cellHeight);
  
  
           var cell = this.getCell(x, y);
           if(x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell){
              if(cell.solid){
                 this._collidingX = x;
                 this._collidingY = y;
              }
              return cell.solid;
           }
  
  
  
           
           return false;
        }*/
        /**
         * Returns the cell by index (row major order)
         * @method getCellByIndex
         * @param index {number}
         * @returns Cell
         */
        TileMap.prototype.getCellByIndex = function (index) {
            return this.data[index];
        };
        /**
         * Returns the cell by it's x and y coordinates
         * @method getCell
         * @param x {number}
         * @param y {number}
         * @returns Cell
         */
        TileMap.prototype.getCell = function (x, y) {
            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
                return null;
            }
            return this.data[x + y * this.cols];
        };
        /**
         * Returns the cell by testing a point in global coordinates,
         * returns null if no cell was found.
         * @method getCellByPoint
         * @param x {number}
         * @param y {number}
         * @returns Cell
         */
        TileMap.prototype.getCellByPoint = function (x, y) {
            var x = Math.floor((x - this.x) / this.cellWidth); // - Math.floor(this.x/this.cellWidth);
            var y = Math.floor((y - this.y) / this.cellHeight);
            var cell = this.getCell(x, y);
            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
                return cell;
            }
            return null;
        };
        TileMap.prototype.update = function (engine, delta) {
            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new ex.Point(0, 0));
            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new ex.Point(engine.width, engine.height));
            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);
            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);
            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
        };
        /**
         * Draws the collision map to the screen. Called by the Scene.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         * @param delta {number} The number of milliseconds since the last draw
         */
        TileMap.prototype.draw = function (ctx, delta) {
            var _this = this;
            ctx.save();
            ctx.translate(this.x, this.y);
            for (var x = this._onScreenXStart; x < Math.min(this._onScreenXEnd, this.cols); x++) {
                for (var y = this._onScreenYStart; y < Math.min(this._onScreenYEnd, this.rows); y++) {
                    this.getCell(x, y).sprites.filter(function (s) {
                        return s.spriteId > -1;
                    }).forEach(function (ts) {
                        var ss = _this._spriteSheets[ts.spriteSheetKey];
                        if (ss) {
                            var sprite = ss.getSprite(ts.spriteId);
                            if (sprite) {
                                sprite.draw(ctx, x * _this.cellWidth, y * _this.cellHeight);
                            }
                            else {
                                _this.logger.warn("Sprite does not exist for id", ts.spriteId, "in sprite sheet", ts.spriteSheetKey, sprite, ss);
                            }
                        }
                        else {
                            _this.logger.warn("Sprite sheet", ts.spriteSheetKey, "does not exist", ss);
                        }
                    });
                }
            }
            ctx.restore();
        };
        /**
         * Draws all the collision map's debug info. Called by the Scene.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         */
        TileMap.prototype.debugDraw = function (ctx) {
            var width = this.cols * this.cellWidth;
            var height = this.rows * this.cellHeight;
            ctx.save();
            ctx.strokeStyle = ex.Color.Red.toString();
            for (var x = 0; x < this.cols + 1; x++) {
                ctx.beginPath();
                ctx.moveTo(this.x + x * this.cellWidth, this.y);
                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
                ctx.stroke();
            }
            for (var y = 0; y < this.rows + 1; y++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + y * this.cellHeight);
                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
                ctx.stroke();
            }
            var solid = ex.Color.Red.clone();
            solid.a = .3;
            this.data.filter(function (cell) {
                return cell.solid;
            }).forEach(function (cell) {
                ctx.fillStyle = solid.toString();
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            });
            if (this._collidingY > -1 && this._collidingX > -1) {
                ctx.fillStyle = ex.Color.Cyan.toString();
                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
            }
            ctx.restore();
        };
        return TileMap;
    })();
    ex.TileMap = TileMap;
})(ex || (ex = {}));
/// <reference path="../Algebra.ts" />
var ex;
(function (ex) {
    (function (CollisionStrategy) {
        CollisionStrategy[CollisionStrategy["Naive"] = 0] = "Naive";
        CollisionStrategy[CollisionStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
        CollisionStrategy[CollisionStrategy["SeparatingAxis"] = 2] = "SeparatingAxis";
    })(ex.CollisionStrategy || (ex.CollisionStrategy = {}));
    var CollisionStrategy = ex.CollisionStrategy;
    /**
     * Axis Aligned collision primitive for Excalibur.
     * @class BoundingBox
     * @constructor
     * @param left {number} x coordinate of the left edge
     * @param top {number} y coordinate of the top edge
     * @param right {number} x coordinate of the right edge
     * @param bottom {number} y coordinate of the bottom edge
     */
    var BoundingBox = (function () {
        function BoundingBox(left, top, right, bottom) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        /**
         * Returns the calculated width of the bounding box
         * @method getWidth
         * @returns number
         */
        BoundingBox.prototype.getWidth = function () {
            return this.right - this.left;
        };
        /**
         * Returns the calculated height of the bounding box
         * @method getHeight
         * @returns number
         */
        BoundingBox.prototype.getHeight = function () {
            return this.bottom - this.top;
        };
        /**
         * Returns the perimeter of the bounding box
         * @method getPerimeter
         * @returns number
         */
        BoundingBox.prototype.getPerimeter = function () {
            var wx = this.getWidth();
            var wy = this.getHeight();
            return 2 * (wx + wy);
        };
        BoundingBox.prototype.contains = function (val) {
            if (val instanceof ex.Point) {
                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);
            }
            else if (val instanceof BoundingBox) {
                if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {
                    return true;
                }
                return false;
            }
            return false;
        };
        /**
         * Combines this bounding box and another together returning a new bounding box
         * @method combine
         * @param other {BoundingBox} The bounding box to combine
         * @returns BoundingBox
         */
        BoundingBox.prototype.combine = function (other) {
            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
            return compositeBB;
        };
        /**
         * Test wether this bounding box collides with another returning,
         * the intersection vector that can be used to resovle the collision. If there
         * is no collision null is returned.
         * @method collides
         * @param collidable {ICollidable} Other collidable to test
         * @returns Vector
         */
        BoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof BoundingBox) {
                var other = collidable;
                var totalBoundingBox = this.combine(other);
                // If the total bounding box is less than the sum of the 2 bounds then there is collision
                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() && totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {
                    // collision
                    var overlapX = 0;
                    if (this.right >= other.left && this.right <= other.right) {
                        overlapX = other.left - this.right;
                    }
                    else {
                        overlapX = other.right - this.left;
                    }
                    var overlapY = 0;
                    if (this.top <= other.bottom && this.top >= other.top) {
                        overlapY = other.bottom - this.top;
                    }
                    else {
                        overlapY = other.top - this.bottom;
                    }
                    if (Math.abs(overlapX) < Math.abs(overlapY)) {
                        return new ex.Vector(overlapX, 0);
                    }
                    else {
                        return new ex.Vector(0, overlapY);
                    }
                }
                else {
                    return null;
                }
            }
            return null;
        };
        BoundingBox.prototype.debugDraw = function (ctx) {
            ctx.lineWidth = 2;
            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());
        };
        return BoundingBox;
    })();
    ex.BoundingBox = BoundingBox;
    var SATBoundingBox = (function () {
        function SATBoundingBox(points) {
            this._points = points.map(function (p) { return p.toVector(); });
        }
        SATBoundingBox.prototype.getSides = function () {
            var lines = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                lines.push(new ex.Line(this._points[i], this._points[(i + 1) % len]));
            }
            return lines;
        };
        SATBoundingBox.prototype.getAxes = function () {
            var axes = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                axes.push(this._points[i].minus(this._points[(i + 1) % len]).normal());
            }
            return axes;
        };
        SATBoundingBox.prototype.project = function (axis) {
            var scalars = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                scalars.push(this._points[i].dot(axis));
            }
            return new ex.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /**
         * Returns the calculated width of the bounding box, by generating an axis aligned box around the current
         * @method getWidth
         * @returns number
         */
        SATBoundingBox.prototype.getWidth = function () {
            var left = this._points.reduce(function (accum, p, i, arr) {
                return Math.min(accum, p.x);
            }, Infinity);
            var right = this._points.reduce(function (accum, p, i, arr) {
                return Math.max(accum, p.x);
            }, -Infinity);
            return right - left;
        };
        /**
         * Returns the calculated height of the bounding box, by generating an axis aligned box around the current
         * @method getHeight
         * @returns number
         */
        SATBoundingBox.prototype.getHeight = function () {
            var top = this._points.reduce(function (accum, p, i, arr) {
                return Math.min(accum, p.y);
            }, Infinity);
            var bottom = this._points.reduce(function (accum, p, i, arr) {
                return Math.max(accum, p.y);
            }, -Infinity);
            return top - bottom;
        };
        /**
         * Tests wether a point is contained within the bounding box, using the PIP algorithm
         * http://en.wikipedia.org/wiki/Point_in_polygon
         * @method contains
         * @param p {Point} The point to test
         * @returns boolean
         */
        SATBoundingBox.prototype.contains = function (p) {
            // Always cast to the right, as long as we cast in a consitent fixed direction we
            // will be fine
            var testRay = new ex.Ray(p, new ex.Vector(1, 0));
            var intersectCount = this.getSides().reduce(function (accum, side, i, arr) {
                if (testRay.intersect(side) >= 0) {
                    return accum + 1;
                }
                return accum;
            }, 0);
            if (intersectCount % 2 === 0) {
                return false;
            }
            return true;
        };
        SATBoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof SATBoundingBox) {
                var other = collidable;
                var axes = this.getAxes();
                axes = other.getAxes().concat(axes);
                var minOverlap = 99999;
                var minAxis = null;
                for (var i = 0; i < axes.length; i++) {
                    var proj1 = this.project(axes[i]);
                    var proj2 = other.project(axes[i]);
                    var overlap = proj1.getOverlap(proj2);
                    if (overlap === 0) {
                        return null;
                    }
                    else {
                        if (overlap <= minOverlap) {
                            minOverlap = overlap;
                            minAxis = axes[i];
                        }
                    }
                }
                if (minAxis) {
                    return minAxis.normalize().scale(minOverlap);
                }
                else {
                    return null;
                }
            }
            return null;
        };
        SATBoundingBox.prototype.debugDraw = function (ctx) {
            ctx.beginPath();
            ctx.lineWidth = 2;
            // Iterate through the supplied points and contruct a 'polygon'
            var firstPoint = this._points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this._points.forEach(function (point) {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            ctx.strokeStyle = ex.Color.Blue.toString();
            ctx.stroke();
        };
        return SATBoundingBox;
    })();
    ex.SATBoundingBox = SATBoundingBox;
})(ex || (ex = {}));
/// <reference path="Events.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur base class
     * @class Class
     * @constructor
     */
    var Class = (function () {
        function Class() {
            this.eventDispatcher = new ex.EventDispatcher(this);
        }
        /**
         * Add an event listener. You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method addEventListener
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Class.prototype.addEventListener = function (eventName, handler) {
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * Removes an event listener. If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified just that handler will be removed.
         *
         * @method removeEventListener
         * @param eventName {string} Name of the event to listen for
         * @param [handler=undefined] {event=>void} Event handler for the thrown event
         */
        Class.prototype.removeEventListener = function (eventName, handler) {
            this.eventDispatcher.unsubscribe(eventName, handler);
        };
        /**
         * Alias for "addEventListener". You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method on
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Class.prototype.on = function (eventName, handler) {
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * Alias for "removeEventListener". If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified only that handler will be removed.
         *
         * @method off
         * @param eventName {string} Name of the event to listen for
         * @param [handler=undefined] {event=>void} Event handler for the thrown event
         */
        Class.prototype.off = function (eventName, handler) {
            this.eventDispatcher.unsubscribe(eventName, handler);
        };
        /**
         * You may wish to extend native Excalibur functionality. Any method on
         * actor may be extended to support additional functionaliy. In the
         * example below we create a new type called "MyActor"
         * <br/><b>Example</b><pre>var MyActor = Actor.extend({
     constructor : function(){
        this.newprop = 'something';
        Actor.apply(this, arguments);
     },
     update : function(engine, delta){
        // Implement custom update
  
           // Call super constructor update
           Actor.prototype.update.call(this, engine, delta);
           console.log("Something cool!");
     }
  });
  var myActor = new MyActor(100, 100, 100, 100, Color.Azure);</pre>
         * @method extend
         * @static
         * @param methods {any}
         */
        Class.extend = function (methods) {
            var parent = this;
            var child;
            if (methods && methods.hasOwnProperty('constructor')) {
                child = methods.constructor;
            }
            else {
                child = function () {
                    return parent.apply(this, arguments);
                };
            }
            // Using constructor allows JS to lazily instantiate super classes
            var Super = function () {
                this.constructor = child;
            };
            Super.prototype = parent.prototype;
            child.prototype = new Super;
            if (methods) {
                for (var prop in methods) {
                    if (methods.hasOwnProperty(prop)) {
                        child.prototype[prop] = methods[prop];
                    }
                }
            }
            // Make subclasses extendable
            child.extend = Class.extend;
            return child;
        };
        return Class;
    })();
    ex.Class = Class;
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Timer = (function () {
        /**
         * The Excalibur timer hooks into the internal timer and fires callbacks, after a certain interval, optionally repeating.
         *
         * @class Timer
         * @constructor
         * @param callback {callback} The callback to be fired after the interval is complete.
         * @param [repeats=false] {boolean} Indicates whether this call back should be fired only once, or repeat after every interval as completed.
         */
        function Timer(fcn, interval, repeats) {
            this.id = 0;
            this.interval = 10;
            this.fcn = function () {
            };
            this.repeats = false;
            this.elapsedTime = 0;
            this._totalTimeAlive = 0;
            this.complete = false;
            this.scene = null;
            this.id = Timer.id++;
            this.interval = interval || this.interval;
            this.fcn = fcn || this.fcn;
            this.repeats = repeats || this.repeats;
        }
        /**
         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
         * @method update
         * @param delta {number} Number of elapsed milliseconds since the last update.
         */
        Timer.prototype.update = function (delta) {
            this._totalTimeAlive += delta;
            this.elapsedTime += delta;
            if (this.elapsedTime > this.interval) {
                this.fcn.call(this);
                if (this.repeats) {
                    this.elapsedTime = 0;
                }
                else {
                    this.complete = true;
                }
            }
        };
        Timer.prototype.getTimeRunning = function () {
            return this._totalTimeAlive;
        };
        /**
         * Cancels the timer, preventing any further executions.
         * @method cancel
         */
        Timer.prototype.cancel = function () {
            if (this.scene) {
                this.scene.cancelTimer(this);
            }
        };
        Timer.id = 0;
        return Timer;
    })();
    ex.Timer = Timer;
})(ex || (ex = {}));
/// <reference path="../Actor.ts"/>
/// <reference path="Side.ts"/>
/// <reference path="ICollisionResolver.ts"/> 
var ex;
(function (ex) {
    var NaiveCollisionResolver = (function () {
        function NaiveCollisionResolver() {
        }
        NaiveCollisionResolver.prototype.register = function (target) {
            // pass
        };
        NaiveCollisionResolver.prototype.remove = function (tartet) {
            // pass
        };
        NaiveCollisionResolver.prototype.evaluate = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== 0 /* PreventCollision */;
            });
            var actor1;
            var actor2;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor1 = potentialColliders[j];
                for (var i = j + 1; i < l; i++) {
                    actor2 = potentialColliders[i];
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor1.collides(actor2)) {
                        var side = actor1.getSideFromIntersect(minimumTranslationVector);
                        var collisionPair = new ex.CollisionPair(actor1, actor2, minimumTranslationVector, side);
                        if (!collisionPairs.some(function (cp) {
                            return cp.equals(collisionPair);
                        })) {
                            collisionPairs.push(collisionPair);
                        }
                    }
                }
            }
            collisionPairs.forEach(function (p) { return p.evaluate(); });
            return collisionPairs;
        };
        NaiveCollisionResolver.prototype.update = function (targets) {
            return 0;
        };
        NaiveCollisionResolver.prototype.debugDraw = function (ctx, delta) {
        };
        return NaiveCollisionResolver;
    })();
    ex.NaiveCollisionResolver = NaiveCollisionResolver;
})(ex || (ex = {}));
/// <reference path="BoundingBox.ts"/>
var ex;
(function (ex) {
    var TreeNode = (function () {
        function TreeNode(parent) {
            this.parent = parent;
            this.parent = parent || null;
            this.actor = null;
            this.bounds = new ex.BoundingBox();
            this.left = null;
            this.right = null;
            this.height = 0;
        }
        TreeNode.prototype.isLeaf = function () {
            return (!this.left && !this.right);
        };
        return TreeNode;
    })();
    ex.TreeNode = TreeNode;
    var DynamicTree = (function () {
        function DynamicTree() {
            this.root = null;
            this.nodes = {};
        }
        DynamicTree.prototype.insert = function (leaf) {
            // If there are no nodes in the tree, make this the root leaf
            if (this.root === null) {
                this.root = leaf;
                this.root.parent = null;
                return;
            }
            // Search the tree for a node that is not a leaf and find the best place to insert
            var leafAABB = leaf.bounds;
            var currentRoot = this.root;
            while (!currentRoot.isLeaf()) {
                var left = currentRoot.left;
                var right = currentRoot.right;
                var area = currentRoot.bounds.getPerimeter();
                var combinedAABB = currentRoot.bounds.combine(leafAABB);
                var combinedArea = combinedAABB.getPerimeter();
                // Calculate cost heuristic for creating a new parent and leaf
                var cost = 2 * combinedArea;
                // Minimum cost of pushing the leaf down the tree
                var inheritanceCost = 2 * (combinedArea - area);
                // Cost of descending
                var leftCost = 0;
                var leftCombined = leafAABB.combine(left.bounds);
                var newArea;
                var oldArea;
                if (left.isLeaf()) {
                    leftCost = leftCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = left.bounds.getPerimeter();
                    newArea = leftCombined.getPerimeter();
                    leftCost = (newArea - oldArea) + inheritanceCost;
                }
                var rightCost = 0;
                var rightCombined = leafAABB.combine(right.bounds);
                if (right.isLeaf()) {
                    rightCost = rightCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = right.bounds.getPerimeter();
                    newArea = rightCombined.getPerimeter();
                    rightCost = (newArea - oldArea) + inheritanceCost;
                }
                // cost is acceptable
                if (cost < leftCost && cost < rightCost) {
                    break;
                }
                // Descend to the depths
                if (leftCost < rightCost) {
                    currentRoot = left;
                }
                else {
                    currentRoot = right;
                }
            }
            // Create the new parent node and insert into the tree
            var oldParent = currentRoot.parent;
            var newParent = new TreeNode(oldParent);
            newParent.bounds = leafAABB.combine(currentRoot.bounds);
            newParent.height = currentRoot.height + 1;
            if (oldParent !== null) {
                // The sibling node was not the root
                if (oldParent.left === currentRoot) {
                    oldParent.left = newParent;
                }
                else {
                    oldParent.right = newParent;
                }
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling node was the root
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
                this.root = newParent;
            }
            // Walk up the tree fixing heights and AABBs
            var currentNode = leaf.parent;
            while (currentNode) {
                currentNode = this.balance(currentNode);
                if (!currentNode.left) {
                    throw new Error("Parent of current leaf cannot have a null left child" + currentNode);
                }
                if (!currentNode.right) {
                    throw new Error("Parent of current leaf cannot have a null right child" + currentNode);
                }
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode = currentNode.parent;
            }
        };
        DynamicTree.prototype.remove = function (leaf) {
            if (leaf === this.root) {
                this.root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.left === leaf) {
                sibling = parent.right;
            }
            else {
                sibling = parent.left;
            }
            if (grandParent) {
                if (grandParent.left === parent) {
                    grandParent.left = sibling;
                }
                else {
                    grandParent.right = sibling;
                }
                sibling.parent = grandParent;
                var currentNode = grandParent;
                while (currentNode) {
                    currentNode = this.balance(currentNode);
                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                    currentNode = currentNode.parent;
                }
            }
            else {
                this.root = sibling;
                sibling.parent = null;
            }
        };
        DynamicTree.prototype.registerActor = function (actor) {
            var node = new TreeNode();
            node.actor = actor;
            node.bounds = actor.getBounds();
            node.bounds.left -= 2;
            node.bounds.top -= 2;
            node.bounds.right += 2;
            node.bounds.bottom += 2;
            this.nodes[actor.id] = node;
            this.insert(node);
        };
        DynamicTree.prototype.updateActor = function (actor) {
            var node = this.nodes[actor.id];
            if (!node)
                return;
            var b = actor.getBounds();
            if (node.bounds.contains(b)) {
                return false;
            }
            this.remove(node);
            b.left -= 5;
            b.top -= 5;
            b.right += 5;
            b.bottom += 5;
            var multdx = actor.dx * 2;
            var multdy = actor.dy * 2;
            if (multdx < 0) {
                b.left += multdx;
            }
            else {
                b.right += multdx;
            }
            if (multdy < 0) {
                b.top += multdy;
            }
            else {
                b.bottom += multdy;
            }
            node.bounds = b;
            this.insert(node);
            return true;
        };
        DynamicTree.prototype.removeActor = function (actor) {
            var node = this.nodes[actor.id];
            if (!node)
                return;
            this.remove(node);
            this.nodes[actor.id] = null;
            delete this.nodes[actor.id];
        };
        DynamicTree.prototype.balance = function (node) {
            if (node === null) {
                throw new Error("Cannot balance at null node");
            }
            if (node.isLeaf() || node.height < 2) {
                return node;
            }
            var left = node.left;
            var right = node.right;
            var a = node;
            var b = left;
            var c = right;
            var d = left.left;
            var e = left.right;
            var f = right.left;
            var g = right.right;
            var balance = c.height - b.height;
            // Rotate c node up
            if (balance > 1) {
                // Swap the right node with it's parent
                c.left = a;
                c.parent = a.parent;
                a.parent = c;
                // The original node's old parent should point to the right node
                // this is mega confusing
                if (c.parent) {
                    if (c.parent.left === a) {
                        c.parent.left = c;
                    }
                    else {
                        c.parent.right = c;
                    }
                }
                else {
                    this.root = c;
                }
                // Rotate
                if (f.height > g.height) {
                    c.right = f;
                    a.right = g;
                    g.parent = a;
                    a.bounds = b.bounds.combine(g.bounds);
                    c.bounds = a.bounds.combine(f.bounds);
                    a.height = 1 + Math.max(b.height, g.height);
                    c.height = 1 + Math.max(a.height, f.height);
                }
                else {
                    c.right = g;
                    a.right = f;
                    f.parent = a;
                    a.bounds = b.bounds.combine(f.bounds);
                    c.bounds = a.bounds.combine(g.bounds);
                    a.height = 1 + Math.max(b.height, f.height);
                    c.height = 1 + Math.max(a.height, g.height);
                }
                return c;
            }
            // Rotate left node up
            if (balance < -1) {
                // swap
                b.left = a;
                b.parent = a.parent;
                a.parent = b;
                // node's old parent should point to b
                if (b.parent) {
                    if (b.parent.left === a) {
                        b.parent.left = b;
                    }
                    else {
                        if (b.parent.right !== a)
                            throw "Error rotating Dynamic Tree";
                        b.parent.right = b;
                    }
                }
                else {
                    this.root = b;
                }
                // rotate
                if (d.height > e.height) {
                    b.right = d;
                    a.left = e;
                    e.parent = a;
                    a.bounds = c.bounds.combine(e.bounds);
                    b.bounds = a.bounds.combine(d.bounds);
                    a.height = 1 + Math.max(c.height, e.height);
                    b.height = 1 + Math.max(a.height, d.height);
                }
                else {
                    b.right = e;
                    a.left = d;
                    d.parent = a;
                    a.bounds = c.bounds.combine(d.bounds);
                    b.bounds = a.bounds.combine(e.bounds);
                    a.height = 1 + Math.max(c.height, d.height);
                    b.height = 1 + Math.max(a.height, e.height);
                }
                return b;
            }
            return node;
        };
        DynamicTree.prototype.getHeight = function () {
            if (this.root === null) {
                return 0;
            }
            return this.root.height;
        };
        DynamicTree.prototype.query = function (actor, callback) {
            var bounds = actor.getBounds();
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.collides(bounds)) {
                    if (currentNode.isLeaf() && currentNode.actor !== actor) {
                        if (callback.call(actor, currentNode.actor)) {
                            return true;
                        }
                    }
                    else {
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                else {
                    return null;
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.rayCast = function (ray, max) {
            // todo implement
            return null;
        };
        DynamicTree.prototype.getNodes = function () {
            var helper = function (currentNode) {
                if (currentNode) {
                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
                }
                else {
                    return [];
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.debugDraw = function (ctx, delta) {
            // draw all the nodes in the Dynamic Tree
            var helper = function (currentNode) {
                if (currentNode) {
                    if (currentNode.isLeaf()) {
                        ctx.strokeStyle = 'green';
                    }
                    else {
                        ctx.strokeStyle = 'white';
                    }
                    currentNode.bounds.debugDraw(ctx);
                    if (currentNode.left)
                        helper(currentNode.left);
                    if (currentNode.right)
                        helper(currentNode.right);
                }
            };
            helper(this.root);
        };
        return DynamicTree;
    })();
    ex.DynamicTree = DynamicTree;
})(ex || (ex = {}));
/// <reference path="ICollisionResolver.ts"/>
/// <reference path="DynamicTree.ts"/>
var ex;
(function (ex) {
    var DynamicTreeCollisionResolver = (function () {
        function DynamicTreeCollisionResolver() {
            this._dynamicCollisionTree = new ex.DynamicTree();
        }
        DynamicTreeCollisionResolver.prototype.register = function (target) {
            this._dynamicCollisionTree.registerActor(target);
        };
        DynamicTreeCollisionResolver.prototype.remove = function (target) {
            this._dynamicCollisionTree.removeActor(target);
        };
        DynamicTreeCollisionResolver.prototype.evaluate = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== 0 /* PreventCollision */;
            });
            var actor;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor = potentialColliders[j];
                this._dynamicCollisionTree.query(actor, function (other) {
                    if (other.collisionType === 0 /* PreventCollision */ || other.isKilled())
                        return false;
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor.collides(other)) {
                        var side = actor.getSideFromIntersect(minimumTranslationVector);
                        var collisionPair = new ex.CollisionPair(actor, other, minimumTranslationVector, side);
                        if (!collisionPairs.some(function (cp) {
                            return cp.equals(collisionPair);
                        })) {
                            collisionPairs.push(collisionPair);
                        }
                        return true;
                    }
                    return false;
                });
            }
            collisionPairs.forEach(function (p) { return p.evaluate(); });
            return collisionPairs;
        };
        DynamicTreeCollisionResolver.prototype.update = function (targets) {
            var _this = this;
            var updated = 0;
            targets.forEach(function (a) {
                if (_this._dynamicCollisionTree.updateActor(a)) {
                    updated++;
                }
            });
            return updated;
        };
        DynamicTreeCollisionResolver.prototype.debugDraw = function (ctx, delta) {
            this._dynamicCollisionTree.debugDraw(ctx, delta);
        };
        return DynamicTreeCollisionResolver;
    })();
    ex.DynamicTreeCollisionResolver = DynamicTreeCollisionResolver;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Collision pairs are used internally by Excalibur to resolve collision between actors. The
     * Pair prevents collisions from being evaluated more than one time
     * @class CollisionPair
     * @constructor
     * @param left {Actor} The first actor in the collision pair
     * @param right {Actor} The second actor in the collision pair
     * @param intersect {Vector} The minimum translation vector to separate the actors from the perspective of the left actor
     * @param side {Side} The side on which the collision occured from the perspective of the left actor
     */
    var CollisionPair = (function () {
        function CollisionPair(left, right, intersect, side) {
            this.left = left;
            this.right = right;
            this.intersect = intersect;
            this.side = side;
        }
        /**
         * Determines if this collision pair and another are equivalent.
         * @method equals
         * @param collisionPair {CollisionPair}
         * @returns boolean
         */
        CollisionPair.prototype.equals = function (collisionPair) {
            return (collisionPair.left === this.left && collisionPair.right === this.right) || (collisionPair.right === this.left && collisionPair.left === this.right);
        };
        /**
         * Evaluates the collision pair, performing collision resolution and event publishing appropriate to each collision type.
         * @method evaluate
         */
        CollisionPair.prototype.evaluate = function () {
            // todo fire collision events on left and right actor
            // todo resolve collisions                  
            // Publish collision events on both participants
            this.left.eventDispatcher.publish('collision', new ex.CollisionEvent(this.left, this.right, this.side, this.intersect));
            this.right.eventDispatcher.publish('collision', new ex.CollisionEvent(this.right, this.left, ex.Util.getOppositeSide(this.side), this.intersect.scale(-1.0)));
            // If the actor is active push the actor out if its not passive
            var leftSide = this.side;
            if ((this.left.collisionType === 2 /* Active */ || this.left.collisionType === 3 /* Elastic */) && this.right.collisionType !== 1 /* Passive */) {
                this.left.y += this.intersect.y;
                this.left.x += this.intersect.x;
                // Naive elastic bounce
                if (this.left.collisionType === 3 /* Elastic */) {
                    if (leftSide === 3 /* Left */) {
                        this.left.dx = Math.abs(this.left.dx);
                    }
                    else if (leftSide === 4 /* Right */) {
                        this.left.dx = -Math.abs(this.left.dx);
                    }
                    else if (leftSide === 1 /* Top */) {
                        this.left.dy = Math.abs(this.left.dy);
                    }
                    else if (leftSide === 2 /* Bottom */) {
                        this.left.dy = -Math.abs(this.left.dy);
                    }
                }
            }
            var rightSide = ex.Util.getOppositeSide(this.side);
            var rightIntersect = this.intersect.scale(-1.0);
            if ((this.right.collisionType === 2 /* Active */ || this.right.collisionType === 3 /* Elastic */) && this.left.collisionType !== 1 /* Passive */) {
                this.right.y += rightIntersect.y;
                this.right.x += rightIntersect.x;
                // Naive elastic bounce
                if (this.right.collisionType === 3 /* Elastic */) {
                    if (rightSide === 3 /* Left */) {
                        this.right.dx = Math.abs(this.right.dx);
                    }
                    else if (rightSide === 4 /* Right */) {
                        this.right.dx = -Math.abs(this.right.dx);
                    }
                    else if (rightSide === 1 /* Top */) {
                        this.right.dy = Math.abs(this.right.dy);
                    }
                    else if (rightSide === 2 /* Bottom */) {
                        this.right.dy = -Math.abs(this.right.dy);
                    }
                }
            }
        };
        return CollisionPair;
    })();
    ex.CollisionPair = CollisionPair;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Algebra.ts" />
var ex;
(function (ex) {
    /**
    * A base implementation of a camera. This class is meant to be extended.
    * @class Camera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var BaseCamera = (function () {
        function BaseCamera() {
            this.focus = new ex.Point(0, 0);
            this.lerp = false;
            this._cameraMoving = false;
            this._currentLerpTime = 0;
            this._lerpDuration = 1 * 1000; // 5 seconds
            this._totalLerpTime = 0;
            this._lerpStart = null;
            this._lerpEnd = null;
            //camera effects
            this.isShaking = false;
            this.shakeMagnitudeX = 0;
            this.shakeMagnitudeY = 0;
            this.shakeDuration = 0;
            this.elapsedShakeTime = 0;
            this.isZooming = false;
            this.currentZoomScale = 1;
            this.maxZoomScale = 1;
            this.zoomDuration = 0;
            this.elapsedZoomTime = 0;
            this.zoomIncrement = 0.01;
        }
        BaseCamera.prototype.easeInOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime * currentTime + startValue;
            currentTime -= 2;
            return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
        };
        /**
        * Sets the {{#crossLink Actor}}{{/crossLink}} to follow with the camera
        * @method setActorToFollow
        * @param actor {Actor} The actor to follow
        */
        BaseCamera.prototype.setActorToFollow = function (actor) {
            this.follow = actor;
        };
        /**
        * Returns the focal point of the camera
        * @method getFocus
        * @returns Point
        */
        BaseCamera.prototype.getFocus = function () {
            return this.focus;
        };
        /**
        * Sets the focal point of the camera. This value can only be set if there is no actor to be followed.
        * @method setFocus
        * @param x {number} The x coordinate of the focal point
        * @param y {number} The y coordinate of the focal point
        */
        BaseCamera.prototype.setFocus = function (x, y) {
            if (!this.follow && !this.lerp) {
                this.focus.x = x;
                this.focus.y = y;
            }
            if (this.lerp) {
                this._lerpStart = this.focus.clone();
                this._lerpEnd = new ex.Point(x, y);
                this._currentLerpTime = 0;
                this._cameraMoving = true;
            }
        };
        /**
        * Sets the camera to shake at the specified magnitudes for the specified duration
        * @method shake
        * @param magnitudeX {number} the x magnitude of the shake
        * @param magnitudeY {number} the y magnitude of the shake
        * @param duration {number} the duration of the shake
        */
        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {
            this.isShaking = true;
            this.shakeMagnitudeX = magnitudeX;
            this.shakeMagnitudeY = magnitudeY;
            this.shakeDuration = duration;
        };
        /**
        * Zooms the camera in or out by the specified scale over the specified duration.
        * If no duration is specified, it will zoom by a set amount until the scale is reached.
        * @method zoom
        * @param scale {number} the scale of the zoom
        * @param [duration] {number} the duration of the zoom
        */
        BaseCamera.prototype.zoom = function (scale, duration) {
            this.isZooming = true;
            this.maxZoomScale = scale;
            this.zoomDuration = duration | 0;
            if (duration) {
                this.zoomIncrement = Math.abs(this.maxZoomScale - this.currentZoomScale) / duration * 1000;
            }
            if (this.maxZoomScale < 1) {
                if (duration) {
                    this.zoomIncrement = -1 * this.zoomIncrement;
                }
                else {
                    this.isZooming = false;
                    this.setCurrentZoomScale(this.maxZoomScale);
                }
            }
            else {
                if (!duration) {
                    this.isZooming = false;
                    this.setCurrentZoomScale(this.maxZoomScale);
                }
            }
            // console.log("zoom increment: " + this.zoomIncrement);
        };
        /**
        * gets the current zoom scale
        * @method getZoom
        * @returns {Number} the current zoom scale
        */
        BaseCamera.prototype.getZoom = function () {
            return this.currentZoomScale;
        };
        BaseCamera.prototype.setCurrentZoomScale = function (zoomScale) {
            this.currentZoomScale = zoomScale;
        };
        /**
        * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
        * @method update
        * @param delta {number} The number of milliseconds since the last update
        */
        BaseCamera.prototype.update = function (ctx, delta) {
            var focus = this.getFocus();
            var xShake = 0;
            var yShake = 0;
            var canvasWidth = ctx.canvas.width;
            var canvasHeight = ctx.canvas.height;
            var newCanvasWidth = canvasWidth * this.getZoom();
            var newCanvasHeight = canvasHeight * this.getZoom();
            if (this.lerp) {
                if (this._currentLerpTime < this._lerpDuration && this._cameraMoving) {
                    if (this._lerpEnd.x < this._lerpStart.x) {
                        this.focus.x = this._lerpStart.x - (this.easeInOutCubic(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                    }
                    else {
                        this.focus.x = this.easeInOutCubic(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                    }
                    if (this._lerpEnd.y < this._lerpStart.y) {
                        this.focus.y = this._lerpStart.y - (this.easeInOutCubic(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                    }
                    else {
                        this.focus.y = this.easeInOutCubic(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                    }
                    this._currentLerpTime += delta;
                }
                else {
                    this._lerpStart = null;
                    this._lerpEnd = null;
                    this._currentLerpTime = 0;
                    this._cameraMoving = false;
                }
            }
            if (this.isDoneShaking()) {
                this.isShaking = false;
                this.elapsedShakeTime = 0;
                this.shakeMagnitudeX = 0;
                this.shakeMagnitudeY = 0;
                this.shakeDuration = 0;
            }
            else {
                this.elapsedShakeTime += delta;
                xShake = (Math.random() * this.shakeMagnitudeX | 0) + 1;
                yShake = (Math.random() * this.shakeMagnitudeY | 0) + 1;
            }
            ctx.translate(-focus.x + xShake + (newCanvasWidth / 2), -focus.y + yShake + (newCanvasHeight / 2));
            if (this.isDoneZooming()) {
                this.isZooming = false;
                this.elapsedZoomTime = 0;
                this.zoomDuration = 0;
                this.setCurrentZoomScale(this.maxZoomScale);
            }
            else {
                this.elapsedZoomTime += delta;
                this.setCurrentZoomScale(this.getZoom() + this.zoomIncrement * delta / 1000);
            }
            ctx.scale(this.getZoom(), this.getZoom());
        };
        BaseCamera.prototype.debugDraw = function (ctx) {
            var focus = this.getFocus();
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        BaseCamera.prototype.isDoneShaking = function () {
            return !(this.isShaking) || (this.elapsedShakeTime >= this.shakeDuration);
        };
        BaseCamera.prototype.isDoneZooming = function () {
            if (this.zoomDuration != 0) {
                return (this.elapsedZoomTime >= this.zoomDuration);
            }
            else {
                if (this.maxZoomScale < 1) {
                    return (this.currentZoomScale <= this.maxZoomScale);
                }
                else {
                    return (this.currentZoomScale >= this.maxZoomScale);
                }
            }
        };
        return BaseCamera;
    })();
    ex.BaseCamera = BaseCamera;
    /**
    * An extension of BaseCamera that is locked vertically; it will only move side to side.
    * @class SideCamera
    * @extends BaseCamera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var SideCamera = (function (_super) {
        __extends(SideCamera, _super);
        function SideCamera() {
            _super.apply(this, arguments);
        }
        SideCamera.prototype.getFocus = function () {
            if (this.follow) {
                return new ex.Point(this.follow.x + this.follow.getWidth() / 2, this.focus.y);
            }
            else {
                return this.focus;
            }
        };
        return SideCamera;
    })(BaseCamera);
    ex.SideCamera = SideCamera;
    /**
    * An extension of BaseCamera that is locked to an actor or focal point; the actor will appear in the center of the screen.
    * @class TopCamera
    * @extends BaseCamera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var TopCamera = (function (_super) {
        __extends(TopCamera, _super);
        function TopCamera() {
            _super.apply(this, arguments);
        }
        TopCamera.prototype.getFocus = function () {
            if (this.follow) {
                return new ex.Point(this.follow.x + this.follow.getWidth() / 2, this.follow.y + this.follow.getHeight() / 2);
            }
            else {
                return this.focus;
            }
        };
        return TopCamera;
    })(BaseCamera);
    ex.TopCamera = TopCamera;
})(ex || (ex = {}));
/// <reference path="Class.ts" />
/// <reference path="Timer.ts" />
/// <reference path="Collision/NaiveCollisionResolver.ts"/>
/// <reference path="Collision/DynamicTreeCollisionResolver.ts"/>
/// <reference path="CollisionPair.ts" />
/// <reference path="Camera.ts" />
var ex;
(function (ex) {
    /**
     * Actors are composed together into groupings called Scenes in
     * Excalibur. The metaphor models the same idea behind real world
     * actors in a scene. Only actors in scenes will be updated and drawn.
     * @class Scene
     * @constructor
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(engine) {
            _super.call(this);
            /**
             * The actors in the current scene
             * @property children {Actor[]}
             */
            this.children = [];
            this.tileMaps = [];
            this.uiActors = [];
            this._collisionResolver = new ex.DynamicTreeCollisionResolver();
            this._killQueue = [];
            this._timers = [];
            this._cancelQueue = [];
            this._isInitialized = false;
            this.camera = new ex.BaseCamera();
            if (engine) {
                this.camera.setFocus(engine.width / 2, engine.height / 2);
            }
        }
        /**
         * This is called when the scene is made active and started. It is meant to be overriden,
         * this is where you should setup any DOM UI or event handlers needed for the scene.
         * @method onActivate
         */
        Scene.prototype.onActivate = function () {
            // will be overridden
        };
        /**
         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,
         * this is where you should cleanup any DOM UI or event handlers needed for the scene.
         * @method onDeactivate
         */
        Scene.prototype.onDeactivate = function () {
            // will be overridden
        };
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         * @method onInitialize
         * @param engine {Engine}
         */
        Scene.prototype.onInitialize = function (engine) {
            // will be overridden
        };
        /**
         * Publish an event to all actors in the scene
         * @method publish
         * @param eventType {string} The name of the event to publish
         * @param event {GameEvent} The event object to send
         */
        Scene.prototype.publish = function (eventType, event) {
            this.children.forEach(function (actor) {
                actor.triggerEvent(eventType, event);
            });
        };
        /**
         * Updates all the actors and timers in the Scene. Called by the Engine.
         * @method update
         * @param engine {Engine} Reference to the current Engine
         * @param delta {number} The number of milliseconds since the last update
         */
        Scene.prototype.update = function (engine, delta) {
            if (!this._isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.publish('initialize', new ex.InitializeEvent(engine));
                this._isInitialized = true;
            }
            this.uiActors.forEach(function (ui) {
                ui.update(engine, delta);
            });
            this.tileMaps.forEach(function (cm) {
                cm.update(engine, delta);
            });
            var len = 0;
            for (var i = 0, len = this.children.length; i < len; i++) {
                this.children[i].update(engine, delta);
            }
            // Run collision resolution strategy
            if (this._collisionResolver) {
                this._collisionResolver.update(this.children);
                this._collisionResolver.evaluate(this.children);
            }
            // Remove actors from scene graph after being killed
            var actorIndex = 0;
            for (var i = 0, len = this._killQueue.length; i < len; i++) {
                actorIndex = this.children.indexOf(this._killQueue[i]);
                if (actorIndex > -1) {
                    this.children.splice(actorIndex, 1);
                }
            }
            this._killQueue.length = 0;
            // Remove timers in the cancel queue before updating them
            var timerIndex = 0;
            for (var i = 0, len = this._cancelQueue.length; i < len; i++) {
                this.removeTimer(this._cancelQueue[i]);
            }
            this._cancelQueue.length = 0;
            // Cycle through timers updating timers
            var that = this;
            this._timers = this._timers.filter(function (timer) {
                timer.update(delta);
                return !timer.complete;
            });
        };
        /**
         * Draws all the actors in the Scene. Called by the Engine.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         * @param delta {number} The number of milliseconds since the last draw
         */
        Scene.prototype.draw = function (ctx, delta) {
            ctx.save();
            if (this.camera) {
                this.camera.update(ctx, delta);
            }
            this.tileMaps.forEach(function (cm) {
                cm.draw(ctx, delta);
            });
            var len = 0;
            var start = 0;
            var end = 0;
            var actor;
            for (var i = 0, len = this.children.length; i < len; i++) {
                actor = this.children[i];
                // only draw actors that are visible
                if (actor.visible) {
                    this.children[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                ctx.strokeStyle = 'yellow';
                this.debugDraw(ctx);
            }
            ctx.restore();
            this.uiActors.forEach(function (ui) {
                if (ui.visible) {
                    ui.draw(ctx, delta);
                }
            });
            if (this.engine && this.engine.isDebug) {
                this.uiActors.forEach(function (ui) {
                    ui.debugDraw(ctx);
                });
            }
        };
        /**
         * Draws all the actors' debug information in the Scene. Called by the Engine.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         */
        Scene.prototype.debugDraw = function (ctx) {
            this.tileMaps.forEach(function (map) {
                map.debugDraw(ctx);
            });
            this.children.forEach(function (actor) {
                actor.debugDraw(ctx);
            });
            // todo possibly enable this with excalibur flags features?
            //this._collisionResolver.debugDraw(ctx, 20);
            //this.camera.debugDraw(ctx);
        };
        Scene.prototype.add = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.addUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.addChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.addTileMap(entity);
            }
        };
        Scene.prototype.remove = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.removeUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this._collisionResolver.remove(entity);
                this.removeChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.removeTileMap(entity);
            }
        };
        /**
         * Adds an actor to act as a piece of UI, meaning it is always positioned
         * in screen coordinates. UI actors do not participate in collisions
         * @method addUIActor
         * @param actor {Actor}
         */
        Scene.prototype.addUIActor = function (actor) {
            this.uiActors.push(actor);
        };
        /**
         * Removes an actor as a piec of UI
         * @method removeUIActor
         * @param actor {Actor}
         */
        Scene.prototype.removeUIActor = function (actor) {
            var index = this.uiActors.indexOf(actor);
            if (index > -1) {
                this.uiActors.splice(index, 1);
            }
        };
        /**
         * Adds an actor to the Scene, once this is done the actor will be drawn and updated.
         * @method addChild
         * @param actor {Actor}
         */
        Scene.prototype.addChild = function (actor) {
            this._collisionResolver.register(actor);
            actor.scene = this;
            this.children.push(actor);
            actor.parent = this.actor;
        };
        /**
         * Adds a TileMap to the Scene, once this is done the TileMap will be drawn and updated.
         * @method addTileMap
         * @param tileMap {TileMap}
         */
        Scene.prototype.addTileMap = function (tileMap) {
            this.tileMaps.push(tileMap);
        };
        /**
         * Removes a TileMap from the Scene, it willno longer be drawn or updated.
         * @method removeTileMap
         * @param tileMap {TileMap}
         */
        Scene.prototype.removeTileMap = function (tileMap) {
            var index = this.tileMaps.indexOf(tileMap);
            if (index > -1) {
                this.tileMaps.splice(index, 1);
            }
        };
        /**
         * Removes an actor from the Scene, it will no longer be drawn or updated.
         * @method removeChild
         * @param actor {Actor} The actor to remove
         */
        Scene.prototype.removeChild = function (actor) {
            this._collisionResolver.remove(actor);
            this._killQueue.push(actor);
            actor.parent = null;
        };
        /**
         * Adds a timer to the Scene
         * @method addTimer
         * @param timer {Timer} The timer to add
         * @returns Timer
         */
        Scene.prototype.addTimer = function (timer) {
            this._timers.push(timer);
            timer.scene = this;
            return timer;
        };
        /**
         * Removes a timer to the Scene, can be dangerous
         * @method removeTimer
         * @private
         * @param timer {Timer} The timer to remove
         * @returns Timer
         */
        Scene.prototype.removeTimer = function (timer) {
            var i = this._timers.indexOf(timer);
            if (i !== -1) {
                this._timers.splice(i, 1);
            }
            return timer;
        };
        /**
         * Cancels a timer, removing it from the scene nicely
         * @method cancelTimer
         * @param timer {Timer} The timer to cancel
         * @returns Timer
         */
        Scene.prototype.cancelTimer = function (timer) {
            this._cancelQueue.push(timer);
            return timer;
        };
        /**
         * Tests whether a timer is active in the scene
         * @method isTimerActive
         * @param timer {Timer}
         * @returns boolean
         */
        Scene.prototype.isTimerActive = function (timer) {
            return (this._timers.indexOf(timer) > -1);
        };
        return Scene;
    })(ex.Class);
    ex.Scene = Scene;
})(ex || (ex = {}));
/// <reference path="Algebra.ts" />
/// <reference path="Engine.ts" />
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    var Internal;
    (function (Internal) {
        var Actions;
        (function (Actions) {
            var EaseTo = (function () {
                function EaseTo(actor, x, y, duration, easingFcn) {
                    this.actor = actor;
                    this.easingFcn = easingFcn;
                    this._currentLerpTime = 0;
                    this._lerpDuration = 1 * 1000; // 5 seconds
                    this._lerpStart = new ex.Point(0, 0);
                    this._lerpEnd = new ex.Point(0, 0);
                    this._initialized = false;
                    this._stopped = false;
                    this._distance = 0;
                    this._lerpDuration = duration;
                    this._lerpEnd = new ex.Point(x, y);
                }
                EaseTo.prototype._initialize = function () {
                    this._lerpStart = new ex.Point(this.actor.x, this.actor.y);
                    this._currentLerpTime = 0;
                    this._distance = this._lerpStart.toVector().distance(this._lerpEnd.toVector());
                };
                EaseTo.prototype.update = function (delta) {
                    if (!this._initialized) {
                        this._initialize();
                        this._initialized = true;
                    }
                    var newX = this.actor.x;
                    var newY = this.actor.y;
                    if (this._currentLerpTime < this._lerpDuration) {
                        if (this._lerpEnd.x < this._lerpStart.x) {
                            newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                        }
                        else {
                            newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                        }
                        if (this._lerpEnd.y < this._lerpStart.y) {
                            newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                        }
                        else {
                            newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                        }
                        this.actor.x = newX;
                        this.actor.y = newY;
                        this._currentLerpTime += delta;
                    }
                    else {
                        this.actor.x = this._lerpEnd.x;
                        this.actor.y = this._lerpEnd.y;
                    }
                };
                EaseTo.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this._lerpStart.toVector()) >= this._distance;
                };
                EaseTo.prototype.reset = function () {
                    this._initialized = false;
                };
                EaseTo.prototype.stop = function () {
                    this._stopped = true;
                };
                return EaseTo;
            })();
            Actions.EaseTo = EaseTo;
            var MoveTo = (function () {
                function MoveTo(actor, destx, desty, speed) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = new ex.Vector(destx, desty);
                    this.speed = speed;
                }
                MoveTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = new ex.Vector(this.actor.x, this.actor.y);
                        this.distance = this.start.distance(this.end);
                        this.dir = this.end.minus(this.start).normalize();
                    }
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                MoveTo.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this.start) >= this.distance;
                };
                MoveTo.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                MoveTo.prototype.reset = function () {
                    this._started = false;
                };
                return MoveTo;
            })();
            Actions.MoveTo = MoveTo;
            var MoveBy = (function () {
                function MoveBy(actor, destx, desty, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = new ex.Vector(destx, desty);
                    if (time <= 0) {
                        ex.Logger.getInstance().error("Attempted to moveBy time less than or equal to zero : " + time);
                        throw new Error("Cannot move in time <= 0");
                    }
                    this.time = time;
                }
                MoveBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = new ex.Vector(this.actor.x, this.actor.y);
                        this.distance = this.start.distance(this.end);
                        this.dir = this.end.minus(this.start).normalize();
                        this.speed = this.distance / (this.time / 1000);
                    }
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                MoveBy.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this.start) >= this.distance;
                };
                MoveBy.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                MoveBy.prototype.reset = function () {
                    this._started = false;
                };
                return MoveBy;
            })();
            Actions.MoveBy = MoveBy;
            var Follow = (function () {
                function Follow(actor, actorToFollow, followDistance) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.actorToFollow = actorToFollow;
                    this.current = new ex.Vector(this.actor.x, this.actor.y);
                    this.end = new ex.Vector(actorToFollow.x, actorToFollow.y);
                    this.maximumDistance = (followDistance != undefined) ? followDistance : this.current.distance(this.end);
                    this.speed = 0;
                }
                Follow.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.distanceBetween = this.current.distance(this.end);
                        this.dir = this.end.minus(this.current).normalize();
                    }
                    var actorToFollowSpeed = Math.sqrt(Math.pow(this.actorToFollow.dx, 2) + Math.pow(this.actorToFollow.dy, 2));
                    if (actorToFollowSpeed != 0) {
                        this.speed = actorToFollowSpeed;
                    }
                    this.current.x = this.actor.x;
                    this.current.y = this.actor.y;
                    this.end.x = this.actorToFollow.x;
                    this.end.y = this.actorToFollow.y;
                    this.distanceBetween = this.current.distance(this.end);
                    this.dir = this.end.minus(this.current).normalize();
                    if (this.distanceBetween >= this.maximumDistance) {
                        var m = this.dir.scale(this.speed);
                        this.actor.dx = m.x;
                        this.actor.dy = m.y;
                    }
                    else {
                        this.actor.dx = 0;
                        this.actor.dy = 0;
                    }
                    if (this.isComplete(this.actor)) {
                        // TODO this should never occur
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                Follow.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                Follow.prototype.isComplete = function (actor) {
                    // the actor following should never stop unless specified to do so
                    return this._stopped;
                };
                Follow.prototype.reset = function () {
                    this._started = false;
                };
                return Follow;
            })();
            Actions.Follow = Follow;
            var Meet = (function () {
                function Meet(actor, actorToMeet, speed) {
                    this._started = false;
                    this._stopped = false;
                    this._speedWasSpecified = false;
                    this.actor = actor;
                    this.actorToMeet = actorToMeet;
                    this.current = new ex.Vector(this.actor.x, this.actor.y);
                    this.end = new ex.Vector(actorToMeet.x, actorToMeet.y);
                    this.speed = speed || 0;
                    if (speed != undefined) {
                        this._speedWasSpecified = true;
                    }
                }
                Meet.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.distanceBetween = this.current.distance(this.end);
                        this.dir = this.end.minus(this.current).normalize();
                    }
                    var actorToMeetSpeed = Math.sqrt(Math.pow(this.actorToMeet.dx, 2) + Math.pow(this.actorToMeet.dy, 2));
                    if ((actorToMeetSpeed != 0) && (!this._speedWasSpecified)) {
                        this.speed = actorToMeetSpeed;
                    }
                    this.current.x = this.actor.x;
                    this.current.y = this.actor.y;
                    this.end.x = this.actorToMeet.x;
                    this.end.y = this.actorToMeet.y;
                    this.distanceBetween = this.current.distance(this.end);
                    this.dir = this.end.minus(this.current).normalize();
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    if (this.isComplete(this.actor)) {
                        // console.log("meeting is complete")
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                Meet.prototype.isComplete = function (actor) {
                    return this._stopped || (this.distanceBetween <= 1);
                };
                Meet.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                Meet.prototype.reset = function () {
                    this._started = false;
                };
                return Meet;
            })();
            Actions.Meet = Meet;
            var RotateTo = (function () {
                function RotateTo(actor, angleRadians, speed) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = angleRadians;
                    this.speed = speed;
                }
                RotateTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = this.actor.rotation;
                        this.distance = Math.abs(this.end - this.start);
                    }
                    this.actor.rx = this.speed;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.rotation = this.end;
                        this.actor.rx = 0;
                    }
                };
                RotateTo.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.rotation - this.start) >= this.distance);
                };
                RotateTo.prototype.stop = function () {
                    this.actor.rx = 0;
                    this._stopped = true;
                };
                RotateTo.prototype.reset = function () {
                    this._started = false;
                };
                return RotateTo;
            })();
            Actions.RotateTo = RotateTo;
            var RotateBy = (function () {
                function RotateBy(actor, angleRadians, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = angleRadians;
                    this.time = time;
                    this.speed = (this.end - this.actor.rotation) / time * 1000;
                }
                RotateBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = this.actor.rotation;
                        this.distance = Math.abs(this.end - this.start);
                    }
                    this.actor.rx = this.speed;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.rotation = this.end;
                        this.actor.rx = 0;
                    }
                };
                RotateBy.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.rotation - this.start) >= this.distance);
                };
                RotateBy.prototype.stop = function () {
                    this.actor.rx = 0;
                    this._stopped = true;
                };
                RotateBy.prototype.reset = function () {
                    this._started = false;
                };
                return RotateBy;
            })();
            Actions.RotateBy = RotateBy;
            var ScaleTo = (function () {
                function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endX = scaleX;
                    this.endY = scaleY;
                    this.speedX = speedX;
                    this.speedY = speedY;
                }
                ScaleTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.startX = this.actor.scale.x;
                        this.startY = this.actor.scale.y;
                        this.distanceX = Math.abs(this.endX - this.startX);
                        this.distanceY = Math.abs(this.endY - this.startY);
                    }
                    if (!(Math.abs(this.actor.scale.x - this.startX) >= this.distanceX)) {
                        var directionX = this.endY < this.startY ? -1 : 1;
                        this.actor.sx = this.speedX * directionX;
                    }
                    else {
                        this.actor.sx = 0;
                    }
                    if (!(Math.abs(this.actor.scale.y - this.startY) >= this.distanceY)) {
                        var directionY = this.endY < this.startY ? -1 : 1;
                        this.actor.sy = this.speedY * directionY;
                    }
                    else {
                        this.actor.sy = 0;
                    }
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.scale.x = this.endX;
                        this.actor.scale.y = this.endY;
                        this.actor.sx = 0;
                        this.actor.sy = 0;
                    }
                };
                ScaleTo.prototype.isComplete = function (actor) {
                    return this._stopped || ((Math.abs(this.actor.scale.y - this.startX) >= this.distanceX) && (Math.abs(this.actor.scale.y - this.startY) >= this.distanceY));
                };
                ScaleTo.prototype.stop = function () {
                    this.actor.sx = 0;
                    this.actor.sy = 0;
                    this._stopped = true;
                };
                ScaleTo.prototype.reset = function () {
                    this._started = false;
                };
                return ScaleTo;
            })();
            Actions.ScaleTo = ScaleTo;
            var ScaleBy = (function () {
                function ScaleBy(actor, scaleX, scaleY, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endX = scaleX;
                    this.endY = scaleY;
                    this.time = time;
                    this.speedX = (this.endX - this.actor.scale.x) / time * 1000;
                    this.speedY = (this.endY - this.actor.scale.y) / time * 1000;
                }
                ScaleBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.startX = this.actor.scale.x;
                        this.startY = this.actor.scale.y;
                        this.distanceX = Math.abs(this.endX - this.startX);
                        this.distanceY = Math.abs(this.endY - this.startY);
                    }
                    var directionX = this.endX < this.startX ? -1 : 1;
                    var directionY = this.endY < this.startY ? -1 : 1;
                    this.actor.sx = this.speedX * directionX;
                    this.actor.sy = this.speedY * directionY;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.scale.x = this.endX;
                        this.actor.scale.y = this.endY;
                        this.actor.sx = 0;
                        this.actor.sy = 0;
                    }
                };
                ScaleBy.prototype.isComplete = function (actor) {
                    return this._stopped || ((Math.abs(this.actor.scale.x - this.startX) >= this.distanceX) && (Math.abs(this.actor.scale.y - this.startY) >= this.distanceY));
                };
                ScaleBy.prototype.stop = function () {
                    this.actor.sx = 0;
                    this.actor.sy = 0;
                    this._stopped = true;
                };
                ScaleBy.prototype.reset = function () {
                    this._started = false;
                };
                return ScaleBy;
            })();
            Actions.ScaleBy = ScaleBy;
            var Delay = (function () {
                function Delay(actor, delay) {
                    this.elapsedTime = 0;
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.delay = delay;
                }
                Delay.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    this.elapsedTime += delta;
                };
                Delay.prototype.isComplete = function (actor) {
                    return this._stopped || (this.elapsedTime >= this.delay);
                };
                Delay.prototype.stop = function () {
                    this._stopped = true;
                };
                Delay.prototype.reset = function () {
                    this.elapsedTime = 0;
                    this._started = false;
                };
                return Delay;
            })();
            Actions.Delay = Delay;
            var Blink = (function () {
                function Blink(actor, timeVisible, timeNotVisible, numBlinks) {
                    if (numBlinks === void 0) { numBlinks = 1; }
                    this.timeVisible = 0;
                    this.timeNotVisible = 0;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                    this._stopped = false;
                    this._started = false;
                    this.actor = actor;
                    this.timeVisible = timeVisible;
                    this.timeNotVisible = timeNotVisible;
                    this.duration = (timeVisible + timeNotVisible) * numBlinks;
                }
                Blink.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    this.elapsedTime += delta;
                    this.totalTime += delta;
                    if (this.actor.visible && this.elapsedTime >= this.timeVisible) {
                        this.actor.visible = false;
                        this.elapsedTime = 0;
                    }
                    if (!this.actor.visible && this.elapsedTime >= this.timeNotVisible) {
                        this.actor.visible = true;
                        this.elapsedTime = 0;
                    }
                    if (this.isComplete(this.actor)) {
                        this.actor.visible = true;
                    }
                };
                Blink.prototype.isComplete = function (actor) {
                    return this._stopped || (this.totalTime >= this.duration);
                };
                Blink.prototype.stop = function () {
                    this.actor.visible = true;
                    this._stopped = true;
                };
                Blink.prototype.reset = function () {
                    this._started = false;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                };
                return Blink;
            })();
            Actions.Blink = Blink;
            var Fade = (function () {
                function Fade(actor, endOpacity, speed) {
                    this.multiplyer = 1;
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endOpacity = endOpacity;
                    this.speed = speed;
                    if (endOpacity < actor.opacity) {
                        this.multiplyer = -1;
                    }
                }
                Fade.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    if (this.speed > 0) {
                        this.actor.opacity += this.multiplyer * (Math.abs(this.actor.opacity - this.endOpacity) * delta) / this.speed;
                    }
                    this.speed -= delta;
                    ex.Logger.getInstance().debug("actor opacity: " + this.actor.opacity);
                    if (this.isComplete(this.actor)) {
                        this.actor.opacity = this.endOpacity;
                    }
                };
                Fade.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.opacity - this.endOpacity) < 0.05);
                };
                Fade.prototype.stop = function () {
                    this._stopped = true;
                };
                Fade.prototype.reset = function () {
                    this._started = false;
                };
                return Fade;
            })();
            Actions.Fade = Fade;
            var Die = (function () {
                function Die(actor) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                }
                Die.prototype.update = function (delta) {
                    this.actor.actionQueue.clearActions();
                    this.actor.kill();
                    this._stopped = true;
                };
                Die.prototype.isComplete = function () {
                    return this._stopped;
                };
                Die.prototype.stop = function () {
                };
                Die.prototype.reset = function () {
                };
                return Die;
            })();
            Actions.Die = Die;
            var CallMethod = (function () {
                function CallMethod(actor, method) {
                    this._method = null;
                    this._actor = null;
                    this._hasBeenCalled = false;
                    this._actor = actor;
                    this._method = method;
                }
                CallMethod.prototype.update = function (delta) {
                    this._method.call(this._actor);
                    this._hasBeenCalled = true;
                };
                CallMethod.prototype.isComplete = function (actor) {
                    return this._hasBeenCalled;
                };
                CallMethod.prototype.reset = function () {
                    this._hasBeenCalled = false;
                };
                CallMethod.prototype.stop = function () {
                    this._hasBeenCalled = true;
                };
                return CallMethod;
            })();
            Actions.CallMethod = CallMethod;
            var Repeat = (function () {
                function Repeat(actor, repeat, actions) {
                    var _this = this;
                    this._stopped = false;
                    this.actor = actor;
                    this.actionQueue = new ActionQueue(actor);
                    this.repeat = repeat;
                    this.originalRepeat = repeat;
                    actions.forEach(function (action) {
                        action.reset();
                        _this.actionQueue.add(action);
                    });
                }
                Repeat.prototype.update = function (delta) {
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    if (!this.actionQueue.hasNext()) {
                        this.actionQueue.reset();
                        this.repeat--;
                    }
                    this.actionQueue.update(delta);
                };
                Repeat.prototype.isComplete = function () {
                    return this._stopped || (this.repeat <= 0);
                };
                Repeat.prototype.stop = function () {
                    this._stopped = true;
                };
                Repeat.prototype.reset = function () {
                    this.repeat = this.originalRepeat;
                };
                return Repeat;
            })();
            Actions.Repeat = Repeat;
            var RepeatForever = (function () {
                function RepeatForever(actor, actions) {
                    var _this = this;
                    this._stopped = false;
                    this.actor = actor;
                    this.actionQueue = new ActionQueue(actor);
                    actions.forEach(function (action) {
                        action.reset();
                        _this.actionQueue.add(action);
                    });
                }
                RepeatForever.prototype.update = function (delta) {
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    if (this._stopped) {
                        return;
                    }
                    if (!this.actionQueue.hasNext()) {
                        this.actionQueue.reset();
                    }
                    this.actionQueue.update(delta);
                };
                RepeatForever.prototype.isComplete = function () {
                    return this._stopped;
                };
                RepeatForever.prototype.stop = function () {
                    this._stopped = true;
                    this.actionQueue.clearActions();
                };
                RepeatForever.prototype.reset = function () {
                };
                return RepeatForever;
            })();
            Actions.RepeatForever = RepeatForever;
            var ActionQueue = (function () {
                function ActionQueue(actor) {
                    this._actions = [];
                    this._completedActions = [];
                    this.actor = actor;
                }
                ActionQueue.prototype.add = function (action) {
                    this._actions.push(action);
                };
                ActionQueue.prototype.remove = function (action) {
                    var index = this._actions.indexOf(action);
                    this._actions.splice(index, 1);
                };
                ActionQueue.prototype.clearActions = function () {
                    this._actions.length = 0;
                    this._completedActions.length = 0;
                    this._currentAction.stop();
                };
                ActionQueue.prototype.getActions = function () {
                    return this._actions.concat(this._completedActions);
                };
                ActionQueue.prototype.hasNext = function () {
                    return this._actions.length > 0;
                };
                ActionQueue.prototype.reset = function () {
                    this._actions = this.getActions();
                    this._actions.forEach(function (action) {
                        action.reset();
                    });
                    this._completedActions = [];
                };
                ActionQueue.prototype.update = function (delta) {
                    if (this._actions.length > 0) {
                        this._currentAction = this._actions[0];
                        this._currentAction.update(delta);
                        if (this._currentAction.isComplete(this.actor)) {
                            //Logger.getInstance().log("Action complete!", Log.DEBUG);
                            this._completedActions.push(this._actions.shift());
                        }
                    }
                };
                return ActionQueue;
            })();
            Actions.ActionQueue = ActionQueue;
        })(Actions = Internal.Actions || (Internal.Actions = {}));
    })(Internal = ex.Internal || (ex.Internal = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var EasingFunctions = (function () {
        function EasingFunctions() {
        }
        /*
       easeInQuad: function (t) { return t * t },
       // decelerating to zero velocity
       easeOutQuad: function (t) { return t * (2 - t) },
       // acceleration until halfway, then deceleration
       easeInOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
       // accelerating from zero velocity
       easeInCubic: function (t) { return t * t * t },
       // decelerating to zero velocity
       easeOutCubic: function (t) { return (--t) * t * t + 1 },
       // acceleration until halfway, then deceleration
       easeInOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
       // accelerating from zero velocity
       easeInQuart: function (t) { return t * t * t * t },
       // decelerating to zero velocity
       easeOutQuart: function (t) { return 1 - (--t) * t * t * t },
       // acceleration until halfway, then deceleration
       easeInOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
       // accelerating from zero velocity
       easeInQuint: function (t) { return t * t * t * t * t },
       // decelerating to zero velocity
       easeOutQuint: function (t) { return 1 + (--t) * t * t * t * t },
       // acceleration until halfway, then deceleration
       easeInOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t }
        */
        EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            return endValue * currentTime / duration + startValue;
        };
        EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {
            //endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * currentTime * currentTime + startValue;
        };
        EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {
            //endValue = (endValue - startValue);
            currentTime /= duration;
            return -endValue * currentTime * (currentTime - 2) + startValue;
        };
        EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime + startValue;
            currentTime--;
            return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
        };
        EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * currentTime * currentTime * currentTime + startValue;
        };
        EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
        };
        EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime * currentTime + startValue;
            currentTime -= 2;
            return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
        };
        return EasingFunctions;
    })();
    ex.EasingFunctions = EasingFunctions;
})(ex || (ex = {}));
/// <reference path="Interfaces/IDrawable.ts" />
/// <reference path="Modules/MovementModule.ts" />
/// <reference path="Modules/OffscreenCullingModule.ts" />
/// <reference path="Modules/CapturePointerModule.ts" />
/// <reference path="Modules/CollisionDetectionModule.ts" />
/// <reference path="Collision/Side.ts" />
/// <reference path="Algebra.ts" />
/// <reference path="Util.ts" />
/// <reference path="TileMap.ts" />
/// <reference path="Collision/BoundingBox.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Action.ts" />
/// <reference path="EasingFunctions.ts"/>
var ex;
(function (ex) {
    /**
     * An enum that describes the types of collisions actors can participate in
     * @class CollisionType
     */
    (function (CollisionType) {
        /**
         * Actors with the PreventCollision setting do not participate in any
         * collisions and do not raise collision events.
         * @property PreventCollision {CollisionType}
         * @static
         */
        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";
        /**
         * Actors with the Passive setting only raise collision events, but are not
         * influenced or moved by other actors and do not influence or move other actors.
         * @property Passive {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Passive"] = 1] = "Passive";
        /**
         * Actors with the Active setting raise collision events and participate
         * in collisions with other actors and will be push or moved by actors sharing
         * the Active or Fixed setting.
         * @property Active {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Active"] = 2] = "Active";
        /**
         * Actors with the Elastic setting will behave the same as Active, except that they will
         * "bounce" in the opposite direction given their velocity dx/dy. This is a naive implementation meant for
         * prototyping, for a more robust elastic collision listen to the "collision" event and perform your custom logic.
         * @property Elastic {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Elastic"] = 3] = "Elastic";
        /**
         * Actors with the Fixed setting raise collision events and participate in
         * collisions with other actors. Actors with the Fixed setting will not be
         * pushed or moved by other actors sharing the Fixed or Actors. Think of Fixed
         * actors as "immovable/onstoppable" objects. If two Fixed actors meet they will
         * not be pushed or moved by each other, they will not interact except to throw
         * collision events.
         * @property Fixed {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Fixed"] = 4] = "Fixed";
    })(ex.CollisionType || (ex.CollisionType = {}));
    var CollisionType = ex.CollisionType;
    /**
     * The most important primitive in Excalibur is an "Actor." Anything that
     * can move on the screen, collide with another Actor, respond to events,
     * or interact with the current scene, must be an actor. An Actor <b>must</b>
     * be part of a {{#crossLink "Scene"}}{{/crossLink}} for it to be drawn to the screen.
     * @class Actor
     * @extends Class
     * @constructor
     * @param [x=0.0] {number} The starting x coordinate of the actor
     * @param [y=0.0] {number} The starting y coordinate of the actor
     * @param [width=0.0] {number} The starting width of the actor
     * @param [height=0.0] {number} The starting height of the actor
     * @param [color=undefined] {Color} The starting color of the actor
     */
    var Actor = (function (_super) {
        __extends(Actor, _super);
        function Actor(x, y, width, height, color) {
            _super.call(this);
            /**
             * The unique identifier for the actor
             */
            this.id = Actor.maxId++;
            /**
             * The x coordinate of the actor (left edge)
             * @property x {number}
             */
            this.x = 0;
            /**
             * The y coordinate of the actor (top edge)
             * @property y {number}
             */
            this.y = 0;
            this.height = 0;
            this.width = 0;
            /**
             * The rotation of the actor in radians
             * @property rotation {number}
             */
            this.rotation = 0; // radians
            /**
             * The rotational velocity of the actor in radians/second
             * @property rx {number}
             */
            this.rx = 0; //radions/sec
            /**
             * The scale vector of the actor
             * @property scale
             */
            this.scale = new ex.Vector(1, 1);
            /**
             * The x scalar velocity of the actor in scale/second
             * @property sx {number}
             */
            this.sx = 0; //scale/sec
            /**
             * The y scalar velocity of the actor in scale/second
             * @property sy {number}
             */
            this.sy = 0; //scale/sec
            /**
             * The x velocity of the actor in pixels/second
             * @property dx {number}
             */
            this.dx = 0; // pixels/sec
            /**
             * The x velocity of the actor in pixels/second
             * @property dx {number}
             */
            this.dy = 0;
            /**
             * The x acceleration of the actor in pixels/second^2
             * @property ax {number}
             */
            this.ax = 0; // pixels/sec/sec
            /**
             * The y acceleration of the actor in pixels/second^2
             * @property ay {number}
             */
            this.ay = 0;
            /**
             * Indicates wether the actor is physically in the viewport
             * @property isOffScreen {boolean}
             */
            this.isOffScreen = false;
            /**
             * The visibility of an actor
             * @property visible {boolean}
             */
            this.visible = true;
            /**
             * The opacity of an actor
             * @property opacity {number}
             */
            this.opacity = 1;
            this.previousOpacity = 1;
            /**
             * Convenience reference to the global logger
             * @property logger {Logger}
             */
            this.logger = ex.Logger.getInstance();
            /**
            * The scene that the actor is in
            * @property scene {Scene}
            */
            this.scene = null; //formerly "parent"
            /**
            * The parent of this actor
            * @property parent {Actor}
            */
            this.parent = null;
            /**
             * Gets or sets the current collision type of this actor. By
             * default all actors participate in Active collisions.
             * @property collisionType {CollisionType}
             */
            this.collisionType = 0 /* PreventCollision */;
            this.collisionGroups = [];
            this._collisionHandlers = {};
            this._isInitialized = false;
            this.frames = {};
            /**
             * Access to the current drawing on for the actor, this can be an {{#crossLink "Animation"}}{{/crossLink}},
             * {{#crossLink "Sprite"}}{{/crossLink}}, or {{#crossLink "Polygon"}}{{/crossLink}}.
             * Set drawings with the {{#crossLink "Actor/setDrawing:method"}}{{/crossLink}}.
             * @property currentDrawing {IDrawable}
             */
            this.currentDrawing = null;
            this.centerDrawingX = false;
            this.centerDrawingY = false;
            /**
             * Modify the current actor update pipeline.
             *
             *
             */
            this.pipeline = [];
            /**
             * Whether or not to enable the CapturePointer trait that propogates pointer events to this actor
             * @property [enableCapturePointer=false] {boolean}
             */
            this.enableCapturePointer = false;
            /**
             * Configuration for CapturePointer trait
             * @property capturePointer {ICapturePointerConfig}
             */
            this.capturePointer = {
                captureMoveEvents: false
            };
            this._isKilled = false;
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
            if (color) {
                this.color = color.clone();
                // set default opacity of an actor to the color
                this.opacity = color.a;
            }
            // Build default pipeline
            this.pipeline.push(new ex.MovementModule());
            //this.pipeline.push(new ex.CollisionDetectionModule());
            this.pipeline.push(new ex.OffscreenCullingModule());
            this.pipeline.push(new ex.CapturePointerModule());
            this.actionQueue = new ex.Internal.Actions.ActionQueue(this);
            this.sceneNode = new ex.Scene();
            this.sceneNode.actor = this;
            this.anchor = new ex.Point(.5, .5);
        }
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         * @method onInitialize
         * @param engine {Engine}
         */
        Actor.prototype.onInitialize = function (engine) {
        };
        Actor.prototype._checkForPointerOptIn = function (eventName) {
            if (eventName && (eventName.toLowerCase() === 'pointerdown' || eventName.toLowerCase() === 'pointerdown' || eventName.toLowerCase() === 'pointermove')) {
                this.enableCapturePointer = true;
                if (eventName.toLowerCase() === 'pointermove') {
                    this.capturePointer.captureMoveEvents = true;
                }
            }
        };
        /**
        * Add an event listener. You can listen for a variety of
        * events off of the engine; see the events section below for a complete list.
        * @method addEventListener
        * @param eventName {string} Name of the event to listen for
        * @param handler {event=>void} Event handler for the thrown event
        */
        Actor.prototype.addEventListener = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            _super.prototype.addEventListener.call(this, eventName, handler);
        };
        /**
         * Alias for "addEventListener". You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method on
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Actor.prototype.on = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * If the current actors is a member of the scene. This will remove
         * it from the scene graph. It will no longer be drawn or updated.
         * @method kill
         */
        Actor.prototype.kill = function () {
            if (this.scene) {
                this.scene.removeChild(this);
                this._isKilled = true;
            }
            else {
                this.logger.warn("Cannot kill actor, it was never added to the Scene");
            }
        };
        /**
         * Indicates wether the actor has been killed.
         * @method isKilled
         * @returns boolean
         */
        Actor.prototype.isKilled = function () {
            return this._isKilled;
        };
        /**
         * Adds a child actor to this actor. All movement of the child actor will be
         * relative to the parent actor. Meaning if the parent moves the child will
         * move with
         * @method addChild
         * @param actor {Actor} The child actor to add
         */
        Actor.prototype.addChild = function (actor) {
            actor.collisionType = 0 /* PreventCollision */;
            this.sceneNode.addChild(actor);
        };
        /**
         * Removes a child actor from this actor.
         * @method removeChild
         * @param actor {Actor} The child actor to remove
         */
        Actor.prototype.removeChild = function (actor) {
            this.sceneNode.removeChild(actor);
        };
        /**
         * Sets the current drawing of the actor to the drawing correspoding to
         * the key.
         * @method setDrawing
         * @param key {string} The key of the drawing
         */
        Actor.prototype.setDrawing = function (key) {
            if (this.currentDrawing != this.frames[key]) {
                this.frames[key].reset();
            }
            this.currentDrawing = this.frames[key];
        };
        Actor.prototype.addDrawing = function (args) {
            if (arguments.length === 2) {
                this.frames[arguments[0]] = arguments[1];
                if (!this.currentDrawing) {
                    this.currentDrawing = arguments[1];
                }
            }
            else {
                if (arguments[0] instanceof ex.Sprite) {
                    this.addDrawing("default", arguments[0]);
                }
                if (arguments[0] instanceof ex.Texture) {
                    this.addDrawing("default", arguments[0].asSprite());
                }
            }
        };
        /**
         * Artificially trigger an event on an actor, useful when creating custom events.
         * @method triggerEvent
         * @param eventName {string} The name of the event to trigger
         * @param [event=undefined] {GameEvent} The event object to pass to the callback
         */
        Actor.prototype.triggerEvent = function (eventName, event) {
            this.eventDispatcher.publish(eventName, event);
        };
        /**
         * Adds an actor to a collision group. Actors with no named collision group are
         * considered to be in every collision group.
         *
         * Once in a collision group(s) actors will only collide with other actors in
         * that group.
         *
         * @method addCollisionGroup
         * @param name {string} The name of the collision group
         */
        Actor.prototype.addCollisionGroup = function (name) {
            this.collisionGroups.push(name);
        };
        /**
         * Remove an actor from a collision group.
         * @method removeCollisionGroup
         * @param name {string} The name of the collision group
         */
        Actor.prototype.removeCollisionGroup = function (name) {
            var index = this.collisionGroups.indexOf(name);
            if (index !== -1) {
                this.collisionGroups.splice(index, 1);
            }
        };
        /**
         * Get the center point of an actor
         * @method getCenter
         * @returns Vector
         */
        Actor.prototype.getCenter = function () {
            var anchor = this._getCalculatedAnchor();
            return new ex.Vector(this.x + this.getWidth() / 2, this.y + this.getHeight() / 2);
        };
        /**
         * Gets the calculated width of an actor
         * @method getWidth
         * @returns number
         */
        Actor.prototype.getWidth = function () {
            return this.width * this.scale.x;
        };
        /**
         * Sets the width of an actor, factoring in the current scale
         * @method setWidth
         */
        Actor.prototype.setWidth = function (width) {
            this.width = width / this.scale.x;
        };
        /**
         * Gets the calculated height of an actor
         * @method getHeight
         * @returns number
         */
        Actor.prototype.getHeight = function () {
            return this.height * this.scale.y;
        };
        /**
         * Sets the height of an actor, factoring in the current scale
         * @method setHeight
         */
        Actor.prototype.setHeight = function (height) {
            this.height = height / this.scale.y;
        };
        /**
         * Centers the actor's drawing around the center of the actor's bounding box
         * @method setCenterDrawing
         * @param center {boolean} Indicates to center the drawing around the actor
         */
        Actor.prototype.setCenterDrawing = function (center) {
            this.centerDrawingY = center;
            this.centerDrawingX = center;
        };
        /**
         * Gets the left edge of the actor
         * @method getLeft
         * @returns number
         */
        Actor.prototype.getLeft = function () {
            return this.x;
        };
        /**
         * Gets the right edge of the actor
         * @method getRight
         * @returns number
         */
        Actor.prototype.getRight = function () {
            return this.x + this.getWidth();
        };
        /**
         * Gets the top edge of the actor
         * @method getTop
         * @returns number
         */
        Actor.prototype.getTop = function () {
            return this.y;
        };
        /**
         * Gets the bottom edge of the actor
         * @method getBottom
         * @returns number
         */
        Actor.prototype.getBottom = function () {
            return this.y + this.getHeight();
        };
        /**
        * Gets the x value of the Actor in global coordinates
        * @method getGlobalX
        * @returns number
        */
        Actor.prototype.getGlobalX = function () {
            if (!this.parent)
                return this.x;
            return this.x * this.parent.scale.y + this.parent.getGlobalX();
        };
        /**
        * Gets the y value of the Actor in global coordinates
        * @method getGlobalY
        * @returns number
        */
        Actor.prototype.getGlobalY = function () {
            if (!this.parent)
                return this.y;
            return this.y * this.parent.scale.y + this.parent.getGlobalY();
        };
        /**
         * Gets the global scale of the Actor
         * @method getGlobalScale
         * @returns Point
         */
        Actor.prototype.getGlobalScale = function () {
            if (!this.parent)
                return new ex.Point(this.scale.x, this.scale.y);
            var parentScale = this.parent.getGlobalScale();
            return new ex.Point(this.scale.x * parentScale.x, this.scale.y * parentScale.y);
        };
        /**
         * Returns the actor's bounding box calculated for this instant.
         * @method getBounds
         * @returns BoundingBox
         */
        Actor.prototype.getBounds = function () {
            var anchor = this._getCalculatedAnchor();
            return new ex.BoundingBox(this.getGlobalX() - anchor.x, this.getGlobalY() - anchor.y, this.getGlobalX() + this.getWidth() - anchor.x, this.getGlobalY() + this.getHeight() - anchor.y);
        };
        /**
         * Tests whether the x/y specified are contained in the actor
         * @method contains
         * @param x {number} X coordinate to test (in world coordinates)
         * @param y {number} Y coordinate to test (in world coordinates)
         */
        Actor.prototype.contains = function (x, y) {
            return this.getBounds().contains(new ex.Point(x, y));
        };
        /**
         * Returns the side of the collision based on the intersection
         * @method getSideFromIntersect
         * @param intersect {Vector} The displacement vector returned by a collision
         * @returns Side
        */
        Actor.prototype.getSideFromIntersect = function (intersect) {
            if (intersect) {
                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {
                    if (intersect.x < 0) {
                        return 4 /* Right */;
                    }
                    return 3 /* Left */;
                }
                else {
                    if (intersect.y < 0) {
                        return 2 /* Bottom */;
                    }
                    return 1 /* Top */;
                }
            }
            return 0 /* None */;
        };
        /**
         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.
         * @method collides
         * @param actor {Actor} The other actor to test
         * @returns Side
         */
        Actor.prototype.collidesWithSide = function (actor) {
            var separationVector = this.collides(actor);
            if (!separationVector) {
                return 0 /* None */;
            }
            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {
                if (this.x < actor.x) {
                    return 4 /* Right */;
                }
                else {
                    return 3 /* Left */;
                }
            }
            else {
                if (this.y < actor.y) {
                    return 2 /* Bottom */;
                }
                else {
                    return 1 /* Top */;
                }
            }
            return 0 /* None */;
        };
        /**
         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns
         * null when there is no collision;
         * @method collides
         * @param actor {Actor} The other actor to test
         * @returns Vector
         */
        Actor.prototype.collides = function (actor) {
            var bounds = this.getBounds();
            var otherBounds = actor.getBounds();
            var intersect = bounds.collides(otherBounds);
            return intersect;
        };
        /**
         * Register a handler to fire when this actor collides with another in a specified group
         * @method onCollidesWith
         * @param group {string} The group name to listen for
         * @param func {callback} The callback to fire on collision with another actor from the group. The callback is passed the other actor.
         */
        Actor.prototype.onCollidesWith = function (group, func) {
            if (!this._collisionHandlers[group]) {
                this._collisionHandlers[group] = [];
            }
            this._collisionHandlers[group].push(func);
        };
        Actor.prototype.getCollisionHandlers = function () {
            return this._collisionHandlers;
        };
        /**
         * Removes all collision handlers for this group on this actor
         * @method removeCollidesWith
         * @param group {string} Group to remove all handlers for on this actor.
         */
        Actor.prototype.removeCollidesWith = function (group) {
            this._collisionHandlers[group] = [];
        };
        /**
         * Returns true if the two actors are less than or equal to the distance specified from each other
         * @method within
         * @param actor {Actor} Actor to test
         * @param distance {number} Distance in pixels to test
         * @returns boolean
         */
        Actor.prototype.within = function (actor, distance) {
            return Math.sqrt(Math.pow(this.x - actor.x, 2) + Math.pow(this.y - actor.y, 2)) <= distance;
        };
        /**
         * Clears all queued actions from the Actor
         * @method clearActions
         */
        Actor.prototype.clearActions = function () {
            this.actionQueue.clearActions();
        };
        Actor.prototype.easeTo = function (x, y, duration, easingFcn) {
            if (easingFcn === void 0) { easingFcn = ex.EasingFunctions.Linear; }
            this.actionQueue.add(new ex.Internal.Actions.EaseTo(this, x, y, duration, easingFcn));
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position at the
         * speed specified (in pixels per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @method moveTo
         * @param x {number} The x location to move the actor to
         * @param y {number} The y location to move the actor to
         * @param speed {number} The speed in pixels per second to move
         * @returns Actor
         */
        Actor.prototype.moveTo = function (x, y, speed) {
            this.actionQueue.add(new ex.Internal.Actions.MoveTo(this, x, y, speed));
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position by a
         * certain time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @method moveBy
         * @param x {number} The x location to move the actor to
         * @param y {number} The y location to move the actor to
         * @param time {number} The time it should take the actor to move to the new location in milliseconds
         * @returns Actor
         */
        Actor.prototype.moveBy = function (x, y, time) {
            this.actionQueue.add(new ex.Internal.Actions.MoveBy(this, x, y, time));
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle at the speed
         * specified (in radians per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @method rotateTo
         * @param angleRadians {number} The angle to rotate to in radians
         * @param speed {number} The angular velocity of the rotation specified in radians per second
         * @returns Actor
         */
        Actor.prototype.rotateTo = function (angleRadians, speed) {
            this.actionQueue.add(new ex.Internal.Actions.RotateTo(this, angleRadians, speed));
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle by a certain
         * time (in milliseconds) and return back the actor. This method is part
         * of the actor 'Action' fluent API allowing action chaining.
         * @method rotateBy
         * @param angleRadians {number} The angle to rotate to in radians
         * @param time {number} The time it should take the actor to complete the rotation in milliseconds
         * @returns Actor
         */
        Actor.prototype.rotateBy = function (angleRadians, time) {
            this.actionQueue.add(new ex.Internal.Actions.RotateBy(this, angleRadians, time));
            return this;
        };
        /**
         * This method will scale an actor to the specified size at the speed
         * specified (in magnitude increase per second) and return back the
         * actor. This method is part of the actor 'Action' fluent API allowing
         * action chaining.
         * @method scaleTo
         * @param size {number} The scaling factor to apply
         * @param speed {number} The speed of scaling specified in magnitude increase per second
         * @returns Actor
         */
        Actor.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {
            this.actionQueue.add(new ex.Internal.Actions.ScaleTo(this, sizeX, sizeY, speedX, speedY));
            return this;
        };
        /**
         * This method will scale an actor to the specified size by a certain time
         * (in milliseconds) and return back the actor. This method is part of the
         * actor 'Action' fluent API allowing action chaining.
         * @method scaleBy
         * @param size {number} The scaling factor to apply
         * @param time {number} The time it should take to complete the scaling in milliseconds
         * @returns Actor
         */
        Actor.prototype.scaleBy = function (sizeX, sizeY, time) {
            this.actionQueue.add(new ex.Internal.Actions.ScaleBy(this, sizeX, sizeY, time));
            return this;
        };
        /**
         * This method will cause an actor to blink (become visible and not
         * visible). Optionally, you may specify the number of blinks. Specify the amount of time
         * the actor should be visible per blink, and the amount of time not visible.
         * This method is part of the actor 'Action' fluent API allowing action chaining.
         * @method blink
         * @param timeVisible {number} The amount of time to stay visible per blink in milliseconds
         * @param timeNotVisible {number} The amount of time to stay not visible per blink in milliseconds
         * @param [numBlinks] {number} The number of times to blink
         * @returns Actor
         */
        Actor.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            this.actionQueue.add(new ex.Internal.Actions.Blink(this, timeVisible, timeNotVisible, numBlinks));
            return this;
        };
        /**
         * This method will cause an actor's opacity to change from its current value
         * to the provided value by a specified time (in milliseconds). This method is
         * part of the actor 'Action' fluent API allowing action chaining.
         * @method fade
         * @param opacity {number} The ending opacity
         * @param time {number} The time it should take to fade the actor (in milliseconds)
         * @returns Actor
         */
        Actor.prototype.fade = function (opacity, time) {
            this.actionQueue.add(new ex.Internal.Actions.Fade(this, opacity, time));
            return this;
        };
        /**
         * This method will delay the next action from executing for a certain
         * amount of time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @method delay
         * @param time {number} The amount of time to delay the next action in the queue from executing in milliseconds
         * @returns Actor
         */
        Actor.prototype.delay = function (time) {
            this.actionQueue.add(new ex.Internal.Actions.Delay(this, time));
            return this;
        };
        /**
         * This method will add an action to the queue that will remove the actor from the
         * scene once it has completed its previous actions. Any actions on the
         * action queue after this action will not be executed.
         * @method die
         * @returns Actor
         */
        Actor.prototype.die = function () {
            this.actionQueue.add(new ex.Internal.Actions.Die(this));
            return this;
        };
        /**
         * This method allows you to call an arbitrary method as the next action in the
         * action queue. This is useful if you want to execute code in after a specific
         * action, i.e An actor arrives at a destinatino after traversing a path
         * @method callMethod
         * @returns Actor
         */
        Actor.prototype.callMethod = function (method) {
            this.actionQueue.add(new ex.Internal.Actions.CallMethod(this, method));
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions a certain number of times. If the number of repeats
         * is not specified it will repeat forever. This method is part of
         * the actor 'Action' fluent API allowing action chaining
         * @method repeat
         * @param [times=undefined] {number} The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions will repeat forever
         * @returns Actor
         */
        Actor.prototype.repeat = function (times) {
            if (!times) {
                this.repeatForever();
                return this;
            }
            this.actionQueue.add(new ex.Internal.Actions.Repeat(this, times, this.actionQueue.getActions()));
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions forever. This method is part of the actor 'Action'
         * fluent API allowing action chaining.
         * @method repeatForever
         * @returns Actor
         */
        Actor.prototype.repeatForever = function () {
            this.actionQueue.add(new ex.Internal.Actions.RepeatForever(this, this.actionQueue.getActions()));
            return this;
        };
        /**
         * This method will cause the actor to follow another at a specified distance
         * @method follow
         * @param actor {Actor} The actor to follow
         * @param [followDistance=currentDistance] {number} The distance to maintain when following, if not specified the actor will follow at the current distance.
         * @returns Actor
         */
        Actor.prototype.follow = function (actor, followDistance) {
            if (followDistance == undefined) {
                this.actionQueue.add(new ex.Internal.Actions.Follow(this, actor));
            }
            else {
                this.actionQueue.add(new ex.Internal.Actions.Follow(this, actor, followDistance));
            }
            return this;
        };
        /**
         * This method will cause the actor to move towards another until they
         * collide "meet" at a specified speed.
         * @method meet
         * @param actor {Actor} The actor to meet
         * @param [speed=0] {number} The speed in pixels per second to move, if not specified it will match the speed of the other actor
         * @returns Actor
         */
        Actor.prototype.meet = function (actor, speed) {
            if (speed == undefined) {
                this.actionQueue.add(new ex.Internal.Actions.Meet(this, actor));
            }
            else {
                this.actionQueue.add(new ex.Internal.Actions.Meet(this, actor, speed));
            }
            return this;
        };
        /**
         * Returns a promise that resolves when the current action queue up to now
         * is finished.
         * @method asPromise
         * @returns Promise
         */
        Actor.prototype.asPromise = function () {
            var complete = new ex.Promise();
            this.callMethod(function () {
                complete.resolve();
            });
            return complete;
        };
        Actor.prototype._getCalculatedAnchor = function () {
            return new ex.Point(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);
        };
        /**
         * Called by the Engine, updates the state of the actor
         * @method update
         * @param engine {Engine} The reference to the current game engine
         * @param delta {number} The time elapsed since the last update in milliseconds
         */
        Actor.prototype.update = function (engine, delta) {
            if (!this._isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.publish('initialize', new ex.InitializeEvent(engine));
                this._isInitialized = true;
            }
            var eventDispatcher = this.eventDispatcher;
            // Update action queue
            this.actionQueue.update(delta);
            for (var i = 0; i < this.pipeline.length; i++) {
                this.pipeline[i].update(this, engine, delta);
            }
            eventDispatcher.publish(ex.EventType[5 /* Update */], new ex.UpdateEvent(delta));
        };
        /**
         * Called by the Engine, draws the actor to the screen
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The rendering context
         * @param delta {number} The time since the last draw in milliseconds
         */
        Actor.prototype.draw = function (ctx, delta) {
            if (this.isOffScreen) {
                return;
            }
            var anchorPoint = this._getCalculatedAnchor();
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale.x, this.scale.y);
            // calculate changing opacity
            if (this.previousOpacity != this.opacity) {
                for (var drawing in this.frames) {
                    this.frames[drawing].addEffect(new ex.Effects.Opacity(this.opacity));
                }
                this.previousOpacity = this.opacity;
            }
            if (this.currentDrawing) {
                var xDiff = 0;
                var yDiff = 0;
                if (this.centerDrawingX) {
                    xDiff = (this.currentDrawing.width * this.currentDrawing.getScaleX() - this.getWidth()) / 2;
                }
                if (this.centerDrawingY) {
                    yDiff = (this.currentDrawing.height * this.currentDrawing.getScaleY() - this.getHeight()) / 2;
                }
                this.currentDrawing.draw(ctx, -xDiff - anchorPoint.x, -yDiff - anchorPoint.y);
            }
            else {
                if (this.color) {
                    ctx.fillStyle = this.color.toString();
                    ctx.fillRect(-anchorPoint.x, -anchorPoint.y, this.width, this.height);
                }
            }
            this.sceneNode.draw(ctx, delta);
            ctx.restore();
        };
        /**
         * Called by the Engine, draws the actors debugging to the screen
         * @method debugDraw
         * @param ctx {CanvasRenderingContext2D} The rendering context
         */
        Actor.prototype.debugDraw = function (ctx) {
            var bb = this.getBounds();
            bb.debugDraw(ctx);
            ctx.fillStyle = ex.Color.Yellow.toString();
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        /**
         * Indicates the next id to be set
         */
        Actor.maxId = 0;
        return Actor;
    })(ex.Class);
    ex.Actor = Actor;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Logging level that Excalibur will tag
     * @class LogLevel
     */
    (function (LogLevel) {
        /**
         @property Debug {LogLevel}
         @static
         @final
         */
        /**
        @property Info {LogLevel}
        @static
        @final
        */
        /**
        @property Warn {LogLevel}
        @static
        @final
        */
        /**
        @property Error {LogLevel}
        @static
        @final
        */
        /**
        @property Fatal {LogLevel}
        @static
        @final
        */
        LogLevel[LogLevel["Debug"] = 0] = "Debug";
        LogLevel[LogLevel["Info"] = 1] = "Info";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
    })(ex.LogLevel || (ex.LogLevel = {}));
    var LogLevel = ex.LogLevel;
    /**
     * Static singleton that represents the logging facility for Excalibur.
     * Excalibur comes built-in with a ConsoleAppender and ScreenAppender.
     * Derive from IAppender to create your own logging appenders.
     * @class Logger
     * @static
     */
    var Logger = (function () {
        function Logger() {
            this.appenders = [];
            /**
             * Gets or sets the default logging level. Excalibur will only log
             * messages if equal to or above this level.
             * @property defaultLevel {LogLevel}
             */
            this.defaultLevel = 1 /* Info */;
            if (Logger._instance) {
                throw new Error("Logger is a singleton");
            }
            Logger._instance = this;
            // Default console appender
            Logger._instance.addAppender(new ConsoleAppender());
            return Logger._instance;
        }
        /**
         * Gets the current static instance of Logger
         * @method getInstance
         * @static
         * @returns Logger
         */
        Logger.getInstance = function () {
            if (Logger._instance == null) {
                Logger._instance = new Logger();
            }
            return Logger._instance;
        };
        /**
         * Adds a new IAppender to the list of appenders to write to
         * @method addAppender
         * @param appender {IAppender} Appender to add
         */
        Logger.prototype.addAppender = function (appender) {
            this.appenders.push(appender);
        };
        /**
         * Clears all appenders from the logger
         * @method clearAppenders
         */
        Logger.prototype.clearAppenders = function () {
            this.appenders.length = 0;
        };
        /**
         * Logs a message at a given LogLevel
         * @method _log
         * @private
         * @param level {LogLevel}The LogLevel`to log the message at
         * @param args An array of arguments to write to an appender
         */
        Logger.prototype._log = function (level, args) {
            var _this = this;
            if (level == null) {
                level = this.defaultLevel;
            }
            this.appenders.forEach(function (appender) {
                if (level >= _this.defaultLevel) {
                    appender.log(level, args);
                }
            });
        };
        /**
         * Writes a log message at the LogLevel.Debug level
         * @method debug
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(0 /* Debug */, args);
        };
        /**
         * Writes a log message at the LogLevel.Info level
         * @method info
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(1 /* Info */, args);
        };
        /**
         * Writes a log message at the LogLevel.Warn level
         * @method warn
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(2 /* Warn */, args);
        };
        /**
         * Writes a log message at the LogLevel.Error level
         * @method error
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(3 /* Error */, args);
        };
        /**
         * Writes a log message at the LogLevel.Fatal level
         * @method fatal
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.fatal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(4 /* Fatal */, args);
        };
        Logger._instance = null;
        return Logger;
    })();
    ex.Logger = Logger;
    /**
     * Console appender for browsers (i.e. console.log)
     * @class ConsoleAppender
     * @constructor
     * @extends IAppender
     */
    var ConsoleAppender = (function () {
        function ConsoleAppender() {
        }
        ConsoleAppender.prototype.log = function (level, args) {
            // Check for console support
            if (!console && !console.log && console.warn && console.error) {
                // todo maybe do something better than nothing
                return;
            }
            // Create a new console args array
            var consoleArgs = [];
            consoleArgs.unshift.apply(consoleArgs, args);
            consoleArgs.unshift("[" + LogLevel[level] + "] : ");
            if (level < 2 /* Warn */) {
                // Call .log for Debug/Info
                if (console.log.apply) {
                    // this is required on some older browsers that don't support apply on console.log :(
                    console.log.apply(console, consoleArgs);
                }
                else {
                    console.log(consoleArgs.join(' '));
                }
            }
            else if (level < 3 /* Error */) {
                // Call .warn for Warn
                if (console.warn.apply) {
                    console.warn.apply(console, consoleArgs);
                }
                else {
                    console.warn(consoleArgs.join(' '));
                }
            }
            else {
                // Call .error for Error/Fatal
                if (console.error.apply) {
                    console.error.apply(console, consoleArgs);
                }
                else {
                    console.error(consoleArgs.join(' '));
                }
            }
        };
        return ConsoleAppender;
    })();
    ex.ConsoleAppender = ConsoleAppender;
    /**
     * On-screen (canvas) appender
     * @todo Clean this up
     * @class ScreenAppender
     * @extends IAppender
     * @constructor
     * @param width {number} Width of the screen appender in pixels
     * @param height {number} Height of the screen appender in pixels
     */
    var ScreenAppender = (function () {
        function ScreenAppender(width, height) {
            this._messages = [];
            this.canvas = document.createElement('canvas');
            this.canvas.width = width || window.innerWidth;
            this.canvas.height = height || window.innerHeight;
            this.canvas.style.position = 'absolute';
            this.ctx = this.canvas.getContext('2d');
            document.body.appendChild(this.canvas);
        }
        ScreenAppender.prototype.log = function (level, args) {
            var message = args.join(",");
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this._messages.unshift("[" + LogLevel[level] + "] : " + message);
            var pos = 10;
            var opacity = 1.0;
            for (var i = 0; i < this._messages.length; i++) {
                this.ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
                this.ctx.fillText(this._messages[i], 200, pos);
                pos += 10;
                opacity = opacity > 0 ? opacity - .05 : 0;
            }
        };
        return ScreenAppender;
    })();
    ex.ScreenAppender = ScreenAppender;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Actor.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    /**
     * An enum representing all of the built in event types for Excalibur
     * @class EventType
     */
    (function (EventType) {
        /**
        @property UserEvent {EventType}
        @static
        @final
        */
        /**
        @property Blur {EventType}
        @static
        @final
        */
        /**
        @property Focus {EventType}
        @static
        @final
        */
        /**
        @property Update {EventType}
        @static
        @final
        */
        /**
        @property EnterViewPort {EventType}
        @static
        @final
        */
        /**
        @property ExitViewPort {EventType}
        @static
        @final
        */
        /**
        @property Activate {EventType}
        @static
        @final
        */
        /**
        @property Deactivate {EventType}
        @static
        @final
        */
        /**
        @property Initialize {EventType}
        @static
        @final
        */
        EventType[EventType["Collision"] = 0] = "Collision";
        EventType[EventType["EnterViewPort"] = 1] = "EnterViewPort";
        EventType[EventType["ExitViewPort"] = 2] = "ExitViewPort";
        EventType[EventType["Blur"] = 3] = "Blur";
        EventType[EventType["Focus"] = 4] = "Focus";
        EventType[EventType["Update"] = 5] = "Update";
        EventType[EventType["Activate"] = 6] = "Activate";
        EventType[EventType["Deactivate"] = 7] = "Deactivate";
        EventType[EventType["Initialize"] = 8] = "Initialize";
    })(ex.EventType || (ex.EventType = {}));
    var EventType = ex.EventType;
    /**
     * Base event type in Excalibur that all other event types derive from.
     *
     * @class GameEvent
     * @constructor
     * @param target {any} Events can have target game object, like the Engine, or an Actor.
     */
    var GameEvent = (function () {
        function GameEvent() {
        }
        return GameEvent;
    })();
    ex.GameEvent = GameEvent;
    /**
     * Event received by the Engine when the browser window is visible
     *
     * @class VisibleEvent
     * @extends GameEvent
     * @constructor
     */
    var VisibleEvent = (function (_super) {
        __extends(VisibleEvent, _super);
        function VisibleEvent() {
            _super.call(this);
        }
        return VisibleEvent;
    })(GameEvent);
    ex.VisibleEvent = VisibleEvent;
    /**
     * Event received by the Engine when the browser window is hidden
     *
     * @class HiddenEvent
     * @extends GameEvent
     * @constructor
     */
    var HiddenEvent = (function (_super) {
        __extends(HiddenEvent, _super);
        function HiddenEvent() {
            _super.call(this);
        }
        return HiddenEvent;
    })(GameEvent);
    ex.HiddenEvent = HiddenEvent;
    /**
     * Event thrown on an actor when a collision has occured
     *
     * @class CollisionEvent
     * @extends GameEvent
     * @constructor
     * @param actor {Actor} The actor the event was thrown on
     * @param other {Actor} The actor that was collided with
     * @param side {Side} The side that was collided with
     */
    var CollisionEvent = (function (_super) {
        __extends(CollisionEvent, _super);
        function CollisionEvent(actor, other, side, intersection) {
            _super.call(this);
            this.actor = actor;
            this.other = other;
            this.side = side;
            this.intersection = intersection;
        }
        return CollisionEvent;
    })(GameEvent);
    ex.CollisionEvent = CollisionEvent;
    /**
     * Event thrown on a game object on Excalibur update
     *
     * @class UpdateEvent
     * @extends GameEvent
     * @constructor
     * @param delta {number} The number of milliseconds since the last update
     */
    var UpdateEvent = (function (_super) {
        __extends(UpdateEvent, _super);
        function UpdateEvent(delta) {
            _super.call(this);
            this.delta = delta;
        }
        return UpdateEvent;
    })(GameEvent);
    ex.UpdateEvent = UpdateEvent;
    /**
     * Event thrown on an Actor only once before the first update call
     *
     * @class InitializeEvent
     * @extends GameEvent
     * @constructor
     * @param engine {Engine} The reference to the current engine
     */
    var InitializeEvent = (function (_super) {
        __extends(InitializeEvent, _super);
        function InitializeEvent(engine) {
            _super.call(this);
            this.engine = engine;
        }
        return InitializeEvent;
    })(GameEvent);
    ex.InitializeEvent = InitializeEvent;
    /**
     * Event thrown on a Scene on activation
     *
     * @class ActivateEvent
     * @extends GameEvent
     * @constructor
     * @param oldScene {Scene} The reference to the old scene
     */
    var ActivateEvent = (function (_super) {
        __extends(ActivateEvent, _super);
        function ActivateEvent(oldScene) {
            _super.call(this);
            this.oldScene = oldScene;
        }
        return ActivateEvent;
    })(GameEvent);
    ex.ActivateEvent = ActivateEvent;
    /**
     * Event thrown on a Scene on deactivation
     *
     * @class DeactivateEvent
     * @extends GameEvent
     * @constructor
     * @param newScene {Scene} The reference to the new scene
     */
    var DeactivateEvent = (function (_super) {
        __extends(DeactivateEvent, _super);
        function DeactivateEvent(newScene) {
            _super.call(this);
            this.newScene = newScene;
        }
        return DeactivateEvent;
    })(GameEvent);
    ex.DeactivateEvent = DeactivateEvent;
    /**
     * Event thrown on an Actor when it completely leaves the screen.
     * @class ExitViewPortEvent
     * @constructor
     */
    var ExitViewPortEvent = (function (_super) {
        __extends(ExitViewPortEvent, _super);
        function ExitViewPortEvent() {
            _super.call(this);
        }
        return ExitViewPortEvent;
    })(GameEvent);
    ex.ExitViewPortEvent = ExitViewPortEvent;
    /**
     * Event thrown on an Actor when it completely leaves the screen.
     * @class EnterViewPortEvent
     * @constructor
     */
    var EnterViewPortEvent = (function (_super) {
        __extends(EnterViewPortEvent, _super);
        function EnterViewPortEvent() {
            _super.call(this);
        }
        return EnterViewPortEvent;
    })(GameEvent);
    ex.EnterViewPortEvent = EnterViewPortEvent;
    /**
     * Enum representing the different mouse buttons
     * @class MouseButton
     */
    (function (MouseButton) {
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Left"] = 0] = "Left";
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Middle"] = 1] = "Middle";
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Right"] = 2] = "Right";
    })(ex.MouseButton || (ex.MouseButton = {}));
    var MouseButton = ex.MouseButton;
})(ex || (ex = {}));
/// <reference path="Events.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur's internal event dispatcher implementation. Callbacks are fired immediately after an event is published
     * @class EventDispatcher
     * @constructor
     * @param target {any} The object that will be the recipient of events from this event dispatcher
     */
    var EventDispatcher = (function () {
        function EventDispatcher(target) {
            this._handlers = {};
            this.log = ex.Logger.getInstance();
            this.target = target;
        }
        /**
         * Publish an event for target
         * @method publish
         * @param eventName {string} The name of the event to publish
         * @param [event=undefined] {GameEvent} Optionally pass an event data object to the handler
         */
        EventDispatcher.prototype.publish = function (eventName, event) {
            if (!eventName) {
                // key not mapped
                return;
            }
            eventName = eventName.toLowerCase();
            var target = this.target;
            if (!event) {
                event = new ex.GameEvent();
            }
            event.target = target;
            if (this._handlers[eventName]) {
                this._handlers[eventName].forEach(function (callback) {
                    callback.call(target, event);
                });
            }
        };
        /**
         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
         * @method subscribe
         * @param eventName {string} The name of the event to subscribe to
         * @param handler {GameEvent=>void} The handler callback to fire on this event
         */
        EventDispatcher.prototype.subscribe = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            if (!this._handlers[eventName]) {
                this._handlers[eventName] = [];
            }
            this._handlers[eventName].push(handler);
        };
        /**
         * Unsubscribe a event handler(s) from an event. If a specific handler
         * is specified for an event, only that handler will be unsubscribed.
         * Otherwise all handlers will be unsubscribed for that event.
         * @method unsubscribe
         * @param eventName {string} The name of the event to unsubscribe
         * @param [handler=undefined] Optionally the specific handler to unsubscribe
         *
         */
        EventDispatcher.prototype.unsubscribe = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            var eventHandlers = this._handlers[eventName];
            if (eventHandlers) {
                // if no explicit handler is give with the event name clear all handlers
                if (!handler) {
                    this._handlers[eventName].length = 0;
                }
                else {
                    var index = eventHandlers.indexOf(handler);
                    if (index < 0)
                        return;
                    this._handlers[eventName].splice(index, 1);
                }
            }
        };
        return EventDispatcher;
    })();
    ex.EventDispatcher = EventDispatcher;
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Color = (function () {
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @class Color
         * @constructor
         * @param r {number} The red component of color (0-255)
         * @param g {number} The green component of color (0-255)
         * @param b {number} The blue component of color (0-255)
         * @param [a=1] {number} The alpha component of color (0-1.0)
         */
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            this.a = (a != null ? a : 1);
        }
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @method fromRGB
         * @static
         * @param r {number} The red component of color (0-255)
         * @param g {number} The green component of color (0-255)
         * @param b {number} The blue component of color (0-255)
         * @param [a=1] {number} The alpha component of color (0-1.0)
         */
        Color.fromRGB = function (r, g, b, a) {
            return new Color(r, g, b, a);
        };
        /**
         * Creates a new inscance of Color from a hex string
         *
         * @method fromHex
         * @static
         * @param hex {string} CSS color string of the form #ffffff, the alpha component is optional
         */
        Color.fromHex = function (hex) {
            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
            var match = null;
            if (match = hex.match(hexRegEx)) {
                var r = parseInt(match[1], 16);
                var g = parseInt(match[2], 16);
                var b = parseInt(match[3], 16);
                var a = 1;
                if (match[4]) {
                    a = parseInt(match[4], 16) / 255;
                }
                return new Color(r, g, b, a);
            }
            else {
                throw new Error("Invalid hex string: " + hex);
            }
        };
        /**
         * Returns a CSS string representation of a color.
         * @method toString
         * @returns string
         */
        Color.prototype.toString = function () {
            var result = String(this.r.toFixed(0)) + ", " + String(this.g.toFixed(0)) + ", " + String(this.b.toFixed(0));
            if (this.a !== undefined || this.a !== null) {
                return "rgba(" + result + ", " + String(this.a) + ")";
            }
            return "rgb(" + result + ")";
        };
        /**
         * Returns a CSS string representation of a color.
         * @method fillStyle
         * @returns string
         */
        Color.prototype.fillStyle = function () {
            return this.toString();
        };
        /**
         * Returns a clone of the current color.
         * @method clone
         * @returns Color
         */
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        /**
         * Color constant
         * @property Black {ex.Color}
         * @static
         * @final
         */
        Color.Black = Color.fromHex('#000000');
        /**
         * Color constant
         * @property White {ex.Color}
         * @static
         * @final
         */
        Color.White = Color.fromHex('#FFFFFF');
        /**
         * Color constant
         * @property Gray {ex.Color}
         * @static
         * @final
         */
        Color.Gray = Color.fromHex('#808080');
        /**
         * Color constant
         * @property LightGray {ex.Color}
         * @static
         * @final
         */
        Color.LightGray = Color.fromHex('#D3D3D3');
        /**
         * Color constant
         * @property DarkGray {ex.Color}
         * @static
         * @final
         */
        Color.DarkGray = Color.fromHex('#A9A9A9');
        /**
         * Color constant
         * @property Yellow {ex.Color}
         * @static
         * @final
         */
        Color.Yellow = Color.fromHex('#FFFF00');
        /**
         * Color constant
         * @property Orange {ex.Color}
         * @static
         * @final
         */
        Color.Orange = Color.fromHex('#FFA500');
        /**
         * Color constant
         * @property Red {ex.Color}
         * @static
         * @final
         */
        Color.Red = Color.fromHex('#FF0000');
        /**
         * Color constant
         * @property Vermillion {ex.Color}
         * @static
         * @final
         */
        Color.Vermillion = Color.fromHex('#FF5B31');
        /**
         * Color constant
         * @property Rose {ex.Color}
         * @static
         * @final
         */
        Color.Rose = Color.fromHex('#FF007F');
        /**
         * Color constant
         * @property Magenta {ex.Color}
         * @static
         * @final
         */
        Color.Magenta = Color.fromHex('#FF00FF');
        /**
         * Color constant
         * @property Violet {ex.Color}
         * @static
         * @final
         */
        Color.Violet = Color.fromHex('#7F00FF');
        /**
         * Color constant
         * @property Blue {ex.Color}
         * @static
         * @final
         */
        Color.Blue = Color.fromHex('#0000FF');
        /**
         * Color constant
         * @property Azure {ex.Color}
         * @static
         * @final
         */
        Color.Azure = Color.fromHex('#007FFF');
        /**
         * Color constant
         * @property Cyan {ex.Color}
         * @static
         * @final
         */
        Color.Cyan = Color.fromHex('#00FFFF');
        /**
         * Color constant
         * @property Viridian {ex.Color}
         * @static
         * @final
         */
        Color.Viridian = Color.fromHex('#59978F');
        /**
         * Color constant
         * @property Green {ex.Color}
         * @static
         * @final
         */
        Color.Green = Color.fromHex('#00FF00');
        /**
         * Color constant
         * @property Chartreuse {ex.Color}
         * @static
         * @final
         */
        Color.Chartreuse = Color.fromHex('#7FFF00');
        /**
         * Color constant
         * @property Transparent {ex.Color}
         * @static
         * @final
         */
        Color.Transparent = Color.fromHex('#FFFFFF00');
        return Color;
    })();
    ex.Color = Color;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * Helper Actor primitive for drawing UI's, optimized for UI drawing. Does
     * not participate in collisions.
     * @class UIActor
     * @extends Actor
     * @constructor
     * @param [x=0.0] {number} The starting x coordinate of the actor
     * @param [y=0.0] {number} The starting y coordinate of the actor
     * @param [width=0.0] {number} The starting width of the actor
     * @param [height=0.0] {number} The starting height of the actor
     */
    var UIActor = (function (_super) {
        __extends(UIActor, _super);
        function UIActor(x, y, width, height) {
            _super.call(this, x, y, width, height);
            this.pipeline = [];
            this.pipeline.push(new ex.MovementModule());
            this.pipeline.push(new ex.CapturePointerModule());
            this.anchor.setTo(0, 0);
            this.collisionType = 0 /* PreventCollision */;
            this.enableCapturePointer = true;
        }
        UIActor.prototype.onInitialize = function (engine) {
            this._engine = engine;
        };
        UIActor.prototype.contains = function (x, y, useWorld) {
            if (useWorld === void 0) { useWorld = true; }
            if (useWorld)
                return _super.prototype.contains.call(this, x, y);
            var coords = this._engine.worldToScreenCoordinates(new ex.Point(x, y));
            return _super.prototype.contains.call(this, coords.x, coords.y);
        };
        return UIActor;
    })(ex.Actor);
    ex.UIActor = UIActor;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
/// <reference path="Engine.ts" />
var ex;
(function (ex) {
    /**
     * Triggers a method of firing arbitrary code on collision. These are useful
     * as 'buttons', 'switches', or to trigger effects in a game. By defualt triggers
     * are invisible, and can only be seen with debug mode enabled on the Engine.
     * @class Trigger
     * @constructor
     * @param [x=0] {number} The x position of the trigger
     * @param [y=0] {number} The y position of the trigger
     * @param [width=0] {number} The width of the trigger
     * @param [height=0] {number} The height of the trigger
     * @param [action=null] {()=>void} Callback to fire when trigger is activated
     * @param [repeats=1] {number} The number of times that this trigger should fire, by default it is 1, if -1 is supplied it will fire indefinitely
     */
    var Trigger = (function (_super) {
        __extends(Trigger, _super);
        function Trigger(x, y, width, height, action, repeats) {
            _super.call(this, x, y, width, height);
            this.action = function () {
            };
            this.repeats = 1;
            this.target = null;
            this.repeats = repeats || this.repeats;
            this.action = action || this.action;
            this.collisionType = 0 /* PreventCollision */;
            this.eventDispatcher = new ex.EventDispatcher(this);
            this.actionQueue = new ex.Internal.Actions.ActionQueue(this);
        }
        Trigger.prototype.update = function (engine, delta) {
            // Update action queue
            this.actionQueue.update(delta);
            // Update placements based on linear algebra
            this.x += this.dx * delta / 1000;
            this.y += this.dy * delta / 1000;
            this.rotation += this.rx * delta / 1000;
            this.scale.x += this.sx * delta / 1000;
            this.scale.y += this.sy * delta / 1000;
            // check for trigger collisions
            if (this.target) {
                if (this.collides(this.target)) {
                    this.dispatchAction();
                }
            }
            else {
                for (var i = 0; i < engine.currentScene.children.length; i++) {
                    var other = engine.currentScene.children[i];
                    if (other !== this && other.collisionType !== 0 /* PreventCollision */ && this.collides(other)) {
                        this.dispatchAction();
                    }
                }
            }
            // remove trigger if its done, -1 repeat forever
            if (this.repeats === 0) {
                this.kill();
            }
        };
        Trigger.prototype.dispatchAction = function () {
            this.action.call(this);
            this.repeats--;
        };
        Trigger.prototype.draw = function (ctx, delta) {
            // does not draw
            return;
        };
        Trigger.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            // Meant to draw debug information about actors
            ctx.save();
            ctx.translate(this.x, this.y);
            var bb = this.getBounds();
            bb.left = bb.left - this.getGlobalX();
            bb.right = bb.right - this.getGlobalX();
            bb.top = bb.top - this.getGlobalY();
            bb.bottom = bb.bottom - this.getGlobalY();
            // Currently collision primitives cannot rotate 
            // ctx.rotate(this.rotation);
            ctx.fillStyle = ex.Color.Violet.toString();
            ctx.strokeStyle = ex.Color.Violet.toString();
            ctx.fillText('Trigger', 10, 10);
            bb.debugDraw(ctx);
            ctx.restore();
        };
        return Trigger;
    })(ex.Actor);
    ex.Trigger = Trigger;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Algebra.ts" />
/// <reference path="Util.ts" />
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * An enum that represents the types of emitter nozzles
     * @class EmitterType
     */
    (function (EmitterType) {
        /**
         * Constant for the circular emitter type
         * @property Circle {EmitterType}
         */
        EmitterType[EmitterType["Circle"] = 0] = "Circle";
        /**
         * Constant for the rectangular emitter type
         * @property Rectangle {EmitterType}
         */
        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
    })(ex.EmitterType || (ex.EmitterType = {}));
    var EmitterType = ex.EmitterType;
    var Particle = (function () {
        function Particle(emitter, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            this.position = new ex.Vector(0, 0);
            this.velocity = new ex.Vector(0, 0);
            this.acceleration = new ex.Vector(0, 0);
            this.particleRotationalVelocity = 0;
            this.currentRotation = 0;
            this.focus = null;
            this.focusAccel = 0;
            this.opacity = 1;
            this.beginColor = ex.Color.White.clone();
            this.endColor = ex.Color.White.clone();
            // Life is counted in ms
            this.life = 300;
            this.fadeFlag = false;
            // Color transitions
            this.rRate = 1;
            this.gRate = 1;
            this.bRate = 1;
            this.aRate = 0;
            this.currentColor = ex.Color.White.clone();
            this.emitter = null;
            this.particleSize = 5;
            this.particleSprite = null;
            this.sizeRate = 0;
            this.elapsedMultiplier = 0;
            this.emitter = emitter;
            this.life = life || this.life;
            this.opacity = opacity || this.opacity;
            this.endColor = endColor || this.endColor.clone();
            this.beginColor = beginColor || this.beginColor.clone();
            this.currentColor = this.beginColor.clone();
            this.position = position || this.position;
            this.velocity = velocity || this.velocity;
            this.acceleration = acceleration || this.acceleration;
            this.rRate = (this.endColor.r - this.beginColor.r) / this.life;
            this.gRate = (this.endColor.g - this.beginColor.g) / this.life;
            this.bRate = (this.endColor.b - this.beginColor.b) / this.life;
            this.aRate = this.opacity / this.life;
            this.startSize = startSize || 0;
            this.endSize = endSize || 0;
            if ((this.endSize > 0) && (this.startSize > 0)) {
                this.sizeRate = (this.endSize - this.startSize) / this.life;
                this.particleSize = this.startSize;
            }
        }
        Particle.prototype.kill = function () {
            this.emitter.removeParticle(this);
        };
        Particle.prototype.update = function (delta) {
            this.life = this.life - delta;
            this.elapsedMultiplier = this.elapsedMultiplier + delta;
            if (this.life < 0) {
                this.kill();
            }
            if (this.fadeFlag) {
                this.opacity = ex.Util.clamp(this.aRate * this.life, 0.0001, 1);
            }
            if ((this.startSize > 0) && (this.endSize > 0)) {
                this.particleSize = ex.Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
            }
            this.currentColor.r = ex.Util.clamp(this.currentColor.r + this.rRate * delta, 0, 255);
            this.currentColor.g = ex.Util.clamp(this.currentColor.g + this.gRate * delta, 0, 255);
            this.currentColor.b = ex.Util.clamp(this.currentColor.b + this.bRate * delta, 0, 255);
            this.currentColor.a = ex.Util.clamp(this.opacity, 0.0001, 1);
            if (this.focus) {
                var accel = this.focus.minus(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);
                this.velocity = this.velocity.add(accel);
            }
            else {
                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
            }
            this.position = this.position.add(this.velocity.scale(delta / 1000));
            if (this.particleRotationalVelocity) {
                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);
            }
        };
        Particle.prototype.draw = function (ctx) {
            if (this.particleSprite) {
                this.particleSprite.setRotation(this.currentRotation);
                this.particleSprite.setScaleX(this.particleSize);
                this.particleSprite.setScaleY(this.particleSize);
                this.particleSprite.draw(ctx, this.position.x, this.position.y);
                return;
            }
            this.currentColor.a = ex.Util.clamp(this.opacity, 0.0001, 1);
            ctx.fillStyle = this.currentColor.toString();
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };
        return Particle;
    })();
    ex.Particle = Particle;
    /**
     * Using a particle emitter is a great way to create interesting effects
     * in your game, like smoke, fire, water, explosions, etc. Particle Emitters
     * extend Actor allowing you to use all of the features that come with Actor
     * @class ParticleEmitter
     * @constructor
     * @param [x=0] {number} The x position of the emitter
     * @param [y=0] {number} The y position of the emitter
     * @param [width=0] {number} The width of the emitter
     * @param [height=0] {number} The height of the emitter
     */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        function ParticleEmitter(x, y, width, height) {
            _super.call(this, x, y, width, height, ex.Color.White);
            this._particlesToEmit = 0;
            this.numParticles = 0;
            /**
             * Gets or sets the isEmitting flag
             * @property isEmitting {boolean}
             */
            this.isEmitting = true;
            /**
             * Gets or sets the backing particle collection
             * @property particles {Util.Collection&lt;Particle&gt;}
             */
            this.particles = null;
            /**
             * Gets or sets the backing deadParticle collection
             * @property particles {Util.Collection&lt;Particle&gt;}
             */
            this.deadParticles = null;
            /**
             * Gets or sets the minimum partical velocity
             * @property [minVel=0] {number}
             */
            this.minVel = 0;
            /**
             * Gets or sets the maximum partical velocity
             * @property [maxVel=0] {number}
             */
            this.maxVel = 0;
            /**
             * Gets or sets the acceleration vector for all particles
             * @property [acceleration=new Vector(0,0)] {Vector}
             */
            this.acceleration = new ex.Vector(0, 0);
            /**
             * Gets or sets the minimum angle in radians
             * @property [minAngle=0] {number}
             */
            this.minAngle = 0;
            /**
             * Gets or sets the maximum angle in radians
             * @property [maxAngle=0] {number}
             */
            this.maxAngle = 0;
            /**
             * Gets or sets the emission rate for particles (particles/sec)
             * @property [emitRate=1] {number}
             */
            this.emitRate = 1; //particles/sec
            /**
             * Gets or sets the life of each particle in milliseconds
             * @property [particleLife=2000] {number}
             */
            this.particleLife = 2000;
            /**
             * Gets or sets the opacity of each particle from 0 to 1.0
             * @property [opacity=1.0] {number}
             */
            this.opacity = 1;
            /**
             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
             * @property [fade=false] {boolean}
             */
            this.fadeFlag = false;
            /**
             * Gets or sets the optional focus where all particles should accelerate towards
             * @property [focus=null] {Vector}
             */
            this.focus = null;
            /**
             * Gets or sets the acceleration for focusing particles if a focus has been specified
             * @property [focusAccel=1] {number}
             */
            this.focusAccel = 1;
            /*
             * Gets or sets the optional starting size for the particles
             * @property [startSize=null] {number}
             */
            this.startSize = null;
            /*
             * Gets or sets the optional ending size for the particles
             * @property [endSize=null] {number}
             */
            this.endSize = null;
            /**
             * Gets or sets the minimum size of all particles
             * @property [minSize=5] {number}
             */
            this.minSize = 5;
            /**
             * Gets or sets the maximum size of all particles
             * @property [maxSize=5] {number}
             */
            this.maxSize = 5;
            /**
             * Gets or sets the beginning color of all particles
             * @property [beginColor=Color.White] {Color}
             */
            this.beginColor = ex.Color.White;
            /**
             * Gets or sets the ending color of all particles
             * @property [endColor=Color.White] {Color}
             */
            this.endColor = ex.Color.White;
            /**
             * Gets or sets the sprite that a particle should use
             * @property [particleSprite=null] {Sprite}
             */
            this.particleSprite = null;
            /**
             * Gets or sets the emitter type for the particle emitter
             * @property [emitterType=EmitterType.Rectangle] {EmitterType}
             */
            this.emitterType = 1 /* Rectangle */;
            /**
             * Gets or sets the emitter radius, only takes effect when the emitterType is Circle
             * @property [radius=0] {number}
             */
            this.radius = 0;
            /**
             * Gets or sets the particle rotational speed velocity
             * @property [particleRotationalVelocity=0] {number}
             */
            this.particleRotationalVelocity = 0;
            /**
             * Indicates whether particles should start with a random rotation
             * @property [randomRotation=false] {boolean}
             */
            this.randomRotation = false;
            this.collisionType = 0 /* PreventCollision */;
            this.particles = new ex.Util.Collection();
            this.deadParticles = new ex.Util.Collection();
        }
        ParticleEmitter.prototype.removeParticle = function (particle) {
            this.deadParticles.push(particle);
        };
        /**
         * Causes the emitter to emit particles
         * @method emit
         * @param particleCount {number} Number of particles to emit right now
         */
        ParticleEmitter.prototype.emit = function (particleCount) {
            for (var i = 0; i < particleCount; i++) {
                this.particles.push(this.createParticle());
            }
        };
        ParticleEmitter.prototype.clearParticles = function () {
            this.particles.clear();
        };
        // Creates a new particle given the contraints of the emitter
        ParticleEmitter.prototype.createParticle = function () {
            // todo implement emitter contraints;
            var ranX = 0;
            var ranY = 0;
            var angle = ex.Util.randomInRange(this.minAngle, this.maxAngle);
            var vel = ex.Util.randomInRange(this.minVel, this.maxVel);
            var size = this.startSize || ex.Util.randomInRange(this.minSize, this.maxSize);
            var dx = vel * Math.cos(angle);
            var dy = vel * Math.sin(angle);
            if (this.emitterType === 1 /* Rectangle */) {
                ranX = ex.Util.randomInRange(this.x, this.x + this.getWidth());
                ranY = ex.Util.randomInRange(this.y, this.y + this.getHeight());
            }
            else if (this.emitterType === 0 /* Circle */) {
                var radius = ex.Util.randomInRange(0, this.radius);
                ranX = radius * Math.cos(angle) + this.x;
                ranY = radius * Math.sin(angle) + this.y;
            }
            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new ex.Vector(ranX, ranY), new ex.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
            p.fadeFlag = this.fadeFlag;
            p.particleSize = size;
            if (this.particleSprite) {
                p.particleSprite = this.particleSprite;
            }
            p.particleRotationalVelocity = this.particleRotationalVelocity;
            if (this.randomRotation) {
                p.currentRotation = ex.Util.randomInRange(0, Math.PI * 2);
            }
            if (this.focus) {
                p.focus = this.focus.add(new ex.Vector(this.x, this.y));
                p.focusAccel = this.focusAccel;
            }
            return p;
        };
        ParticleEmitter.prototype.update = function (engine, delta) {
            var _this = this;
            _super.prototype.update.call(this, engine, delta);
            if (this.isEmitting) {
                this._particlesToEmit += this.emitRate * (delta / 1000);
                var numParticles = Math.ceil(this.emitRate * delta / 1000);
                if (this._particlesToEmit > 1.0) {
                    this.emit(Math.floor(this._particlesToEmit));
                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
                }
            }
            this.particles.forEach(function (particle, index) {
                particle.update(delta);
            });
            this.deadParticles.forEach(function (particle, index) {
                _this.particles.removeElement(particle);
            });
            this.deadParticles.clear();
        };
        ParticleEmitter.prototype.draw = function (ctx, delta) {
            this.particles.forEach(function (particle, index) {
                // todo is there a more efficient to draw 
                // possibly use a webgl offscreen canvas and shaders to do particles?
                particle.draw(ctx);
            });
        };
        ParticleEmitter.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            ctx.fillStyle = ex.Color.Black.toString();
            ctx.fillText("Particles: " + this.particles.count(), this.x, this.y + 20);
            if (this.focus) {
                ctx.fillRect(this.focus.x + this.x, this.focus.y + this.y, 3, 3);
                ex.Util.drawLine(ctx, "yellow", this.focus.x + this.x, this.focus.y + this.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);
                ctx.fillText("Focus", this.focus.x + this.x, this.focus.y + this.y);
            }
        };
        return ParticleEmitter;
    })(ex.Actor);
    ex.ParticleEmitter = ParticleEmitter;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Animations allow you to display a series of images one after another,
     * creating the illusion of change. Generally these images will come from a sprite sheet source.
     * @class Animation
     * @extends IDrawable
     * @constructor
     * @param engine {Engine} Reference to the current game engine
     * @param images {Sprite[]} An array of sprites to create the frames for the animation
     * @param speed {number} The number in milliseconds to display each frame in the animation
     * @param [loop=false] {boolean} Indicates whether the animation should loop after it is completed
     */
    var Animation = (function () {
        function Animation(engine, images, speed, loop) {
            this.currIndex = 0;
            this.oldTime = Date.now();
            this.rotation = 0.0;
            this.scaleX = 1.0;
            this.scaleY = 1.0;
            /**
             * Indicates whether the animation should loop after it is completed
             * @property [loop=false] {boolean}
             */
            this.loop = false;
            this.freezeFrame = -1;
            this.flipVertical = false;
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.sprites = images;
            this.speed = speed;
            this.engine = engine;
            if (loop != null) {
                this.loop = loop;
            }
            this.height = images[0] ? images[0].height : 0;
            this.width = images[0] ? images[0].width : 0;
        }
        Animation.prototype.addEffect = function (effect) {
            for (var i in this.sprites) {
                this.sprites[i].addEffect(effect);
            }
        };
        Animation.prototype.removeEffect = function (param) {
            for (var i in this.sprites) {
                this.sprites[i].removeEffect(param);
            }
        };
        Animation.prototype.clearEffects = function () {
            for (var i in this.sprites) {
                this.sprites[i].clearEffects();
            }
        };
        Animation.prototype.transformAboutPoint = function (point) {
            for (var i in this.sprites) {
                this.sprites[i].transformAboutPoint(point);
            }
        };
        Animation.prototype.setRotation = function (radians) {
            this.rotation = radians;
            for (var i in this.sprites) {
                this.sprites[i].setRotation(radians);
            }
        };
        Animation.prototype.getRotation = function () {
            return this.rotation;
        };
        Animation.prototype.setScaleX = function (scaleX) {
            this.scaleX = scaleX;
            for (var i in this.sprites) {
                this.sprites[i].setScaleX(scaleX);
            }
        };
        Animation.prototype.setScaleY = function (scaleY) {
            this.scaleY = scaleY;
            for (var i in this.sprites) {
                this.sprites[i].setScaleY(scaleY);
            }
        };
        Animation.prototype.getScaleX = function () {
            return this.scaleX;
        };
        Animation.prototype.getScaleY = function () {
            return this.scaleY;
        };
        /**
         * Resets the animation to first frame.
         * @method reset
         */
        Animation.prototype.reset = function () {
            this.currIndex = 0;
        };
        /**
         * Indicates whether the animation is complete, animations that loop are never complete.
         * @method isDone
         * @returns boolean
         */
        Animation.prototype.isDone = function () {
            return (!this.loop && this.currIndex >= this.sprites.length);
        };
        /**
         * Not meant to be called by game developers. Ticks the animation forward internally an
         * calculates whether to change to teh frame.
         * @method tick
         */
        Animation.prototype.tick = function () {
            var time = Date.now();
            if ((time - this.oldTime) > this.speed) {
                this.currIndex = (this.loop ? (this.currIndex + 1) % this.sprites.length : this.currIndex + 1);
                this.oldTime = time;
            }
        };
        /**
         * Skips ahead a specified number of frames in the animation
         * @method skip
         * @param frames {number} Frames to skip ahead
         */
        Animation.prototype.skip = function (frames) {
            this.currIndex = (this.currIndex + frames) % this.sprites.length;
        };
        Animation.prototype.draw = function (ctx, x, y) {
            this.tick();
            if (this.currIndex < this.sprites.length) {
                var currSprite = this.sprites[this.currIndex];
                if (this.flipVertical) {
                    currSprite.flipVertical = this.flipVertical;
                }
                if (this.flipHorizontal) {
                    currSprite.flipHorizontal = this.flipHorizontal;
                }
                currSprite.draw(ctx, x, y);
            }
            if (this.freezeFrame !== -1 && this.currIndex >= this.sprites.length) {
                var currSprite = this.sprites[ex.Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];
                currSprite.draw(ctx, x, y);
            }
        };
        /**
         * Plays an animation at an arbitrary location in the game.
         * @method play
         * @param x {number} The x position in the game to play
         * @param y {number} The y position in the game to play
         */
        Animation.prototype.play = function (x, y) {
            this.reset();
            this.engine.playAnimation(this, x, y);
        };
        return Animation;
    })();
    ex.Animation = Animation;
})(ex || (ex = {}));
/// <reference path="MonkeyPatch.ts" />
/// <reference path="Util.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    var Internal;
    (function (Internal) {
        var FallbackAudio = (function () {
            function FallbackAudio(path, volume) {
                this.log = ex.Logger.getInstance();
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                if (window.AudioContext) {
                    this.log.debug("Using new Web Audio Api for " + path);
                    this.soundImpl = new WebAudio(path, volume);
                }
                else {
                    this.log.debug("Falling back to Audio Element for " + path);
                    this.soundImpl = new AudioTag(path, volume);
                }
            }
            FallbackAudio.prototype.setVolume = function (volume) {
                this.soundImpl.setVolume(volume);
            };
            FallbackAudio.prototype.setLoop = function (loop) {
                this.soundImpl.setLoop(loop);
            };
            FallbackAudio.prototype.load = function () {
                this.soundImpl.onload = this.onload;
                this.soundImpl.onprogress = this.onprogress;
                this.soundImpl.onerror = this.onerror;
                this.soundImpl.load();
            };
            FallbackAudio.prototype.isPlaying = function () {
                return this.soundImpl.isPlaying();
            };
            FallbackAudio.prototype.play = function () {
                return this.soundImpl.play();
            };
            FallbackAudio.prototype.pause = function () {
                this.soundImpl.pause();
            };
            FallbackAudio.prototype.stop = function () {
                this.soundImpl.stop();
            };
            return FallbackAudio;
        })();
        Internal.FallbackAudio = FallbackAudio;
        var AudioTag = (function () {
            function AudioTag(path, volume) {
                var _this = this;
                this.path = path;
                this.audioElements = new Array(5);
                this._loadedAudio = null;
                this.isLoaded = false;
                this.index = 0;
                this.log = ex.Logger.getInstance();
                this._isPlaying = false;
                this._currentOffset = 0;
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                for (var i = 0; i < this.audioElements.length; i++) {
                    (function (i) {
                        _this.audioElements[i] = new Audio();
                    })(i);
                }
                if (volume) {
                    this.setVolume(ex.Util.clamp(volume, 0, 1.0));
                }
                else {
                    this.setVolume(1.0);
                }
            }
            AudioTag.prototype.isPlaying = function () {
                return this._isPlaying;
            };
            AudioTag.prototype.audioLoaded = function () {
                this.isLoaded = true;
            };
            AudioTag.prototype.setVolume = function (volume) {
                this.audioElements.forEach(function (a) {
                    a.volume = volume;
                });
            };
            AudioTag.prototype.setLoop = function (loop) {
                this.audioElements.forEach(function (a) {
                    a.loop = loop;
                });
            };
            AudioTag.prototype.getLoop = function () {
                this.audioElements.some(function (a) { return a.loop; });
            };
            AudioTag.prototype.load = function () {
                var _this = this;
                var request = new XMLHttpRequest();
                request.open("GET", this.path, true);
                request.responseType = 'blob';
                request.onprogress = this.onprogress;
                request.onerror = this.onerror;
                request.onload = function (e) {
                    if (request.status !== 200) {
                        _this.log.error("Failed to load audio resource ", _this.path, " server responded with error code", request.status);
                        _this.onerror(request.response);
                        _this.isLoaded = false;
                        return;
                    }
                    _this._loadedAudio = URL.createObjectURL(request.response);
                    _this.audioElements.forEach(function (a) {
                        a.src = _this._loadedAudio;
                    });
                    _this.onload(e);
                };
                request.send();
            };
            AudioTag.prototype.play = function () {
                var _this = this;
                this.audioElements[this.index].load();
                //this.audioElements[this.index].currentTime = this._currentOffset;
                this.audioElements[this.index].play();
                this._currentOffset = 0;
                var done = new ex.Promise();
                this._isPlaying = true;
                if (!this.getLoop()) {
                    this.audioElements[this.index].addEventListener('ended', function () {
                        _this._isPlaying = false;
                        done.resolve(true);
                    });
                }
                this.index = (this.index + 1) % this.audioElements.length;
                return done;
            };
            AudioTag.prototype.pause = function () {
                this.index = (this.index - 1 + this.audioElements.length) % this.audioElements.length;
                this._currentOffset = this.audioElements[this.index].currentTime;
                this.audioElements.forEach(function (a) {
                    a.pause();
                });
                this._isPlaying = false;
            };
            AudioTag.prototype.stop = function () {
                this.audioElements.forEach(function (a) {
                    a.pause();
                    //a.currentTime = 0;
                });
                this._isPlaying = false;
            };
            return AudioTag;
        })();
        Internal.AudioTag = AudioTag;
        if (window.AudioContext) {
            var audioContext = new window.AudioContext();
        }
        var WebAudio = (function () {
            function WebAudio(soundPath, volume) {
                this.context = audioContext;
                this.volume = this.context.createGain();
                this.buffer = null;
                this.sound = null;
                this.path = "";
                this.isLoaded = false;
                this.loop = false;
                this._isPlaying = false;
                this._isPaused = false;
                this._currentOffset = 0;
                this.logger = ex.Logger.getInstance();
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                this.path = soundPath;
                if (volume) {
                    this.volume.gain.value = ex.Util.clamp(volume, 0, 1.0);
                }
                else {
                    this.volume.gain.value = 1.0; // max volume
                }
            }
            WebAudio.prototype.setVolume = function (volume) {
                this.volume.gain.value = volume;
            };
            WebAudio.prototype.load = function () {
                var _this = this;
                var request = new XMLHttpRequest();
                request.open('GET', this.path);
                request.responseType = 'arraybuffer';
                request.onprogress = this.onprogress;
                request.onerror = this.onerror;
                request.onload = function () {
                    if (request.status !== 200) {
                        _this.logger.error("Failed to load audio resource ", _this.path, " server responded with error code", request.status);
                        _this.onerror(request.response);
                        _this.isLoaded = false;
                        return;
                    }
                    _this.context.decodeAudioData(request.response, function (buffer) {
                        _this.buffer = buffer;
                        _this.isLoaded = true;
                        _this.onload(_this);
                    }, function (e) {
                        _this.logger.error("Unable to decode " + _this.path + " this browser may not fully support this format, or the file may be corrupt, " + "if this is an mp3 try removing id3 tags and album art from the file.");
                        _this.isLoaded = false;
                        _this.onload(_this);
                    });
                };
                try {
                    request.send();
                }
                catch (e) {
                    console.error("Error loading sound! If this is a cross origin error, you must host your sound with your html and javascript.");
                }
            };
            WebAudio.prototype.setLoop = function (loop) {
                this.loop = loop;
            };
            WebAudio.prototype.isPlaying = function () {
                return this._isPlaying;
            };
            WebAudio.prototype.play = function () {
                var _this = this;
                if (this.isLoaded) {
                    this.sound = this.context.createBufferSource();
                    this.sound.buffer = this.buffer;
                    this.sound.loop = this.loop;
                    this.sound.connect(this.volume);
                    this.volume.connect(this.context.destination);
                    this.sound.start(0, this._currentOffset % this.buffer.duration);
                    this._currentOffset = 0;
                    var done;
                    if (!this._isPaused || !this._playPromise) {
                        done = new ex.Promise();
                    }
                    else {
                        done = this._playPromise;
                    }
                    this._isPaused = false;
                    this._isPlaying = true;
                    if (!this.loop) {
                        this.sound.onended = (function () {
                            _this._isPlaying = false;
                            if (!_this._isPaused) {
                                done.resolve(true);
                            }
                        }).bind(this);
                    }
                    this._playPromise = done;
                    return done;
                }
                else {
                    return ex.Promise.wrap(true);
                }
            };
            WebAudio.prototype.pause = function () {
                if (this._isPlaying) {
                    try {
                        window.clearTimeout(this._playingTimer);
                        this.sound.stop(0);
                        this._currentOffset = this.context.currentTime;
                        this._isPlaying = false;
                        this._isPaused = true;
                    }
                    catch (e) {
                        this.logger.warn("The sound clip", this.path, "has already been paused!");
                    }
                }
            };
            WebAudio.prototype.stop = function () {
                if (this.sound) {
                    try {
                        window.clearTimeout(this._playingTimer);
                        this._currentOffset = 0;
                        this.sound.stop(0);
                        this._isPlaying = false;
                        this._isPaused = false;
                    }
                    catch (e) {
                        this.logger.warn("The sound clip", this.path, "has already been stopped!");
                    }
                }
            };
            return WebAudio;
        })();
        Internal.WebAudio = WebAudio;
    })(Internal = ex.Internal || (ex.Internal = {}));
})(ex || (ex = {}));
/// <reference path="Log.ts" />
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
var ex;
(function (ex) {
    /**
     * Valid states for a promise to be in
     * @class PromiseState
     */
    (function (PromiseState) {
        /**
        @property Resolved {PromiseState}
        */
        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
        /**
        @property Rejected {PromiseState}
        */
        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
        /**
        @property Pending {PromiseState}
        */
        PromiseState[PromiseState["Pending"] = 2] = "Pending";
    })(ex.PromiseState || (ex.PromiseState = {}));
    var PromiseState = ex.PromiseState;
    /**
     * Promises/A+ spec implementation of promises
     * @class Promise
     * @constructor
     */
    var Promise = (function () {
        function Promise() {
            this._state = 2 /* Pending */;
            this.successCallbacks = [];
            this.rejectCallback = function () {
            };
            this.logger = ex.Logger.getInstance();
        }
        /**
         * Wrap a value in a resolved promise
         * @method wrap<T>
         * @param [value=undefined] {T} An optional value to wrap in a resolved promise
         * @returns Promise&lt;T&gt;
         */
        Promise.wrap = function (value) {
            var promise = (new Promise()).resolve(value);
            return promise;
        };
        /**
         * Returns a new promise that resolves when all the promises passed to it resolve, or rejects
         * when at least 1 promise rejects.
         * @param promises {Promise[]}
         * @returns Promise
         */
        Promise.join = function () {
            var promises = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                promises[_i - 0] = arguments[_i];
            }
            var joinedPromise = new Promise();
            if (!promises) {
                return joinedPromise.resolve();
            }
            var total = promises.length;
            var successes = 0;
            var rejects = 0;
            var errors = [];
            promises.forEach(function (p) {
                p.then(function () {
                    successes += 1;
                    if (successes === total) {
                        joinedPromise.resolve();
                    }
                    else if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }, function () {
                    rejects += 1;
                    if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }).error(function (e) {
                    errors.push(e);
                    if ((errors.length + successes + rejects) === total) {
                        joinedPromise.reject(errors);
                    }
                });
            });
            return joinedPromise;
        };
        /**
         * Chain success and reject callbacks after the promise is resovled
         * @method then
         * @param successCallback {T=>any} Call on resolution of promise
         * @param rejectCallback {any=>any} Call on rejection of promise
         * @returns Promise&lt;T&gt;
         */
        Promise.prototype.then = function (successCallback, rejectCallback) {
            if (successCallback) {
                this.successCallbacks.push(successCallback);
                // If the promise is already resovled call immediately
                if (this.state() === 0 /* Resolved */) {
                    try {
                        successCallback.call(this, this.value);
                    }
                    catch (e) {
                        this.handleError(e);
                    }
                }
            }
            if (rejectCallback) {
                this.rejectCallback = rejectCallback;
                // If the promise is already rejected call immediately
                if (this.state() === 1 /* Rejected */) {
                    try {
                        rejectCallback.call(this, this.value);
                    }
                    catch (e) {
                        this.handleError(e);
                    }
                }
            }
            return this;
        };
        /**
         * Add an error callback to the promise
         * @method error
         * @param errorCallback {any=>any} Call if there was an error in a callback
         * @returns Promise&lt;T&gt;
         */
        Promise.prototype.error = function (errorCallback) {
            if (errorCallback) {
                this.errorCallback = errorCallback;
            }
            return this;
        };
        /**
         * Resolve the promise and pass an option value to the success callbacks
         * @method resolve
         * @param [value=undefined] {T} Value to pass to the success callbacks
         */
        Promise.prototype.resolve = function (value) {
            var _this = this;
            if (this._state === 2 /* Pending */) {
                this.value = value;
                try {
                    this._state = 0 /* Resolved */;
                    this.successCallbacks.forEach(function (cb) {
                        cb.call(_this, _this.value);
                    });
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            else {
                throw new Error('Cannot resolve a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Reject the promise and pass an option value to the reject callbacks
         * @method reject
         * @param [value=undefined] {T} Value to pass to the reject callbacks
         */
        Promise.prototype.reject = function (value) {
            if (this._state === 2 /* Pending */) {
                this.value = value;
                try {
                    this._state = 1 /* Rejected */;
                    this.rejectCallback.call(this, this.value);
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            else {
                throw new Error('Cannot reject a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Inpect the current state of a promise
         * @method state
         * @returns PromiseState
         */
        Promise.prototype.state = function () {
            return this._state;
        };
        Promise.prototype.handleError = function (e) {
            if (this.errorCallback) {
                this.errorCallback.call(this, e);
            }
            else {
                throw e;
            }
        };
        return Promise;
    })();
    ex.Promise = Promise;
})(ex || (ex = {}));
/// <reference path="Interfaces/ILoadable.ts" />
var ex;
(function (ex) {
    /**
     * The Resource type allows games built in Excalibur to load generic resources.
     * For any type of remote resource it is recome
     * @class Resource
     * @extend ILoadable
     * @constructor
     * @param path {string} Path to the remote resource
     */
    var Resource = (function () {
        function Resource(path, responseType, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            this.path = path;
            this.responseType = responseType;
            this.bustCache = bustCache;
            this.data = null;
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
        }
        /**
         * Returns true if the Resource is completely loaded and is ready
         * to be drawn.
         * @method isLoaded
         * @returns boolean
         */
        Resource.prototype.isLoaded = function () {
            return !!this.data;
        };
        Resource.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        Resource.prototype.cacheBust = function (uri) {
            var query = /\?\w*=\w*/;
            if (query.test(uri)) {
                uri += ("&__=" + Date.now());
            }
            else {
                uri += ("?__=" + Date.now());
            }
            return uri;
        };
        Resource.prototype._start = function (e) {
            this.logger.debug("Started loading resource " + this.path);
        };
        /**
         * Begin loading the resource and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;any&gt;
         */
        Resource.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var request = new XMLHttpRequest();
            request.open("GET", this.bustCache ? this.cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = function (e) {
                _this._start(e);
            };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function (e) {
                if (request.status !== 200) {
                    _this.logger.error("Failed to load resource ", _this.path, " server responded with error code", request.status);
                    _this.onerror(request.response);
                    complete.resolve(request.response);
                    return;
                }
                _this.data = _this.processDownload(request.response);
                _this.oncomplete();
                _this.logger.debug("Completed loading resource", _this.path);
                complete.resolve(_this.data);
            };
            request.send();
            return complete;
        };
        /**
         * Returns the loaded data once the resource is loaded
         * @method GetData
         * @returns any
         */
        Resource.prototype.getData = function () {
            return this.data;
        };
        /**
         * This method is meant to be overriden to handle any additional
         * processing. Such as decoding downloaded audio bits.
         * @method ProcessDownload
         */
        Resource.prototype.processDownload = function (data) {
            // Handle any additional loading after the xhr has completed.
            return URL.createObjectURL(data);
        };
        return Resource;
    })();
    ex.Resource = Resource;
})(ex || (ex = {}));
/// <reference path="Sound.ts" />
/// <reference path="Util.ts" />
/// <reference path="Promises.ts" />
/// <reference path="Resource.ts" />
/// <reference path="Interfaces/ILoadable.ts" />
var ex;
(function (ex) {
    /**
     * The Texture object allows games built in Excalibur to load image resources.
     * It is generally recommended to preload images using the "Texture" object.
     * @class Texture
     * @extend Resource
     * @constructor
     * @param path {string} Path to the image resource
     * @param [bustCache=true] {boolean} Optionally load texture with cache busting
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture(path, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            _super.call(this, path, 'blob', bustCache);
            this.path = path;
            this.bustCache = bustCache;
            this.loaded = new ex.Promise();
            this._isLoaded = false;
            this._sprite = null;
            this._sprite = new ex.Sprite(this, 0, 0, 0, 0);
        }
        /**
         * Returns true if the Texture is completely loaded and is ready
         * to be drawn.
         * @method isLoaded
         * @returns boolean
         */
        Texture.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the texture and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;HTMLImageElement&gt;
         */
        Texture.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var loaded = _super.prototype.load.call(this);
            loaded.then(function () {
                _this.image = new Image();
                _this.image.addEventListener("load", function () {
                    _this._isLoaded = true;
                    _this.width = _this._sprite.swidth = _this._sprite.width = _this.image.naturalWidth;
                    _this.height = _this._sprite.sheight = _this._sprite.height = _this.image.naturalHeight;
                    _this.loaded.resolve(_this.image);
                    complete.resolve(_this.image);
                });
                _this.image.src = _super.prototype.getData.call(_this);
            }, function () {
                complete.reject("Error loading texture.");
            });
            return complete;
        };
        Texture.prototype.asSprite = function () {
            return this._sprite;
        };
        return Texture;
    })(ex.Resource);
    ex.Texture = Texture;
    /**
     * The Sound object allows games built in Excalibur to load audio
     * components, from soundtracks to sound effects. It is generally
     * recommended to load sound resources when using Excalibur
     * @class Sound
     * @extend Resource
     * @constructor
     * @param ...paths {string[]} A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    var Sound = (function () {
        function Sound() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i - 0] = arguments[_i];
            }
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            this.onload = function () {
            };
            this._isLoaded = false;
            this._selectedFile = "";
            this._wasPlayingOnHidden = false;
            /* Chrome : MP3, WAV, Ogg
             * Firefox : WAV, Ogg,
             * IE : MP3, WAV coming soon
             * Safari MP3, WAV, Ogg
             */
            this._selectedFile = "";
            for (var i = 0; i < paths.length; i++) {
                if (Sound.canPlayFile(paths[i])) {
                    this._selectedFile = paths[i];
                    break;
                }
            }
            if (!this._selectedFile) {
                this.logger.warn("This browser does not support any of the files specified");
                this._selectedFile = paths[0]; // select the first specified
            }
            this.sound = new ex.Internal.FallbackAudio(this._selectedFile, 1.0);
        }
        Sound.canPlayFile = function (file) {
            try {
                var a = new Audio();
                var filetype = /.*\.([A-Za-z0-9]+)$/;
                var type = file.match(filetype)[1];
                if (a.canPlayType('audio/' + type)) {
                    return true;
                }
                {
                    return false;
                }
            }
            catch (e) {
                ex.Logger.getInstance().warn("Cannot determine audio support, assuming no support for the Audio Tag", e);
                return false;
            }
        };
        Sound.prototype.wireEngine = function (engine) {
            var _this = this;
            if (engine) {
                this._engine = engine;
                this._engine.on('hidden', function () {
                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {
                        _this._wasPlayingOnHidden = true;
                        _this.pause();
                    }
                });
                this._engine.on('visible', function () {
                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {
                        _this.play();
                        _this._wasPlayingOnHidden = false;
                    }
                });
            }
        };
        /**
         * Sets the volume of the sound clip
         * @method setVolume
         * @param volume {number} A volume value between 0-1.0
         */
        Sound.prototype.setVolume = function (volume) {
            if (this.sound)
                this.sound.setVolume(volume);
        };
        /**
         * Indicates whether the clip should loop when complete
         * @method setLoop
         * @param loop {boolean} Set the looping flag
         */
        Sound.prototype.setLoop = function (loop) {
            if (this.sound)
                this.sound.setLoop(loop);
        };
        Sound.prototype.isPlaying = function () {
            if (this.sound)
                return this.sound.isPlaying();
        };
        /**
         * Play the sound, returns a promise that resolves when the sound is done playing
         * @method play
         * @return ex.Promise
         */
        Sound.prototype.play = function () {
            if (this.sound)
                return this.sound.play();
        };
        /**
         * Stop the sound, and do not rewind
         * @method pause
         */
        Sound.prototype.pause = function () {
            if (this.sound)
                this.sound.pause();
        };
        /**
         * Stop the sound and rewind
         * @method stop
         */
        Sound.prototype.stop = function () {
            if (this.sound)
                this.sound.stop();
        };
        /**
         * Returns true if the sound is loaded
         * @method isLoaded
         */
        Sound.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the sound and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;Sound&gt;
         */
        Sound.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            this.logger.debug("Started loading sound", this._selectedFile);
            this.sound.onprogress = this.onprogress;
            this.sound.onload = function () {
                _this.oncomplete();
                _this._isLoaded = true;
                _this.logger.debug("Completed loading sound", _this._selectedFile);
                complete.resolve(_this.sound);
            };
            this.sound.onerror = function (e) {
                _this.onerror(e);
                complete.resolve(e);
            };
            this.sound.load();
            return complete;
        };
        return Sound;
    })();
    ex.Sound = Sound;
    /**
     * The loader provides a mechanism to preload multiple resources at
     * one time. The loader must be passed to the engine in order to
     * trigger the loading progress bar
     * @class Loader
     * @extend ILoadable
     * @constructor
     * @param [loadables=undefined] {ILoadable[]} Optionally provide the list of resources you want to load at constructor time
     */
    var Loader = (function () {
        function Loader(loadables) {
            this.resourceList = [];
            this.index = 0;
            this.resourceCount = 0;
            this.numLoaded = 0;
            this.progressCounts = {};
            this.totalCounts = {};
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            if (loadables) {
                this.addResources(loadables);
            }
        }
        Loader.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Add a resource to the loader to load
         * @method addResource
         * @param loadable {ILoadable} Resource to add
         */
        Loader.prototype.addResource = function (loadable) {
            var key = this.index++;
            this.resourceList.push(loadable);
            this.progressCounts[key] = 0;
            this.totalCounts[key] = 1;
            this.resourceCount++;
        };
        /**
         * Add a list of resources to the loader to load
         * @method addResources
         * @param loadables {ILoadable[]} The list of resources to load
         */
        Loader.prototype.addResources = function (loadables) {
            var _this = this;
            loadables.forEach(function (l) {
                _this.addResource(l);
            });
        };
        Loader.prototype.sumCounts = function (obj) {
            var sum = 0;
            var prev = 0;
            for (var i in obj) {
                sum += obj[i] | 0;
            }
            return sum;
        };
        /**
         * Returns true if the loader has completely loaded all resources
         * @method isLoaded
         */
        Loader.prototype.isLoaded = function () {
            return this.numLoaded === this.resourceCount;
        };
        /**
         * Begin loading all of the supplied resources, returning a promise that resolves when loading of all is complete
         * @method load
         * @returns Promsie&lt;any&gt;
         */
        Loader.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var me = this;
            if (this.resourceList.length === 0) {
                me.oncomplete.call(me);
                return complete;
            }
            var progressArray = new Array(this.resourceList.length);
            var progressChunks = this.resourceList.length;
            this.resourceList.forEach(function (r, i) {
                if (_this._engine) {
                    r.wireEngine(_this._engine);
                }
                r.onprogress = function (e) {
                    var total = e.total;
                    var loaded = e.loaded;
                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };
                    var progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: (accum.loaded + next.loaded), total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                r.oncomplete = r.onerror = function () {
                    me.numLoaded++;
                    if (me.numLoaded === me.resourceCount) {
                        me.onprogress.call(me, { loaded: 100, total: 100 });
                        me.oncomplete.call(me);
                        complete.resolve();
                    }
                };
            });
            function loadNext(list, index) {
                if (!list[index])
                    return;
                list[index].load().then(function () {
                    loadNext(list, index + 1);
                });
            }
            loadNext(this.resourceList, 0);
            return complete;
        };
        return Loader;
    })();
    ex.Loader = Loader;
})(ex || (ex = {}));
/// <reference path="Promises.ts" />
/// <reference path="Loader.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur's built in templating class, it is a loadable that will load
     * and html fragment from a url. Excalibur templating is very basic only
     * allowing bindings of the type data-text="this.obj.someprop",
     * data-style="color:this.obj.color.toString()". Bindings allow all valid
     * javascript expressions.
     * @class Template
     * @extends ILoadable
     * @constructor
     * @param path {string} Location of the html template
     */
    var Template = (function () {
        function Template(path) {
            this.path = path;
            this._isLoaded = false;
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            this._innerElement = document.createElement('div');
            this._innerElement.className = "excalibur-template";
        }
        Template.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Returns the full html template string once loaded.
         * @method getTemplateString
         * @returns string
         */
        Template.prototype.getTemplateString = function () {
            if (!this._isLoaded)
                return "";
            return this._htmlString;
        };
        Template.prototype._compile = function () {
            this._innerElement.innerHTML = this._htmlString;
            this._styleElements = this._innerElement.querySelectorAll('[data-style]');
            this._textElements = this._innerElement.querySelectorAll('[data-text]');
        };
        Template.prototype._evaluateExpresion = function (expression, ctx) {
            var func = new Function("return " + expression + ";");
            var val = func.call(ctx);
            return val;
        };
        /**
         * Applies any ctx object you wish and evaluates the template.
         * Overload this method to include your favorite template library.
         * You may return either an HTML string or a Dom node.
         * @method apply
         * @param ctx {any} Any object you wish to apply to the template
         * @returns any
         */
        Template.prototype.apply = function (ctx) {
            var _this = this;
            for (var j = 0; j < this._styleElements.length; j++) {
                (function () {
                    // poor man's json parse for things that aren't exactly json :(
                    // Extract style expressions
                    var styles = {};
                    _this._styleElements[j].dataset["style"].split(";").forEach(function (s) {
                        if (s) {
                            var vals = s.split(":");
                            styles[vals[0].trim()] = vals[1].trim();
                        }
                    });
                    for (var style in styles) {
                        (function () {
                            var expression = styles[style];
                            _this._styleElements[j].style[style] = _this._evaluateExpresion(expression, ctx);
                        })();
                    }
                })();
            }
            for (var i = 0; i < this._textElements.length; i++) {
                (function () {
                    // Evaluate text expressions
                    var expression = _this._textElements[i].dataset["text"];
                    _this._textElements[i].innerText = _this._evaluateExpresion(expression, ctx);
                })();
            }
            // If the template HTML has a root element return that, otherwise use constructed root
            if (this._innerElement.children.length === 1) {
                this._innerElement = this._innerElement.firstChild;
            }
            return this._innerElement;
        };
        /**
         * Begins loading the template. Returns a promise that resolves with the template string when loaded.
         * @method load
         * @returns {Promise}
         */
        Template.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var request = new XMLHttpRequest();
            request.open("GET", this.path, true);
            request.responseType = "text";
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function (e) {
                if (request.status !== 200) {
                    _this.logger.error("Failed to load html template resource ", _this.path, " server responded with error code", request.status);
                    _this.onerror(request.response);
                    _this._isLoaded = false;
                    complete.resolve("error");
                    return;
                }
                _this._htmlString = request.response;
                _this.oncomplete();
                _this.logger.debug("Completed loading template", _this.path);
                _this._compile();
                _this._isLoaded = true;
                complete.resolve(_this._htmlString);
            };
            if (request.overrideMimeType) {
                request.overrideMimeType('text/plain; charset=x-user-defined');
            }
            request.send();
            return complete;
        };
        /**
         * Indicates whether the template has been loaded
         * @method isLoaded
         * @returns {boolean}
         */
        Template.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        return Template;
    })();
    ex.Template = Template;
    /**
     * Excalibur's binding library that allows you to bind an html
     * template to the dom given a certain context. Excalibur bindings are only updated
     * when the update() method is called
     * @class Binding
     * @constructor
     * @param parentElementId {string} The id of the element in the dom to attach the template binding
     * @param template {Template} The template you wish to bind
     * @param ctx {any} The context of the binding, which can be any object
     */
    var Binding = (function () {
        function Binding(parentElementId, template, ctx) {
            this.parent = document.getElementById(parentElementId);
            this.template = template;
            this._ctx = ctx;
            this.update();
        }
        /**
         * Listen to any arbitrary object's events to update this binding
         * @method listen
         * @param obj {any} Any object that supports addEventListener
         * @param events {string[]} A list of events to listen for
         * @param [hander=defaultHandler] {callback} A optional handler to fire on any event
         */
        Binding.prototype.listen = function (obj, events, handler) {
            var _this = this;
            // todo
            if (!handler) {
                handler = function () {
                    _this.update();
                };
            }
            if (obj.addEventListener) {
                events.forEach(function (e) {
                    obj.addEventListener(e, handler);
                });
            }
        };
        /**
         * Update this template binding with the latest values from the ctx reference passed to the constructor
         * @method update
         */
        Binding.prototype.update = function () {
            var html = this._applyTemplate(this.template, this._ctx);
            if (html instanceof String) {
                this.parent.innerHTML = html;
            }
            if (html instanceof Node) {
                if (this.parent.lastChild !== html) {
                    this.parent.appendChild(html);
                }
            }
        };
        Binding.prototype._applyTemplate = function (template, ctx) {
            if (template.isLoaded()) {
                return template.apply(ctx);
            }
        };
        return Binding;
    })();
    ex.Binding = Binding;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * Enum representing the different horizontal text alignments
     * @class TextAlign
     */
    (function (TextAlign) {
        /**
         * The text is left-aligned.
         * @property Left
         * @static
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * The text is right-aligned.
         * @property Right
         * @static
         */
        TextAlign[TextAlign["Right"] = 1] = "Right";
        /**
         * The text is centered.
         * @property Center
         * @static
         */
        TextAlign[TextAlign["Center"] = 2] = "Center";
        /**
         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).
         * @property Start
         * @static
         */
        TextAlign[TextAlign["Start"] = 3] = "Start";
        /**
         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).
         * @property End
         * @static
         */
        TextAlign[TextAlign["End"] = 4] = "End";
    })(ex.TextAlign || (ex.TextAlign = {}));
    var TextAlign = ex.TextAlign;
    /**
     * Enum representing the different baseline text alignments
     * @class BaseAlign
     */
    (function (BaseAlign) {
        /**
         * The text baseline is the top of the em square.
         * @property Top
         * @static
         */
        BaseAlign[BaseAlign["Top"] = 0] = "Top";
        /**
         * The text baseline is the hanging baseline.  Currently unsupported; this will act like alphabetic.
         * @property Hanging
         * @static
         */
        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
        /**
         * The text baseline is the middle of the em square.
         * @property Middle
         * @static
         */
        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
        /**
         * The text baseline is the normal alphabetic baseline.
         * @property Alphabetic
         * @static
         */
        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
        /**
         * The text baseline is the ideographic baseline; this is the bottom of
         * the body of the characters, if the main body of characters protrudes
         * beneath the alphabetic baseline.  Currently unsupported; this will
         * act like alphabetic.
         * @property Ideographic
         * @static
         */
        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
        /**
         * The text baseline is the bottom of the bounding box.  This differs
         * from the ideographic baseline in that the ideographic baseline
         * doesn't consider descenders.
         * @property Bottom
         * @static
         */
        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
    })(ex.BaseAlign || (ex.BaseAlign = {}));
    var BaseAlign = ex.BaseAlign;
    /**
     * Labels are the way to draw small amounts of text to the screen in Excalibur. They are
     * actors and inherit all of the benifits and capabilities.
     * @class Label
     * @extends Actor
     * @constructor
     * @param [text=empty] {string} The text of the label
     * @param [x=0] {number} The x position of the label
     * @param [y=0] {number} The y position of the label
     * @param [font=sans-serif] {string} Use any valid css font string for the label's font. Default is "10px sans-serif".
     * @param [spriteFont=undefined] {SpriteFont} Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precendence over a css font.
     *
     */
    var Label = (function (_super) {
        __extends(Label, _super);
        function Label(text, x, y, font, spriteFont) {
            _super.call(this, x, y);
            /**
             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
             * @property [letterSpacing=0] {number}
             */
            this.letterSpacing = 0; //px
            this.caseInsensitive = true;
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = ex.Color.Black.clone();
            this._shadowColorDirty = false;
            this._textSprites = {};
            this._shadowSprites = {};
            this._color = ex.Color.Black.clone();
            this.text = text || "";
            this.color = ex.Color.Black.clone();
            this.spriteFont = spriteFont;
            this.collisionType = 0 /* PreventCollision */;
            this.font = font || "10px sans-serif"; // coallesce to default canvas font
            if (spriteFont) {
                this._textSprites = spriteFont.getTextSprites();
            }
        }
        /**
         * Returns the width of the text in the label (in pixels);
         * @method getTextWidth {number}
         * @param ctx {CanvasRenderingContext2D} Rending context to measure the string with
         */
        Label.prototype.getTextWidth = function (ctx) {
            var oldFont = ctx.font;
            ctx.font = this.font;
            var width = ctx.measureText(this.text).width;
            ctx.font = oldFont;
            return width;
        };
        // TypeScript doesn't support string enums :(
        Label.prototype._lookupTextAlign = function (textAlign) {
            switch (textAlign) {
                case 0 /* Left */:
                    return "left";
                    break;
                case 1 /* Right */:
                    return "right";
                    break;
                case 2 /* Center */:
                    return "center";
                    break;
                case 4 /* End */:
                    return "end";
                    break;
                case 3 /* Start */:
                    return "start";
                    break;
                default:
                    return "start";
                    break;
            }
        };
        Label.prototype._lookupBaseAlign = function (baseAlign) {
            switch (baseAlign) {
                case 3 /* Alphabetic */:
                    return "alphabetic";
                    break;
                case 5 /* Bottom */:
                    return "bottom";
                    break;
                case 1 /* Hanging */:
                    return "hangin";
                    break;
                case 4 /* Ideographic */:
                    return "ideographic";
                    break;
                case 2 /* Middle */:
                    return "middle";
                    break;
                case 0 /* Top */:
                    return "top";
                    break;
                default:
                    return "alphabetic";
                    break;
            }
        };
        /**
         * Sets the text shadow for sprite fonts
         * @method setTextShadow
         * @param offsetX {number} The x offset in pixels to place the shadow
         * @param offsetY {number} The y offset in pixles to place the shadow
         * @param shadowColor {Color} The color of the text shadow
         */
        Label.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this._textShadowOn = true;
            this._shadowOffsetX = offsetX;
            this._shadowOffsetY = offsetY;
            this._shadowColor = shadowColor.clone();
            this._shadowColorDirty = true;
            for (var character in this._textSprites) {
                this._shadowSprites[character] = this._textSprites[character].clone();
            }
        };
        /**
         * Clears the current text shadow
         * @method clearTextShadow
         */
        Label.prototype.clearTextShadow = function () {
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = ex.Color.Black.clone();
        };
        Label.prototype.update = function (engine, delta) {
            _super.prototype.update.call(this, engine, delta);
            if (this.spriteFont && this._color !== this.color) {
                for (var character in this._textSprites) {
                    this._textSprites[character].clearEffects();
                    this._textSprites[character].addEffect(new ex.Effects.Fill(this.color.clone()));
                    this._color = this.color;
                }
            }
            if (this.spriteFont && this._textShadowOn && this._shadowColorDirty && this._shadowColor) {
                for (var character in this._shadowSprites) {
                    this._shadowSprites[character].clearEffects();
                    this._shadowSprites[character].addEffect(new ex.Effects.Fill(this._shadowColor.clone()));
                }
                this._shadowColorDirty = false;
            }
        };
        Label.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            if (this._textShadowOn) {
                ctx.save();
                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
                this._fontDraw(ctx, delta, this._shadowSprites);
                ctx.restore();
            }
            this._fontDraw(ctx, delta, this._textSprites);
            _super.prototype.draw.call(this, ctx, delta);
            ctx.restore();
        };
        Label.prototype._fontDraw = function (ctx, delta, sprites) {
            if (this.spriteFont) {
                var currX = 0;
                for (var i = 0; i < this.text.length; i++) {
                    var character = this.text[i];
                    if (this.caseInsensitive) {
                        character = character.toLowerCase();
                    }
                    try {
                        var charSprite = sprites[character];
                        if (this.previousOpacity !== this.opacity) {
                            charSprite.clearEffects();
                            charSprite.addEffect(new ex.Effects.Opacity(this.opacity));
                        }
                        charSprite.draw(ctx, currX, 0);
                        currX += (charSprite.swidth + this.letterSpacing);
                    }
                    catch (e) {
                        ex.Logger.getInstance().error("SpriteFont Error drawing char " + character);
                    }
                }
                if (this.previousOpacity !== this.opacity) {
                    this.previousOpacity = this.opacity;
                }
            }
            else {
                var oldAlign = ctx.textAlign;
                var oldTextBaseline = ctx.textBaseline;
                ctx.textAlign = this._lookupTextAlign(this.textAlign);
                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
                if (this.color) {
                    this.color.a = this.opacity;
                }
                ctx.fillStyle = this.color.toString();
                ctx.font = this.font;
                if (this.maxWidth) {
                    ctx.fillText(this.text, 0, 0, this.maxWidth);
                }
                else {
                    ctx.fillText(this.text, 0, 0);
                }
                ctx.textAlign = oldAlign;
                ctx.textBaseline = oldTextBaseline;
            }
        };
        Label.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
        };
        return Label;
    })(ex.Actor);
    ex.Label = Label;
})(ex || (ex = {}));
/// <reference path="../Events.ts"/>
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        (function (PointerType) {
            PointerType[PointerType["Touch"] = 0] = "Touch";
            PointerType[PointerType["Mouse"] = 1] = "Mouse";
            PointerType[PointerType["Pen"] = 2] = "Pen";
            PointerType[PointerType["Unknown"] = 3] = "Unknown";
        })(Input.PointerType || (Input.PointerType = {}));
        var PointerType = Input.PointerType;
        (function (PointerButton) {
            PointerButton[PointerButton["Left"] = 0] = "Left";
            PointerButton[PointerButton["Middle"] = 1] = "Middle";
            PointerButton[PointerButton["Right"] = 2] = "Right";
            PointerButton[PointerButton["Unknown"] = 3] = "Unknown";
        })(Input.PointerButton || (Input.PointerButton = {}));
        var PointerButton = Input.PointerButton;
        var PointerEvent = (function (_super) {
            __extends(PointerEvent, _super);
            function PointerEvent(x, y, index, pointerType, button, ev) {
                _super.call(this);
                this.x = x;
                this.y = y;
                this.index = index;
                this.pointerType = pointerType;
                this.button = button;
                this.ev = ev;
            }
            return PointerEvent;
        })(ex.GameEvent);
        Input.PointerEvent = PointerEvent;
        ;
        /**
         * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to W3C Pointer Events.
         * There is always at least one pointer available (primary).
         *
         * @class Pointers
         * @extends Class
         * @constructor
         */
        var Pointers = (function (_super) {
            __extends(Pointers, _super);
            function Pointers(engine) {
                _super.call(this);
                this._pointerDown = [];
                this._pointerUp = [];
                this._pointerMove = [];
                this._pointerCancel = [];
                this._pointers = [];
                this._activePointers = [];
                this._engine = engine;
                this._pointers.push(new Pointer());
                this._activePointers = [-1];
                this.primary = this._pointers[0];
            }
            /**
             * Initializes pointer event listeners
             */
            Pointers.prototype.init = function () {
                // Touch Events
                document.addEventListener('touchstart', this._handleTouchEvent("down", this._pointerDown));
                document.addEventListener('touchend', this._handleTouchEvent("up", this._pointerUp));
                document.addEventListener('touchmove', this._handleTouchEvent("move", this._pointerMove));
                document.addEventListener('touchcancel', this._handleTouchEvent("cancel", this._pointerCancel));
                // W3C Pointer Events
                // Current: IE11, IE10
                if (window.PointerEvent) {
                    // IE11
                    this._engine.canvas.style.touchAction = "none";
                    document.addEventListener('pointerdown', this._handlePointerEvent("down", this._pointerDown));
                    document.addEventListener('pointerup', this._handlePointerEvent("up", this._pointerUp));
                    document.addEventListener('pointermove', this._handlePointerEvent("move", this._pointerMove));
                    document.addEventListener('pointercancel', this._handlePointerEvent("cancel", this._pointerMove));
                }
                else if (window.MSPointerEvent) {
                    // IE10
                    this._engine.canvas.style.msTouchAction = "none";
                    document.addEventListener('MSPointerDown', this._handlePointerEvent("down", this._pointerDown));
                    document.addEventListener('MSPointerUp', this._handlePointerEvent("up", this._pointerUp));
                    document.addEventListener('MSPointerMove', this._handlePointerEvent("move", this._pointerMove));
                    document.addEventListener('MSPointerCancel', this._handlePointerEvent("cancel", this._pointerMove));
                }
                else {
                    // Mouse Events
                    document.addEventListener('mousedown', this._handleMouseEvent("down", this._pointerDown));
                    document.addEventListener('mouseup', this._handleMouseEvent("up", this._pointerUp));
                    document.addEventListener('mousemove', this._handleMouseEvent("move", this._pointerMove));
                }
            };
            Pointers.prototype.update = function (delta) {
                this._pointerUp.length = 0;
                this._pointerDown.length = 0;
                this._pointerMove.length = 0;
                this._pointerCancel.length = 0;
            };
            /**
             * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
             * @param index {number} The pointer index to retrieve
             */
            Pointers.prototype.at = function (index) {
                if (index >= this._pointers.length) {
                    for (var i = this._pointers.length - 1, max = index; i < max; i++) {
                        this._pointers.push(new Pointer());
                        this._activePointers.push(-1);
                    }
                }
                return this._pointers[index];
            };
            /**
             * Get number of pointers being watched
             */
            Pointers.prototype.count = function () {
                return this._pointers.length;
            };
            /**
             * Propogates events to actor if necessary
             */
            Pointers.prototype.propogate = function (actor) {
                var isUIActor = actor instanceof ex.UIActor;
                this._pointerUp.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointerup", e);
                    }
                });
                this._pointerDown.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointerdown", e);
                    }
                });
                if (actor.capturePointer.captureMoveEvents) {
                    this._pointerMove.forEach(function (e) {
                        if (actor.contains(e.x, e.y, !isUIActor)) {
                            actor.eventDispatcher.publish("pointermove", e);
                        }
                    });
                }
                this._pointerCancel.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointercancel", e);
                    }
                });
            };
            Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    var x = e.pageX - ex.Util.getPosition(_this._engine.canvas).x;
                    var y = e.pageY - ex.Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, 0, 1 /* Mouse */, e.button, e);
                    eventArr.push(pe);
                    _this.at(0).eventDispatcher.publish(eventName, pe);
                };
            };
            Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                        var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                        if (index === -1)
                            continue;
                        var x = e.changedTouches[i].pageX - ex.Util.getPosition(_this._engine.canvas).x;
                        var y = e.changedTouches[i].pageY - ex.Util.getPosition(_this._engine.canvas).y;
                        var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                        var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, index, 0 /* Touch */, 3 /* Unknown */, e);
                        eventArr.push(pe);
                        _this.at(index).eventDispatcher.publish(eventName, pe);
                        // only with multi-pointer
                        if (_this._pointers.length > 1) {
                            if (eventName === "up") {
                                // remove pointer ID from pool when pointer is lifted
                                _this._activePointers[index] = -1;
                            }
                            else if (eventName === "down") {
                                // set pointer ID to given index
                                _this._activePointers[index] = e.changedTouches[i].identifier;
                            }
                        }
                    }
                };
            };
            Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    // get the index for this pointer ID if multi-pointer is asked for
                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;
                    if (index === -1)
                        return;
                    var x = e.pageX - ex.Util.getPosition(_this._engine.canvas).x;
                    var y = e.pageY - ex.Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, index, _this._stringToPointerType(e.pointerType), e.button, e);
                    eventArr.push(pe);
                    _this.at(index).eventDispatcher.publish(eventName, pe);
                    // only with multi-pointer
                    if (_this._pointers.length > 1) {
                        if (eventName === "up") {
                            // remove pointer ID from pool when pointer is lifted
                            _this._activePointers[index] = -1;
                        }
                        else if (eventName === "down") {
                            // set pointer ID to given index
                            _this._activePointers[index] = e.pointerId;
                        }
                    }
                };
            };
            /**
             * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
             * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
             * @private
             */
            Pointers.prototype._getPointerIndex = function (pointerId) {
                var idx;
                if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
                    return idx;
                }
                for (var i = 0; i < this._activePointers.length; i++) {
                    if (this._activePointers[i] === -1)
                        return i;
                }
                // ignore pointer because game isn't watching
                return -1;
            };
            Pointers.prototype._stringToPointerType = function (s) {
                switch (s) {
                    case "touch":
                        return 0 /* Touch */;
                    case "mouse":
                        return 1 /* Mouse */;
                    case "pen":
                        return 2 /* Pen */;
                    default:
                        return 3 /* Unknown */;
                }
            };
            return Pointers;
        })(ex.Class);
        Input.Pointers = Pointers;
        /**
         * Captures and dispatches PointerEvents
         * @class Pointer
         * @constructor
         * @extends Class
         */
        var Pointer = (function (_super) {
            __extends(Pointer, _super);
            function Pointer() {
                _super.apply(this, arguments);
            }
            return Pointer;
        })(ex.Class);
        Input.Pointer = Pointer;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        /**
        * Enum representing input key codes
        * @class Keys
        *
        */
        (function (Keys) {
            /**
            @property Num1 {Keys}
            */
            /**
            @property Num2 {Keys}
            */
            /**
            @property Num3 {Keys}
            */
            /**
            @property Num4 {Keys}
            */
            /**
            @property Num5 {Keys}
            */
            /**
            @property Num6 {Keys}
            */
            /**
            @property Num7 {Keys}
            */
            /**
            @property Num8 {Keys}
            */
            /**
            @property Num9 {Keys}
            */
            /**
            @property Num0 {Keys}
            */
            Keys[Keys["Num1"] = 97] = "Num1";
            Keys[Keys["Num2"] = 98] = "Num2";
            Keys[Keys["Num3"] = 99] = "Num3";
            Keys[Keys["Num4"] = 100] = "Num4";
            Keys[Keys["Num5"] = 101] = "Num5";
            Keys[Keys["Num6"] = 102] = "Num6";
            Keys[Keys["Num7"] = 103] = "Num7";
            Keys[Keys["Num8"] = 104] = "Num8";
            Keys[Keys["Num9"] = 105] = "Num9";
            Keys[Keys["Num0"] = 96] = "Num0";
            /**
            @property Numlock {Keys}
            */
            Keys[Keys["Numlock"] = 144] = "Numlock";
            /**
            @property Semicolon {Keys}
            */
            Keys[Keys["Semicolon"] = 186] = "Semicolon";
            /**
            @property A {Keys}
            */
            /**
            @property B {Keys}
            */
            /**
            @property C {Keys}
            */
            /**
            @property D {Keys}
            */
            /**
            @property E {Keys}
            */
            /**
            @property F {Keys}
            */
            /**
            @property G {Keys}
            */
            /**
            @property H {Keys}
            */
            /**
            @property I {Keys}
            */
            /**
            @property J {Keys}
            */
            /**
            @property K {Keys}
            */
            /**
            @property L {Keys}
            */
            /**
            @property M {Keys}
            */
            /**
            @property N {Keys}
            */
            /**
            @property O {Keys}
            */
            /**
            @property P {Keys}
            */
            /**
            @property Q {Keys}
            */
            /**
            @property R {Keys}
            */
            /**
            @property S {Keys}
            */
            /**
            @property T {Keys}
            */
            /**
            @property U {Keys}
            */
            /**
            @property V {Keys}
            */
            /**
            @property W {Keys}
            */
            /**
            @property X {Keys}
            */
            /**
            @property Y {Keys}
            */
            /**
            @property Z {Keys}
            */
            Keys[Keys["A"] = 65] = "A";
            Keys[Keys["B"] = 66] = "B";
            Keys[Keys["C"] = 67] = "C";
            Keys[Keys["D"] = 68] = "D";
            Keys[Keys["E"] = 69] = "E";
            Keys[Keys["F"] = 70] = "F";
            Keys[Keys["G"] = 71] = "G";
            Keys[Keys["H"] = 72] = "H";
            Keys[Keys["I"] = 73] = "I";
            Keys[Keys["J"] = 74] = "J";
            Keys[Keys["K"] = 75] = "K";
            Keys[Keys["L"] = 76] = "L";
            Keys[Keys["M"] = 77] = "M";
            Keys[Keys["N"] = 78] = "N";
            Keys[Keys["O"] = 79] = "O";
            Keys[Keys["P"] = 80] = "P";
            Keys[Keys["Q"] = 81] = "Q";
            Keys[Keys["R"] = 82] = "R";
            Keys[Keys["S"] = 83] = "S";
            Keys[Keys["T"] = 84] = "T";
            Keys[Keys["U"] = 85] = "U";
            Keys[Keys["V"] = 86] = "V";
            Keys[Keys["W"] = 87] = "W";
            Keys[Keys["X"] = 88] = "X";
            Keys[Keys["Y"] = 89] = "Y";
            Keys[Keys["Z"] = 90] = "Z";
            /**
            @property Shift {Keys}
            */
            /**
            @property Alt {Keys}
            */
            /**
            @property Up {Keys}
            */
            /**
            @property Down {Keys}
            */
            /**
            @property Left {Keys}
            */
            /**
            @property Right {Keys}
            */
            /**
            @property Space {Keys}
            */
            /**
            @property Esc {Keys}
            */
            Keys[Keys["Shift"] = 16] = "Shift";
            Keys[Keys["Alt"] = 18] = "Alt";
            Keys[Keys["Up"] = 38] = "Up";
            Keys[Keys["Down"] = 40] = "Down";
            Keys[Keys["Left"] = 37] = "Left";
            Keys[Keys["Right"] = 39] = "Right";
            Keys[Keys["Space"] = 32] = "Space";
            Keys[Keys["Esc"] = 27] = "Esc";
        })(Input.Keys || (Input.Keys = {}));
        var Keys = Input.Keys;
        ;
        /**
         * Event thrown on a game object for a key event
         *
         * @class KeyEvent
         * @extends GameEvent
         * @constructor
         * @param key {InputKey} The key responsible for throwing the event
         */
        var KeyEvent = (function (_super) {
            __extends(KeyEvent, _super);
            function KeyEvent(key) {
                _super.call(this);
                this.key = key;
            }
            return KeyEvent;
        })(ex.GameEvent);
        Input.KeyEvent = KeyEvent;
        /**
         * Manages Keyboard input events that you can query or listen for events on
         *
         * @class Keyboard
         * @extends Class
         * @constructor
         *
         */
        var Keyboard = (function (_super) {
            __extends(Keyboard, _super);
            function Keyboard(engine) {
                _super.call(this);
                this._keys = [];
                this._keysUp = [];
                this._keysDown = [];
                this._engine = engine;
            }
            /**
             * Initialize Keyboard event listeners
             */
            Keyboard.prototype.init = function () {
                var _this = this;
                window.addEventListener('blur', function (ev) {
                    _this._keys.length = 0; // empties array efficiently
                });
                // key up is on window because canvas cannot have focus
                window.addEventListener('keyup', function (ev) {
                    var key = _this._keys.indexOf(ev.keyCode);
                    _this._keys.splice(key, 1);
                    _this._keysUp.push(ev.keyCode);
                    var keyEvent = new KeyEvent(ev.keyCode);
                    _this.eventDispatcher.publish("up", keyEvent);
                });
                // key down is on window because canvas cannot have focus
                window.addEventListener('keydown', function (ev) {
                    if (_this._keys.indexOf(ev.keyCode) === -1) {
                        _this._keys.push(ev.keyCode);
                        _this._keysDown.push(ev.keyCode);
                        var keyEvent = new KeyEvent(ev.keyCode);
                        _this.eventDispatcher.publish("down", keyEvent);
                    }
                });
            };
            Keyboard.prototype.update = function (delta) {
                // Reset keysDown and keysUp after update is complete
                this._keysDown.length = 0;
                this._keysUp.length = 0;
            };
            /**
             * Gets list of keys being pressed down
             */
            Keyboard.prototype.getKeys = function () {
                return this._keys;
            };
            /**
             *  Tests if a certain key is down.
             * @method isKeyDown
             * @param key {Keys} Test wether a key is down
             * @returns boolean
             */
            Keyboard.prototype.isKeyDown = function (key) {
                return this._keysDown.indexOf(key) > -1;
            };
            /**
             *  Tests if a certain key is pressed.
             * @method isKeyPressed
             * @param key {Keys} Test wether a key is pressed
             * @returns boolean
             */
            Keyboard.prototype.isKeyPressed = function (key) {
                return this._keys.indexOf(key) > -1;
            };
            /**
             *  Tests if a certain key is up.
             * @method isKeyUp
             * @param key {Keys} Test wether a key is up
             * @returns boolean
             */
            Keyboard.prototype.isKeyUp = function (key) {
                return this._keysUp.indexOf(key) > -1;
            };
            return Keyboard;
        })(ex.Class);
        Input.Keyboard = Keyboard;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        /**
         * Manages Gamepad API input. You can query the gamepads that are connected
         * or listen to events ("button" and "axis").
         * @class Gamepads
         * @extends Class
         * @param pads {Gamepad[]} The connected gamepads.
         * @param supported {boolean} Whether or not the Gamepad API is present
         */
        var Gamepads = (function (_super) {
            __extends(Gamepads, _super);
            function Gamepads(engine) {
                _super.call(this);
                /**
                 * Whether or not to poll for Gamepad input (default: false)
                 * @property enabled {boolean}
                 */
                this.enabled = false;
                /**
                 * Whether or not Gamepad API is supported
                 * @property supported {boolean}
                 */
                this.supported = !!navigator.getGamepads;
                this._gamePadTimeStamps = [0, 0, 0, 0];
                this._oldPads = [];
                this._pads = [];
                this._initSuccess = false;
                this._navigator = navigator;
                this._engine = engine;
            }
            Gamepads.prototype.init = function () {
                if (!this.supported)
                    return;
                if (this._initSuccess)
                    return;
                // In Chrome, this will return 4 undefined items until a button is pressed
                // In FF, this will not return any items until a button is pressed
                this._oldPads = this._clonePads(this._navigator.getGamepads());
                if (this._oldPads.length && this._oldPads[0]) {
                    this._initSuccess = true;
                }
            };
            /**
             * Updates Gamepad state and publishes Gamepad events
             */
            Gamepads.prototype.update = function (delta) {
                if (!this.enabled || !this.supported)
                    return;
                this.init();
                var gamepads = this._navigator.getGamepads();
                for (var i = 0; i < gamepads.length; i++) {
                    if (!gamepads[i]) {
                        // Reset connection status
                        this.at(i).connected = false;
                        continue;
                    }
                    else {
                        // Set connection status
                        this.at(i).connected = true;
                    }
                    ;
                    // Only supported in Chrome
                    if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                        continue;
                    }
                    this._gamePadTimeStamps[i] = gamepads[i].timestamp;
                    // Buttons
                    var b, a, value, buttonIndex, axesIndex;
                    for (b in Buttons) {
                        if (typeof Buttons[b] !== "number")
                            continue;
                        buttonIndex = Buttons[b];
                        value = gamepads[i].buttons[buttonIndex].value;
                        if (value !== this._oldPads[i].getButton(buttonIndex)) {
                            if (gamepads[i].buttons[buttonIndex].pressed) {
                                this.at(i).updateButton(buttonIndex, value);
                                this.at(i).eventDispatcher.publish("button", new GamepadButtonEvent(buttonIndex, value));
                            }
                            else {
                                this.at(i).updateButton(buttonIndex, 0);
                            }
                        }
                    }
                    for (a in Axes) {
                        if (typeof Axes[a] !== "number")
                            continue;
                        axesIndex = Axes[a];
                        value = gamepads[i].axes[axesIndex];
                        if (value !== this._oldPads[i].getAxes(axesIndex)) {
                            this.at(i).updateAxes(axesIndex, value);
                            this.at(i).eventDispatcher.publish("axis", new GamepadAxisEvent(axesIndex, value));
                        }
                    }
                    this._oldPads[i] = this._clonePad(gamepads[i]);
                }
            };
            /**
             * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
             */
            Gamepads.prototype.at = function (index) {
                if (index >= this._pads.length) {
                    for (var i = this._pads.length - 1, max = index; i < max; i++) {
                        this._pads.push(new Gamepad());
                        this._oldPads.push(new Gamepad());
                    }
                }
                return this._pads[index];
            };
            /**
             * Gets the number of connected gamepads
             */
            Gamepads.prototype.count = function () {
                return this._pads.filter(function (p) { return p.connected; }).length;
            };
            Gamepads.prototype._clonePads = function (pads) {
                var arr = [];
                for (var i = 0, len = pads.length; i < len; i++) {
                    arr.push(this._clonePad(pads[i]));
                }
                return arr;
            };
            /**
             * Fastest way to clone a known object is to do it yourself
             */
            Gamepads.prototype._clonePad = function (pad) {
                var i, len;
                var clonedPad = new Gamepad();
                if (!pad)
                    return clonedPad;
                for (i = 0, len = pad.buttons.length; i < len; i++) {
                    clonedPad.updateButton(i, pad.buttons[i].value);
                }
                for (i = 0, len = pad.axes.length; i < len; i++) {
                    clonedPad.updateAxes(i, pad.axes[i]);
                }
                return clonedPad;
            };
            /**
             * The minimum value an axis has to move before considering it a change
             * @property MinAxisMoveThreshold {number}
             * @static
             */
            Gamepads.MinAxisMoveThreshold = 0.05;
            return Gamepads;
        })(ex.Class);
        Input.Gamepads = Gamepads;
        /**
         * Individual state for a Gamepad
         * @class Gamepad
         * @extends Class
         */
        var Gamepad = (function (_super) {
            __extends(Gamepad, _super);
            function Gamepad() {
                _super.call(this);
                this.connected = false;
                this._buttons = new Array(16);
                this._axes = new Array(4);
                var i;
                for (i = 0; i < this._buttons.length; i++) {
                    this._buttons[i] = 0;
                }
                for (i = 0; i < this._axes.length; i++) {
                    this._axes[i] = 0;
                }
            }
            /**
             * Whether or not the given button is pressed
             * @param button {Buttons}
             * @param [threshold=1] {number} The threshold over which the button is considered to be pressed
             */
            Gamepad.prototype.isButtonPressed = function (button, threshold) {
                if (threshold === void 0) { threshold = 1; }
                return this._buttons[button] >= threshold;
            };
            /**
             * Gets the given button value
             * @param button {Buttons}
             */
            Gamepad.prototype.getButton = function (button) {
                return this._buttons[button];
            };
            /**
             * Gets the given axis value
             * @param axes {Axes}
             */
            Gamepad.prototype.getAxes = function (axes) {
                var value = this._axes[axes];
                if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
                    return 0;
                }
                else {
                    return value;
                }
            };
            Gamepad.prototype.updateButton = function (buttonIndex, value) {
                this._buttons[buttonIndex] = value;
            };
            Gamepad.prototype.updateAxes = function (axesIndex, value) {
                this._axes[axesIndex] = value;
            };
            return Gamepad;
        })(ex.Class);
        Input.Gamepad = Gamepad;
        /**
         * Gamepad Buttons enumeration
         * @class Buttons
         */
        (function (Buttons) {
            /**
             * Face 1 button (e.g. A)
             * @property Face1 {Buttons}
             * @static
             */
            /**
             * Face 2 button (e.g. B)
             * @property Face2 {Buttons}
             * @static
             */
            /**
             * Face 3 button (e.g. X)
             * @property Face3 {Buttons}
             * @static
             */
            /**
             * Face 4 button (e.g. Y)
             * @property Face4 {Buttons}
             * @static
             */
            Buttons[Buttons["Face1"] = 0] = "Face1";
            Buttons[Buttons["Face2"] = 1] = "Face2";
            Buttons[Buttons["Face3"] = 2] = "Face3";
            Buttons[Buttons["Face4"] = 3] = "Face4";
            /**
             * Left bumper button
             * @property LeftBumper {Buttons}
             * @static
             */
            /**
             * Right bumper button
             * @property RightBumper {Buttons}
             * @static
             */
            Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
            Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
            /**
             * Left trigger button
             * @property LeftTrigger {Buttons}
             * @static
             */
            /**
             * Right trigger button
             * @property RightTrigger {Buttons}
             * @static
             */
            Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
            Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
            /**
             * Select button
             * @property Select {Buttons}
             * @static
             */
            /**
             * Start button
             * @property Start {Buttons}
             * @static
             */
            Buttons[Buttons["Select"] = 8] = "Select";
            Buttons[Buttons["Start"] = 9] = "Start";
            /**
             * Left analog stick press (e.g. L3)
             * @property LeftStick {Buttons}
             * @static
             */
            /**
             * Right analog stick press (e.g. R3)
             * @property Start {Buttons}
             * @static
             */
            Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
            Buttons[Buttons["RightStick"] = 11] = "RightStick";
            /**
             * D-pad up
             * @property DpadUp {Buttons}
             * @static
             */
            /**
             * D-pad down
             * @property DpadDown {Buttons}
             * @static
             */
            /**
             * D-pad left
             * @property DpadLeft {Buttons}
             * @static
             */
            /**
             * D-pad right
             * @property DpadRight {Buttons}
             * @static
             */
            Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
            Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
            Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
            Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
        })(Input.Buttons || (Input.Buttons = {}));
        var Buttons = Input.Buttons;
        /**
         * Gamepad Axes enumeration
         * @class Axes
         */
        (function (Axes) {
            /**
             * Left analogue stick X direction
             * @property LeftStickX {Axes}
             * @static
             */
            /**
             * Left analogue stick Y direction
             * @property LeftStickY {Axes}
             * @static
             */
            /**
             * Right analogue stick X direction
             * @property RightStickX {Axes}
             * @static
             */
            /**
             * Right analogue stick Y direction
             * @property RightStickY {Axes}
             * @static
             */
            Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
            Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
            Axes[Axes["RightStickX"] = 2] = "RightStickX";
            Axes[Axes["RightStickY"] = 3] = "RightStickY";
        })(Input.Axes || (Input.Axes = {}));
        var Axes = Input.Axes;
        var GamepadButtonEvent = (function (_super) {
            __extends(GamepadButtonEvent, _super);
            function GamepadButtonEvent(button, value) {
                _super.call(this);
                this.button = button;
                this.value = value;
            }
            return GamepadButtonEvent;
        })(ex.GameEvent);
        Input.GamepadButtonEvent = GamepadButtonEvent;
        var GamepadAxisEvent = (function (_super) {
            __extends(GamepadAxisEvent, _super);
            function GamepadAxisEvent(axis, value) {
                _super.call(this);
                this.axis = axis;
                this.value = value;
            }
            return GamepadAxisEvent;
        })(ex.GameEvent);
        Input.GamepadAxisEvent = GamepadAxisEvent;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
/// <reference path="MonkeyPatch.ts" />
/// <reference path="Events.ts" />
/// <reference path="EventDispatcher.ts" />
/// <reference path="Class.ts" />
/// <reference path="Color.ts" />
/// <reference path="Log.ts" />
/// <reference path="Collision/Side.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Actor.ts" />
/// <reference path="UIActor.ts" />
/// <reference path="Trigger.ts" />
/// <reference path="Particles.ts" />
/// <reference path="Animation.ts" />
/// <reference path="Camera.ts" />
/// <reference path="Sound.ts" />
/// <reference path="Loader.ts" />
/// <reference path="Promises.ts" />
/// <reference path="Util.ts" />
/// <reference path="Binding.ts" />
/// <reference path="TileMap.ts" />
/// <reference path="Label.ts" />
/// <reference path="PostProcessing/IPostProcessor.ts"/>
/// <reference path="Input/IEngineInput.ts"/>
/// <reference path="Input/Pointer.ts"/>
/// <reference path="Input/Keyboard.ts"/>
/// <reference path="Input/Gamepad.ts"/>
var ex;
(function (ex) {
    /**
     * Enum representing the different display modes available to Excalibur
     * @class DisplayMode
     */
    (function (DisplayMode) {
        /**
         * Show the game as full screen
         * @property FullScreen {DisplayMode}
         */
        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";
        /**
         * Scale the game to the parent DOM container
         * @property Container {DisplayMode}
         */
        DisplayMode[DisplayMode["Container"] = 1] = "Container";
        /**
         * Show the game as a fixed size
         * @Property Fixed {DisplayMode}
         */
        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";
    })(ex.DisplayMode || (ex.DisplayMode = {}));
    var DisplayMode = ex.DisplayMode;
    // internal
    var AnimationNode = (function () {
        function AnimationNode(animation, x, y) {
            this.animation = animation;
            this.x = x;
            this.y = y;
        }
        return AnimationNode;
    })();
    /**
     * The 'Engine' is the main driver for a game. It is responsible for
     * starting/stopping the game, maintaining state, transmitting events,
     * loading resources, and managing the scene.
     *
     * @class Engine
     * @constructor
     * @param [width] {number} The width in pixels of the Excalibur game viewport
     * @param [height] {number} The height in pixels of the Excalibur game viewport
     * @param [canvasElementId] {string} If this is not specified, then a new canvas will be created and inserted into the body.
     * @param [displayMode] {DisplayMode} If this is not specified, then it will fall back to fixed if a height and width are specified, else the display mode will be FullScreen.
     */
    var Engine = (function (_super) {
        __extends(Engine, _super);
        function Engine(width, height, canvasElementId, displayMode) {
            _super.call(this);
            /**
             * Sets or gets the collision strategy for Excalibur
             * @property collisionStrategy {CollisionStrategy}
             */
            this.collisionStrategy = 1 /* DynamicAABBTree */;
            this.hasStarted = false;
            this.fps = 0;
            this.postProcessors = [];
            this.sceneHash = {};
            this.animations = [];
            /**
             * Indicates whether the engine is set to fullscreen or not
             * @property isFullscreen {boolean}
             */
            this.isFullscreen = false;
            /**
             * Indicates the current DisplayMode of the engine.
             * @property [displayMode=FullScreen] {DisplayMode}
             */
            this.displayMode = 0 /* FullScreen */;
            /**
             * Indicates whether audio should be paused when the game is no longer visible.
             * @property [pauseAudioWhenHidden=true] {boolean}
             */
            this.pauseAudioWhenHidden = true;
            /**
             * Indicates whether the engine should draw with debug information
             * @property [isDebug=false] {boolean}
             */
            this.isDebug = false;
            this.debugColor = new ex.Color(255, 255, 255);
            /**
             * Sets the background color for the engine.
             * @property [backgroundColor=new Color(0, 0, 100)] {Color}
             */
            this.backgroundColor = new ex.Color(0, 0, 100);
            this.isSmoothingEnabled = true;
            this.isLoading = false;
            this.progress = 0;
            this.total = 1;
            this.logger = ex.Logger.getInstance();
            this.logger.info("Powered by Excalibur.js visit", "http://excaliburjs.com", "for more information.");
            this.logger.debug("Building engine...");
            this.canvasElementId = canvasElementId;
            if (canvasElementId) {
                this.logger.debug("Using Canvas element specified: " + canvasElementId);
                this.canvas = document.getElementById(canvasElementId);
            }
            else {
                this.logger.debug("Using generated canvas element");
                this.canvas = document.createElement('canvas');
            }
            if (width && height) {
                if (displayMode == undefined) {
                    this.displayMode = 2 /* Fixed */;
                }
                this.logger.debug("Engine viewport is size " + width + " x " + height);
                this.width = width;
                this.canvas.width = width;
                this.height = height;
                this.canvas.height = height;
            }
            else if (!displayMode) {
                this.logger.debug("Engine viewport is fullscreen");
                this.displayMode = 0 /* FullScreen */;
            }
            this.loader = new ex.Loader();
            this.initialize();
            this.rootScene = this.currentScene = new ex.Scene(this);
            this.addScene('root', this.rootScene);
        }
        /**
         * Plays a sprite animation on the screen at the specified x and y
         * (in game coordinates, not screen pixels). These animations play
         * independent of actors, and will be cleaned up internally as soon
         * as they are complete. Note animations that loop will never be
         * cleaned up.
         * @method playAnimation
         * @param animation {Animation} Animation to play
         * @param x {number} x game coordinate to play the animation
         * @param y {number} y game coordinate to play the animation
         */
        Engine.prototype.playAnimation = function (animation, x, y) {
            this.animations.push(new AnimationNode(animation, x, y));
        };
        /**
         * Adds an actor to the current scene of the game. This is synonymous
         * to calling engine.currentScene.addChild(actor : Actor).
         *
         * Actors can only be drawn if they are a member of a scene, and only
         * the 'currentScene' may be drawn or updated.
         * @method addChild
         * @param actor {Actor} The actor to add to the current scene
         */
        Engine.prototype.addChild = function (actor) {
            this.currentScene.addChild(actor);
        };
        /**
         * Removes an actor from the currentScene of the game. This is synonymous
         * to calling engine.currentScene.removeChild(actor : Actor).
         * Actors that are removed from a scene will no longer be drawn or updated.
         *
         * @method removeChild
         * @param actor {Actor} The actor to remove from the current scene.
         */
        Engine.prototype.removeChild = function (actor) {
            this.currentScene.removeChild(actor);
        };
        /**
         * Adds a TileMap to the Scene, once this is done the TileMap will be drawn and updated.
         * @method addTileMap
         * @param tileMap {TileMap}
         */
        Engine.prototype.addTileMap = function (tileMap) {
            this.currentScene.addTileMap(tileMap);
        };
        /**
         * Removes a TileMap from the Scene, it willno longer be drawn or updated.
         * @method removeTileMap
         * @param tileMap {TileMap}
         */
        Engine.prototype.removeTileMap = function (tileMap) {
            this.currentScene.removeTileMap(tileMap);
        };
        /**
         * Adds an excalibur timer to the current scene.
         * @param timer {Timer} The timer to add to the current scene.
         * @method addTimer
         */
        Engine.prototype.addTimer = function (timer) {
            return this.currentScene.addTimer(timer);
        };
        /**
         * Removes an excalibur timer from the current scene.
         * @method removeTimer
         * @param timer {Timer} The timer to remove to the current scene.
         */
        Engine.prototype.removeTimer = function (timer) {
            return this.currentScene.removeTimer(timer);
        };
        /**
         * Adds a scene to the engine, think of scenes in excalibur as you
         * would scenes in a play.
         * @method addScene
         * @param name {string} The name of the scene, must be unique
         * @param scene {Scene} The scene to add to the engine
         */
        Engine.prototype.addScene = function (name, scene) {
            if (this.sceneHash[name]) {
                this.logger.warn("Scene", name, "already exists overwriting");
            }
            this.sceneHash[name] = scene;
            scene.engine = this;
        };
        Engine.prototype.removeScene = function (entity) {
            if (entity instanceof ex.Scene) {
                for (var key in this.sceneHash) {
                    if (this.sceneHash.hasOwnProperty(key)) {
                        if (this.sceneHash[key] === entity) {
                            delete this.sceneHash[key];
                        }
                    }
                }
            }
            if (typeof entity === "string") {
                // remove scene
                delete this.sceneHash[entity];
            }
        };
        Engine.prototype.add = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.currentScene.addUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.addChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.addTileMap(entity);
            }
            if (arguments.length === 2) {
                this.addScene(arguments[0], arguments[1]);
            }
        };
        Engine.prototype.remove = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.currentScene.removeUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.removeChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.removeTileMap(entity);
            }
            if (entity instanceof ex.Scene) {
                this.removeScene(entity);
            }
            if (typeof entity === "string") {
                this.removeScene(entity);
            }
        };
        /**
         * Changes the currently updating and drawing scene to a different,
         * named scene.
         * @method goToScene
         * @param name {string} The name of the scene to trasition to.
         */
        Engine.prototype.goToScene = function (name) {
            if (this.sceneHash[name]) {
                this.currentScene.onDeactivate.call(this.currentScene);
                var oldScene = this.currentScene;
                this.currentScene = this.sceneHash[name];
                oldScene.eventDispatcher.publish('deactivate', new ex.DeactivateEvent(this.currentScene));
                this.currentScene.onActivate.call(this.currentScene);
                this.currentScene.eventDispatcher.publish('activate', new ex.ActivateEvent(oldScene));
            }
            else {
                this.logger.error("Scene", name, "does not exist!");
            }
        };
        /**
         * Returns the width of the engines drawing surface in pixels.
         * @method getWidth
         * @returns number The width of the drawing surface in pixels.
         */
        Engine.prototype.getWidth = function () {
            if (this.currentScene && this.currentScene.camera) {
                return this.width / this.currentScene.camera.getZoom();
            }
            return this.width;
        };
        /**
         * Returns the height of the engines drawing surface in pixels.
         * @method getHeight
         * @returns number The height of the drawing surface in pixels.
         */
        Engine.prototype.getHeight = function () {
            if (this.currentScene && this.currentScene.camera) {
                return this.height / this.currentScene.camera.getZoom();
            }
            return this.height;
        };
        /**
         * Transforms the current x, y from screen coordinates to world coordinates
         * @method screenToWorldCoordinates
         * @param point {Point} screen coordinate to convert
         */
        Engine.prototype.screenToWorldCoordinates = function (point) {
            // todo set these back this.canvas.clientWidth
            var newX = point.x;
            var newY = point.y;
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                newX = focus.x + (point.x - (this.getWidth() / 2));
                newY = focus.y + (point.y - (this.getHeight() / 2));
            }
            newX = Math.floor((newX / this.canvas.clientWidth) * this.getWidth());
            newY = Math.floor((newY / this.canvas.clientHeight) * this.getHeight());
            return new ex.Point(newX, newY);
        };
        /**
         * Transforms a world coordinate, to a screen coordinate
         * @method worldToScreenCoordinates
         * @param point {Point} world coordinate to convert
         *
         */
        Engine.prototype.worldToScreenCoordinates = function (point) {
            // todo set these back this.canvas.clientWidth
            // this isn't correct on zoom
            var screenX = point.x;
            var screenY = point.y;
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                screenX = (point.x - focus.x) + (this.getWidth() / 2); //(this.getWidth() / this.canvas.clientWidth);
                screenY = (point.y - focus.y) + (this.getHeight() / 2); // (this.getHeight() / this.canvas.clientHeight);
            }
            screenX = Math.floor((screenX / this.getWidth()) * this.canvas.clientWidth);
            screenY = Math.floor((screenY / this.getHeight()) * this.canvas.clientHeight);
            return new ex.Point(screenX, screenY);
        };
        /**
         * Sets the internal canvas height based on the selected display mode.
         * @method setHeightByDisplayMode
         * @private
         */
        Engine.prototype.setHeightByDisplayMode = function (parent) {
            if (this.displayMode === 1 /* Container */) {
                this.width = this.canvas.width = parent.clientWidth;
                this.height = this.canvas.height = parent.clientHeight;
            }
            if (this.displayMode === 0 /* FullScreen */) {
                document.body.style.margin = '0px';
                document.body.style.overflow = 'hidden';
                this.width = this.canvas.width = parent.innerWidth;
                this.height = this.canvas.height = parent.innerHeight;
            }
        };
        /**
         * Initializes the internal canvas, rendering context, displaymode, and native event listeners
         * @method initialize
         * @private
         */
        Engine.prototype.initialize = function () {
            var _this = this;
            if (this.displayMode === 0 /* FullScreen */ || this.displayMode === 1 /* Container */) {
                var parent = (this.displayMode === 1 /* Container */ ? (this.canvas.parentElement || document.body) : window);
                this.setHeightByDisplayMode(parent);
                window.addEventListener('resize', function (ev) {
                    _this.logger.debug("View port resized");
                    _this.setHeightByDisplayMode(parent);
                    _this.logger.info("parent.clientHeight " + parent.clientHeight);
                    _this.setAntialiasing(_this.isSmoothingEnabled);
                });
            }
            // initialize inputs
            this.input = {
                keyboard: new ex.Input.Keyboard(this),
                pointers: new ex.Input.Pointers(this),
                gamepads: new ex.Input.Gamepads(this)
            };
            this.input.keyboard.init();
            this.input.pointers.init();
            this.input.gamepads.init();
            // Issue #385 make use of the visibility api
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
            document.addEventListener("visibilitychange", function () {
                if (document.hidden || document.msHidden) {
                    _this.eventDispatcher.publish('hidden', new ex.HiddenEvent());
                    _this.logger.debug("Window hidden");
                }
                else {
                    _this.eventDispatcher.publish('visible', new ex.VisibleEvent());
                    _this.logger.debug("Window visible");
                }
            });
            /*
            // DEPRECATED in favor of visibility api
            window.addEventListener('blur', () => {
               this.eventDispatcher.publish(EventType[EventType.Blur], new BlurEvent());
            });
   
            window.addEventListener('focus', () => {
               this.eventDispatcher.publish(EventType[EventType.Focus], new FocusEvent());
            });*/
            this.ctx = this.canvas.getContext('2d');
            if (!this.canvasElementId) {
                document.body.appendChild(this.canvas);
            }
        };
        /**
         * If supported by the browser, this will set the antialiasing flag on the
         * canvas. Set this to false if you want a 'jagged' pixel art look to your
         * image resources.
         * @method setAntialiasing
         * @param isSmooth {boolean} Set smoothing to true or false
         */
        Engine.prototype.setAntialiasing = function (isSmooth) {
            this.isSmoothingEnabled = isSmooth;
            this.ctx.imageSmoothingEnabled = isSmooth;
            this.ctx.webkitImageSmoothingEnabled = isSmooth;
            this.ctx.mozImageSmoothingEnabled = isSmooth;
            this.ctx.msImageSmoothingEnabled = isSmooth;
        };
        /**
         *  Return the current smoothing status of the canvas
         * @method getAntialiasing
         * @returns boolean
         */
        Engine.prototype.getAntialiasing = function () {
            return this.ctx.imageSmoothingEnabled || this.ctx.webkitImageSmoothingEnabled || this.ctx.mozImageSmoothingEnabled || this.ctx.msImageSmoothingEnabled;
        };
        /**
         * Updates the entire state of the game
         * @method update
         * @private
         * @param delta {number} Number of milliseconds elapsed since the last update.
         */
        Engine.prototype.update = function (delta) {
            if (this.isLoading) {
                // suspend updates untill loading is finished
                return;
            }
            // process engine level events
            this.currentScene.update(this, delta);
            // update animations
            this.animations = this.animations.filter(function (a) {
                return !a.animation.isDone();
            });
            // Update input listeners
            this.input.keyboard.update(delta);
            this.input.pointers.update(delta);
            this.input.gamepads.update(delta);
            // Publish update event
            this.eventDispatcher.publish(ex.EventType[5 /* Update */], new ex.UpdateEvent(delta));
        };
        /**
         * Draws the entire game
         * @method draw
         * @private
         * @param draw {number} Number of milliseconds elapsed since the last draw.
         */
        Engine.prototype.draw = function (delta) {
            var ctx = this.ctx;
            if (this.isLoading) {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, this.width, this.height);
                this.drawLoadingBar(ctx, this.progress, this.total);
                // Drawing nothing else while loading
                return;
            }
            ctx.clearRect(0, 0, this.width, this.height);
            ctx.fillStyle = this.backgroundColor.toString();
            ctx.fillRect(0, 0, this.width, this.height);
            this.currentScene.draw(this.ctx, delta);
            // todo needs to be a better way of doing this
            this.animations.forEach(function (a) {
                a.animation.draw(ctx, a.x, a.y);
            });
            this.fps = 1.0 / (delta / 1000);
            // Draw debug information
            if (this.isDebug) {
                this.ctx.font = "Consolas";
                this.ctx.fillStyle = this.debugColor.toString();
                var keys = this.input.keyboard.getKeys();
                for (var j = 0; j < keys.length; j++) {
                    this.ctx.fillText(keys[j].toString() + " : " + (ex.Input.Keys[keys[j]] ? ex.Input.Keys[keys[j]] : "Not Mapped"), 100, 10 * j + 10);
                }
                this.ctx.fillText("FPS:" + this.fps.toFixed(2).toString(), 10, 10);
            }
            for (var i = 0; i < this.postProcessors.length; i++) {
                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.width, this.height), this.ctx);
            }
            //ctx.drawImage(currentImage, 0, 0, this.width, this.height);
        };
        /**
         * Starts the internal game loop for Excalibur after loading
         * any provided assets.
         * @method start
         * @param [loader=undefined] {ILoadable} Optional resources to load before
         * starting the mainloop. Some loadable such as a Loader collection, Sound, or Texture.
         * @returns Promise
         */
        Engine.prototype.start = function (loader) {
            var loadingComplete;
            if (loader) {
                loader.wireEngine(this);
                loadingComplete = this.load(loader);
            }
            else {
                loadingComplete = ex.Promise.wrap();
            }
            if (!this.hasStarted) {
                this.hasStarted = true;
                this.logger.debug("Starting game...");
                // Mainloop
                var lastTime = Date.now();
                var game = this;
                (function mainloop() {
                    if (!game.hasStarted) {
                        return;
                    }
                    window.requestAnimationFrame(mainloop);
                    // Get the time to calculate time-elapsed
                    var now = Date.now();
                    var elapsed = Math.floor(now - lastTime) || 1;
                    // Resolves issue #138 if the game has been paused, or blurred for 
                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability 
                    // and provides more expected behavior when the engine comes back
                    // into focus
                    if (elapsed > 200) {
                        elapsed = 1;
                    }
                    game.update(elapsed);
                    game.draw(elapsed);
                    lastTime = now;
                })();
                this.logger.debug("Game started");
            }
            else {
            }
            return loadingComplete;
        };
        /**
         * Stops Excalibur's mainloop, useful for pausing the game.
         * @method stop
         */
        Engine.prototype.stop = function () {
            if (this.hasStarted) {
                this.hasStarted = false;
                this.logger.debug("Game stopped");
            }
        };
        /**
         * Takes a screen shot of the current viewport and returns it as an
         * HTML Image Element.
         * @method screenshot
         * @returns HTMLImageElement
         */
        Engine.prototype.screenshot = function () {
            var result = new Image();
            var raw = this.canvas.toDataURL("image/png");
            result.src = raw;
            return result;
        };
        /**
         * Draws the Excalibur loading bar
         * @method drawLoadingBar
         * @private
         * @param ctx {CanvasRenderingContext2D} The canvas rendering context
         * @param loaded {number} Number of bytes loaded
         * @param total {number} Total number of bytes to load
         */
        Engine.prototype.drawLoadingBar = function (ctx, loaded, total) {
            if (this.loadingDraw) {
                this.loadingDraw(ctx, loaded, total);
                return;
            }
            var y = this.canvas.height / 2;
            var width = this.canvas.width / 3;
            var x = width;
            // loading image
            var image = new Image();
            // 64 bit string encoding of the excalibur logo
            image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAEsCAYAAAA7Ldc6AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjenhJ3MAAA6Y0lEQVR4Xu3dUagkWZ3ncUEEQYSiRXBdmi2KdRUZxgJZhmV9qOdmkWJYlmYYhkKWcWcfpEDQFx9K2O4Fm6UaVhoahi4GF2wWh1pnYawHoXzxpVu6Gimatqni0kpTiGLhgy++3Pn9Mk6kkXlPZp4TGSfiROT3A39aq25EnMi6GfH/ZcSJ/BAAAAAAAAAAAAAAYAw/+9nPLqluqO6rroc/BgAAAIDhhNBxV3Ue6mn4KwAAAAA4nkLGddUdh40QOrp1J/wYAAAAAPSjYHHV4UIVCx3duhoWAQAAAIB0DhOq26qzEC4O1VlYFAAAAAAOU4i4rLrpMBFCxYV66623zt99993z999///ydd97p/t3tsBoAAAAAiFNwaEPHgxAkotWGjt/85jer+vWvf739M9x+BQAAAOAihYX2sbndJ1hdKF/hODs7W4WNNni09fjx4+7PPgirBgAAAICGgsLB0PHzn/98Z+joln+us9zNsAkAAAAAp0zhYN9jc1flMOErGk+ePImGje3yz22t43LYHAAAAIBTo0Bw8LG5b7/99vl7772XHDq6xe1XAAAAwIlTEDj42Nw2dHzwwQfRYJFaXk9nvTfCEAAAAAAsmZr/rMfmxsJEbjm8bG3jUhgOAAAAgKVRw9/rsblDla+gdLZzNwwLAAAAwFKo0T/6sblDFbdfAQAAAAvlBl81yGNzh6hf/epX3W17gju3XwEAAABzpqZ+8MfmDlW+raszjjthyAAAAADmRM180cfmDlWe0N4Z0/UwfAAAAAC1UwM/2mNzhyhPaO+M7WnYDQAAAAC1UwPvuR3dhn5dQz82d6ji9isAAABghtS8R8NHjaGjLU9w3xrv1bA7AAAAAGqlxn0jfPhqx1hPsDqmPMbOuM/C7gAAAAColRr3C+GjhrkdKeXvF+mM/XbYJQAAAAA1UtM+2/DB7VcAAADAjKhhn234cPn7RjrjfxB2CwAAAEBt1LDPOny4/KWHnX24GXYNAAAAQE3UrM8+fPhLD7v7oLocdg8AAABALdSozz58uB49etQNH9x+BQAAANRGjfpG+PAtTHMMHy5/E3tnX26EXQQAAABQAzfpnYZ9FT5q/46PXeXQ1N0X1aWwmwAAAACmpgZ9MeHD9d5773XDx92wmwAAAACmpgZ9UeHDxe1XAAAAQIXcnHca9UWEj/fff78bPp6quP0KAAAAmJoa88WFD9e7777bDSB3wu4CAAAAmIoa80WGD5cfG9zZt+thlwEAAABMQU35YsPH9u1XYZcBAAAATEFN+WLDh+udd97pBpDbYbcBAAAAjE0N+aLDh/elu3+qq2HXAQAAAIxJzfiiw4fr7OysGz7Owq4DAAAAGJOa8cWHDxe3XwEAAAATUyN+EuHjyZMn3fDhuhxeAgAAAABjUBN+EuHD9fjx4274eBBeAgAAAABjUBN+MuHD5f3r7O/N8DIAAAAAKE0N+EmFD26/AgAAACai5vukwofr0aNH3fBxP7wUAAAAAEpS831y4cP19ttvdwPIjfByAAAAACjFjXenCT+Z8PHBBx90w4frUnhJAAAAAJSgpvskw4frvffe64aPu+ElAQAAAFCCmu6TDR8ubr8CAAAARuKGu9N8n1z4eP/997vh42l4WQAAAAAMTQ33SYcP17vvvtsNIHfCSwMAAABgSGq2Tz58uN56661uALkeXh4AAAAAQ1GjTfhQPX78uBs+uP0KAAAAGJoabcKH6uzsrBs+XLfDSwQAAABgCGqyCR+qSPh4oOK7PwAAAIChqMEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qAgfAAAAQGFqsAkfKsIHAAAAUJgabMKHivABAAAAFKYGm/ChInwAAAAAhanBvt1puAkffyrCBwAAADAkNdh3Og034eNPRfgAAAAAhqQGm/ChInwAAAAAhanBJnyoCB8AAABAYWqwCR8qwgcAAABQmBpswoeK8AEAAAAUpgab8KEifAAAAACFqcEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qAgfAAAAQGFqsAkfKsIHAAAAUJgabMKHivABAAAAFKYGm/ChInwAAAAAhanBJnyoCB8AAABAYWqwCR8qwgcAAABQmBpswoeK8AEAAAAUpgab8KEifAAAAACFqcEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qB49etQNHi7CBwAAADAkNdiED9W7777bDR4uwgcAAAAwJDXYhA8V4QMAAAAoTA024UNF+AAAAAAKU4NN+FARPgAAAIDC1GATPlSEDwAAAKAwNdiEDxXhAwAAAChMDTbhQ0X4AAAAAApTg034UBE+AAAAgMLUYBM+VIQPAAAAoDA12IQPFeEDAAAAKEwNNuFDRfgAAAAAClODTfhQET4AAACAwtRgEz5UhA8AAACgMDXYhA8V4QMAAAAoTA024UNF+AAAAAAKU4NN+FARPgAAAIDC1GATPlSEDwAAAKAwNdiEDxXhAwAAAChMDTbhQ0X4AAAAAApTg034UBE+AAAAgMLUYBM+VIQPAAAAoDA12IQPFeEDAAAAKEwNNuFDRfgAMHfn5+ffUCULixWh1b/QbCXJm2GxIrT+e81mktwLiwEASlCDTfhQET4ALIGa5yoCiFb9pWYLWV4Iiw9O6yaAAEAN1GBvhI+HDx8SPpoaLXz4RNec7xbhG2G3AEzE78Pm7ZgmLDY4rfrNZgvZroRVDErrJYAAwNTUYG+EDzfhseZ86TX1lQ+f6Jrz3SIQQICJ+X3YvB3ThMUGpdVeadbey1fDagal9RJAAGBKarAJH6oabrvyia453y0CAQSYmN+HzdsxTVhsUFptn9uvWq+E1QxK6yWAAMBU1GATPlQ1hA/zia453y0CAQSYmN+HzdsxTVhsUFrtMQGkSPPv9TarT0IAAYChqMEmfKhqCR/mE11zvlsEAggwMb8Pm7djmrDYoLRaroAAAAgfbdUUPswnuuZ8twgEEGBifh82b8c0YbFBabXMAQGAU6cGm/Chqi18mE90zfluEQggwMT8PmzejmnCYoPTqh81W8jGU7AAYO7UYBM+VDWGD/OJrjnfLQIBBJiY34fN2zFNWGxwWvVzzRayFDuGaN0EEAAYgxpswoeq1vBhPtE157tFIIAAE/P7sHk7pgmLFaHVv9JsJQnfhA4Ac6cGm/Chqjl8mE90zfluEQggwMT8PmzejmnCYsVoEynjcVD5RFikCK2fAAIAJanBJnyoag8f5hNdc75bBAIIMDG/D5u3Y5qwWFHajCelv6Dqfju654g4eHwp/FhR2g4BBABKUYNN+FDNIXyYT3TN+S5NWAwAonSYqC6A1EC7SgABgBLUYBM+VHMJH+YTXXO+SxMWA4AoHSYIIBHaVQIIAAxNDTbhQzWn8GE+0TXnuzRhMQCI0mGCABKhXSWAAMCQ1GATPlRzCx/mE11zvksTFgOAKB0mCCAR2lUCCAAMRQ024UM1x/BhPtE157s0YTEAiNJhggASoV0lgADAENRgEz5Ucw0f5hNdc75LExYDgCgdJgggEdpVAggAHEsNNuFDNefwYT7RNee7NGExAIjSYYIAEqFdJYAAwDHUYBM+VHMPH+YTXXO+SxMWA4AoHSYIIBHaVQIIAPSlBpvwoVpC+DCf6JrzXZqwGABE6TBBAInQrhJAAKAPNdiED9VSwof5RNec79KExQAgSocJAkiEdpUAAgC51GATPlRLCh/mE11zvksTFgOAKB0mCCAR2lUCCADkUINN+FBFwsd91WzDh/lE15zv0oTFACBKhwkCSIR2lQACAKnUYBM+VJHwcSe8RLPmE11zvksTFgOAKB0mCCAR2lUCCIDy/unvPnRZdS2hbiXUHdX9Tt0ImynKTXa36SZ8LCt8mE90zfkuTVgMAKJ0mCCARGhXCSAALlJT7zCw3ejvqvOJ61YYdjFusrtNN+FjeeHDfKJrzndpwmIAEKXDBAEkQruac6wlgACnwk39VpNfc90Nwy7CTXa36SZ8LDN8mE90zfkuTVgMAKJ0mCCARGhXc461BBDgVKipHzSA/OhrHz7/6bc+drAevvTM+S9e/uTeevzdT62qs/77YdiDc5PdbboJH8sNH+YTXXO+SxMWAwajX6svqZ5XuXH176PrkWoX/137c17Gy34hrK56Gqv396th7O1+vKna5Xeq2exvGGOysNjiaVf975dqkACi9XxB5d+XF7zOULvM5ncM86LfpSsqH/NeV8WOde0x7hWVf+5KWPQ0qKlfB5AHL146/+33Lu+sP/7ws+fn//z5UesPP/jMamxthWEPyk12t+kmfCw7fFh40ycLiwG96dfITVHbfA/N66zmBKZxfEL1nMon1n0how+ftL3e58LmqqDxEEAitKs5v++9A4iWdcD178W+EJ/K66judwzzoN8b/y72Oc6f1hVANfXrAOKrDrEQMHW14wt1OQx9EG6yu0034WP54cP8Rm/e72nCYrOnXfEnMm7gcj0fVjEpjcONbe74Jzuoa9t+vf0p7BBNUSo3/P4k9xNhGKPw9sJ2/WnfWPy6uvEfdV9jwjiShcWK0Opzjm9F3x9ef7OZJNlj0TL+nSv5/vK6He5r+B2b9XlLQ8p6j8iXwqKD07oH/73Uz/lDpqx/oy0EkNrKt2y1Y1RdD0M/mpvsbtNN+DiN8GF+ozfv9zRhsUXQ7vhkmutRWHxSGoeb+RwOK6NfFdA2/QnYmI14jPf9G2FIxWgbDln+tLhPsB2Ktz1pSNb2CSARXn+zmSTJY9HPlg4e22r4HZv1eUtDWmwA0c/0Oa9uO7kA4idgnbs83yIWAKYu3xrWjlE1yJOw3GR3m27Cx+mED/MbvXm/pwmLLYZ2KWv/g+LN7D7avj9dyvXVsPgotD03431e22LC0AanVfe9zaAkj2eST6q1XQJIhNffbCZJSqM39XvMVxgnmSei7Wbtd1isGhrSIgOI/t4fwAzh5ALI+vG6nucRCwBT1y9f/fRqfKGOnojuJrvbdBM+Tit8mN/ozfs9TVhsMbRLfZp5fwI42W0I2nbWv5mMdjDXtnz7Ue7VmVGEIQ5Gq2yveNTKv6ejN4jaJgEkwutvNpPkUKPneUVTXmlrTXI1RNuc9XlLQ1pcANHfDXksJIDUVr9//cpqfKGehqH34ia723QTPk4vfJjf6M37PU1YbFG0W7knA3slLD4qbde3W+RwgzDKrVfajsPcmLeCZAnDHIRW1+d3ZgqjhxBtjwAS4fU3m0myr9HLPQaMYdSrwtrerM9bGtKiAoj+fOgPYgggNZYf79uOU3U1DD+Lm+xu0034OM3wYX6jN+/3NGGxxdGu9XlC0diNXZ+J56PceqXt1NgUbQhDPZpW5Vuu5mS0EGraFgEkwutvNpNkrEZvSKN9KKNtzfq8pSEtJoDoz4aY87GNAFJjvfHtj6/GGOpmGH4SNdiXVPc7DTfh4091cuHD/EZv3u9pwmKLo13r01SOepDU9nJvbRplfNpOzU3RWhju0bSquQUQezMMvzhtiwAS4fU3m0kSa/Rym9YpvBCGW5S2M+vzloa0iACi/9/nFuYUo55bJ6dmfhYBpO8XEqrBdvh40Gm4CR9/qpMMH+Y3evN+TxMWWyTtXp+5C6M8H1/byT3Qj/Kpt7Yxi/BhYchH06rmGEBslNtkvJ1mc2nCYkVo9TnHt2oDiP5/9VcYO4rPCdE2Zn3e0pCWEkCG/m6jFgGkxtr+QkLVpbALO6nBJnyEInxs8hu9eb+nCYstknbPtzjlzmEY5bG82k7Wv5MUv/VK2xgyfDgw+XG9PjG7wY+ecPXnDmL+e1/29/aT/73CKo6mVR0bQDzmdl89mdjru/BQA/9Z+Dvvq38+9/a7mDFCKQEkwutvNpNkPRb97z6fMvt3zB+oOLj4d+jCv7v/LPxd+14a4verVfT2VK1/1uctDWn2AUT/u8StVy0CSK31469/ZDXOUDfCLkSpwSZ8hCJ8XOQ3evN+TxMWWyztohvCXEWbfa0/d0zFD97axlDhw+s56iqSlncj5ZPh3jASfvxoWlWfAOIA4WawdwDQsu0XHOaG5K7i9+lrGwSQCK+/2UyS1Vj035wPRRwg/Nof8zvmY80Q39vjMRd7UqDWPevzloY06wCi/+bMR/Tvk4/PF/ZBf9Z+yOLjWvcDJQJIrfXwpWdW4wx1N+zCBWqwCR+hCB9xfqM37/c0YbFF027mnoB9IC5ysvV6VTkNp8dS9FNurT/35BnjdQz+mmmdPplFf6fDjxxNq0oNIP5384l30P30+lTHBMCqfj/CYkVo9TnHtxoDSMqxaBU8VhsZiNbnqy5Z54aIYvNBtO5Zn7c0pLkHkJTx+xiVfazRMg7Bo8wlqkanoV/d5hRr/GuprcfxuqK3YanJvtttugkfhI9teqPfUyULiy2adjPn051WkQOm1pt7oqrtasw2N1RFG2DTNi4EkfBXR9OqDgUQ3xc9xn3wfecFFD25a/0EkAivv9lMEv9synvN76eSVxqOvc2myK1YWu+sz1sa0twDyL4Pxfx3o3//0Kx1G/pY019bpdyGpUb7Vrfx/vWvfx1t0JdchI/9dKC4tzpkJAqLLZ52tU9zN2hj7fU1q01WuoHqE8xaXm6KLyzzv+NqzOGPjqZV7QogPvGOuo/aXm4jY78Lixeh9RNAIrz+ZjNJHGIPXfkc6xHbvhrS931f5DX1epvVpwmLVUNDmm0AUe0Lxv77YoF4sTrNfLThr622bsOKPg1LzbZvwXraNt+PHj2KNulLLcLHYeGAkSwsdhK0u1mvjQx6svX6mtUmcYNQ+taa3Nej5bFN9omYtu3gNNi/jdYVCyBuKCY58Wq7ff5dSjY0BJAIr7/ZzCDGDrrHhJDBf9e0zqzXMixWDQ1pzgFk122Br4dVIlenmY82/LVV5GlYl8OubFDTvb4K8tZbb53MVRDCRxodNO41x440YbGToN31FYjck+4gJwqtJ/dWp1pvvfInucVvuRqT9qcbQCa/3cDbX40kT7FH8nrdzSbShMWK0Opzjm9zCSCjX0k0bbfP75kN/rp6nc2q04TFqqEhzTWA7Loq5+M8Vz766jbzsYa/xvrptz62HrPqdtiVDWq8T+4qCOEjnQ4a91aHj/kq+t0GXn+zmWRHP5ZX68ideF66cep761XxqzJT0D61AaTo/fc5NI7cSenFfme0bgJIhNffbOYok4SPlrbfd07I0LenZr2WYbFqaEhzDSAxizzOj6rTyEeb/Rrrl69+ej1m1VPVrsnoG3NBnjx5Em3cl1CEjzw6cNxbHULmq/iXq2kbuV+2dFSToOVzTk7FD/5af+7J0jyuRU5E1H45gIxy/30qjSf7ClVYdHBaNQEkwutvNtNb8Ucop9A4+uzHoA8+0PqyxhAWq4aGtKQAMsqX8S5ap5GPNvu11tZk9Jthdy5QI37WNuXvvPNOtHmfexE+8ungca85hszWGAEk99YDN9+9PhnXcrkTz0vfetX36gcnpZHpNc/9dyr1hCICSITX32ymF18RreVqW59bUwd98IHWl/VahsWqoSEtJYAUfc+cjE4TH230a61fvPzJ9bhVZ2F3LlAzfr3bnP/qV7+KNvFzLcJHPz6ANMeR2SoeQMzbaTaXrNe4tFzOv0fxg7+2kbvfdlrPcK+EXvfc27CKNDVaLwEkwutvNtNLsQa0D42nz3FhsA8ltK6s1zIsVg0NaSkBhFuvjqXG/VKniY82+rXWH3/42fMffe3D67Grdn4zupry+22D/vbbby9mQjrhoz8dQO41x5HZGiuA5M7LsKyDs34+5zYafwJZ/OCvbeTuczWf1J4ave659+cXee94vc3q04TFitDqc45vtQaQ6j5l1ph8PMw12AcTWlfWaxkWq4aGtIQAUsUtgbOnpv1a28B7Ynes0a+5Mq6CXFatJ6S/99570YZ+TkX4OI4OIn0PPrUYJYCYtrXr+x92SX4soX42N+AUn4OgbfR58tWkk2RPmV773N9PAsimWgNIVVc/WhpX7hW3ox/Q0dK6sl7LsFg1NKQlBBC+bHAIatpnHUAiV0FuhV27QA36xoT0Od+KRfg4ng4ifQ8+tRgtgJi2V+Q2F/1czglplE9EtZ1dz3vfZbAGA/n0+ud+Kl3Ft/eHxYrQ6nOObzUGkOqufrQ0tj6P5R3kqq3Wk/VahsWqoSHNPYC8GRbHsdSwzzqAuLaugux8IpapUX/QNu1z/W4QwscwdCDpc/CpydgBJHdS9sEDtX4mZ1LnWLde9bnFgqsfEwv/DqmKNLdaLwEkwutvNpOl6veUxpd7i+Yg80C0nqzXMixWDQ1p7gGkqqcAzpqa9dkHkMhVkOj3gpia9auq9a1Yc3sqFuFjODqQ9Dn41GTUAGLaZu6tSXubCP19zpWGUQ782s7zzeaScfWjAvp3yAnHBJBNNQaQqudTaXy5V4QHOV5rPVmvZVisGhrS3AMIt18NRc367AOI6/F3P7Xah05dDbt4gZr2m90mfi5fUEj4GJYOJPea48lsjR5ATNvNCQ07J2brz3Pu2x/tdgxtK7ex4MlXFdC/Q877mQCyqbYAMtr7vS+NMfeDikH2yetpVpcmLFYNDWnOAYQPm4akRn0RAcT1k29+dLUfoe6HXYxS836328zXPh+E8DE8HUxyDz61mSqA5D4LPzpO/XnqLQyj3HrV0rZyb63gE7EK6N8h5/1MANlUWwCZ5NiWQ2PM/d6iQZpXrSfrtQyLVUNDmnMASX64ChKoUV9MAPnt9y6v9qNT+76c8JJqYz7IBx98EG3+py7CRxk6mNxrjilpwmIQvRw5jz11gNi4CqL/n3MSGu2eW21rkqYC6fSa+8qZbwX075CvVvl9nBOIjQCyqbYAUqzpHFIYa7Kw2FG0mlmftzSkOQeQ6oPxrKhJX0wAcT148dJqX0J5QvrlsKsXqJHfmA/y85//vKpJ6R6L56i04wtF+BiIDiZZB5+wGAK9JDmv3/q56frfOVdQijZG27S93DkuPA++AL2uQ4SMfQggm2oLILP4Ph2NM3e/jr6Sq3VkbTMsVg0Nac4BZBbBeDbUoN9oG/Y3vv3xaFM/p4pMSD90K9bGt6TXEkI8Bo+lOzYV4WNAOphkHXzCYgj0kuQ+inJ18tV/U+eQjHrrlWl7uSdHnn7Vk1670iFjHwLIpqoCSFisehpq7uO6j25gtY5Zv5Ya0pwDyKjno8VTg36rbdb9ONtYUz+3evLas6v96dTO7wYxNfY3uo3+w4cPo6FgrCJ8jEMHk3vNMSVNWAwdellyTiZuMnMmno/+uENtM7ehYP7HAX6NVL5l7wWV33NjhYx9CCCbagogs/meBY119GZa65j1eUtDmm0ACYthKG7O20Z9KQHE9fClZ1b71KlrYZej3OB3G37Pu4iFg9JF+BiPjif3msNKmrAYtuilebN5hZKkNp+TNCHaLr8TR9LL4u9R8ROCHOZqCBsxBJBNNQWQomMZksZKAMmkIRFA0FBjvsgA4luxtp6KtfcLCs2NfrfxHzuEED7GpeMJB58B6KXJuaqRapIrC2HbqZiA3qHXw7dT5V5BmgoBZBMBpAeNNbeZPnoSs9Yx6/OWhjTXADKb38vZUFO+yADi+v3rV7bngzwIu72TG/5uAHAIGWNOCOFjfD6gNMeVNGExROjl8e01Q5nsSSNh+6k4IYleB1/tyH108dQIIJsIID1orASQTBoSAQQNNeWLDSCuX7766dW+depgU+/GvxsEHAxKhhDCxzR8QGmOK2nCYojQy+PbboZoQie7/1vb9j7kOOkTkvbfV77mFjxaBJBNBJAeNFYCSCYNiQCChhryRQcQV2Q+yN5J6eYA0A0EpUII4WM6PqA0x5U0YTHsoJco9xG2MZNN6ta2c28lO8lvQNd+O6gNecVrCgSQTQSQHjRWAkgmDYkAgoab8bYxX2oAcfkRw+1+hroRXoKdHAS6wWDoLyskfEzLB5TmuJImLIY99DIdMwdgsluvTNvPDSCTjncK2meHj5yHDpTg961/z9zI+PYv/7t5XDnvZwLIJgJIDxorASSThkQAQUON+DqA+IsI/W3if/jBZ6JN/JwrMindlRJCbnUDgkPI2dlZNFDkFOFjej6gNMeVNGEx7KGXKfc2pq5Jv3xM2yeA7KH99eN0x3iqlbfh96Yf27wRMsJQovT3Oe9nAsgmAkgPGisBJJOGRABBQ0343a2mfF0OJL59yd+r4QY+1tjPqbwPP/76R7b3MyWEbHxPiOuYJ2QRPurgA0pzXEkTFsMeepn8fQ99TXpLk7ZPANlB++pgOXT48JWUNmT49r2jGg0tn/N+JoBsIoD0oLGO3kxrHbM+b2lIBBA01IDf32rId5avILSBJNbgz6EiT8ZypYSQq6qnncCwChG5t2QRPurhA0pzXEkTFsMOeolyvxk9ptjJ5hBvuxlCslMKIEPcduV1uPko8m+s9ea8nwkgmwggPWisBJBMGhIBBA0131dV11W+FeuOKjmQeF6FnzI1t6sjR4SQS6oHneCwuiXr8ePH0bCxXYSPuviA0hxX0oTFsINeoiGaVD9VaZJbsbTd3AByEick7ecxE8797+mG40pYXTHaRs77mQCyiQDSg8aaO+eNAEIAwSFqyB1Mbqhuqx6ozvfVgxcvzerKSN8QYgoNt7dCxPnDhw/Pnzx5Eg0eLsJHfXxAaY4racJiiNDLk3tS2WeSW7G0XQLIFu1j36tavl3r+bCaUWh7Oe9nAsgmAkgPHmsz5GRHB3GtY9bnLQ2JAII8as4vqXylxFdJzlTnsfIcCz9Naw5XRXaEkKRQoPBwTXXWCROrevTo0SpsED7q5wNKc1xJExbDFr00uY17imInnV20zdwJ9KcQQLLeI4E/FR79Kpa2mTNWAsgmAkgPGmvW9+CExY6i1cz6vKUhEUBwHDXqvkLiqyPRMOLG3ldFan+i1o6nY/k2tEthV3dSiPAtWRuP6nW9/fbb5++//z7ho3I+oDTHlTRhMXToZXHTXuLL6Ca5FavZdLqw2CJp9/pc/XglLD46bTvn/UwA2UQA6SGMN9XvwmJH0Xpmfd7SkAggGI6a9WsqXxk5j1XtQWRHCPFtZ1fDLu6lQBG9GuLbsggf9fIBpTmupAmLoUMvi59ilMonnpywMvqtWNpm7pOeJn10cEnat5x/W5v0BO3tN8NIQgDZRADJpHFOcsum1pM1JyssVg0NiQCC4alh921aN1XRqyK1BxGPb2vMT1Wp80J8NcTfGbLxpKytInxUxAeU5riSJiyGQC9JzjefvxmW8Xc65Bj1VixtL+t3Qka/VWws2rfcMFZ8ovk+2n7OeAkgmwggmTTO3EeOD/KBitZTze9YHxoSAQRluXFXXZi87luzap4j8vi7n9oYbyh/V8rBW7JMIeOyg0YndBA+KuUDSnNcSRMWg+jlyP1eiC+ERb1sztOyRr0VS9vK/dR/kY/i1X7lfro72a1XrTCOVASQTTUFkEdhsappnLnHiq+GRY+i9cw9gOQ+VY8Agn7UuPv2rAtXRDxZvdanZvnb4COT070P18JuHaTA4e8NuU/4qJcPKM1xJU1YDKKXI+fxkxuf/On/5za3o92KpW3lfjq3yJOS9iv3dXguLDoJbf9KM4xkBJBNNQWQWRxrNczcuW/rD2GOofXkvjerukqr8WT9LggBBMdR8+4rIheCiL9LpMarIR6Tvwl+e7wqz3VJuhpiDiLhf6IyPqA0x5U0YbGTp5ci59YDXyW5cAVDf5b76eEoJ1Fvp9lclsXNA9E+Zb03ZNLXQNuf5H78bVovASTC6282k2yQZr0Uj68ZZrqw6NG0qrkHkNxbOwkgGIaad3/hoedWnLflqw21Xg3xLVmRqyHJc0NQLx9QmuNKmrDYSdPL4E+ac04g0e+C0J/nrme0W7GazWUZ9fsuxqB9yvl0d/JbZjSG3KaMALKptgAyyO1KpWh8ubcRDfb6al25v+vV3CaqseReqTQCCIaj5v2y6sI3rtd6NcQT53dcDfEcl+TbslAXH1Ca40qasNhJ08uQM39j7wFbfz/JJM5DtJ2s3wtZ3Ikp7FeqyfffY2iGkqzImLVeAkiE199sJtnrYdEqaXy5t18NFqi0rtnNz2ppLLkPITECCNL8q+f+x+XwPw9S8+4vNty4GuK5If6CwFgQmLp2XA1xOUwRRGbGB5TmuJImLHay9BLkfvJ28KlI+pmcQGPFbyfQNnKDkVV9y0gO7cusvpBR288drxFANtUWQKzKWxs1rj63aQ52fNC6cre/egJhDTSWnLmDLQIIDlP4uKU6D/9Nmiehxt2P7r1wNeSXr346GgKmLl+hiTyuty2CyIz4gNIcV9KExU6Sdj/3nueky/76udyTafFbsbT+PrcJVPMp47G0L1XMp0il7fcJjASQTTUGkCpvbdS4cpvoQW9R1Pr6BO7Jw5zH0AwlGwEE+ylwXA/ho62nqpvhrw9S4+7vD3ETvy43+rEQUEP5Ks2O27JcDiLXw66hUj6gNMeVNGGxk6Nd94mj2KNz9bO5E9KL34qlbeRembFFXAXRfswtgOTeDmMEkE01BpDqHserMfX5cGLwORhaZ+5E7snDnMaQewW9RQDBbgoaV0Pg6AaQth6okp4Epab9qmrjSVlu8mv9zhCXH9m7J4h4XzzpPvm2NIzHB5TmuJImLHZytOtFn9uun3fAqebJKKb197lXeREnKO3HbAKItt3n38kIIJtqDCBW1VUQjafPfgz+BZ1aZ+44Jp1To+33Oca3CCCIU7i4FELGKnD86//0P1fV/v9O3VYdvC1Lzbpvydr4AsOffPOjVYcQ14Eg4vJVET+KOPkRvijLB5TmuJImLHZStNu5zWivE52Wy72NpuitWF63qs8Js+qn96TQPuTebjfJJ9Xarv+N+lz9MALIploDiN+DVcwF0TieW40oT6nfs9wPhWzwIJRK2+579cMIIIhTqLjbCRnnX/zK98//w3/7f+efe/7VbvhoK+dqiL9vw437qjz5u9bJ6d3yE7N869iOyeptOYz4ljOujEzIB5TmuJImLHYytMu5Tbh/tvdJTsvm3vZU9FYsrb/vSXP2t2KF/cgxenOjbfZpwloEkE21BhCb/IlYGkPfDySKNM9ab58wNMnjeLVd37bW57VrEUBwkcJEO+l8VX/216+d/8f//v/X5TDyb67/r24AaetWWMVeoUl3w76quYQQl6/YeCK9r9509yFSvk3LYctXR/jSwhH5gNIcV9KExU6Gdjl3suVRn/5r+dyrLVby5NS36fAysw4hzW5kGbW50fb6/K50EUA21RxAbNJbsbT9Pk9vKvaaat0+NuU66gOivrTNPvPpuggg2KQQsTHp/N/9l1c2wke3Pv9Xf98NH23dV6XckuXG3I36quYUQtryVZGHLz2zesRwd1/2lK+Q3FZ5/sg1FcGkAB9QmuNKmrDYSdDu5n7CNsijHrWe3E+1S9+K1fcqiMc12S0Px9LYs94b4uZmlFtltB3fInbMJ6pGANlUewCx58LqRqXt5j4ko1WscTatv09jP+rVJG2v72vXRQDBnyg4bEw691UO33YVCx9t/fv/+n/Pn/3yd7ZDyJnqYHOtBnz2IaQthxF/n8iB+SLRCi8HBuIDSnNcSRMWWzztap9L5oN84q/19LnqUOxWLK3b4+k7z8D7MemVEG9flf36eBlVrjGeTjZE+DACyKY5BBD/uxdt6rdpe30b6OLNqrbR5/HTNsrVJG2n7/i2EUDQUGC4MOn8L/72H6OhY7scUnylpF02lIPMjbD6ndSAXwghtU9MTylPXv/Fy59cBZID80YIIAPzAaU5rqQJiy2edjXrdZFBG0+tr7Zvyz3mdh83TZPcPqLtts1w9olTy/S5x9yK7avWPVT4MALIpjkEkNZYDfQxn94X/+BB2/AHRX0VfQ21/r5XjmMIIGgoLFyYdB4LG/vKc0W66wh18DtD1IRvhJA5PB0rt3yF5Mlrz65CyRvf/vh6X1X3w8uAgfiA0hxX0oTFFk27mfuplRvCwW+90Tqz/m2k9K1Yx0x4Nt9DPtYtSg5w3as2fQJIn3vMW4M3N16nal/48N/lhBMCyKY5BRDz+7HI+0nrdWN/zHhHmw+lbfWZm9Iq8T71cePQmHI/RCCA4PCk85zyLVmRx/XeCZvaSY34hRASa+SXUL460tlXAsjAfEBpjiuL0vsgqWX7fMJc5L5srddjyVX6qVjHTqb0a+sGtURg84l/O3i0ev1OaLljPgEepAnTelKbQb+uOe9nAsimmgKIf4dTjkP+ucGaaK3L7yH/++UeA7sGmQuXSts79mEMg30wovX4qmns+NPlv896jwgB5NQpHCRPOk8t37oVeUpWSgjZeDpWzd+YfkwRQMryAaU5rizKMQEkt8Eu3bT0uepQ8mTVZ27MLm7ujw5vXkdY175x9fp30nLHNje9G0Qt522nBqBV06f/5ryfi/zuar0EkAivv9lMEv9szuu4+j1T9WqktZzf18cGD/PyUzxl6tjzmMft/e81di3n1z51DH5fE0CQTqEge9J5ank9PUPIxveE+JG3sSZ+zkUAKcsHlOa4sih9m83ck4IVPdlq/f5EMrcpcDNS7FYnrXvIeQjmdfn30K+/w4RP0BfG7z8Lf+ef8c/m/O72PnF62WYVR/E+Oky4UbnQTOjP2n3z3/vnDn2Kum11v73+O8prso/Wm/U+CosVodVP/nq0vP5mM0lWY9F/+1xx9Hb8b+DfpwvzMPRn3d81f8Bx7FXNrqme0tXnavEufj3aY9G+18+36vrqSc6xcHWFWv/Neo8IAeRUKQz0nnSeWjsmp6eEED+u9rytuT4Za1cRQMryAaU5rixK9kFSy/iEkmuU+5y1HTcKuUrfijV0CCmt94lTyw7Z3JSw/u4Z/e+c93ORZkLrJYBEeP3NZpKsxqL/DnnFsbSik7oP0faPnaNWmoPN6oMV/ZcAgjQKAkdPOk+t3BCipvySyl/kd+7y92wsaVI6AaQsH1Ca48qiZB0k9fP+RCv3E+dHYfFRaHt9/p2KnbRM659TCDnqxKnlcxuGsbwShrii/5/ze1KkmdB6CSARXn+zmSTrseh/+5P42k0aPloax5BXc4bk4+T6aor+NwEEhykADDbpPLV6hJCrnSZ99eSoWDM/xyKAlOUDSnNcWZSsg6R+vqp5FjHanj8JzVX0VizT+h1CcsPbFI4+cWodxzxtp4QL++Q/a/4qSZFmQuslgER4/c1mkmyMRf+/z1XQsVQRPkxj8YdJNX4osnG+0P8ngGA/Nf6DTzpPrUgI2fuIXjXnG5PS/UV/sYZ+bkUAKcsHlOa4sijJB0n9bJ9PFzc+dR6LttvnU/gxvhjPJ/3af4+OPnFqHd7PWj5h9esdmyeT8+9QpJnQegkgEV5/s5kkF8aiP6sthLjRryZ8tDSm2q7MXniN9GcEEOymhr/YpPOU2jExfe+XFapBv9s26/5CP3+fRqypn1M5SLX7pDo4JwZ5fEBpjiuLknSQ1M/1+bTMP1/0qsIu3q6qz9WGUa7WaDuelFnjp482yIlT66khhOwMwPq7nPdzkWZC6yWARHj9zWaSRMeiP68lhPg9UPyLBvvy2FRTX5n1sTD6GunPCSCIU6NffNJ5SkVCiAPR1TDMC9Sgez7I07Zh9zeLx5r6OZW/jLDdH9WtsKsYiA8ozXFlUZIOkvq5PrfUrCf8TkHb73PFpvitWC1tx7eK1fY75fEM+rQyrW+KCa9uaPb+/unvc157Asim6gOI6e+mbq5H+5LBY2icU16ZdUDbeczR3xFAEKcmf7RJ54fKwWfrywrPVJfCUC9Qk36907CvvlE81tjPpQggZfmA0hxXFuXgQVI/k/tt51bFwdfjaIaTpfitWF3anp8qNvXvlrdf8sTtMDhWI+h9ORiiws+lKvL7rPUSQCK8/mYzSfaORX/v5nrsEOzHQxd97HgJGrOvGo11ZdbbORjQ/DOrn05HADkFau5Hn3R+qPyN6d0xqfbOhVCjvr4Va+5PxSKAlOUDSnNcWZRDJ+++j7as4pYDjaPPhHQb5VasLm3Tn9Ye+pLAITkQuDEbrVHSttxMlAoifn8m/7uFn09FANk0mwDS0s/5WJD6ZZV9+H07y+DRpfE7sPn3stRxKOt10s8RQLBJjf1kk84P1Z//zT90A4hrZzOuRv2yan0rlpv4WHM/hyKAAMugk5evGPgkPXSz7tsdHDomDYjavvcv94vJYtpmptp77FEX/a44iAwVhNvfv+ommA9B+9Ueh4YIIz72+Gr6JPMCsRBq6CeddJ5SkSdj7ZsPcqvTuM92QjoBBFgenbDdMLkRcNPkpv2eat/kbjdW/hmXl/FJf/QrOqk8tjBGNzr79q3dL/+cf57QgaPod8jvLd925FC+73fPDXj3PeVlTur3z/ur8vuufa1cu3RfKx+7CB04nhr5KiadHyoHome//J1uADk0H2T9BYUPXrwUbfBrLwIIAAAAFkdNfDWTzg9VZD7I7bAbF6hh35iQPserIAQQAAAALIoa+OomnR+qz//V33cDiGvfrVj32wZ+jldBHr70DAEEAAAAy6DGvdpJ54dq6/tBHoRdukBN+7VOAz+7qyD+LpPO+K+F3QIAAADmRU179ZPO91XkVqybYdcuUOM+26sgBBAAAADMnpr1C5PO3dDHGv2aK/It6dEJ6WrcZzsXhAACAACA2VOjvjHp/OqN/xNt8GstX6m58pcvd8OHywHkctjFC9S8r5+INafvBSGAAAAAYNbUpG9MOveE7liTX2v5Ss3Wo3hdvpqzM3yYmvcbbSPvb0ePNfs1FgEEAAAAs6UmfWPS+b/9z/872uTXWv42dN8u1t0H1R3Vzu8Caal5v6Rafzv6k9eejTb8tRUBBAAAALOkJn3Wk84/9/yr28HDtXPieYwa+DttM//Gtz8ebfhrKwIIAAAAZkeN+mwnne+Z77Hzuz92UQN/tdPMn//xh5+NNv01FQEEAAAAs6NmfZaTzvfM9zh4y9UuauLXk9F/+eqno01/TfWjr324G0D2znMBAAAAJqdmfZaTznfN9wi71Zua+NttQz+H27DasbrCLgAAAAB1UsM+y0nn/kb27rhD3Qi7dRQ18rO6Das71rALAAAAQH3UsM9u0rnHt/Xlgq5e8z32UTO/vg2r9qdhteN0heEDAAAAdVHDPrtJ5x5f5Jaro+Z77KJmfn0b1oMXL0Ub/1qqHacrDB8AAACoi5r2WU0693yP7nhDHT3fYxc189fbpr72LyVsx+kKwwcAAADqocZ9VpPOS8732Kfb2P/hB5+JNv81VHecYegAAABAHdS4z2bS+Y75HmeqQed77KKG/n7b2Nf8ON52jK4wdAAAAGB6btxVs5h0vmO+x33V4PM9dlFDf6tt7B++9Ey0+Z+6/ISudoyuMHQAAABgWm7cVbOYdL5jvsftsCujUUO/ngfibxuPBYCp67ffu9wNIPfD0AEAAIBpqYGvftK5r8ZE5nv4ik3x+R4xaugvd5r7aACYugggAAAAqI4a+Judhr7KSed/8bf/OOl8j13U1D9tG/zfv34lGgKmLAIIAAAAqqIG/lqnoa9y0vkXv/L9yed77OKmvm3wa/xCQgIIAAAAqqEG/rKq6knnf/bXr20HD9fo8z12UVO/8YWEbvgP1ePvfur8Fy9/8mB5Xsmh+sk3P9oNGIeKAAIAAIBpqImvetJ5bfM9dlFTv34S1gyKAAIAAIBpqJG/02nsq5p0Xut8jxg19de2mvxay3NVqrlyBAAAgBOiRr7aSec1z/eIUVPfDSBu8j0n5FDdUfnKyaHyY369/r0VhgIAAADUR418tZPOd8z3uBWGDgAAAGBO1MxXOel8z3yP62HoAAAAAOZEzXyVk853zPfwOKub7wEAAAAgkRr66iadewyR+R7+RvYq53sAAAAASKCGvrpJ5x5Dd0yhmO8BAAAAzJma+qomnXu+h8fQHZOK+R4AAADA3Kmpr2rSueecMN8DAAAAWCA19RuTzl3+jo1YMBijmO8BAAAALJga+41J5y4HAM+9GPsqCPM9AAAAgIVTg++5Hw4h61uw2nr2y98Z5SlYe+Z78O3dAAAAwBKp2fetWH4K1plqIwz4y/9KXQ3ZM9/jchgaAAAAgKVS4+8gcku1cUXEIWHoLyTcMd/DV2OY7wEAAACcEoUAPxnrfggFqxryW9E/9/yr3dDR1s2weQAAAACnSKHAV0PWIeHYEOJbua785cvd0OFivgcAAAAwV//0dx+6prquutWpmyr/efbcCoWDGyEkHBVCvIwntrfrCcV8DwAAAGBOHCpCwLivOk+op6o7quRvFVdIuKraCCE5E9P//G/+gfkeAAAAwJwpQDh4OEjEQkZqnaluhFXupbDgELIOEJ6YHgsb28V8DwAAAGDGFBguqW6HAHGhfvz1j5z/9FsfO3/40jPnv3j5k6t68OKl1Z/Ffj6Ug8jBeRgKDr4dax0k/OWBsdDhYr4HAAAAMHMKCVdVD0JoWNdPvvnR88ff/dT5H37wmfPzf/783nry2rOrQPKjr314Yx2hbodN7aQAcbsTKKLzQZjvAQAAAMycwoHDh+dvrAODr3b89nuXo0HjUP3xh59dXR3pri+U55LsnJuhEOHvCll/YaGvcnTDx675HmFxAAAAALVTILgQPhweYsEit3zVxFdQuutW+SrLvhByrRswvviV76/Cx475HklzTAAAAABUQEFgI3z41qm+Vz32lW/LarcRau9VCwULP8VqFTJ8FcST0tv/H8rzPa6GHwcAAABQO4UATzhfz/lw+Pj961eiAWKIioSQnU+rUrjwt6Vvh462PN+DR+wCAAAAc6IAsPG0qxJXPrbrjW9/vBtAXDsnjitkrK+CdIr5HgAAAMDcuPHvBoGh5nwcKk9O9+T2zrbvhyFdoLCxMRdExXwPAAAAYI7U+K+/ZNCTxGNhoVT5Sku77VA7v7tDocNPxGK+BwAAADBXavg3rn6McevVdm19ceHO26oUPK6rmO8BAAAAzJUa/ptt8z/21Y+2IldBCBkAAADAEqnZXz/5yt9wHgsIY9TWXBDmdwAAAABL1Gn6V18UGAsHY9TDl57pBpDbYXgAAAAAlkKN/rW26fcViFgwGKuevPZsN4DsfBoWAAAAgJlSo3+jbfo9ETwWDMYqX31px+IKQwQAAACwFGr0b7UN/1jf/bGv2rG4whABAAAALIUafQIIAAAAgHGo0SeAAAAAABiHGv11APFTqGKhYMxqx+IKQwQAAACwFGr010/BmnoS+taXEZ6FIQIAAABYCjX6V9um/0df+3A0GIxVv3z1090AwmN4AQAAgCVSs/+0bfx///qVaDgYo9749se7AeRWGB4AAACAJVGzf7dt/KeaB/LHH352dQWmHYfqahgeAAAAgCVRs7/+MkKHAIeBWEgoWVu3XzH/AwAAAFgyNf3r27DGfhyvA8+Pv/6RbgDh9isAAABgydz0twHAV0H+8IPPRMNCiXLgabetchC6FIYFAAAAYInc9KvOQggY7ZG8nvTebjMUVz8AAACAU6Dm/3o3DDx48VI0NAxVvsqyNfH8QRgKAAAAgFOgEHCnEwiKhRCHj59886Pd8OFbr3jyFQAAAHBqFAQedILBKoQM+WQs33a1deXDdSNsHgAAAMApURjwfJCNEOKrFb/93uVooMiprQnnbRE+AAAAgFOmUOAQcr8TElblqyG535buqyf+no+tR+22RfgAAAAA0FBAWD+et1u+IuKrGb4qErs9yyHFocOBJXK7lctP3GLOBwAAAIBNDgqqC1dDepYnmzvU8F0fAAAAAHZTaLimuquKBYtDRfAAAAAAkM8hQnVD5Uf2bkxW75QDh6+aOHRcC4sCAAAAAAAAAAAAAAAAAAAAAAAg1Yc+9C+CyYFQsnpjxgAAAABJRU5ErkJggg==';
            var imageHeight = width * 3 / 8;
            var oldAntialias = this.getAntialiasing();
            this.setAntialiasing(true);
            ctx.drawImage(image, 0, 0, 800, 300, x, y - imageHeight - 20, width, imageHeight);
            // loading box
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, 20);
            var progress = width * (loaded / total);
            ctx.fillStyle = 'white';
            var margin = 5;
            var width = progress - margin * 2;
            var height = 20 - margin * 2;
            ctx.fillRect(x + margin, y + margin, width > 0 ? width : 0, height);
            this.setAntialiasing(oldAntialias);
        };
        /**
         * Sets the loading screen draw function if you want to customize the draw
         * @method setLoadingDrawFunction
         * @param fcn {ctx: CanvasRenderingContext2D, loaded: number, total: number) => void}
         * Callback to draw the loading screen which is passed a rendering context, the number of bytes loaded, and the total number of bytes to load.
         */
        Engine.prototype.setLoadingDrawFunction = function (fcn) {
            this.loadingDraw = fcn;
        };
        /**
         * Another option available to you to load resources into the game.
         * Immediately after calling this the game will pause and the loading screen
         * will appear.
         * @method load
         * @param loader {ILoadable} Some loadable such as a Loader collection, Sound, or Texture.
         */
        Engine.prototype.load = function (loader) {
            var _this = this;
            var complete = new ex.Promise();
            this.isLoading = true;
            loader.onprogress = function (e) {
                _this.progress = e.loaded;
                _this.total = e.total;
                _this.logger.debug('Loading ' + (100 * _this.progress / _this.total).toFixed(0));
            };
            loader.oncomplete = function () {
                setTimeout(function () {
                    _this.isLoading = false;
                    complete.resolve();
                }, 500);
            };
            loader.load();
            return complete;
        };
        return Engine;
    })(ex.Class);
    ex.Engine = Engine;
    ;
})(ex || (ex = {}));
//# sourceMappingURL=excalibur-0.2.5.js.map
;
// Concatenated onto excalibur after build
// Exports the excalibur module so it can be used with browserify
// https://github.com/excaliburjs/Excalibur/issues/312
if (typeof module !== 'undefined') {module.exports = ex;}
},{}],"/home/a/snake/lib/food.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
var _ = require('lodash');

module.exports = function (opts) {
    'use strict';
    var
        parts = opts.parts,
        ex = opts.ex,
        game = opts.game,
        color = opts.color,
        w = game.width,
        h = game.height,
        size = opts.size,
        findX = function () {
            var x = size * _.random(2, Math.floor(w / size) - 2);
            return _.pluck(parts, 'x').indexOf(x) === -1 ? x : findX();
        },
        findY = function () {
            var y = size * _.random(2, Math.floor(h / size) - 2);
            return _.pluck(parts, 'y').indexOf(y) === -1 ? y : findY();
        },
        actor = new ex.Actor(findX(), findY(), size, size, color);
    this.eat = function () {
        actor.kill();
    };
    this.actor = actor;
    game.add(actor);
};

},{"lodash":"/home/a/snake/node_modules/lodash/index.js"}],"/home/a/snake/lib/snake.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
var Food = require('./food'),
    _ = require('lodash');

module.exports = function (opts) {
    'use strict';
    var
        self = this,
        v = {},
        running = false,
        speed = 150,
        game = opts.game,
        size = Math.floor(Math.min(game.width, game.height) / 32),
        ex = opts.ex,
        color = opts.color,
        part = function (x, y, color) {
            var actor = new ex.Actor(x, y, size, size, color);
            game.add(actor);
            return actor;
        },
        startPlaceRandX = _.random(2, Math.floor(game.width / size) - 2),
        startPlaceRandY = _.random(2, Math.floor(game.height / size) - 2),
        parts = [
            part((startPlaceRandX + 1) * size, startPlaceRandY * size, color.body),
            part(startPlaceRandX * size, startPlaceRandY * size, color.body)
        ],
        food = new Food({
            ex: ex,
            game: game,
            color: color.food,
            parts: parts,
            size: size
        }),
        cutTail = function () {
            var last = parts.pop(),
                prelast = parts[parts.length - 1];
            last.moveTo(
                prelast.x,
                prelast.y,
                2 * speed
            );
            return last;
        },
        addNeck = function (time) {
            var firstPart = parts[0],
                x = firstPart.x,
                y =  firstPart.y,
                newPart = part(x, y, color.body);
            parts.unshift(newPart);
            newPart.on('collision', function (e) {
                if (e.other.color !== color.food) {
                    self.onLose();
                }
            });
            newPart.moveTo(
                x + v.x * size,
                y + v.y * size,
                speed
            );
            newPart.on('exitviewport', function () {
                self.onLose();
            });
            return newPart;
        },
        step = function () {
            addNeck().callMethod(function () {
                this.off('collision');
                if (this.within(food.actor, size / 2)) {
                    speed += 50;
                    food.eat();
                    food = new Food({
                        ex: ex,
                        game: game,
                        color: color.food,
                        parts: parts,
                        size: size
                    });
                    step();
                } else {
                    cutTail().callMethod(function () {
                        this.kill();
                        document.title = 'Score: ' + (parts.length - 2);
                        step();
                    });
                }
            });
        };
    this.right = function () {
        v.x = 1;
        v.y = 0;
    };
    this.left = function () {
        v.x = -1;
        v.y = 0;
    };
    this.up = function () {
        v.x = 0;
        v.y = -1;
    };
    this.down = function () {
        v.x = 0;
        v.y = 1;
    };
    this.run = function (obj) {
        v.x = obj.x || 0;
        v.y = obj.y || 0;
        step();
    };
    this.kill = function (v) {
        food.actor.kill();
        parts.forEach(function (part) {part.kill(); });
    };
};

},{"./food":"/home/a/snake/lib/food.js","lodash":"/home/a/snake/node_modules/lodash/index.js"}],"/home/a/snake/node_modules/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/home/a/snake/node_modules/lodash/index.js":[function(require,module,exports){
(function (global){
/**
 * @license
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -d -o ./index.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.1.0';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      REARG_FLAG = 128,
      ARY_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 0,
      LAZY_MAP_FLAG = 1,
      LAZY_WHILE_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /**
   * Used to match ES template delimiters.
   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)
   * for more details.
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect named functions. */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to detect hexadecimal string values. */
  var reHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /**
   * Used to match `RegExp` special characters.
   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
   * for more details.
   */
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to detect functions containing a `this` reference. */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to detect and test for whitespace. */
  var whitespace = (
    // Basic whitespace characters.
    ' \t\x0b\f\xa0\ufeff' +

    // Line terminators.
    '\n\r\u2028\u2029' +

    // Unicode category "Zs" space separators.
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    'window', 'WinRTError'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used as an internal `_.debounce` options object by `_.throttle`. */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it is the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare to `other`.
   * @param {*} other The value to compare to `value`.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsReflexive = value === value,
          othIsReflexive = other === other;

      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
        return 1;
      }
      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = (fromIndex || 0) - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`
   * to define the sort order of `array` and replaces criteria objects with their
   * corresponding values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * Converts `value` to a string if it is not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.max` and `_.min` as the default callback for string values.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the code unit of the first character of the string.
   */
  function charAtCallback(string) {
    return string.charCodeAt(0);
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByAll` to compare multiple properties of each element
   * in a collection and stable sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultipleAscending(object, other) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        return result;
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   * If `fromRight` is provided elements of `array` are iterated from right to left.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} [fromIndex] The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return (value && typeof value == 'object') || false;
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'add': function(a, b) { return a + b; } });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'sub': function(a, b) { return a - b; } });
   *
   * _.isFunction(_.add);
   * // => true
   * _.isFunction(_.sub);
   * // => false
   *
   * lodash.isFunction(lodash.add);
   * // => false
   * lodash.isFunction(lodash.sub);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype;

    /** Used to detect DOM support. */
    var document = (document = context.window) && document.document;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to the length of n-tuples for `_.unzip`. */
    var getLength = baseProperty('length');

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = context._;

    /** Used to detect if a method is native. */
    var reNative = RegExp('^' +
      escapeRegExp(objToString)
      .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
        ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        push = arrayProto.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = isNative(Set = context.Set) && Set,
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
        unshift = arrayProto.unshift,
        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

    /** Used to clone array buffers. */
    var Float64Array = (function() {
      // Safari 5 errors when using an array buffer to initialize a typed array
      // where the array buffer's `byteLength` is not a multiple of the typed
      // array's `BYTES_PER_ELEMENT`.
      try {
        var func = isNative(func = context.Float64Array) && func,
            result = new func(new ArrayBuffer(10), 0, 1) && func;
      } catch(e) {}
      return result;
    }());

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsFinite = context.isFinite,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = isNative(nativeNow = Date.now) && nativeNow,
        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /** Used as the size, in bytes, of each `Float64Array` element. */
    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

    /**
     * Used as the maximum length of an array-like value.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
     * for more details.
     */
    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable intuitive chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that return a boolean or single value will
     * automatically end the chain returning the unwrapped value. Explicit chaining
     * may be enabled using `_.chain`. The execution of chained methods is lazy,
     * that is, execution is deferred until `_#value` is implicitly or explicitly
     * called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization that merges iteratees to avoid creating intermediate
     * arrays and reduce the number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * The wrapper functions that support shortcut fusion are:
     * `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`, `first`,
     * `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`, `slice`,
     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `where`
     *
     * The chainable wrapper functions are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `compact`, `concat`, `constant`, `countBy`,
     * `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`, `difference`,
     * `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`, `flatten`,
     * `flattenDeep`, `flow`, `flowRight`, `forEach`, `forEachRight`, `forIn`,
     * `forInRight`, `forOwn`, `forOwnRight`, `functions`, `groupBy`, `indexBy`,
     * `initial`, `intersection`, `invert`, `invoke`, `keys`, `keysIn`, `map`,
     * `mapValues`, `matches`, `memoize`, `merge`, `mixin`, `negate`, `noop`,
     * `omit`, `once`, `pairs`, `partial`, `partialRight`, `partition`, `pick`,
     * `pluck`, `property`, `propertyOf`, `pull`, `pullAt`, `push`, `range`,
     * `rearg`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `sortByAll`, `splice`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `values`, `valuesIn`,
     * `where`, `without`, `wrap`, `xor`, `zip`, and `zipObject`
     *
     * The wrapper functions that are **not** chainable by default are:
     * `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
     * `identity`, `includes`, `indexOf`, `isArguments`, `isArray`, `isBoolean`,
     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`,
     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
     * `startCase`, `startsWith`, `template`, `trim`, `trimLeft`, `trimRight`,
     * `trunc`, `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper function `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, n) { return sum + n; });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) { return n * n; });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return new LodashWrapper(value.__wrapped__, value.__chain__, arrayCopy(value.__actions__));
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    (function(x) {

      /**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but Firefox OS certified apps, older Opera mobile browsers, and
       * the PlayStation 3; forced `false` for Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

      /**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcNames = typeof Function.name == 'string';

      /**
       * Detect if the DOM is supported.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.dom = document.createDocumentFragment().nodeType === 11;
      } catch(e) {
        support.dom = false;
      }

      /**
       * Detect if `arguments` object indexes are non-enumerable.
       *
       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
       * checks for indexes that exceed their function's formal parameters with
       * associated values of `0`.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
      } catch(e) {
        support.nonEnumArgs = true;
      }
    }(0, 0));

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.actions = null;
      this.dir = 1;
      this.dropCount = 0;
      this.filtered = false;
      this.iteratees = null;
      this.takeCount = POSITIVE_INFINITY;
      this.views = null;
      this.wrapped = value;
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var actions = this.actions,
          iteratees = this.iteratees,
          views = this.views,
          result = new LazyWrapper(this.wrapped);

      result.actions = actions ? arrayCopy(actions) : null;
      result.dir = this.dir;
      result.dropCount = this.dropCount;
      result.filtered = this.filtered;
      result.iteratees = iteratees ? arrayCopy(iteratees) : null;
      result.takeCount = this.takeCount;
      result.views = views ? arrayCopy(views) : null;
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.filtered) {
        var result = new LazyWrapper(this);
        result.dir = -1;
        result.filtered = true;
      } else {
        result = this.clone();
        result.dir *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.wrapped.value();
      if (!isArray(array)) {
        return baseWrapperValue(array, this.actions);
      }
      var dir = this.dir,
          isRight = dir < 0,
          view = getView(0, array.length, this.views),
          start = view.start,
          end = view.end,
          length = end - start,
          dropCount = this.dropCount,
          takeCount = nativeMin(length, this.takeCount - dropCount),
          index = isRight ? end : start - 1,
          iteratees = this.iteratees,
          iterLength = iteratees ? iteratees.length : 0,
          resIndex = 0,
          result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              computed = iteratee(value, index, array),
              type = data.type;

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        if (dropCount) {
          dropCount--;
        } else {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Adds `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * A specialized version of `_.max` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     */
    function arrayMax(array) {
      var index = -1,
          length = array.length,
          result = NEGATIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value > result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.min` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     */
    function arrayMin(array) {
      var index = -1,
          length = array.length,
          result = POSITIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value < result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return typeof objectValue == 'undefined' ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This method is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize assigning values.
     * @returns {Object} Returns the destination object.
     */
    function baseAssign(object, source, customizer) {
      var props = keys(source);
      if (!customizer) {
        return baseCopy(source, object, props);
      }
      var index = -1,
          length = props.length

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? result !== value : value === value) ||
            (typeof value == 'undefined' && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.at` without support for strings and individual
     * key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          length = collection.length,
          isArr = isLength(length),
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          key = parseFloat(key);
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = collection[key];
        }
      }
      return result;
    }

    /**
     * Copies the properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Array} props The property names to copy.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, object, props) {
      if (!props) {
        props = object;
        object = {};
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.bindAll` without support for individual
     * method name arguments.
     *
     * @private
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {string[]} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     */
    function baseBindAll(object, methodNames) {
      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return (typeof thisArg != 'undefined' && isBindable(func))
          ? bindCallback(func, thisArg, argCount)
          : func;
      }
      if (func == null) {
        return identity;
      }
      // Handle "_.property" and "_.matches" style callback shorthands.
      return type == 'object'
        ? baseMatches(func)
        : baseProperty(func + '');
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (typeof result != 'undefined') {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseCopy(value, result, keys(value));
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || context.Object();
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The `arguments` object to slice and provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args, fromIndex) {
      if (!isFunction(func)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = isCommon && values.length >= 200 && createCache(values),
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEach(collection, iteratee) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        return baseForOwn(collection, iteratee);
      }
      var index = -1,
          iterable = toObject(collection);

      while (++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    }

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEachRight(collection, iteratee) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        return baseForOwnRight(collection, iteratee);
      }
      var iterable = toObject(collection);
      while (length--) {
        if (iteratee(iterable[length], length, iterable) === false) {
          break;
        }
      }
      return collection;
    }

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            value = baseFlatten(value, isDeep, isStrict);
          }
          var valIndex = -1,
              valLength = value.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[++resIndex] = value[valIndex];
          }
        } else if (!isStrict) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iterator functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseFor(object, iteratee, keysFunc) {
      var index = -1,
          iterable = toObject(object),
          props = keysFunc(object),
          length = props.length;

      while (++index < length) {
        var key = props[index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseForRight(object, iteratee, keysFunc) {
      var iterable = toObject(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[length];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invoke` which requires additional arguments
     * to be provided as an array of arguments rather than individually.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {Array} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     */
    function baseInvoke(collection, methodName, args) {
      var index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? methodName : (value != null && value[methodName]);
        result[++index] = func ? func.apply(value, args) : undefined;
      });
      return result;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
      // Exit early for identical values.
      if (value === other) {
        // Treat `+0` vs. `-0` as not equal.
        return value !== 0 || (1 / value == 1 / other);
      }
      var valType = typeof value,
          othType = typeof other;

      // Exit early for unlike primitive values.
      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
          value == null || other == null) {
        // Return `false` unless both values are `NaN`.
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (valWrapped || othWrapped) {
        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Object} source The object to inspect.
     * @param {Array} props The source property names to match.
     * @param {Array} values The source values to match.
     * @param {Array} strictCompareFlags Strict comparison flags for source values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      var index = -1,
          noCustomizer = !customizer;

      while (++index < length) {
        if ((noCustomizer && strictCompareFlags[index])
              ? values[index] !== object[props[index]]
              : !hasOwnProperty.call(object, props[index])
            ) {
          return false;
        }
      }
      index = -1;
      while (++index < length) {
        var key = props[index];
        if (noCustomizer && strictCompareFlags[index]) {
          var result = hasOwnProperty.call(object, key);
        } else {
          var objValue = object[key],
              srcValue = values[index];

          result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (typeof result == 'undefined') {
            result = baseIsEqual(srcValue, objValue, customizer, true);
          }
        }
        if (!result) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var result = [];
      baseEach(collection, function(value, key, collection) {
        result.push(iteratee(value, key, collection));
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which supports specifying whether
     * `source` should be cloned.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var props = keys(source),
          length = props.length;

      if (length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return function(object) {
            return object != null && value === object[key] && hasOwnProperty.call(object, key);
          };
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = source[props[length]];
        values[length] = value;
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return function(object) {
        return baseIsMatch(object, props, values, strictCompareFlags);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns the destination object.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));

      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        var value = object[key],
            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
            isCommon = typeof result == 'undefined';

        if (isCommon) {
          result = srcValue;
        }
        if ((isSrcArr || typeof result != 'undefined') &&
            (isCommon || (result === result ? result !== value : value === value))) {
          object[key] = result;
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = typeof result == 'undefined';

      if (isCommon) {
        result = srcValue;
        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (value ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? result !== value : value === value) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` which does not coerce `key` to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     */
    function basePullAt(array, indexes) {
      var length = indexes.length,
          result = baseAt(array, indexes);

      indexes.sort(baseCompareAscending);
      while (length--) {
        var index = parseFloat(indexes[length]);
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands or `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection)
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end - start) >>> 0;
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= 200,
          seen = isLarge && createCache(),
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * returned by `keysFunc`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved unwrapped value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var args = [result],
            action = actions[index];

        push.apply(args, action.args);
        result = action.func.apply(action.thisArg, args);
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest, instead
     *  of the lowest, index at which a value should be inserted into `array`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (retHighest ? (computed <= value) : (computed < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest, instead
     *  of the lowest, index at which a value should be inserted into `array`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsUndef = typeof value == 'undefined';

      while (low < high) {
        var mid = floor((low + high) / 2),
            computed = iteratee(array[mid]),
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || typeof computed != 'undefined');
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (typeof thisArg == 'undefined') {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      return bufferSlice.call(buffer, 0);
    }
    if (!bufferSlice) {
      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
        var byteLength = buffer.byteLength,
            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
            result = new ArrayBuffer(byteLength);

        if (floatLength) {
          var view = new Float64Array(result, 0, floatLength);
          view.set(new Float64Array(buffer, 0, floatLength));
        }
        if (byteLength != offset) {
          view = new Uint8Array(result, offset);
          view.set(new Uint8Array(buffer, offset));
        }
        return result;
      };
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(argsLength + leftLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var pad = argsIndex;
      while (++rightIndex < rightLength) {
        result[pad + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[pad + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an accumulator
     * object composed from the results of running each element in the collection
     * through an iteratee. The `setter` sets the keys and values of the accumulator
     * object. If `initializer` is provided initializes the accumulator object.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that assigns properties of source object(s) to a given
     * destination object.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return function() {
        var length = arguments.length,
            object = arguments[0];

        if (length < 2 || object == null) {
          return object;
        }
        if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
          length = 2;
        }
        // Juggle arguments.
        if (length > 3 && typeof arguments[length - 2] == 'function') {
          var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
        } else if (length > 2 && typeof arguments[length - 1] == 'function') {
          customizer = arguments[--length];
        }
        var index = 0;
        while (++index < length) {
          var source = arguments[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
      return new SetCache(values);
    };

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, arguments);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that gets the extremum value of a collection.
     *
     * @private
     * @param {Function} arrayFunc The function to get the extremum value from an array.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
     *  extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(arrayFunc, isMin) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = null;
        }
        var func = getCallback(),
            noIteratee = iteratee == null;

        if (!(func === baseCallback && noIteratee)) {
          noIteratee = false;
          iteratee = func(iteratee, thisArg, 3);
        }
        if (noIteratee) {
          var isArr = isArray(collection);
          if (!isArr && isString(collection)) {
            iteratee = charAtCallback;
          } else {
            return arrayFunc(isArr ? collection : toIterable(collection));
          }
        }
        return extremumBy(collection, iteratee, isMin);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG;

      var Ctor = !isBindKey && createCtorWrapper(func),
          key = func;

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : null,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : null,
                newHoldersRight = isCurry ? null : argsHolders,
                newPartials = isCurry ? args : null,
                newPartialsRight = isCurry ? null : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this;
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the pad required for `string` based on the given padding length.
     * The `chars` string may be truncated if the number of padding characters
     * exceeds the padding length.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPad(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(argsLength + leftLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && !isFunction(func)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = null;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = null;
      }
      var data = !isBindKey && getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data && data !== true) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(null, newData);
      } else {
        result = createHybridWrapper.apply(null, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length,
          result = true;

      if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
        return false;
      }
      // Deep compare the contents, ignoring non-numeric properties.
      while (result && ++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        result = undefined;
        if (customizer) {
          result = isWhere
            ? customizer(othValue, arrValue, index)
            : customizer(arrValue, othValue, index);
        }
        if (typeof result == 'undefined') {
          // Recursively compare arrays (susceptible to call stack limits).
          if (isWhere) {
            var othIndex = othLength;
            while (othIndex--) {
              othValue = other[othIndex];
              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
              if (result) {
                break;
              }
            }
          } else {
            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
          }
        }
      }
      return !!result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} value The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            // But, treat `-0` vs. `+0` as not equal.
            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isWhere) {
        return false;
      }
      var hasCtor,
          index = -1;

      while (++index < objLength) {
        var key = objProps[index],
            result = hasOwnProperty.call(other, key);

        if (result) {
          var objValue = object[key],
              othValue = other[key];

          result = undefined;
          if (customizer) {
            result = isWhere
              ? customizer(othValue, objValue, key)
              : customizer(objValue, othValue, key);
          }
          if (typeof result == 'undefined') {
            // Recursively compare objects (susceptible to call stack limits).
            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
          }
        }
        if (!result) {
          return false;
        }
        hasCtor || (hasCtor = key == 'constructor');
      }
      if (!hasCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments; (value, index, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the
     *  maximum, extremum value.
     * @returns {*} Returns the extremum value.
     */
    function extremumBy(collection, iteratee, isMin) {
      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
          computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = iteratee(value, index, collection);
        if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} [transforms] The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms ? transforms.length : 0;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Checks if `func` is eligible for `this` binding.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
     */
    function isBindable(func) {
      var support = lodash.support,
          result = !(support.funcNames ? func.name : support.funcDecomp);

      if (!result) {
        var source = fnToString.call(func);
        if (!support.funcNames) {
          result = !reFuncName.test(source);
        }
        if (!result) {
          // Check if `func` references the `this` keyword and store the result.
          result = reThis.test(source) || isNative(func);
          baseSetData(func, result);
        }
      }
      return result;
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = +value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number') {
        var length = object.length,
            prereq = isLength(length) && isIndex(index, length);
      } else {
        prereq = type == 'string' && index in object;
      }
      return prereq && object[index] === value;
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on ES `ToLength`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
     * for more details.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask;

      var arityFlags = ARY_FLAG | REARG_FLAG,
          bindFlags = BIND_FLAG | BIND_KEY_FLAG,
          comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

      var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
          isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
          argPos = (isRearg ? data : source)[7],
          ary = (isAry ? data : source)[8];

      var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
        !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

      var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
        (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties specified
     * by the `props` array.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `_.isPlainObject` which checks if `value`
     * is an object created by the `Object` constructor or has a `[[Prototype]]`
     * of `null`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var Ctor,
          support = lodash.support;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
          (!hasOwnProperty.call(value, 'constructor') &&
            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length,
          support = lodash.support;

      var allowIndexes = length && isLength(length) &&
        (isArray(object) || (support.nonEnumArgs && isArguments(object)));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isLength(value.length)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {numer} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(+size || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(ceil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [5, 2, 10]);
     * // => [1, 3]
     */
    function difference() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var value = arguments[index];
        if (isArray(value) || isArguments(value)) {
          break;
        }
      }
      return baseDifference(value, baseFlatten(arguments, false, true, ++index));
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per element.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) { return n > 1; });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'status': 'busy', 'active': false },
     *   { 'user': 'fred',    'status': 'busy', 'active': true },
     *   { 'user': 'pebbles', 'status': 'away', 'active': true }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney']
     *
     * // using the "_.matches" callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'status': 'away' }), 'user');
     * // => ['barney', 'fred']
     */
    function dropRightWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      predicate = getCallback(predicate, thisArg, 3);
      while (length-- && predicate(array[length], length, array)) {}
      return baseSlice(array, 0, length + 1);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per element.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) { return n < 3; });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'status': 'busy', 'active': true },
     *   { 'user': 'fred',    'status': 'busy', 'active': false },
     *   { 'user': 'pebbles', 'status': 'away', 'active': true }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the "_.matches" callback shorthand
     * _.pluck(_.dropWhile(users, { 'status': 'busy' }), 'user');
     * // => ['pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var index = -1;
      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length && predicate(array[index], index, array)) {}
      return baseSlice(array, index);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.findIndex(users, function(chr) { return chr.age < 40; });
     * // => 0
     *
     * // using the "_.matches" callback shorthand
     * _.findIndex(users, { 'age': 1 });
     * // => 2
     *
     * // using the "_.property" callback shorthand
     * _.findIndex(users, 'active');
     * // => 1
     */
    function findIndex(array, predicate, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) { return chr.age < 40; });
     * // => 2
     *
     * // using the "_.matches" callback shorthand
     * _.findLastIndex(users, { 'age': 40 });
     * // => 1
     *
     * // using the "_.property" callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      predicate = getCallback(predicate, thisArg, 3);
      while (length--) {
        if (predicate(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, [[4]]];
     *
     * // using `isDeep`
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, 4];
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
     * it is used as the offset from the end of `array`. If `array` is sorted
     * providing `true` for `fromIndex` performs a faster binary search.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * // performing a binary search
     * _.indexOf([4, 4, 5, 5, 6, 6], 5, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      } else if (fromIndex) {
        var index = binaryIndex(array, value),
            other = array[index];

        return (value === value ? value === other : other !== other) ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values in all provided arrays using `SameValueZero`
     * for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = [],
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf;

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(isCommon && value.length >= 120 && createCache(argsIndex && value));
        }
      }
      argsLength = args.length;
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [],
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
          argsIndex = argsLength;
          while (--argsIndex) {
            var cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([4, 4, 5, 5, 6, 6], 5, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        return (value === value ? value === other : other !== other) ? index : -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using `SameValueZero` for equality
     * comparisons.
     *
     * **Notes:**
     *  - Unlike `_.without`, this method mutates `array`.
     *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
     *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     *    for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var array = arguments[0];
      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = arguments.length;

      while (++index < length) {
        var fromIndex = 0,
            value = arguments[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    function pullAt(array) {
      return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
    }

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) { return n % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This function is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5, 6, 6], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the "_.property" callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    function sortedIndex(array, value, iteratee, thisArg) {
      var func = getCallback(iteratee);
      return (func === baseCallback && iteratee == null)
        ? binaryIndex(array, value)
        : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5, 6, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value, iteratee, thisArg) {
      var func = getCallback(iteratee);
      return (func === baseCallback && iteratee == null)
        ? binaryIndex(array, value, true)
        : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per element.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) { return n > 1; });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'status': 'busy', 'active': false },
     *   { 'user': 'fred',    'status': 'busy', 'active': true },
     *   { 'user': 'pebbles', 'status': 'away', 'active': true }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the "_.matches" callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'status': 'away' }), 'user');
     * // => ['pebbles']
     */
    function takeRightWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      predicate = getCallback(predicate, thisArg, 3);
      while (length-- && predicate(array[length], length, array)) {}
      return baseSlice(array, length + 1);
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per element.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) { return n < 3; });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'status': 'busy', 'active': true },
     *   { 'user': 'fred',    'status': 'busy', 'active': false },
     *   { 'user': 'pebbles', 'status': 'away', 'active': true }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => ['barney']
     *
     * // using the "_.matches" callback shorthand
     * _.pluck(_.takeWhile(users, { 'status': 'busy' }), 'user');
     * // => ['barney', 'fred']
     */
    function takeWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var index = -1;
      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length && predicate(array[index], index, array)) {}
      return baseSlice(array, 0, index);
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, false, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using `SameValueZero`
     * for equality comparisons. Providing `true` for `isSorted` performs a faster
     * search algorithm for sorted arrays. If an iteratee function is provided it
     * is invoked for each value in the array to generate the criterion by which
     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     *  If a property name or object is provided it is used to create a "_.property"
     *  or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1]);
     * // => [1, 2]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) { return this.floor(n); }, Math);
     * // => [1, 2.5]
     *
     * // using the "_.property" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      // Juggle arguments.
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
        isSorted = false;
      }
      var func = getCallback();
      if (!(func === baseCallback && iteratee == null)) {
        iteratee = func(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-`_.zip`
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      var index = -1,
          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
          result = Array(length);

      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * Creates an array excluding all provided values using `SameValueZero` for
     * equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, baseSlice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseDifference(result, array).concat(baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var length = arguments.length,
          array = Array(length);

      while (length--) {
        array[length] = arguments[length];
      }
      return unzip(array);
    }

    /**
     * Creates an object composed from arrays of property names and values. Provide
     * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of property names and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` object.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) { return chr.user + ' is ' + chr.age; })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _([1, 2, 3])
     *  .last()
     *  .thru(function(value) { return [value]; })
     *  .value();
     * // => [3]
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {*} Returns the `lodash` object.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` object.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        if (this.__actions__.length) {
          value = new LazyWrapper(this);
        }
        return new LodashWrapper(value.reverse());
      }
      return this.thru(function(value) {
        return value.reverse();
      });
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var length = collection ? collection.length : 0;
      if (isLength(length)) {
        collection = toIterable(collection);
      }
      return baseAt(collection, baseFlatten(arguments, false, false, 1));
    }

    /**
     * Checks if `value` is in `collection` using `SameValueZero` for equality
     * comparisons. If `fromIndex` is negative, it is used as the offset from
     * the end of `collection`.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (!length) {
        return false;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      } else {
        fromIndex = 0;
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
        : (getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) { return Math.floor(n); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) { return this.floor(n); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.every(users, 'age');
     * // => true
     *
     * // using the "_.matches" callback shorthand
     * _.every(users, { 'age': 36 });
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4], function(n) { return n % 2 == 0; });
     * // => [2, 4]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['fred']
     *
     * // using the "_.matches" callback shorthand
     * _.pluck(_.filter(users, { 'age': 36 }), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.result(_.find(users, function(chr) { return chr.age < 40; }), 'user');
     * // => 'barney'
     *
     * // using the "_.matches" callback shorthand
     * _.result(_.find(users, { 'age': 1 }), 'user');
     * // => 'pebbles'
     *
     * // using the "_.property" callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'fred'
     */
    function find(collection, predicate, thisArg) {
      if (isArray(collection)) {
        var index = findIndex(collection, predicate, thisArg);
        return index > -1 ? collection[index] : undefined;
      }
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(collection, predicate, baseEach);
    }

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) { return n % 2 == 1; });
     * // => 3
     */
    function findLast(collection, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(collection, predicate, baseEachRight);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'status': 'busy' },
     *   { 'user': 'fred',   'age': 40, 'status': 'busy' }
     * ];
     *
     * _.result(_.findWhere(users, { 'status': 'busy' }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40 }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Iterator functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(n) { console.log(n); }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(n, key) { console.log(n, key); });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    function forEach(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
        ? arrayEach(collection, iteratee)
        : baseEach(collection, bindCallback(iteratee, thisArg, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(n) { console.log(n); }).join(',');
     * // => logs each value from right to left and returns the array
     */
    function forEachRight(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
        ? arrayEachRight(collection, iteratee)
        : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) { return Math.floor(n); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) { return this.floor(n); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the "_.property" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) { return String.fromCharCode(object.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) { return this.fromCharCode(object.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in `collection`,
     * returning an array of the results of each invoked method. Any additional
     * arguments are provided to each invoked method. If `methodName` is a function
     * it is invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      return baseInvoke(collection, methodName, baseSlice(arguments, 2));
    }

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * _.map([1, 2, 3], function(n) { return n * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(n) { return n * 3; });
     * // => [3, 6, 9] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     *  If a property name or object is provided it is used to create a "_.property"
     *  or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) { return chr.age; });
     * // => { 'user': 'fred', 'age': 40 };
     *
     * // using the "_.property" callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 };
     */
    var max = createExtremum(arrayMax);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     *  If a property name or object is provided it is used to create a "_.property"
     *  or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) { return chr.age; });
     * // => { 'user': 'barney', 'age': 36 };
     *
     * // using the "_.property" callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 };
     */
    var min = createExtremum(arrayMin, true);

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) { return n % 2; });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) { return this.floor(n) % 2; }, Math);
     * // => [[1, 3], [2]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * // using the "_.matches" callback shorthand
     * _.map(_.partition(users, { 'age': 1 }), function(array) { return _.pluck(array, 'user'); });
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the "_.property" callback shorthand
     * _.map(_.partition(users, 'active'), function(array) { return _.pluck(array, 'user'); });
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the value of `key` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} key The key of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, key) {
      return map(collection, baseProperty(key + ''));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
     * (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, n) { return sum + n; });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator, thisArg) {
      var func = isArray(collection) ? arrayReduce : baseReduce;
      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     * _.reduceRight(array, function(flattened, other) { return flattened.concat(other); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator, thisArg) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce;
      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4], function(n) { return n % 2 == 0; });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     *
     * // using the "_.matches" callback shorthand
     * _.pluck(_.reject(users, { 'age': 36 }), 'user');
     * // => ['fred']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      collection = toIterable(collection);

      var index = -1,
          length = collection.length,
          result = Array(length);

      while (++index < length) {
        var rand = baseRandom(0, index);
        if (index != rand) {
          result[index] = result[rand];
        }
        result[rand] = collection[index];
      }
      return result;
    }

    /**
     * Gets the size of `collection` by returning `collection.length` for
     * array-like values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.some(users, 'active');
     * // => true
     *
     * // using the "_.matches" callback shorthand
     * _.some(users, { 'age': 1 });
     * // => false
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity] The function
     *  invoked per iteration. If a property name or an object is provided it is
     *  used to create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) { return Math.sin(n); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) { return this.sin(n); }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the "_.property" callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = isLength(length) ? Array(length) : [];

      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = null;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      baseEach(collection, function(value, key, collection) {
        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it sorts by property names
     * instead of an iteratee function.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(string|string[])} props The property names to sort by,
     *  specified as individual property names or arrays of property names.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 26 },
     *   { 'user': 'fred',   'age': 30 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortByAll(collection) {
      var args = arguments;
      if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
        args = [collection, args[1]];
      }
      var index = -1,
          length = collection ? collection.length : 0,
          props = baseFlatten(args, false, false, 1),
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value, key, collection) {
        var length = props.length,
            criteria = Array(length);

        while (length--) {
          criteria[length] = value == null ? undefined : value[props[length]];
        }
        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
      });
      return baseSortBy(result, compareMultipleAscending);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'status': 'busy', 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'status': 'busy', 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36 }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     *
     * _.pluck(_.where(users, { 'status': 'busy' }), 'user');
     * // => ['barney', 'fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) { console.log(_.now() - stamp); }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        if (isFunction(n)) {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = null;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, null, null, null, null, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (!isFunction(func)) {
        if (isFunction(n)) {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        } else {
          func = null;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the `length`
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    function bind(func, thisArg) {
      var bitmask = BIND_FLAG;
      if (arguments.length > 2) {
        var partials = baseSlice(arguments, 2),
            holders = replaceHolders(partials, bind.placeholder);

        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the `length` property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    function bindAll(object) {
      return baseBindAll(object,
        arguments.length > 1
          ? baseFlatten(arguments, false, false, 1)
          : functions(object)
      );
    }

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (arguments.length > 2) {
        var partials = baseSlice(arguments, 2),
            holders = replaceHolders(partials, bindKey.placeholder);

        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    }

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      if (guard && isIterateeCall(func, arity, guard)) {
        arity = null;
      }
      var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      if (guard && isIterateeCall(func, arity, guard)) {
        arity = null;
      }
      var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a function that delays invoking `func` until after `wait` milliseconds
     * have elapsed since the last time it was invoked. The created function comes
     * with a `cancel` method to cancel delayed invocations. Provide an options
     * object to indicate that `func` should be invoked on the leading and/or
     * trailing edge of the `wait` timeout. Subsequent calls to the debounced
     * function return the result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : wait;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      return baseDelay(func, 1, arguments, 1);
    }

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      return baseDelay(func, wait, arguments, 2);
    }

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function add(x, y) {
     *   return x + y;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(add, square);
     * addSquare(1, 2);
     * // => 9
     */
    function flow() {
      var funcs = arguments,
          length = funcs.length;

      if (!length) {
        return function() {};
      }
      if (!arrayEvery(funcs, isFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var index = 0,
            result = funcs[index].apply(this, arguments);

        while (++index < length) {
          result = funcs[index].call(this, result);
        }
        return result;
      };
    }

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function add(x, y) {
     *   return x + y;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, add);
     * addSquare(1, 2);
     * // => 9
     */
    function flowRight() {
      var funcs = arguments,
          fromIndex = funcs.length - 1;

      if (fromIndex < 0) {
        return function() {};
      }
      if (!arrayEvery(funcs, isFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var index = fromIndex,
            result = funcs[index].apply(this, arguments);

        while (index--) {
          result = funcs[index].call(this, result);
        }
        return result;
      };
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the ES `Map` method interface
     * of `get`, `has`, and `set`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (!isFunction(func) || (resolver && !isFunction(resolver))) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : arguments[0];

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, arguments);
        cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (!isFunction(predicate)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(func, 2);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    function partial(func) {
      var partials = baseSlice(arguments, 1),
          holders = replaceHolders(partials, partial.placeholder);

      return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
    }

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    function partialRight(func) {
      var partials = baseSlice(arguments, 1),
          holders = replaceHolders(partials, partialRight.placeholder);

      return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
    }

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) { return n * 3; }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    function rearg(func) {
      var indexes = baseFlatten(arguments, false, false, 1);
      return createWrapper(func, REARG_FLAG, null, null, null, indexes);
    }

    /**
     * Creates a function that only invokes `func` at most once per every `wait`
     * milliseconds. The created function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the throttled function return the result of the last
     * `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * var throttled =  _.throttle(renewToken, 300000, { 'trailing': false })
     * jQuery('.interactive').on('click', throttled);
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = +wait;
      debounceOptions.trailing = trailing;
      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the structured clone algorithm.
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var body = _.clone(document.body, function(value) {
     *   return _.isElement(value) ? value.cloneNode(false) : undefined;
     * });
     *
     * body === document.body
     * // => false
     * body.nodeName
     * // => BODY
     * body.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      // Juggle arguments.
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = customizer;
        customizer = isIterateeCall(value, isDeep, thisArg) ? null : isDeep;
        isDeep = false;
      }
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, isDeep, customizer);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the structured clone algorithm.
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * body === document.body
     * // => false
     * body.nodeName
     * // => BODY
     * body.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, true, customizer);
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })();
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      var length = isObjectLike(value) ? value.length : undefined;
      return (isLength(length) && objToString.call(value) == argsTag) || false;
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return (value && value.nodeType === 1 && isObjectLike(value) &&
        objToString.call(value).indexOf('Element') > -1) || false;
    }
    // Fallback for environments without DOM support.
    if (!support.dom) {
      isElement = function(value) {
        return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
      };
    }

    /**
     * Checks if a value is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      var length = value.length;
      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments; (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
        return value === other;
      }
      var result = customizer ? customizer(value, other) : undefined;
      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on ES `Number.isFinite`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    var isFinite = nativeNumIsFinite || function(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    };

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // Avoid a Chakra JIT bug in compatibility modes of IE 11.
      // See https://github.com/jashkenas/underscore/issues/1621 for more details.
      return typeof value == 'function' || false;
    }
    // Fallback for environments that return incorrect `typeof` operator results.
    if (isFunction(/x/) || (Uint8Array && !isFunction(Uint8Array))) {
      isFunction = function(value) {
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in older versions of Chrome and Safari which return 'function' for regexes
        // and Safari 8 equivalents which return 'object' for typed array constructors.
        return objToString.call(value) == funcTag;
      };
    }

    /**
     * Checks if `value` is the language type of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return type == 'function' || (value && type == 'object') || false;
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments; (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} source The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      var props = keys(source),
          length = props.length;

      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return object != null && value === object[key] && hasOwnProperty.call(object, key);
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = values[length] = source[props[length]];
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return baseIsMatch(object, props, values, strictCompareFlags, customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as native `isNaN` which returns `true`
     * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (objToString.call(value) == funcTag) {
        return reNative.test(fnToString.call(value));
      }
      return (isObjectLike(value) && reHostCtor.test(value)) || false;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && objToString.call(value) == objectTag)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3);
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? value.length : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments;
     * (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return typeof value == 'undefined' ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(baseAssign);

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = null;
      }
      return properties ? baseCopy(properties, result, keys(properties)) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property are ignored.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    function defaults(object) {
      if (object == null) {
        return object;
      }
      var args = arrayCopy(arguments);
      args.push(assignDefaults);
      return assign.apply(undefined, args);
    }

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) { return chr.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the "_.matches" callback shorthand
     * _.findKey(users, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using the "_.property" callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(object, predicate, baseForOwn, true);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `predicate` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) { return chr.age < 40; });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the "_.matches" callback shorthand
     * _.findLastKey(users, { 'age': 36 });
     * // => 'barney'
     *
     * // using the "_.property" callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(object, predicate, baseForOwnRight, true);
    }

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments; (value, key, object). Iterator functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    function forIn(object, iteratee, thisArg) {
      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
        iteratee = bindCallback(iteratee, thisArg, 3);
      }
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    function forInRight(object, iteratee, thisArg) {
      iteratee = bindCallback(iteratee, thisArg, 3);
      return baseForRight(object, iteratee, keysIn);
    }

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments; (value, key, object). Iterator functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (iteration order is not guaranteed)
     */
    function forOwn(object, iteratee, thisArg) {
      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
        iteratee = bindCallback(iteratee, thisArg, 3);
      }
      return baseForOwn(object, iteratee);
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(n, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, iteratee, thisArg) {
      iteratee = bindCallback(iteratee, thisArg, 3);
      return baseForRight(object, iteratee, keys);
    }

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Checks if `key` exists as a direct property of `object` instead of an
     * inherited property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {string} key The key to check.
     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     *
     * // without `multiValue`
     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' });
     * // => { 'fred': 'third', 'barney': 'second' }
     *
     * // with `multiValue`
     * _.invert({ 'first': 'fred', 'second': 'barney', 'third': 'fred' }, true);
     * // => { 'fred': ['first', 'third'], 'barney': ['second'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = null;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (object) {
        var Ctor = object.constructor,
            length = object.length;
      }
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
         (typeof object != 'function' && (length && isLength(length)))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype == object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created "_.property"
     * style callback returns the property value of the given element.
     *
     * If an object is provided for `iteratee` the created "_.matches" style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration. If a property name or object is provided it is used to
     *  create a "_.property" or "_.matches" style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(n) { return n * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the "_.property" callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee, thisArg) {
      var result = {};
      iteratee = getCallback(iteratee, thisArg, 3);

      baseForOwn(object, function(value, key, object) {
        result[key] = iteratee(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments; (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If `predicate` is provided it is invoked for each property
     * of `object` omitting the properties `predicate` returns truthy for. The
     * predicate is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    function omit(object, predicate, thisArg) {
      if (object == null) {
        return {};
      }
      if (typeof predicate != 'function') {
        var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      predicate = bindCallback(predicate, thisArg, 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    }

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    function pick(object, predicate, thisArg) {
      if (object == null) {
        return {};
      }
      return typeof predicate == 'function'
        ? pickByCallback(object, bindCallback(predicate, thisArg, 3))
        : pickByArray(object, baseFlatten(arguments, false, false, 1));
    }

    /**
     * Resolves the value of property `key` on `object`. If the value of `key` is
     * a function it is invoked with the `this` binding of `object` and its result
     * is returned, else the property value is returned. If the property value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to resolve.
     * @param {*} [defaultValue] The value returned if the property value
     *  resolves to `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'user': 'fred', 'age': _.constant(40) };
     *
     * _.result(object, 'user');
     * // => 'fred'
     *
     * _.result(object, 'age');
     * // => 40
     *
     * _.result(object, 'status', 'busy');
     * // => 'busy'
     *
     * _.result(object, 'status', _.constant('busy'));
     * // => 'busy'
     */
    function result(object, key, defaultValue) {
      var value = object == null ? undefined : object[key];
      if (typeof value == 'undefined') {
        value = defaultValue;
      }
      return isFunction(value) ? value.call(object) : value;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments; (accumulator, value, key, object). Iterator functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6], function(result, n) {
     *   n *= n;
     *   if (n % 2) {
     *     return result.push(n) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(typeof Ctor == 'function' && Ctor.prototype);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = null;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to camel case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter);
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and '`', in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't require escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
     *
     * When working with HTML you should always quote attribute values to reduce
     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
     * "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, '\\$&')
        : string;
    }

    /**
     * Converts `string` to kebab case (a.k.a. spinal case).
     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it is shorter then the given
     * padding length. The `chars` string may be truncated if the number of padding
     * characters can't be evenly divided by the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = floor(mid),
          rightLength = ceil(mid);

      chars = createPad('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    function padLeft(string, length, chars) {
      string = baseToString(string);
      return string && (createPad(string, length, chars) + string);
    }

    /**
     * Pads `string` on the right side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    function padRight(string, length, chars) {
      string = baseToString(string);
      return string && (string + createPad(string, length, chars));
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the ES5 implementation of `parseInt`.
     * See the [ES5 spec](https://es5.github.io/#E) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard && isIterateeCall(string, radix, guard)) {
        radix = 0;
      }
      return nativeParseInt(string, radix);
    }
    // Fallback for environments with pre-ES5 implementations.
    if (nativeParseInt(whitespace + '08') != 8) {
      parseInt = function(string, radix, guard) {
        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
        // Chrome fails to trim leading <BOM> whitespace characters.
        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        string = trim(string);
        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
      };
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = floor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to snake case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to start case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.
     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for more details.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '';
     *   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = null;
      }
      string = baseToString(string);
      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar]
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string))
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1)
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it is longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': ' ' });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', { 'length': 24, 'separator': /,? +/ });
     * //=> 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', { 'omission': ' [...]' });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = null;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? +options.length || 0 : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = null;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught
     * error object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function() {
     *   return document.querySelectorAll(selector);
     * });
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    function attempt(func) {
      try {
        return func();
      } catch(e) {
        return isError(e) ? e : Error(e);
      }
    }

    /**
     * Creates a function bound to an optional `thisArg`. If `func` is a property
     * name the created callback returns the property value for a given element.
     * If `func` is an object the created callback returns `true` for elements
     * that contain the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = null;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function which performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * var matchesAge = _.matches({ 'age': 36 });
     *
     * _.filter(users, matchesAge);
     * // => [{ 'user': 'barney', 'age': 36 }]
     *
     * _.find(users, matchesAge);
     * // => { 'user': 'barney', 'age': 36 }
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=this] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj && keys(source),
            methodNames = props && props.length && baseFunctions(source, props);

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__);
                (result.__actions__ = arrayCopy(this.__actions__)).push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              var args = [this.value()];
              push.apply(args, arguments);
              return func.apply(object, args);
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function which returns the property value of `key` on a given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'barney' }
     * ];
     *
     * var getName = _.property('user');
     *
     * _.map(users, getName);
     * // => ['fred', barney']
     *
     * _.pluck(_.sortBy(users, getName), 'user');
     * // => ['barney', 'fred']
     */
    function property(key) {
      return baseProperty(key + '');
    }

    /**
     * The inverse of `_.property`; this method creates a function which returns
     * the property value of a given key on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to inspect.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40, 'active': true };
     * _.map(['active', 'user'], _.propertyOf(object));
     * // => [true, 'fred']
     *
     * var object = { 'a': 3, 'b': 1, 'c': 2 };
     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
     * // => ['b', 'c', 'a']
     */
    function propertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `start` is less than `end` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = null;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(ceil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = +n;

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    // Ensure `new LodashWrapper` is an instance of `lodash`.
    LodashWrapper.prototype = lodash.prototype;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var isFilter = index == LAZY_FILTER_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone(),
            filtered = result.filtered,
            iteratees = result.iteratees || (result.iteratees = []);

        result.filtered = filtered || isFilter || (index == LAZY_WHILE_FLAG && result.dir < 0);
        iteratees.push({ 'iteratee': getCallback(iteratee, thisArg, 3), 'type': index });
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      var countName = methodName + 'Count',
          whileName = methodName + 'While';

      LazyWrapper.prototype[methodName] = function(n) {
        n = n == null ? 1 : nativeMax(+n || 0, 0);

        var result = this.clone();
        if (result.filtered) {
          var value = result[countName];
          result[countName] = index ? nativeMin(value, n) : (value + n);
        } else {
          var views = result.views || (result.views = []);
          views.push({ 'size': n, 'type': methodName + (result.dir < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };

      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
        return this.reverse()[whileName](predicate, thisArg).reverse();
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right': '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : baseProperty;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(index ? value : (value + '')));
      };
    });

    LazyWrapper.prototype.dropWhile = function(iteratee, thisArg) {
      var done,
          lastIndex,
          isRight = this.dir < 0;

      iteratee = getCallback(iteratee, thisArg, 3);
      return this.filter(function(value, index, array) {
        done = done && (isRight ? index < lastIndex : index > lastIndex);
        lastIndex = index;
        return done || (done = !iteratee(value, index, array));
      });
    };

    LazyWrapper.prototype.reject = function(iteratee, thisArg) {
      iteratee = getCallback(iteratee, thisArg, 3);
      return this.filter(function(value, index, array) {
        return !iteratee(value, index, array);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);
      var result = start < 0 ? this.takeRight(-start) : this.drop(start);

      if (typeof end != 'undefined') {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName],
          retUnwrapped = /^(?:first|last)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = arguments,
            chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          return onlyLazy
            ? func.call(value)
            : lodashFunc.call(lodash, this.value());
        }
        var interceptor = function(value) {
          var otherArgs = [value];
          push.apply(otherArgs, args);
          return lodashFunc.apply(lodash, otherArgs);
        };
        if (isLazy || isArray(value)) {
          var wrapper = onlyLazy ? value : new LazyWrapper(this),
              result = func.apply(wrapper, args);

          if (!retUnwrapped && (isHybrid || result.actions)) {
            var actions = result.actions || (result.actions = []);
            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
          }
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array.prototype` functions to `lodash.prototype`.
    arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the lodash wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the lodash wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Narwhal or Rhino -require.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},["/home/a/snake/index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiaW5kZXguanMiLCJsaWIvZXhjYWxpYnVyLmpzIiwibGliL2Zvb2QuanMiLCJsaWIvc25ha2UuanMiLCJub2RlX21vZHVsZXMvZG9tcmVhZHkvcmVhZHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5dVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKmpzbGludCBub2RlOnRydWUqL1xuLypnbG9iYWwgd2luZG93Ki9cbnZhciBkb21yZWFkeSA9IHJlcXVpcmUoJ2RvbXJlYWR5JyksXG4gICAgZXggPSByZXF1aXJlKCcuL2xpYi9leGNhbGlidXInKSxcbiAgICBTbmFrZSA9IHJlcXVpcmUoJy4vbGliL3NuYWtlJyk7XG5cbmRvbXJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGdhbWUgPSBuZXcgZXguRW5naW5lKCksXG4gICAgICAgIHNuYWtlID0gbmV3IFNuYWtlKHtcbiAgICAgICAgICAgIGV4OiBleCxcbiAgICAgICAgICAgIGdhbWU6IGdhbWUsXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGhlYWQ6IGV4LkNvbG9yLlJlZCxcbiAgICAgICAgICAgICAgICBib2R5OiBleC5Db2xvci5ZZWxsb3csXG4gICAgICAgICAgICAgICAgZm9vZDogZXguQ29sb3IuR3JlZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHJlcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdhbWUucm9vdFNjZW5lLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYWN0b3Iua2lsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzbmFrZSA9IG5ldyBTbmFrZSh7XG4gICAgICAgICAgICAgICAgICAgIGV4OiBleCxcbiAgICAgICAgICAgICAgICAgICAgZ2FtZTogZ2FtZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQ6IGV4LkNvbG9yLlJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGV4LkNvbG9yLlllbGxvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvb2Q6IGV4LkNvbG9yLkdyZWVuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzbmFrZS5vbkxvc2UgPSByZXBsYXk7XG4gICAgICAgICAgICAgICAgc25ha2UucnVuKHt4OiAxfSk7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9LFxuICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBnYW1lLmlucHV0LmtleWJvYXJkLm9uKCdkb3duJywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgayA9IGsua2V5O1xuICAgICAgICBpZiAoayA9PT0gMzcpIHtcbiAgICAgICAgICAgIHNuYWtlLmxlZnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSAzOCkge1xuICAgICAgICAgICAgc25ha2UudXAoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSAzOSkge1xuICAgICAgICAgICAgc25ha2UucmlnaHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSA0MCkge1xuICAgICAgICAgICAgc25ha2UuZG93bigpO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IDMyKSB7XG4gICAgICAgICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgZ2FtZS5zdGFydCgpO1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnYW1lLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcGxheSgpO1xuICAgIH0pO1xuICAgIGdhbWUuc3RhcnQoKTtcbiAgICBzbmFrZS5vbkxvc2UgPSByZXBsYXk7XG4gICAgc25ha2UucnVuKHt4OiAxfSk7XG59KTtcbiIsIi8qISBleGNhbGlidXIgLSB2MC4yLjUgLSAyMDE1LTAyLTA0XG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXJcbiogQ29weXJpZ2h0IChjKSAyMDE1IDsgTGljZW5zZWQgQlNEKi9cbmlmICh0eXBlb2Ygd2luZG93ID09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93ID0geyBhdWRpb0NvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB9IH07XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHdpbmRvdy5zZXRJbnRlcnZhbChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICB9O1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0IHx8IHdpbmRvdy5tb3pBdWRpb0NvbnRleHQgfHwgd2luZG93Lm1zQXVkaW9Db250ZXh0IHx8IHdpbmRvdy5vQXVkaW9Db250ZXh0O1xufVxuLy8gUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4vLyBQcm9kdWN0aW9uIHN0ZXBzIG9mIEVDTUEtMjYyLCBFZGl0aW9uIDUsIDE1LjQuNC4xOFxuLy8gUmVmZXJlbmNlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjQuNC4xOFxuaWYgKCFBcnJheS5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBULCBrO1xuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcgdGhpcyBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMS4gTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0IHBhc3NpbmcgdGhlIHx0aGlzfCB2YWx1ZSBhcyB0aGUgYXJndW1lbnQuXG4gICAgICAgIHZhciBPID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAvLyAyLiBMZXQgbGVuVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCB0aGUgYXJndW1lbnQgXCJsZW5ndGhcIi5cbiAgICAgICAgLy8gMy4gTGV0IGxlbiBiZSBUb1VpbnQzMihsZW5WYWx1ZSkuXG4gICAgICAgIHZhciBsZW4gPSBPLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgLy8gNC4gSWYgSXNDYWxsYWJsZShjYWxsYmFjaykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gU2VlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjExXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA1LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4gTGV0IGsgYmUgMFxuICAgICAgICBrID0gMDtcbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIHZhciBrVmFsdWU7XG4gICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgVG9TdHJpbmcoaykuXG4gICAgICAgICAgICAvLyAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3JcbiAgICAgICAgICAgIC8vIGIuIExldCBrUHJlc2VudCBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEhhc1Byb3BlcnR5IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAgICAgICAvLyAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjXG4gICAgICAgICAgICAvLyBjLiBJZiBrUHJlc2VudCBpcyB0cnVlLCB0aGVuXG4gICAgICAgICAgICBpZiAoayBpbiBPKSB7XG4gICAgICAgICAgICAgICAgLy8gaS4gTGV0IGtWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgICAgICAgICAgIGtWYWx1ZSA9IE9ba107XG4gICAgICAgICAgICAgICAgLy8gaWkuIENhbGwgdGhlIENhbGwgaW50ZXJuYWwgbWV0aG9kIG9mIGNhbGxiYWNrIHdpdGggVCBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBsaXN0IGNvbnRhaW5pbmcga1ZhbHVlLCBrLCBhbmQgTy5cbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFQsIGtWYWx1ZSwgaywgTyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkLiBJbmNyZWFzZSBrIGJ5IDEuXG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gOC4gcmV0dXJuIHVuZGVmaW5lZFxuICAgIH07XG59XG4vLyBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcbmlmICghQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNBcmcgKi8pIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgICAgIGlmICh0eXBlb2YgZnVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbi8vIFBvbHlmaWxsIGZyb20gIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQjUG9seWZpbGxcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZlRvQmluZCA9IHRoaXMsIGZOT1AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH0sIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID8gdGhpcyA6IG9UaGlzLCBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcbiAgICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICB9O1xufVxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBFZmZlY3RzO1xuICAgIChmdW5jdGlvbiAoRWZmZWN0cykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgXCJHcmF5c2NhbGVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHJlbW92aW5nIGNvbG9yIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAY2xhc3MgRWZmZWN0cy5HcmF5c2NhbGVcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBleHRlbmRzIElTcHJpdGVFZmZlY3RcbiAgICAgICAgICovXG4gICAgICAgIHZhciBHcmF5c2NhbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gR3JheXNjYWxlKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR3JheXNjYWxlLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBhdmcgPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDFdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDJdKSAvIDM7XG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gYXZnO1xuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGF2ZztcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBhdmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEdyYXlzY2FsZTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgRWZmZWN0cy5HcmF5c2NhbGUgPSBHcmF5c2NhbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBcIkludmVydFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXG4gICAgICAgICAqIEBjbGFzcyBFZmZlY3RzLkludmVydFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQGV4dGVuZHMgSVNwcml0ZUVmZmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEludmVydCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBJbnZlcnQoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJbnZlcnQucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDBdO1xuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXTtcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMl07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEludmVydDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgRWZmZWN0cy5JbnZlcnQgPSBJbnZlcnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBcIk9wYWNpdHlcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHNldHRpbmcgdGhlIGFscGhhIG9mIGFsbCBwaXhlbHMgdG8gYSBnaXZlbiB2YWx1ZS5cbiAgICAgICAgICogQGNsYXNzIEVmZmVjdHMuT3BhY2l0eVxuICAgICAgICAgKiBAZXh0ZW5kcyBJU3ByaXRlRWZmZWN0XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gb3BhY2l0eSB7bnVtYmVyfSBUaGUgbmV3IG9wYWNpdHkgb2YgdGhlIHNwcml0ZSBmcm9tIDAtMS4wXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgT3BhY2l0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT3BhY2l0eS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IE1hdGgucm91bmQodGhpcy5vcGFjaXR5ICogMjU1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIE9wYWNpdHk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEVmZmVjdHMuT3BhY2l0eSA9IE9wYWNpdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBcIkNvbG9yaXplXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIHRoZSBwaXhlbHMgdG8gYW5cbiAgICAgICAgICogYXZlcmFnZSBvZiB0aGUgb3JpZ2luYWwgY29sb3IgYW5kIHRoZSBwcm92aWRlZCBjb2xvclxuICAgICAgICAgKiBAY2xhc3MgRWZmZWN0cy5Db2xvcml6ZVxuICAgICAgICAgKiBAZXh0ZW5kcyBJU3ByaXRlRWZmZWN0XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gY29sb3Ige0NvbG9yfSBUaGUgY29sb3IgdG8gYXBwbHkgdG8gdGhlIHNwcml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIENvbG9yaXplID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbG9yaXplKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ29sb3JpemUucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgdGhpcy5jb2xvci5yKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMV0gKyB0aGlzLmNvbG9yLmcpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSArIHRoaXMuY29sb3IuYikgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gQ29sb3JpemU7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEVmZmVjdHMuQ29sb3JpemUgPSBDb2xvcml6ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFwiRmlsbFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoXG4gICAgICAgICAqIGEgZ2l2ZW4gY29sb3JcbiAgICAgICAgICogQGNsYXNzIEVmZmVjdHMuRmlsbFxuICAgICAgICAgKiBAZXh0ZW5kcyBJU3ByaXRlRWZmZWN0XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gY29sb3Ige0NvbG9yfSBUaGUgY29sb3IgdG8gYXBwbHkgdG8gdGhlIHNwcml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEZpbGwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRmlsbChjb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEZpbGwucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSB0aGlzLmNvbG9yLnI7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IHRoaXMuY29sb3IuZztcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gdGhpcy5jb2xvci5iO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gRmlsbDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgRWZmZWN0cy5GaWxsID0gRmlsbDtcbiAgICB9KShFZmZlY3RzID0gZXguRWZmZWN0cyB8fCAoZXguRWZmZWN0cyA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1Nwcml0ZUVmZmVjdHMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0ludGVyZmFjZXMvSVBpcGVsaW5lTW9kdWxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgTW92ZW1lbnRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNb3ZlbWVudE1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBNb3ZlbWVudE1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgcGxhY2VtZW50cyBiYXNlZCBvbiBsaW5lYXIgYWxnZWJyYVxuICAgICAgICAgICAgYWN0b3IueCArPSBhY3Rvci5keCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIGFjdG9yLnkgKz0gYWN0b3IuZHkgKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICBhY3Rvci5keCArPSBhY3Rvci5heCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIGFjdG9yLmR5ICs9IGFjdG9yLmF5ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgYWN0b3Iucm90YXRpb24gKz0gYWN0b3IucnggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICBhY3Rvci5zY2FsZS54ICs9IGFjdG9yLnN4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgYWN0b3Iuc2NhbGUueSArPSBhY3Rvci5zeSAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1vdmVtZW50TW9kdWxlO1xuICAgIH0pKCk7XG4gICAgZXguTW92ZW1lbnRNb2R1bGUgPSBNb3ZlbWVudE1vZHVsZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vSW50ZXJmYWNlcy9JUGlwZWxpbmVNb2R1bGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBPZmZzY3JlZW5DdWxsaW5nTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBPZmZzY3JlZW5DdWxsaW5nTW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBldmVudERpc3BhdGNoZXIgPSBhY3Rvci5ldmVudERpc3BhdGNoZXI7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gYWN0b3IuYW5jaG9yO1xuICAgICAgICAgICAgdmFyIGdsb2JhbFNjYWxlID0gYWN0b3IuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGdsb2JhbFNjYWxlLnggKiBhY3Rvci5nZXRXaWR0aCgpIC8gYWN0b3Iuc2NhbGUueDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBnbG9iYWxTY2FsZS55ICogYWN0b3IuZ2V0SGVpZ2h0KCkgLyBhY3Rvci5zY2FsZS55O1xuICAgICAgICAgICAgdmFyIGFjdG9yU2NyZWVuQ29vcmRzID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhuZXcgZXguUG9pbnQoYWN0b3IuZ2V0R2xvYmFsWCgpIC0gYW5jaG9yLnggKiB3aWR0aCwgYWN0b3IuZ2V0R2xvYmFsWSgpIC0gYW5jaG9yLnkgKiBoZWlnaHQpKTtcbiAgICAgICAgICAgIHZhciB6b29tID0gMS4wO1xuICAgICAgICAgICAgaWYgKGFjdG9yLnNjZW5lICYmIGFjdG9yLnNjZW5lLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHpvb20gPSBhY3Rvci5zY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhY3Rvci5pc09mZlNjcmVlbikge1xuICAgICAgICAgICAgICAgIGlmIChhY3RvclNjcmVlbkNvb3Jkcy54ICsgd2lkdGggKiB6b29tIDwgMCB8fCBhY3RvclNjcmVlbkNvb3Jkcy55ICsgaGVpZ2h0ICogem9vbSA8IDAgfHwgYWN0b3JTY3JlZW5Db29yZHMueCA+IGVuZ2luZS53aWR0aCB8fCBhY3RvclNjcmVlbkNvb3Jkcy55ID4gZW5naW5lLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIucHVibGlzaCgnZXhpdHZpZXdwb3J0JywgbmV3IGV4LkV4aXRWaWV3UG9ydEV2ZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rvci5pc09mZlNjcmVlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yU2NyZWVuQ29vcmRzLnggKyB3aWR0aCAqIHpvb20gPiAwICYmIGFjdG9yU2NyZWVuQ29vcmRzLnkgKyBoZWlnaHQgKiB6b29tID4gMCAmJiBhY3RvclNjcmVlbkNvb3Jkcy54IDwgZW5naW5lLndpZHRoICYmIGFjdG9yU2NyZWVuQ29vcmRzLnkgPCBlbmdpbmUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdlbnRlcnZpZXdwb3J0JywgbmV3IGV4LkVudGVyVmlld1BvcnRFdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuaXNPZmZTY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPZmZzY3JlZW5DdWxsaW5nTW9kdWxlO1xuICAgIH0pKCk7XG4gICAgZXguT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZSA9IE9mZnNjcmVlbkN1bGxpbmdNb2R1bGU7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0ludGVyZmFjZXMvSVBpcGVsaW5lTW9kdWxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBQcm9wb2dhdGVzIHBvaW50ZXIgZXZlbnRzIHRvIHRoZSBhY3RvclxuICAgICAqL1xuICAgIHZhciBDYXB0dXJlUG9pbnRlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENhcHR1cmVQb2ludGVyTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIENhcHR1cmVQb2ludGVyTW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICghYWN0b3IuZW5hYmxlQ2FwdHVyZVBvaW50ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGFjdG9yLmlzS2lsbGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZW5naW5lLmlucHV0LnBvaW50ZXJzLnByb3BvZ2F0ZShhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDYXB0dXJlUG9pbnRlck1vZHVsZTtcbiAgICB9KSgpO1xuICAgIGV4LkNhcHR1cmVQb2ludGVyTW9kdWxlID0gQ2FwdHVyZVBvaW50ZXJNb2R1bGU7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0ludGVyZmFjZXMvSVBpcGVsaW5lTW9kdWxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbGxpc2lvbkRldGVjdGlvbk1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnREaXNwYXRjaGVyID0gYWN0b3IuZXZlbnREaXNwYXRjaGVyO1xuICAgICAgICAgICAgaWYgKGFjdG9yLmNvbGxpc2lvblR5cGUgIT09IDAgLyogUHJldmVudENvbGxpc2lvbiAqLykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZW5naW5lLmN1cnJlbnRTY2VuZS50aWxlTWFwcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gZW5naW5lLmN1cnJlbnRTY2VuZS50aWxlTWFwc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdE1hcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGUgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQm91bmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW50ZXJzZWN0TWFwID0gbWFwLmNvbGxpZGVzKGFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heC0tIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZSA9IGFjdG9yLmdldFNpZGVGcm9tSW50ZXJzZWN0KGludGVyc2VjdE1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIucHVibGlzaCgnY29sbGlzaW9uJywgbmV3IGV4LkNvbGxpc2lvbkV2ZW50KGFjdG9yLCBudWxsLCBzaWRlLCBpbnRlcnNlY3RNYXApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gMiAvKiBBY3RpdmUgKi8gfHwgYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gMyAvKiBFbGFzdGljICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLnkgKz0gaW50ZXJzZWN0TWFwLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IueCArPSBpbnRlcnNlY3RNYXAueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOYWl2ZSBlbGFzdGljIGJvdW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8gJiYgIWhhc0JvdW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQm91bmNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID09PSAzIC8qIExlZnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmR4ID0gTWF0aC5hYnMoYWN0b3IuZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPT09IDQgLyogUmlnaHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmR4ID0gLU1hdGguYWJzKGFjdG9yLmR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWRlID09PSAxIC8qIFRvcCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZHkgPSBNYXRoLmFicyhhY3Rvci5keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA9PT0gMiAvKiBCb3R0b20gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmR5ID0gLU1hdGguYWJzKGFjdG9yLmR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkRldGVjdGlvbk1vZHVsZTtcbiAgICB9KSgpO1xuICAgIGV4LkNvbGxpc2lvbkRldGVjdGlvbk1vZHVsZSA9IENvbGxpc2lvbkRldGVjdGlvbk1vZHVsZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgc2lkZXMgb2YgYW4gQWN0b3IgZm9yIGNvbGxpc2lvblxuICAgICAqIEBjbGFzcyBTaWRlXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChTaWRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgTm9uZSB7U2lkZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgU2lkZVtTaWRlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgVG9wIHtTaWRlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBTaWRlW1NpZGVbXCJUb3BcIl0gPSAxXSA9IFwiVG9wXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgQm90dG9tIHtTaWRlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBTaWRlW1NpZGVbXCJCb3R0b21cIl0gPSAyXSA9IFwiQm90dG9tXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgTGVmdCB7U2lkZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgU2lkZVtTaWRlW1wiTGVmdFwiXSA9IDNdID0gXCJMZWZ0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgUmlnaHQge1NpZGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIFNpZGVbU2lkZVtcIlJpZ2h0XCJdID0gNF0gPSBcIlJpZ2h0XCI7XG4gICAgfSkoZXguU2lkZSB8fCAoZXguU2lkZSA9IHt9KSk7XG4gICAgdmFyIFNpZGUgPSBleC5TaWRlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBfX2V4dGVuZHMgPSB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICAgIGQucHJvdG90eXBlID0gbmV3IF9fKCk7XG59O1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIDJEIHBvaW50IG9uIGEgcGxhbmVcbiAgICAgKiBAY2xhc3MgUG9pbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgICogQHBhcmFtIHkge251bWJlcn0gWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAqXG4gICAgICovXG4gICAgdmFyIFBvaW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFggQ29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgICAgICogQHByb3BlcnR5IHgge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZIENvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSB5IHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCB0aGlzIHBvaW50IHRvIGEgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgdG9WZWN0b3JcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBQb2ludC5wcm90b3R5cGUudG9WZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb3RhdGVzIHRoZSBjdXJyZW50IHBvaW50IGFyb3VuZCBhbm90aGVyIGJ5IGEgY2VydGFpbiBudW1iZXIgb2ZcbiAgICAgICAgICogZGVncmVlcyBpbiByYWRpYW5zXG4gICAgICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBQb2ludC5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCBhbmNob3IpIHtcbiAgICAgICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IGV4LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgdmFyIHggPSBjb3NBbmdsZSAqICh0aGlzLnggLSBhbmNob3IueCkgLSBzaW5BbmdsZSAqICh0aGlzLnkgLSBhbmNob3IueSkgKyBhbmNob3IueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2luQW5nbGUgKiAodGhpcy54IC0gYW5jaG9yLngpICsgY29zQW5nbGUgKiAodGhpcy55IC0gYW5jaG9yLnkpICsgYW5jaG9yLnk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNsYXRlcyB0aGUgY3VycmVudCBwb2ludCBieSBhIHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2ZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdmVjdG9yLngsIHRoaXMueSArIHZlY3Rvci55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHggYW5kIHkgY29tcG9uZW50cyBhdCBvbmNlXG4gICAgICAgICAqIEBtZXRob2Qgc2V0VG9cbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn1cbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIFBvaW50LnByb3RvdHlwZS5zZXRUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lcyBhIG5ldyBwb2ludCB0aGF0IGlzIGEgY29weSBvZiB0aGlzIG9uZS5cbiAgICAgICAgICogQG1ldGhvZCBjbG9uZVxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQb2ludDtcbiAgICB9KSgpO1xuICAgIGV4LlBvaW50ID0gUG9pbnQ7XG4gICAgLyoqXG4gICAgICogQSAyRCB2ZWN0b3Igb24gYSBwbGFuZS5cbiAgICAgKiBAY2xhc3MgVmVjdG9yXG4gICAgICogQGV4dGVuZHMgUG9pbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBYIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXG4gICAgICogQHBhcmFtIHkge251bWJlcn0gWSBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxuICAgICAqL1xuICAgIHZhciBWZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVmVjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBWZWN0b3IoeCwgeSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHZlY3RvciBvZiB1bml0IGxlbmd0aCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzcGVjaWZpZWQgYW5nbGUuXG4gICAgICAgICAqIEBtZXRob2QgZnJvbUFuZ2xlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIGFuZ2xlIHtudW1iZXJ9IFRoZSBhbmdsZSB0byBnZW5lcmF0ZSB0aGUgdmVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLmZyb21BbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3RhbmNlIHRvIGFub3RoZXIgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZGlzdGFuY2VcbiAgICAgICAgICogQHBhcmFtIHYge1ZlY3Rvcn0gVGhlIG90aGVyIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgdiA9IG5ldyBWZWN0b3IoMC4wLCAwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB2LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gdi55LCAyKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3JtYWxpemVzIGEgdmVjdG9yIHRvIGhhdmUgYSBtYWduaXR1ZGUgb2YgMS5cbiAgICAgICAgICogQG1ldGhvZCBub3JtYWxpemVcbiAgICAgICAgICogQHJldHVybiBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRpc3RhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggLyBkLCB0aGlzLnkgLyBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGVzIGEgdmVjdG9yJ3MgYnkgYSBmYWN0b3Igb2Ygc2l6ZVxuICAgICAgICAgKiBAbWV0aG9kIHNjYWxlXG4gICAgICAgICAqIEBwYXJhbSBzaXplIHtudW1iZXJ9IFRoZSBmYWN0b3IgdG8gc2NhbGUgdGhlIG1hZ25pdHVkZSBieVxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICogc2l6ZSwgdGhpcy55ICogc2l6ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIG9uZSB2ZWN0b3IgdG8gYW5vdGhlclxuICAgICAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgdmVjdG9yIHRvIGFkZFxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCArIHYueCwgdGhpcy55ICsgdi55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnRyYWN0cyBhIHZlY3RvciBmcm9tIHRoZSBjdXJyZW50IHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIG1pbnVzXG4gICAgICAgICAqIEBwYXJhbSB2IHtWZWN0b3J9IFRoZSB2ZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm1pbnVzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgZG90IHByb2R1Y3Qgd2l0aCBhbm90aGVyIHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGRvdFxuICAgICAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgdmVjdG9yIHRvIGRvdFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIDJEIGNyb3NzIHByb2R1Y3Qgd2l0aCBhbm90aGVyIHZlY3Rvci4gMkQgY3Jvc3MgcHJvZHVjdHMgcmV0dXJuIGEgc2NhbGFyIHZhbHVlIG5vdCBhIHZlY3Rvci5cbiAgICAgICAgICogQG1ldGhvZCBjcm9zc1xuICAgICAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgdmVjdG9yIHRvIGNyb3NzXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5jcm9zcyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdi55IC0gdGhpcy55ICogdi54O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcGVycGVuZGljdWxhciB2ZWN0b3IgdG8gdGhpcyBvbmVcbiAgICAgICAgICogQG1ldGhvZCBwZXJwZW5kaWN1bGFyXG4gICAgICAgICAqIEByZXR1cm4gVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnBlcnBlbmRpY3VsYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnksIC10aGlzLngpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbm9ybWFsIHZlY3RvciB0byB0aGlzIG9uZVxuICAgICAgICAgKiBAbWV0aG9kIG5vcm1hbFxuICAgICAgICAgKiBAcmV0dXJuIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJwZW5kaWN1bGFyKCkubm9ybWFsaXplKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBvZiB0aGlzIHZlY3Rvci5cbiAgICAgICAgICogQG1ldGhvZCB0b0FuZ2xlXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS50b0FuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcG9pbnQgcmVwcmVzZW50aW9uIG9mIHRoaXMgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgdG9Qb2ludFxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS50b1BvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb3RhdGVzIHRoZSBjdXJyZW50IHZlY3RvciBhcm91bmQgYSBwb2ludCBieSBhIGNlcnRhaW4gbnVtYmVyIG9mXG4gICAgICAgICAqIGRlZ3JlZXMgaW4gcmFkaWFuc1xuICAgICAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlLCBhbmNob3IpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJvdGF0ZS5jYWxsKHRoaXMsIGFuZ2xlLCBhbmNob3IpLnRvVmVjdG9yKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWZWN0b3I7XG4gICAgfSkoUG9pbnQpO1xuICAgIGV4LlZlY3RvciA9IFZlY3RvcjtcbiAgICAvKipcbiAgICAgKiBBIDJEIHJheSB0aGF0IGNhbiBiZSBjYXN0IGludG8gdGhlIHNjZW5lIHRvIGRvIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgKiBAY2xhc3MgUmF5XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHBvcyB7UG9pbnR9IFRoZSBzdGFydGluZyBwb3NpdGlvbiBmb3IgdGhlIHJheVxuICAgICAqIEBwYXJhbSBkaXIge1ZlY3Rvcn0gVGhlIHZlY3RvciBpbmRpY2F0aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJheVxuICAgICAqL1xuICAgIHZhciBSYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSYXkocG9zLCBkaXIpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgdGhpcy5kaXIgPSBkaXIubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3RzIGEgd2hldGhlciB0aGlzIHJheSBpbnRlcnNlY3RzIHdpdGggYSBsaW5lIHNlZ21lbnQuIFJldHVybnMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgb24gc3VjY2Vzcy5cbiAgICAgICAgICogVGhpcyBudW1iZXIgaW5kaWNhdGVzIHRoZSBtYXRoZW1hdGljYWwgaW50ZXJzZWN0aW9uIHRpbWUuXG4gICAgICAgICAqIEBtZXRob2QgaW50ZXJzZWN0XG4gICAgICAgICAqIEBwYXJhbSBsaW5lIHtMaW5lfSBUaGUgbGluZSB0byB0ZXN0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgUmF5LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IGxpbmUuYmVnaW4udG9WZWN0b3IoKS5taW51cyh0aGlzLnBvcy50b1ZlY3RvcigpKTtcbiAgICAgICAgICAgIC8vIFRlc3QgaXMgbGluZSBhbmQgcmF5IGFyZSBwYXJhbGxlbCBhbmQgbm9uIGludGVyc2VjdGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgPT09IDAgJiYgbnVtZXJhdG9yLmNyb3NzKHRoaXMuZGlyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBwYXJhbGxlbFxuICAgICAgICAgICAgdmFyIGRpdmlzb3IgPSAodGhpcy5kaXIuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSk7XG4gICAgICAgICAgICBpZiAoZGl2aXNvciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gbnVtZXJhdG9yLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xuICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gKG51bWVyYXRvci5jcm9zcyh0aGlzLmRpcikgLyBkaXZpc29yKSAvIGxpbmUuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHUgPj0gMCAmJiB1IDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIGdpdmVuIHRoZSBpbnRlcnNlY3Rpb24gdGltZVxuICAgICAgICAgKiBAbWV0aG9kIGdldFBvaW50XG4gICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBSYXkucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcy50b1ZlY3RvcigpLmFkZCh0aGlzLmRpci5zY2FsZSh0aW1lKSkudG9Qb2ludCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmF5O1xuICAgIH0pKCk7XG4gICAgZXguUmF5ID0gUmF5O1xuICAgIC8qKlxuICAgICAqIEEgMkQgbGluZSBzZWdtZW50XG4gICAgICogQGNsYXNzIExpbmVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gYmVnaW4ge1BvaW50fSBUaGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICAqIEBwYXJhbSBlbmQge1BvaW50fSBUaGUgZW5kaW5nIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgKi9cbiAgICB2YXIgTGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpbmUoYmVnaW4sIGVuZCkge1xuICAgICAgICAgICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNsb3BlIG9mIHRoZSBsaW5lIGluIHRoZSBmb3JtIG9mIGEgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2xvcGVcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBMaW5lLnByb3RvdHlwZS5nZXRTbG9wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuYmVnaW4udG9WZWN0b3IoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZC50b1ZlY3RvcigpO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcbiAgICAgICAgICAgIHJldHVybiBlbmQubWludXMoYmVnaW4pLnNjYWxlKDEgLyBkaXN0YW5jZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgc2VnbWVudCBpbiBwaXhlbHNcbiAgICAgICAgICogQG1ldGhvZCBnZXRMZW5ndGhcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBMaW5lLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmJlZ2luLnRvVmVjdG9yKCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQudG9WZWN0b3IoKTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaW5lO1xuICAgIH0pKCk7XG4gICAgZXguTGluZSA9IExpbmU7XG4gICAgdmFyIFByb2plY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcm9qZWN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIFByb2plY3Rpb24ucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24gKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCA+IHByb2plY3Rpb24ubWluICYmIHByb2plY3Rpb24ubWF4ID4gdGhpcy5taW47XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb24ucHJvdG90eXBlLmdldE92ZXJsYXAgPSBmdW5jdGlvbiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcmxhcHMocHJvamVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXggPiBwcm9qZWN0aW9uLm1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbi5tYXggLSB0aGlzLm1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCAtIHByb2plY3Rpb24ubWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvamVjdGlvbjtcbiAgICB9KSgpO1xuICAgIGV4LlByb2plY3Rpb24gPSBQcm9qZWN0aW9uO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50cy50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgVXRpbDtcbiAgICAoZnVuY3Rpb24gKFV0aWwpIHtcbiAgICAgICAgVXRpbC5Ud29QSSA9IE1hdGguUEkgKiAyO1xuICAgICAgICBmdW5jdGlvbiBiYXNlNjRFbmNvZGUoaW5wdXRTdHIpIHtcbiAgICAgICAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICAgICAgICB2YXIgb3V0cHV0U3RyID0gXCJcIjtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaW5wdXRTdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy9hbGwgdGhyZWUgXCImIDB4ZmZcIiBhZGRlZCBiZWxvdyBhcmUgdGhlcmUgdG8gZml4IGEga25vd24gYnVnIFxuICAgICAgICAgICAgICAgIC8vd2l0aCBieXRlcyByZXR1cm5lZCBieSB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xuICAgICAgICAgICAgICAgIHZhciBieXRlMyA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgdmFyIGVuYzEgPSBieXRlMSA+PiAyO1xuICAgICAgICAgICAgICAgIHZhciBlbmMyID0gKChieXRlMSAmIDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgICAgIHZhciBlbmMzLCBlbmM0O1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihieXRlMikpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jMyA9IGVuYzQgPSA2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYzMgPSAoKGJ5dGUyICYgMTUpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYnl0ZTMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmM0ID0gYnl0ZTMgJiA2MztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXRTdHIgKz0gYjY0LmNoYXJBdChlbmMxKSArIGI2NC5jaGFyQXQoZW5jMikgKyBiNjQuY2hhckF0KGVuYzMpICsgYjY0LmNoYXJBdChlbmM0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5iYXNlNjRFbmNvZGUgPSBiYXNlNjRFbmNvZGU7XG4gICAgICAgIGZ1bmN0aW9uIGNsYW1wKHZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgPD0gbWluID8gbWluIDogKHZhbCA+PSBtYXggPyBtYXggOiB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwuY2xhbXAgPSBjbGFtcDtcbiAgICAgICAgZnVuY3Rpb24gZHJhd0xpbmUoY3R4LCBjb2xvciwgc3RhcnR4LCBzdGFydHksIGVuZHgsIGVuZHkpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhzdGFydHgsIHN0YXJ0eSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGVuZHgsIGVuZHkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwuZHJhd0xpbmUgPSBkcmF3TGluZTtcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tSW5SYW5nZShtaW4sIG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLnJhbmRvbUluUmFuZ2UgPSByYW5kb21JblJhbmdlO1xuICAgICAgICBmdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKG1pbiwgbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChyYW5kb21JblJhbmdlKG1pbiwgbWF4KSk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5yYW5kb21JbnRJblJhbmdlID0gcmFuZG9tSW50SW5SYW5nZTtcbiAgICAgICAgZnVuY3Rpb24gY2Fub25pY2FsaXplQW5nbGUoYW5nbGUpIHtcbiAgICAgICAgICAgIHZhciB0bXBBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgaWYgKGFuZ2xlID4gdGhpcy5Ud29QSSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0bXBBbmdsZSA+IHRoaXMuVHdvUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wQW5nbGUgLT0gdGhpcy5Ud29QSTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRtcEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0bXBBbmdsZSArPSB0aGlzLlR3b1BJO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0bXBBbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLmNhbm9uaWNhbGl6ZUFuZ2xlID0gY2Fub25pY2FsaXplQW5nbGU7XG4gICAgICAgIGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gMTgwIC8gTWF0aC5QSSAqIHJhZGlhbnM7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC50b0RlZ3JlZXMgPSB0b0RlZ3JlZXM7XG4gICAgICAgIGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC50b1JhZGlhbnMgPSB0b1JhZGlhbnM7XG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgb0xlZnQgPSAwLCBvVG9wID0gMDtcbiAgICAgICAgICAgIHZhciBjYWxjT2Zmc2V0TGVmdCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBvTGVmdCArPSBwYXJlbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjT2Zmc2V0TGVmdChwYXJlbnQub2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNhbGNPZmZzZXRUb3AgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgb1RvcCArPSBwYXJlbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNPZmZzZXRUb3AocGFyZW50Lm9mZnNldFBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbGNPZmZzZXRMZWZ0KGVsKTtcbiAgICAgICAgICAgIGNhbGNPZmZzZXRUb3AoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludChvTGVmdCwgb1RvcCk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5nZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xuICAgICAgICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVNpZGUoc2lkZSkge1xuICAgICAgICAgICAgaWYgKHNpZGUgPT09IDEgLyogVG9wICovKVxuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEJvdHRvbSAqLztcbiAgICAgICAgICAgIGlmIChzaWRlID09PSAyIC8qIEJvdHRvbSAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBUb3AgKi87XG4gICAgICAgICAgICBpZiAoc2lkZSA9PT0gMyAvKiBMZWZ0ICovKVxuICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIFJpZ2h0ICovO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT09IDQgLyogUmlnaHQgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogTGVmdCAqLztcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5nZXRPcHBvc2l0ZVNpZGUgPSBnZXRPcHBvc2l0ZVNpZGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGNhbGlidXJzIGR5bmFtaWNhbGx5IHJlc2l6aW5nIGNvbGxlY3Rpb25cbiAgICAgICAgICogQGNsYXNzIENvbGxlY3Rpb25cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBbaW5pdGlhbFNpemU9MjAwXSB7bnVtYmVyfSBJbml0aWFsIHNpemUgb2YgdGhlIGludGVybmFsIGJhY2tpbmcgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHZhciBDb2xsZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oaW5pdGlhbFNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQXJyYXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kUG9pbnRlciA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBpbml0aWFsU2l6ZSB8fCBDb2xsZWN0aW9uLkRlZmF1bHRTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBcnJheSA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuaW50ZXJuYWxBcnJheS5sZW5ndGggKiAyO1xuICAgICAgICAgICAgICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdTaXplKTtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FycmF5W2ldID0gdGhpcy5pbnRlcm5hbEFycmF5W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbnRlcm5hbEFycmF5O1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBcnJheSA9IG5ld0FycmF5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHVzaCBlbGVtZW50cyB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHB1c2hcbiAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50IHtUfVxuICAgICAgICAgICAgICogQHJldHVybnMgVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRQb2ludGVyID09PSB0aGlzLmludGVybmFsQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXlbdGhpcy5lbmRQb2ludGVyKytdID0gZWxlbWVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBvcFxuICAgICAgICAgICAgICogQHJldHVybnMgVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRQb2ludGVyID0gdGhpcy5lbmRQb2ludGVyIC0gMSA8IDAgPyAwIDogdGhpcy5lbmRQb2ludGVyIC0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5W3RoaXMuZW5kUG9pbnRlcl07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBjb3VudFxuICAgICAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZFBvaW50ZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbXB0aWVzIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kUG9pbnRlciA9IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBpbnRlcm5hbCBiYWNraW5nIGFycmF5XG4gICAgICAgICAgICAgKiBAbWV0aG9kIGludGVybmFsU2l6ZVxuICAgICAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmludGVybmFsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICAgICAgICAgKiBAbWV0aG9kIGVsZW1lbnRBdFxuICAgICAgICAgICAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IEluZGV4IG9mIGVsZW1lbnQgdG8gcmV0cmVpdmVcbiAgICAgICAgICAgICAqIEByZXR1cm5zIFRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZWxlbWVudEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5zZXJ0cyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5zZXJ0XG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gSW5kZXggdG8gaW5zZXJ0IHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5jb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAgICAgICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBJbmRleCBvZiBlbGVtZW50IHRvIHJlbW92ZVxuICAgICAgICAgICAgICogQHJldHVybnMgVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gTyhuKSBTaGlmdCBcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuaW50ZXJuYWxBcnJheVtpbmRleF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQXJyYXlbaV0gPSB0aGlzLmludGVybmFsQXJyYXlbaSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVuZFBvaW50ZXItLTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBieSByZWZlcmVuY2VcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRWxlbWVudFxuICAgICAgICAgICAgICogQHBhcmFtIGVsZW1lbnQge1R9IEluZGV4IG9mIGVsZW1lbnQgdG8gcmV0cmVpdmVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbnRlcm5hbEFycmF5LmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIGFycmF5IHJlcHJlc2VudGluZyB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCB0b0FycmF5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5LnNsaWNlKDAsIHRoaXMuZW5kUG9pbnRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJdGVyYXRlIG92ZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBmb3JFYWNoXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnVuYyB7KFQsbnVtYmVyKT0+YW55fSBDYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQgcGFzc2luZyBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4LCByZXR1cm5lZCB2YWx1ZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgdGhpcy5pbnRlcm5hbEFycmF5W2ldLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNdXRhdGUgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBtYXBcbiAgICAgICAgICAgICAqIEBwYXJhbSBmdW5jIHsoVCxudW1iZXIpPT5hbnl9IENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggZWxlbWVudCBwYXNzaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgsIGFueSB2YWx1ZXMgcmV0dXJuZWQgbXV0YXRlIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQXJyYXlbaV0gPSBmdW5jLmNhbGwodGhpcywgdGhpcy5pbnRlcm5hbEFycmF5W2ldLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWZhdWx0IGNvbGxlY3Rpb24gc2l6ZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IERlZmF1bHRTaXplIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5EZWZhdWx0U2l6ZSA9IDIwMDtcbiAgICAgICAgICAgIHJldHVybiBDb2xsZWN0aW9uO1xuICAgICAgICB9KSgpO1xuICAgICAgICBVdGlsLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuICAgIH0pKFV0aWwgPSBleC5VdGlsIHx8IChleC5VdGlsID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQSBTcHJpdGUgaXMgb25lIG9mIHRoZSBtYWluIGRyYXdpbmcgcHJpbWl0aXZlcy4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmdcbiAgICAgKiBpbWFnZXMgb3IgcGFydHMgb2YgaW1hZ2VzIGtub3duIGFzIFRleHR1cmVzIHRvIHRoZSBzY3JlZW4uXG4gICAgICogQGNsYXNzIFNwcml0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBpbWFnZSB7VGV4dHVyZX0gVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlXG4gICAgICogQHBhcmFtIHN4IHtudW1iZXJ9IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzcHJpdGVcbiAgICAgKiBAcGFyYW0gc3kge251bWJlcn0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHNwcml0ZVxuICAgICAqIEBwYXJhbSBzd2lkdGgge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHNoZWlnaHQge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHZhciBTcHJpdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTcHJpdGUoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5zeCA9IHN4O1xuICAgICAgICAgICAgdGhpcy5zeSA9IHN5O1xuICAgICAgICAgICAgdGhpcy5zd2lkdGggPSBzd2lkdGg7XG4gICAgICAgICAgICB0aGlzLnNoZWlnaHQgPSBzaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSAxLjA7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IDEuMDtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwLjA7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVBvaW50ID0gbmV3IGV4LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBpeGVsRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBpeGVsc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eUVmZmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN4IDwgMCB8fCBzeSA8IDAgfHwgc3dpZHRoIDwgMCB8fCBzaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU3ByaXRlIGNhbm5vdCBoYXZlIGFueSBuZWdhdGl2ZSBkaW1lbnNpb25zIHg6XCIsIHN4LCBcInk6XCIsIHN5LCBcIndpZHRoOlwiLCBzd2lkdGgsIFwiaGVpZ2h0OlwiLCBzaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ2FudmFzLndpZHRoID0gc3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDYW52YXMuaGVpZ2h0ID0gc2hlaWdodDtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ3R4ID0gdGhpcy5zcHJpdGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5sb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3ByaXRlQ2FudmFzLndpZHRoID0gX3RoaXMuc3ByaXRlQ2FudmFzLndpZHRoIHx8IF90aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgICAgIF90aGlzLnNwcml0ZUNhbnZhcy5oZWlnaHQgPSBfdGhpcy5zcHJpdGVDYW52YXMuaGVpZ2h0IHx8IF90aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkUGl4ZWxzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlydHlFZmZlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHRleHR1cmUgXCIsIF90aGlzLnRleHR1cmUucGF0aCwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBzd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5sb2FkUGl4ZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyZS5pc0xvYWRlZCgpICYmICF0aGlzLnBpeGVsc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGFtcCA9IGV4LlV0aWwuY2xhbXA7XG4gICAgICAgICAgICAgICAgdmFyIG5hdHVyYWxXaWR0aCA9IHRoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsV2lkdGggfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IHRoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3dpZHRoID4gbmF0dXJhbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGUgc3ByaXRlIHdpZHRoXCIsIHRoaXMuc3dpZHRoLCBcImV4Y2VlZHMgdGhlIHdpZHRoXCIsIG5hdHVyYWxXaWR0aCwgXCJvZiB0aGUgYmFja2luZyB0ZXh0dXJlXCIsIHRoaXMudGV4dHVyZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hlaWdodCA+IG5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoZSBzcHJpdGUgaGVpZ2h0XCIsIHRoaXMuc2hlaWdodCwgXCJleGNlZWRzIHRoZSBoZWlnaHRcIiwgbmF0dXJhbEhlaWdodCwgXCJvZiB0aGUgYmFja2luZyB0ZXh0dXJlXCIsIHRoaXMudGV4dHVyZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZS5pbWFnZSwgY2xhbXAodGhpcy5zeCwgMCwgbmF0dXJhbFdpZHRoKSwgY2xhbXAodGhpcy5zeSwgMCwgbmF0dXJhbEhlaWdodCksIGNsYW1wKHRoaXMuc3dpZHRoLCAwLCBuYXR1cmFsV2lkdGgpLCBjbGFtcCh0aGlzLnNoZWlnaHQsIDAsIG5hdHVyYWxIZWlnaHQpLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAvL3RoaXMucGl4ZWxEYXRhID0gdGhpcy5zcHJpdGVDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxJbWFnZS5zcmMgPSB0aGlzLnNwcml0ZUNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5waXhlbHNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG5ldyB7eyNjcm9zc0xpbmsgRWZmZWN0cy5JU3ByaXRlRWZmZWN0fX17ey9jcm9zc0xpbmt9fSB0byB0aGlzIGRyYXdpbmcuXG4gICAgICAgICAqIEBtZXRob2QgYWRkRWZmZWN0XG4gICAgICAgICAqIEBwYXJhbSBlZmZlY3Qge0VmZmVjdHMuSVNwcml0ZUVmZmVjdH0gRWZmZWN0IHRvIGFkZCB0byB0aGUgdGhpcyBkcmF3aW5nXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgICAgICAgICAvLyBXZSBtdXN0IGNoZWNrIGlmIHRoZSB0ZXh0dXJlIGFuZCB0aGUgYmFja2luZyBzcHJpdGUgcGl4ZWxzIGFyZSBsb2FkZWQgYXMgd2VsbCBiZWZvcmUgXG4gICAgICAgICAgICAvLyBhbiBlZmZlY3QgY2FuIGJlIGFwcGxpZWRcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMucGl4ZWxzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eUVmZmVjdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnJlbW92ZUVmZmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFyIGluZGV4VG9SZW1vdmUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gcGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gdGhpcy5lZmZlY3RzLmluZGV4T2YocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKTtcbiAgICAgICAgICAgIC8vIFdlIG11c3QgY2hlY2sgaWYgdGhlIHRleHR1cmUgYW5kIHRoZSBiYWNraW5nIHNwcml0ZSBwaXhlbHMgYXJlIGxvYWRlZCBhcyB3ZWxsIGJlZm9yZSBcbiAgICAgICAgICAgIC8vIGFuIGVmZmVjdCBjYW4gYmUgYXBwbGllZFxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUuaXNMb2FkZWQoKSB8fCAhdGhpcy5waXhlbHNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5RWZmZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuYXBwbHlFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGFtcCA9IGV4LlV0aWwuY2xhbXA7XG4gICAgICAgICAgICB2YXIgbmF0dXJhbFdpZHRoID0gdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAwO1xuICAgICAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodCB8fCAwO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHguZHJhd0ltYWdlKHRoaXMudGV4dHVyZS5pbWFnZSwgY2xhbXAodGhpcy5zeCwgMCwgbmF0dXJhbFdpZHRoKSwgY2xhbXAodGhpcy5zeSwgMCwgbmF0dXJhbEhlaWdodCksIGNsYW1wKHRoaXMuc3dpZHRoLCAwLCBuYXR1cmFsV2lkdGgpLCBjbGFtcCh0aGlzLnNoZWlnaHQsIDAsIG5hdHVyYWxIZWlnaHQpLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxEYXRhID0gdGhpcy5zcHJpdGVDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLmZvckVhY2goZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgX3RoaXMuc2hlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgX3RoaXMuc3dpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdC51cGRhdGVQaXhlbCh4LCB5LCBfdGhpcy5waXhlbERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eC5wdXRJbWFnZURhdGEodGhpcy5waXhlbERhdGEsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEltYWdlLnNyYyA9IHRoaXMuc3ByaXRlQ2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgZWZmZWN0cyBmcm9tIHRoZSBkcmF3aW5nIGFuZCByZXR1cm4gaXQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyRWZmZWN0c1xuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5jbGVhckVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBwb2ludCBhYm91dCB3aGljaCB0byBhcHBseSB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGRyYXdpbmcgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgZHJhd2luZy5cbiAgICAgICAgICogQG1ldGhvZCB0cmFuc2Zvcm1BYm90UG9pbnRcbiAgICAgICAgICogQHBhcmFtIHBvaW50IHtQb2ludH0gVGhlIHBvaW50IGFib3V0IHdoaWNoIHRvIGFwcGx5IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS50cmFuc2Zvcm1BYm91dFBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIGZvciB0aGUgZHJhd2luZy5cbiAgICAgICAgICogQG1ldGhvZCBzZXRSb3RhdGlvblxuICAgICAgICAgKiBAcGFyYW0gcmFkaWFucyB7bnVtYmVyfSBUaGUgcm90YXRpb24gdG8gYXBwbHkgdG8gdGhlIGRyYXdpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnNldFJvdGF0aW9uID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSByYWRpYW5zO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCByb3RhdGlvbiBmb3IgdGhlIGRyYXdpbmcgaW4gcmFkaWFucy5cbiAgICAgICAgICogQG1ldGhvZCBnZXRSb3RhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHNjYWxlIHRyYXNmb3JtYXRpb24gaW4gdGhlIHggZGlyZWN0aW9uXG4gICAgICAgICAqIEBtZXRob2Qgc2V0U2NhbGVcbiAgICAgICAgICogQHBhcmFtIHNjYWxlIHtudW1iZXJ9IFRoZSBtYWduaXR1ZGUgdG8gc2NhbGUgdGhlIGRyYXdpbmcgaW4gdGhlIHggZGlyZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnNldFNjYWxlWCA9IGZ1bmN0aW9uIChzY2FsZVgpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc2NhbGUgdHJhc2Zvcm1hdGlvbiBpbiB0aGUgeCBkaXJlY3Rpb25cbiAgICAgICAgICogQG1ldGhvZCBzZXRTY2FsZVxuICAgICAgICAgKiBAcGFyYW0gc2NhbGUge251bWJlcn0gVGhlIG1hZ25pdHVkZSB0byBzY2FsZSB0aGUgZHJhd2luZyBpbiB0aGUgeCBkaXJlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuc2V0U2NhbGVZID0gZnVuY3Rpb24gKHNjYWxlWSkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1hZ25pdHVkZSBvZiB0aGUgZHJhd2luZydzIHNjYWxlIGluIHRoZSB4IGRpcmVjdGlvblxuICAgICAgICAgKiBAbWV0aG9kIGdldFNjYWxlXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5nZXRTY2FsZVggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG1hZ25pdHVkZSBvZiB0aGUgZHJhd2luZydzIHNjYWxlIGluIHRoZSB5IGRpcmVjdGlvblxuICAgICAgICAgKiBAbWV0aG9kIGdldFNjYWxlXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5nZXRTY2FsZVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBkcmF3aW5nIChpZiBhbnkpXG4gICAgICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3cyB0aGUgc3ByaXRlIGFwcHJvcHJpYXRlbHkgdG8gdGhlIDJEIHJlbmRlcmluZyBjb250ZXh0LCBhdCBhbiB4IGFuZCB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSAyRCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBjb29yZGluYXRlIG9mIHdoZXJlIHRvIGRyYXdcbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgY29vcmRpbmF0ZSBvZiB3aGVyZSB0byBkcmF3XG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJ0eUVmZmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eUVmZmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcEhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuc3dpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbEltYWdlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmludGVybmFsSW1hZ2UsIDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQsIC0odGhpcy50cmFuc2Zvcm1Qb2ludC54ICogdGhpcy5zd2lkdGgpICogdGhpcy5zY2FsZVgsIC0odGhpcy50cmFuc2Zvcm1Qb2ludC55ICogdGhpcy5zaGVpZ2h0KSAqIHRoaXMuc2NhbGVZLCB0aGlzLnN3aWR0aCAqIHRoaXMuc2NhbGVYLCB0aGlzLnNoZWlnaHQgKiB0aGlzLnNjYWxlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHNwcml0ZVxuICAgICAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICAgICAqIEByZXR1cm5zIFNwcml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3ByaXRlKHRoaXMudGV4dHVyZSwgdGhpcy5zeCwgdGhpcy5zeSwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICByZXN1bHQuc2NhbGVYID0gdGhpcy5zY2FsZVg7XG4gICAgICAgICAgICByZXN1bHQuc2NhbGVZID0gdGhpcy5zY2FsZVk7XG4gICAgICAgICAgICByZXN1bHQucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICAgICAgcmVzdWx0LmZsaXBIb3Jpem9udGFsID0gdGhpcy5mbGlwSG9yaXpvbnRhbDtcbiAgICAgICAgICAgIHJlc3VsdC5mbGlwVmVydGljYWwgPSB0aGlzLmZsaXBWZXJ0aWNhbDtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZEVmZmVjdChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNwcml0ZTtcbiAgICB9KSgpO1xuICAgIGV4LlNwcml0ZSA9IFNwcml0ZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU3ByaXRlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBTcHJpdGVTaGVldHMgYXJlIGEgdXNlZnVsIG1lY2hhbmlzbSBmb3Igc2xpY2luZyB1cCBpbWFnZSByZXNvdXJjZXMgaW50b1xuICAgICAqIHNlcGFyYXRlIHNwcml0ZXMgb3IgZm9yIGdlbmVyYXRpbmcgaW4gZ2FtZSBhbmltYXRpb25zLiBTcHJpdGVzIGFyZSBvcmdhbml6ZWRcbiAgICAgKiBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFNwcml0ZVNoZWV0LlxuICAgICAqIEBjbGFzcyBTcHJpdGVTaGVldFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBpbWFnZSB7VGV4dHVyZX0gVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlU2hlZXRcbiAgICAgKiBAcGFyYW0gY29sdW1ucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIGltYWdlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gcm93cyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGltYWdlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gc3BXaWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgZWFjaCBpbmRpdmlkdWFsIHNwcml0ZSBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gc3BIZWlnaHQge251bWJlcn0gVGhlIGhlaWdodCBvZiBlYWNoIGluZGl2aWR1YWwgc3ByaXRlIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHZhciBTcHJpdGVTaGVldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZVNoZWV0KGltYWdlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxJbWFnZSA9IGltYWdlLmltYWdlO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gbmV3IEFycmF5KGNvbHVtbnMgKiByb3dzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEluc3BlY3QgYWN0dWFsIGltYWdlIGRpbWVuc2lvbnMgd2l0aCBwcmVsb2FkaW5nXG4gICAgICAgICAgICAvKmlmKHNwV2lkdGggKiBjb2x1bW5zID4gdGhpcy5pbnRlcm5hbEltYWdlLm5hdHVyYWxXaWR0aCl7XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpdGVTaGVldCBzcGVjaWZpZWQgaXMgd2lkZXIgdGhhbiBpbWFnZSB3aWR0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgIFxuICAgICAgICAgICAgaWYoc3BIZWlnaHQgKiByb3dzID4gdGhpcy5pbnRlcm5hbEltYWdlLm5hdHVyYWxIZWlnaHQpe1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ByaXRlU2hlZXQgc3BlY2lmaWVkIGlzIGhpZ2hlciB0aGFuIGltYWdlIGhlaWdodFwiKTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ogKyBpICogY29sdW1uc10gPSBuZXcgZXguU3ByaXRlKHRoaXMuaW1hZ2UsIGogKiBzcFdpZHRoLCBpICogc3BIZWlnaHQsIHNwV2lkdGgsIHNwSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbiBhbmltYXRpb24gZnJvbSB0aGUgdGhpcyBTcHJpdGVTaGVldCBieSBsaXN0aW5nIG91dCB0aGVcbiAgICAgICAgICogc3ByaXRlIGluZGljZXMuIFNwcml0ZXMgYXJlIG9yZ2FuaXplZCBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFNwcml0ZVNoZWV0LlxuICAgICAgICAgKiBAbWV0aG9kIGdldEFuaW1hdGlvbkJ5SW5kaWNlc1xuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIEVuZ2luZVxuICAgICAgICAgKiBAcGFyYW0gaW5kaWNlcyB7bnVtYmVyW119IEFuIGFycmF5IG9mIHNwcml0ZSBpbmRpY2VzIHRvIHVzZSBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBBbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZVNoZWV0LnByb3RvdHlwZS5nZXRBbmltYXRpb25CeUluZGljZXMgPSBmdW5jdGlvbiAoZW5naW5lLCBpbmRpY2VzLCBzcGVlZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3ByaXRlc1tpbmRleF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LkFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiBmcm9tIHRoZSB0aGlzIFNwcml0ZVNoZWV0IGJ5IHNwZWNpZmluZyB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgICogaW1hZ2VzIHdpdGggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGluZGV4XG4gICAgICAgICAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uQmV0d2VlblxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIEVuZ2luZVxuICAgICAgICAgKiBAcGFyYW0gYmVnaW5JbmRleCB7bnVtYmVyfSBUaGUgaW5kZXggdG8gc3RhcnQgdGFraW5nIGZyYW1lc1xuICAgICAgICAgKiBAcGFyYW0gZW5kSW5kZXgge251bWJlcn0gVGhlIGluZGV4IHRvIHN0b3AgdGFraW5nIGZyYW1lc1xuICAgICAgICAgKiBAcGFyYW0gc3BlZWQge251bWJlcn0gVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogQHJldHVybnMgQW5pbWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGVTaGVldC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uQmV0d2VlbiA9IGZ1bmN0aW9uIChlbmdpbmUsIGJlZ2luSW5kZXgsIGVuZEluZGV4LCBzcGVlZCkge1xuICAgICAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMuc3ByaXRlcy5zbGljZShiZWdpbkluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgICAgICBpbWFnZXMgPSBpbWFnZXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5BbmltYXRpb24oZW5naW5lLCBpbWFnZXMsIHNwZWVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyZWF0IHRoZSBlbnRpcmUgU3ByaXRlU2hlZXQgYXMgb25lIGFuaW1hdGlvbiwgb3JnYW5pemluZyB0aGUgZnJhbWVzIGluXG4gICAgICAgICAqIHJvdyBtYWpvciBvcmRlci5cbiAgICAgICAgICogQG1ldGhvZCBnZXRBbmltYXRpb25Gb3JBbGxcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBFbmdpbmVcbiAgICAgICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIEFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlU2hlZXQucHJvdG90eXBlLmdldEFuaW1hdGlvbkZvckFsbCA9IGZ1bmN0aW9uIChlbmdpbmUsIHNwZWVkKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlcyA9IHRoaXMuc3ByaXRlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LkFuaW1hdGlvbihlbmdpbmUsIHNwcml0ZXMsIHNwZWVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJlaXZlIGEgc3BlY2lmaWMgc3ByaXRlIGZyb20gdGhlIFNwcml0ZVNoZWV0IGJ5IGl0cyBpbmRleC4gU3ByaXRlcyBhcmUgb3JnYW5pemVkXG4gICAgICAgICAqIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgU3ByaXRlU2hlZXQuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U3ByaXRlXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHNwcml0ZVxuICAgICAgICAgKiBAcmV0dXJucyBTcHJpdGVcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZVNoZWV0LnByb3RvdHlwZS5nZXRTcHJpdGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3ByaXRlU2hlZXQ7XG4gICAgfSkoKTtcbiAgICBleC5TcHJpdGVTaGVldCA9IFNwcml0ZVNoZWV0O1xuICAgIC8qKlxuICAgICAqIFNwcml0ZUZvbnRzIGFyZSBhIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHt7I2Nyb3NzTGluayBMYWJlbH19e3svY3Jvc3NMaW5rfX0gdG8gc3BlY2lmeVxuICAgICAqIGEgcGFydGljdWxhciBiaXRtYXAgYXMgYSBmb250LlxuICAgICAqIEBjbGFzcyBTcHJpdGVGb250XG4gICAgICogQGV4dGVuZHMgU3ByaXRlU2hlZXRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gaW1hZ2Uge1RleHR1cmV9IFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZUZvbnRcbiAgICAgKiBAcGFyYW0gYWxwaGFiZXQge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCB0aGUgY2hhcmF0ZXJzIGluIHRoZSBpbWFnZSwgaW4gcm93IG1ham9yIG9yZGVyLlxuICAgICAqIEBwYXJhbSBjYXNlSW5zZW5zaXR2ZSB7Ym9vbGVhbn0gSW5kaWNhdGUgd2hldGhlciB0aGlzIGZvbnQgdGFrZXMgY2FzZSBpbnRvIGFjY291bnRcbiAgICAgKiBAcGFyYW0gY29sdW1ucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgb2YgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0gcm93cyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3Mgb2YgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0gc3BXZGl0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgZWFjaCBjaGFyYWN0ZXIgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHNwSGVpZ2h0IHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgZWFjaCBjaGFyYWN0ZXIgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgdmFyIFNwcml0ZUZvbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU3ByaXRlRm9udCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlRm9udChpbWFnZSwgYWxwaGFiZXQsIGNhc2VJbnNlbnNpdGl2ZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGltYWdlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXQ7XG4gICAgICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IGNhc2VJbnNlbnNpdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlTG9va3VwID0ge307XG4gICAgICAgICAgICB0aGlzLmNvbG9yTG9va3VwID0ge307XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBleC5Db2xvci5CbGFjaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGRpY3Rpb25hcnkgdGhhdCBtYXBzIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBhbHBoYWJldCB0byB0aGUgYXBwcm9wcmlhdGUgU3ByaXRlLlxuICAgICAgICAgKiBAbWV0aG9kIGdldFRleHRTcHJpdGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGVGb250LnByb3RvdHlwZS5nZXRUZXh0U3ByaXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5hbHBoYWJldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9va3VwW2NoYXJdID0gdGhpcy5zcHJpdGVzW2ldLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3ByaXRlRm9udDtcbiAgICB9KShTcHJpdGVTaGVldCk7XG4gICAgZXguU3ByaXRlRm9udCA9IFNwcml0ZUZvbnQ7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVuZ2luZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU3ByaXRlU2hlZXQudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBUaWxlU3ByaXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGlsZVNwcml0ZShzcHJpdGVTaGVldEtleSwgc3ByaXRlSWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlU2hlZXRLZXkgPSBzcHJpdGVTaGVldEtleTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlSWQgPSBzcHJpdGVJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGlsZVNwcml0ZTtcbiAgICB9KSgpO1xuICAgIGV4LlRpbGVTcHJpdGUgPSBUaWxlU3ByaXRlO1xuICAgIC8qKlxuICAgICAqIEEgbGlnaHQtd2VpZ2h0IG9iamVjdCB0aGF0IG9jY3VwaWVzIGEgc3BhY2UgaW4gYSBjb2xsaXNpb24gbWFwLiBHZW5lcmFsbHlcbiAgICAgKiBjcmVhdGVkIGJ5IGEgQ29sbGlzaW9uTWFwLlxuICAgICAqIEBjbGFzcyBDZWxsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHgge251bWJlcn1cbiAgICAgKiBAcGFyYW0geSB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSBoZWlnaHQge251bWJlcn1cbiAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn1cbiAgICAgKiBAcGFyYW0gW3NvbGlkPWZhbHNlXSB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0gW3Nwcml0ZUlkPS0xXSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHZhciBDZWxsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2VsbChcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCBpbiB3b3JsZCBjb29yZGluYXRlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgeCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB5IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHksIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHdpZHRoIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgd2lkdGgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgd2lkdGgsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGhlaWdodCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGhlaWdodCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoZWlnaHQsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNlbGwgaW4gcm93IG1ham9yIG9yZGVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgaW5kZXgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaW5kZXgsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGlzIGNlbGwgaXMgc29saWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzb2xpZCB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc29saWQsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHNwcml0ZSB0byB1c2UgZnJvbSB0aGUgQ29sbGlzaW9uTWFwIFNwcml0ZVNoZWV0LCBpZiAtMSBpcyBzcGVjaWZpZWQgbm90aGluZyBpcyBkcmF3bi5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBudW1iZXIge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3ByaXRlcykge1xuICAgICAgICAgICAgaWYgKHNvbGlkID09PSB2b2lkIDApIHsgc29saWQgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHNwcml0ZXMgPT09IHZvaWQgMCkgeyBzcHJpdGVzID0gW107IH1cbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBzcHJpdGVzO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzID0gbmV3IGV4LkJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCB0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhpcyBjZWxsXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Qm91bmRzXG4gICAgICAgICAqIEByZXR1cm5zIEJvdW5kaW5nQm94XG4gICAgICAgICAqL1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xuICAgICAgICB9O1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlZlY3Rvcih0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUucHVzaFNwcml0ZSA9IGZ1bmN0aW9uICh0aWxlU3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMucHVzaCh0aWxlU3ByaXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUucmVtb3ZlU3ByaXRlID0gZnVuY3Rpb24gKHRpbGVTcHJpdGUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKChpbmRleCA9IHRoaXMuc3ByaXRlcy5pbmRleE9mKHRpbGVTcHJpdGUpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIENlbGwucHJvdG90eXBlLmNsZWFyU3ByaXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2VsbDtcbiAgICB9KSgpO1xuICAgIGV4LkNlbGwgPSBDZWxsO1xuICAgIC8qKlxuICAgICAqIFRoZSBDb2xsaXNpb25NYXAgb2JqZWN0IHByb3ZpZGVzIGEgbGlnaHR3ZWlnaHQgd2F5IHRvIGRvIGxhcmdlIGNvbXBsZXggc2NlbmVzIHdpdGggY29sbGlzaW9uXG4gICAgICogd2l0aG91dCB0aGUgb3ZlcmhlYWQgb2YgYWN0b3JzLlxuICAgICAqIEBjbGFzcyBDb2xsaXNpb25NYXBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBjb29yZGluYXRlIHRvIGFuY2hvciB0aGUgY29sbGlzaW9uIG1hcCdzIHVwcGVyIGxlZnQgY29ybmVyIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXG4gICAgICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgY29vcmRpbmF0ZSB0byBhbmNob3IgdGhlIGNvbGxpc2lvbiBtYXAncyB1cHBlciBsZWZ0IGNvcm5lciAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSBjZWxsV2lkdGgge251bWJlcn0gVGhlIGluZGl2aWR1YWwgd2lkdGggb2YgZWFjaCBjZWxsIChpbiBwaXhlbHMpIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXG4gICAgICogQHBhcmFtIGNlbGxIZWlnaHQge251bWJlcn0gVGhlIGluZGl2aWR1YWwgaGVpZ2h0IG9mIGVhY2ggY2VsbCAoaW4gcGl4ZWxzKSAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSByb3dzIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgY29sbGlzaW9uIG1hcCAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSBjb2xzIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29scyBpbiB0aGUgY29sbGlzaW9uIG1hcCAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSBzcHJpdGVTaGVldCB7U3ByaXRlU2hlZXR9IFRoZSBzcHJpdGVTaGVldCB0byB1c2UgZm9yIGRyYXdpbmdcbiAgICAgKi9cbiAgICB2YXIgVGlsZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRpbGVNYXAoeCwgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCByb3dzLCBjb2xzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICB0aGlzLmNlbGxXaWR0aCA9IGNlbGxXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2VsbEhlaWdodCA9IGNlbGxIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICAgICAgdGhpcy5jb2xzID0gY29scztcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGluZ1ggPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGluZ1kgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWEVuZCA9IDk5OTk7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllTdGFydCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllFbmQgPSA5OTk5O1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlU2hlZXRzID0ge307XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXkocm93cyAqIGNvbHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gbmV3IENlbGwoaSAqIGNlbGxXaWR0aCArIHgsIGogKiBjZWxsSGVpZ2h0ICsgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBpICsgaiAqIGNvbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGF0YVtpICsgaiAqIGNvbHNdID0gY2Q7XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLnJlZ2lzdGVyU3ByaXRlU2hlZXQgPSBmdW5jdGlvbiAoa2V5LCBzcHJpdGVTaGVldCkge1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlU2hlZXRzW2tleV0gPSBzcHJpdGVTaGVldDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGludGVzZWN0aW9uIHZlY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgY29sbGlzaW9ucyB3aXRoIGFjdG9ycy4gSWYgdGhlcmVcbiAgICAgICAgICogaXMgbm8gY29sbGlzaW9uIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn1cbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gYWN0b3IueCArIGFjdG9yLmdldFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYWN0b3IueSArIGFjdG9yLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIGFjdG9yQm91bmRzID0gYWN0b3IuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBhY3RvckJvdW5kcy5sZWZ0OyB4IDw9IHdpZHRoOyB4ICs9IE1hdGgubWluKGFjdG9yLmdldFdpZHRoKCkgLyAyLCB0aGlzLmNlbGxXaWR0aCAvIDIpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IGFjdG9yQm91bmRzLnRvcDsgeSA8PSBoZWlnaHQ7IHkgKz0gTWF0aC5taW4oYWN0b3IuZ2V0SGVpZ2h0KCkgLyAyLCB0aGlzLmNlbGxIZWlnaHQgLyAyKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbEJ5UG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwuc29saWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwID0gYWN0b3JCb3VuZHMuY29sbGlkZXMoY2VsbC5nZXRCb3VuZHMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyID0gYWN0b3IuZ2V0Q2VudGVyKCkubWludXMoY2VsbC5nZXRDZW50ZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCAmJiBvdmVybGFwLmRvdChkaXIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2gob3ZlcmxhcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3ZlcmxhcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNtYWxsZXN0IGNoYW5nZSBvdGhlciB0aGFuIHplcm9cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBhY2N1bS54O1xuICAgICAgICAgICAgICAgIHZhciB5ID0gYWNjdW0ueTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYWNjdW0ueCkgPCBNYXRoLmFicyhuZXh0LngpKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXh0Lng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhY2N1bS55KSA8IE1hdGguYWJzKG5leHQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IG5leHQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5WZWN0b3IoeCwgeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgIHB1YmxpYyBjb2xsaWRlc0FjdG9yKGFjdG9yOiBBY3Rvcik6IGJvb2xlYW57XG4gICAgICAgICAgIFxuICAgICAgICAgICB2YXIgcG9pbnRzOiBQb2ludFtdID0gW107XG4gICAgICAgICAgIHZhciB3aWR0aCA9IGFjdG9yLnggKyBhY3Rvci5nZXRXaWR0aCgpO1xuICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYWN0b3IueSArIGFjdG9yLmdldEhlaWdodCgpO1xuICAgICAgICAgICBmb3IodmFyIHggPSBhY3Rvci54OyB4IDw9IHdpZHRoOyB4ICs9IE1hdGgubWluKGFjdG9yLmdldFdpZHRoKCkvMix0aGlzLmNlbGxXaWR0aC8yKSl7XG4gICAgICAgICAgICAgIGZvcih2YXIgeSA9IGFjdG9yLnk7IHkgPD0gaGVpZ2h0OyB5ICs9IE1hdGgubWluKGFjdG9yLmdldEhlaWdodCgpLzIsIHRoaXMuY2VsbEhlaWdodC8yKSl7XG4gICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBQb2ludCh4LHkpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgIHZhciByZXN1bHQgPSBwb2ludHMuc29tZSgocCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlc1BvaW50KHAueCwgcC55KTtcbiAgICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICBcbiAgICAgICAgfSovXG4gICAgICAgIC8qXG4gICAgICAgIHB1YmxpYyBjb2xsaWRlc1BvaW50KHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbntcbiAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHgvdGhpcy5jZWxsV2lkdGgpOy8vIC0gTWF0aC5mbG9vcih0aGlzLngvdGhpcy5jZWxsV2lkdGgpO1xuICAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IoeS90aGlzLmNlbGxIZWlnaHQpO1xuICBcbiAgXG4gICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsKHgsIHkpO1xuICAgICAgICAgICBpZih4ID49IDAgJiYgeSA+PSAwICYmIHggPCB0aGlzLmNvbHMgJiYgeSA8IHRoaXMucm93cyAmJiBjZWxsKXtcbiAgICAgICAgICAgICAgaWYoY2VsbC5zb2xpZCl7XG4gICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGluZ1ggPSB4O1xuICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRpbmdZID0geTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY2VsbC5zb2xpZDtcbiAgICAgICAgICAgfVxuICBcbiAgXG4gIFxuICAgICAgICAgICBcbiAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9Ki9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNlbGwgYnkgaW5kZXggKHJvdyBtYWpvciBvcmRlcilcbiAgICAgICAgICogQG1ldGhvZCBnZXRDZWxsQnlJbmRleFxuICAgICAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn1cbiAgICAgICAgICogQHJldHVybnMgQ2VsbFxuICAgICAgICAgKi9cbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUuZ2V0Q2VsbEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2VsbCBieSBpdCdzIHggYW5kIHkgY29vcmRpbmF0ZXNcbiAgICAgICAgICogQG1ldGhvZCBnZXRDZWxsXG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9XG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9XG4gICAgICAgICAqIEByZXR1cm5zIENlbGxcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmdldENlbGwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPj0gdGhpcy5jb2xzIHx8IHkgPj0gdGhpcy5yb3dzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3ggKyB5ICogdGhpcy5jb2xzXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNlbGwgYnkgdGVzdGluZyBhIHBvaW50IGluIGdsb2JhbCBjb29yZGluYXRlcyxcbiAgICAgICAgICogcmV0dXJucyBudWxsIGlmIG5vIGNlbGwgd2FzIGZvdW5kLlxuICAgICAgICAgKiBAbWV0aG9kIGdldENlbGxCeVBvaW50XG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9XG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9XG4gICAgICAgICAqIEByZXR1cm5zIENlbGxcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmdldENlbGxCeVBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcigoeCAtIHRoaXMueCkgLyB0aGlzLmNlbGxXaWR0aCk7IC8vIC0gTWF0aC5mbG9vcih0aGlzLngvdGhpcy5jZWxsV2lkdGgpO1xuICAgICAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKCh5IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCk7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCh4LCB5KTtcbiAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeSA+PSAwICYmIHggPCB0aGlzLmNvbHMgJiYgeSA8IHRoaXMucm93cyAmJiBjZWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciB3b3JsZENvb3Jkc1VwcGVyTGVmdCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KDAsIDApKTtcbiAgICAgICAgICAgIHZhciB3b3JsZENvb3Jkc0xvd2VyUmlnaHQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBleC5Qb2ludChlbmdpbmUud2lkdGgsIGVuZ2luZS5oZWlnaHQpKTtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcih3b3JsZENvb3Jkc1VwcGVyTGVmdC54IC8gdGhpcy5jZWxsV2lkdGgpIC0gMiwgMCk7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllTdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzVXBwZXJMZWZ0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSAtIDIsIDApO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5YRW5kID0gTWF0aC5tYXgoTWF0aC5mbG9vcih3b3JsZENvb3Jkc0xvd2VyUmlnaHQueCAvIHRoaXMuY2VsbFdpZHRoKSArIDIsIDApO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5ZRW5kID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNMb3dlclJpZ2h0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSArIDIsIDApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgdGhlIGNvbGxpc2lvbiBtYXAgdG8gdGhlIHNjcmVlbi4gQ2FsbGVkIGJ5IHRoZSBTY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSB0aGlzLl9vblNjcmVlblhTdGFydDsgeCA8IE1hdGgubWluKHRoaXMuX29uU2NyZWVuWEVuZCwgdGhpcy5jb2xzKTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IHRoaXMuX29uU2NyZWVuWVN0YXJ0OyB5IDwgTWF0aC5taW4odGhpcy5fb25TY3JlZW5ZRW5kLCB0aGlzLnJvd3MpOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDZWxsKHgsIHkpLnNwcml0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5zcHJpdGVJZCA+IC0xO1xuICAgICAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNzID0gX3RoaXMuX3Nwcml0ZVNoZWV0c1t0cy5zcHJpdGVTaGVldEtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gc3MuZ2V0U3ByaXRlKHRzLnNwcml0ZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ByaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5kcmF3KGN0eCwgeCAqIF90aGlzLmNlbGxXaWR0aCwgeSAqIF90aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJTcHJpdGUgZG9lcyBub3QgZXhpc3QgZm9yIGlkXCIsIHRzLnNwcml0ZUlkLCBcImluIHNwcml0ZSBzaGVldFwiLCB0cy5zcHJpdGVTaGVldEtleSwgc3ByaXRlLCBzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJTcHJpdGUgc2hlZXRcIiwgdHMuc3ByaXRlU2hlZXRLZXksIFwiZG9lcyBub3QgZXhpc3RcIiwgc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgYWxsIHRoZSBjb2xsaXNpb24gbWFwJ3MgZGVidWcgaW5mby4gQ2FsbGVkIGJ5IHRoZSBTY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY29scyAqIHRoaXMuY2VsbFdpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMucm93cyAqIHRoaXMuY2VsbEhlaWdodDtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBleC5Db2xvci5SZWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5jb2xzICsgMTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy54ICsgeCAqIHRoaXMuY2VsbFdpZHRoLCB0aGlzLnkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy54ICsgeCAqIHRoaXMuY2VsbFdpZHRoLCB0aGlzLnkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5yb3dzICsgMTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy54LCB0aGlzLnkgKyB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMueCArIHdpZHRoLCB0aGlzLnkgKyB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc29saWQgPSBleC5Db2xvci5SZWQuY2xvbmUoKTtcbiAgICAgICAgICAgIHNvbGlkLmEgPSAuMztcbiAgICAgICAgICAgIHRoaXMuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbC5zb2xpZDtcbiAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc29saWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2VsbC54LCBjZWxsLnksIGNlbGwud2lkdGgsIGNlbGwuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxpZGluZ1kgPiAtMSAmJiB0aGlzLl9jb2xsaWRpbmdYID4gLTEpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZXguQ29sb3IuQ3lhbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB0aGlzLl9jb2xsaWRpbmdYICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSArIHRoaXMuX2NvbGxpZGluZ1kgKiB0aGlzLmNlbGxIZWlnaHQsIHRoaXMuY2VsbFdpZHRoLCB0aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRpbGVNYXA7XG4gICAgfSkoKTtcbiAgICBleC5UaWxlTWFwID0gVGlsZU1hcDtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQWxnZWJyYS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgKGZ1bmN0aW9uIChDb2xsaXNpb25TdHJhdGVneSkge1xuICAgICAgICBDb2xsaXNpb25TdHJhdGVneVtDb2xsaXNpb25TdHJhdGVneVtcIk5haXZlXCJdID0gMF0gPSBcIk5haXZlXCI7XG4gICAgICAgIENvbGxpc2lvblN0cmF0ZWd5W0NvbGxpc2lvblN0cmF0ZWd5W1wiRHluYW1pY0FBQkJUcmVlXCJdID0gMV0gPSBcIkR5bmFtaWNBQUJCVHJlZVwiO1xuICAgICAgICBDb2xsaXNpb25TdHJhdGVneVtDb2xsaXNpb25TdHJhdGVneVtcIlNlcGFyYXRpbmdBeGlzXCJdID0gMl0gPSBcIlNlcGFyYXRpbmdBeGlzXCI7XG4gICAgfSkoZXguQ29sbGlzaW9uU3RyYXRlZ3kgfHwgKGV4LkNvbGxpc2lvblN0cmF0ZWd5ID0ge30pKTtcbiAgICB2YXIgQ29sbGlzaW9uU3RyYXRlZ3kgPSBleC5Db2xsaXNpb25TdHJhdGVneTtcbiAgICAvKipcbiAgICAgKiBBeGlzIEFsaWduZWQgY29sbGlzaW9uIHByaW1pdGl2ZSBmb3IgRXhjYWxpYnVyLlxuICAgICAqIEBjbGFzcyBCb3VuZGluZ0JveFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBsZWZ0IHtudW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBlZGdlXG4gICAgICogQHBhcmFtIHRvcCB7bnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBlZGdlXG4gICAgICogQHBhcmFtIHJpZ2h0IHtudW1iZXJ9IHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgZWRnZVxuICAgICAqIEBwYXJhbSBib3R0b20ge251bWJlcn0geSBjb29yZGluYXRlIG9mIHRoZSBib3R0b20gZWRnZVxuICAgICAqL1xuICAgIHZhciBCb3VuZGluZ0JveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJvdW5kaW5nQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09IHZvaWQgMCkgeyBsZWZ0ID0gMDsgfVxuICAgICAgICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7IHRvcCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gMDsgfVxuICAgICAgICAgICAgaWYgKGJvdHRvbSA9PT0gdm9pZCAwKSB7IGJvdHRvbSA9IDA7IH1cbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAgICAgICogQG1ldGhvZCBnZXRXaWR0aFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgICAgICAgKiBAbWV0aG9kIGdldEhlaWdodFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b20gLSB0aGlzLnRvcDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBlcmltZXRlciBvZiB0aGUgYm91bmRpbmcgYm94XG4gICAgICAgICAqIEBtZXRob2QgZ2V0UGVyaW1ldGVyXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFBlcmltZXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3eCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciB3eSA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICByZXR1cm4gMiAqICh3eCArIHd5KTtcbiAgICAgICAgfTtcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIGV4LlBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmxlZnQgPD0gdmFsLnggJiYgdGhpcy50b3AgPD0gdmFsLnkgJiYgdGhpcy5ib3R0b20gPj0gdmFsLnkgJiYgdGhpcy5yaWdodCA+PSB2YWwueCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgPCB2YWwubGVmdCAmJiB0aGlzLnRvcCA8IHZhbC50b3AgJiYgdmFsLmJvdHRvbSA8IHRoaXMuYm90dG9tICYmIHZhbC5yaWdodCA8IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbWJpbmVzIHRoaXMgYm91bmRpbmcgYm94IGFuZCBhbm90aGVyIHRvZ2V0aGVyIHJldHVybmluZyBhIG5ldyBib3VuZGluZyBib3hcbiAgICAgICAgICogQG1ldGhvZCBjb21iaW5lXG4gICAgICAgICAqIEBwYXJhbSBvdGhlciB7Qm91bmRpbmdCb3h9IFRoZSBib3VuZGluZyBib3ggdG8gY29tYmluZVxuICAgICAgICAgKiBAcmV0dXJucyBCb3VuZGluZ0JveFxuICAgICAgICAgKi9cbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBjb21wb3NpdGVCQiA9IG5ldyBCb3VuZGluZ0JveChNYXRoLm1pbih0aGlzLmxlZnQsIG90aGVyLmxlZnQpLCBNYXRoLm1pbih0aGlzLnRvcCwgb3RoZXIudG9wKSwgTWF0aC5tYXgodGhpcy5yaWdodCwgb3RoZXIucmlnaHQpLCBNYXRoLm1heCh0aGlzLmJvdHRvbSwgb3RoZXIuYm90dG9tKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9zaXRlQkI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IHdldGhlciB0aGlzIGJvdW5kaW5nIGJveCBjb2xsaWRlcyB3aXRoIGFub3RoZXIgcmV0dXJuaW5nLFxuICAgICAgICAgKiB0aGUgaW50ZXJzZWN0aW9uIHZlY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc292bGUgdGhlIGNvbGxpc2lvbi4gSWYgdGhlcmVcbiAgICAgICAgICogaXMgbm8gY29sbGlzaW9uIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgICAgICogQHBhcmFtIGNvbGxpZGFibGUge0lDb2xsaWRhYmxlfSBPdGhlciBjb2xsaWRhYmxlIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoY29sbGlkYWJsZSkge1xuICAgICAgICAgICAgaWYgKGNvbGxpZGFibGUgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNvbGxpZGFibGU7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsQm91bmRpbmdCb3ggPSB0aGlzLmNvbWJpbmUob3RoZXIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0b3RhbCBib3VuZGluZyBib3ggaXMgbGVzcyB0aGFuIHRoZSBzdW0gb2YgdGhlIDIgYm91bmRzIHRoZW4gdGhlcmUgaXMgY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsQm91bmRpbmdCb3guZ2V0V2lkdGgoKSA8IG90aGVyLmdldFdpZHRoKCkgKyB0aGlzLmdldFdpZHRoKCkgJiYgdG90YWxCb3VuZGluZ0JveC5nZXRIZWlnaHQoKSA8IG90aGVyLmdldEhlaWdodCgpICsgdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPj0gb3RoZXIubGVmdCAmJiB0aGlzLnJpZ2h0IDw9IG90aGVyLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLmxlZnQgLSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5yaWdodCAtIHRoaXMubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AgPD0gb3RoZXIuYm90dG9tICYmIHRoaXMudG9wID49IG90aGVyLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci5ib3R0b20gLSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gb3RoZXIudG9wIC0gdGhpcy5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG92ZXJsYXBYKSA8IE1hdGguYWJzKG92ZXJsYXBZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5WZWN0b3Iob3ZlcmxhcFgsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5WZWN0b3IoMCwgb3ZlcmxhcFkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94O1xuICAgIH0pKCk7XG4gICAgZXguQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcbiAgICB2YXIgU0FUQm91bmRpbmdCb3ggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTQVRCb3VuZGluZ0JveChwb2ludHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudG9WZWN0b3IoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFNpZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBleC5MaW5lKHRoaXMuX3BvaW50c1tpXSwgdGhpcy5fcG9pbnRzWyhpICsgMSkgJSBsZW5dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICAgIH07XG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGF4ZXMucHVzaCh0aGlzLl9wb2ludHNbaV0ubWludXModGhpcy5fcG9pbnRzWyhpICsgMSkgJSBsZW5dKS5ub3JtYWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXhlcztcbiAgICAgICAgfTtcbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIHNjYWxhcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHNjYWxhcnMucHVzaCh0aGlzLl9wb2ludHNbaV0uZG90KGF4aXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguUHJvamVjdGlvbihNYXRoLm1pbi5hcHBseShNYXRoLCBzY2FsYXJzKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgc2NhbGFycykpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCB3aWR0aCBvZiB0aGUgYm91bmRpbmcgYm94LCBieSBnZW5lcmF0aW5nIGFuIGF4aXMgYWxpZ25lZCBib3ggYXJvdW5kIHRoZSBjdXJyZW50XG4gICAgICAgICAqIEBtZXRob2QgZ2V0V2lkdGhcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBwLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oYWNjdW0sIHAueCk7XG4gICAgICAgICAgICB9LCBJbmZpbml0eSk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgcCwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGFjY3VtLCBwLngpO1xuICAgICAgICAgICAgfSwgLUluZmluaXR5KTtcbiAgICAgICAgICAgIHJldHVybiByaWdodCAtIGxlZnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94LCBieSBnZW5lcmF0aW5nIGFuIGF4aXMgYWxpZ25lZCBib3ggYXJvdW5kIHRoZSBjdXJyZW50XG4gICAgICAgICAqIEBtZXRob2QgZ2V0SGVpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgcCwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGFjY3VtLCBwLnkpO1xuICAgICAgICAgICAgfSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBwLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoYWNjdW0sIHAueSk7XG4gICAgICAgICAgICB9LCAtSW5maW5pdHkpO1xuICAgICAgICAgICAgcmV0dXJuIHRvcCAtIGJvdHRvbTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3RzIHdldGhlciBhIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGJvdW5kaW5nIGJveCwgdXNpbmcgdGhlIFBJUCBhbGdvcml0aG1cbiAgICAgICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb2ludF9pbl9wb2x5Z29uXG4gICAgICAgICAqIEBtZXRob2QgY29udGFpbnNcbiAgICAgICAgICogQHBhcmFtIHAge1BvaW50fSBUaGUgcG9pbnQgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgLy8gQWx3YXlzIGNhc3QgdG8gdGhlIHJpZ2h0LCBhcyBsb25nIGFzIHdlIGNhc3QgaW4gYSBjb25zaXRlbnQgZml4ZWQgZGlyZWN0aW9uIHdlXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGZpbmVcbiAgICAgICAgICAgIHZhciB0ZXN0UmF5ID0gbmV3IGV4LlJheShwLCBuZXcgZXguVmVjdG9yKDEsIDApKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RDb3VudCA9IHRoaXMuZ2V0U2lkZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBzaWRlLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFJheS5pbnRlcnNlY3Qoc2lkZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RDb3VudCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGNvbGxpZGFibGUpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaWRhYmxlIGluc3RhbmNlb2YgU0FUQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjb2xsaWRhYmxlO1xuICAgICAgICAgICAgICAgIHZhciBheGVzID0gdGhpcy5nZXRBeGVzKCk7XG4gICAgICAgICAgICAgICAgYXhlcyA9IG90aGVyLmdldEF4ZXMoKS5jb25jYXQoYXhlcyk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbk92ZXJsYXAgPSA5OTk5OTtcbiAgICAgICAgICAgICAgICB2YXIgbWluQXhpcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9qMSA9IHRoaXMucHJvamVjdChheGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2oyID0gb3RoZXIucHJvamVjdChheGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBwcm9qMS5nZXRPdmVybGFwKHByb2oyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPD0gbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkF4aXMgPSBheGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtaW5BeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5BeGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1pbk92ZXJsYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3VwcGxpZWQgcG9pbnRzIGFuZCBjb250cnVjdCBhICdwb2x5Z29uJ1xuICAgICAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSB0aGlzLl9wb2ludHNbMF07XG4gICAgICAgICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZXguQ29sb3IuQmx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU0FUQm91bmRpbmdCb3g7XG4gICAgfSkoKTtcbiAgICBleC5TQVRCb3VuZGluZ0JveCA9IFNBVEJvdW5kaW5nQm94O1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudHMudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEV4Y2FsaWJ1ciBiYXNlIGNsYXNzXG4gICAgICogQGNsYXNzIENsYXNzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIENsYXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2xhc3MoKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBleC5FdmVudERpc3BhdGNoZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxuICAgICAgICAgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuc3Vic2NyaWJlKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLiBJZiBvbmx5IHRoZSBldmVudE5hbWUgaXMgc3BlY2lmaWVkXG4gICAgICAgICAqIGl0IHdpbGwgcmVtb3ZlIGFsbCBoYW5kbGVycyByZWdpc3RlcmVkIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50LiBJZiB0aGUgZXZlbnROYW1lXG4gICAgICAgICAqIGFuZCB0aGUgaGFuZGxlciBpbnN0YW5jZSBhcmUgc3BlY2lmaWVkIGp1c3QgdGhhdCBoYW5kbGVyIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gW2hhbmRsZXI9dW5kZWZpbmVkXSB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIudW5zdWJzY3JpYmUoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBcImFkZEV2ZW50TGlzdGVuZXJcIi4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxuICAgICAgICAgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cbiAgICAgICAgICogQG1ldGhvZCBvblxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIge2V2ZW50PT52b2lkfSBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBDbGFzcy5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5zdWJzY3JpYmUoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIi4gSWYgb25seSB0aGUgZXZlbnROYW1lIGlzIHNwZWNpZmllZFxuICAgICAgICAgKiBpdCB3aWxsIHJlbW92ZSBhbGwgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgdGhhdCBzcGVjaWZpYyBldmVudC4gSWYgdGhlIGV2ZW50TmFtZVxuICAgICAgICAgKiBhbmQgdGhlIGhhbmRsZXIgaW5zdGFuY2UgYXJlIHNwZWNpZmllZCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gW2hhbmRsZXI9dW5kZWZpbmVkXSB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci51bnN1YnNjcmliZShldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogWW91IG1heSB3aXNoIHRvIGV4dGVuZCBuYXRpdmUgRXhjYWxpYnVyIGZ1bmN0aW9uYWxpdHkuIEFueSBtZXRob2Qgb25cbiAgICAgICAgICogYWN0b3IgbWF5IGJlIGV4dGVuZGVkIHRvIHN1cHBvcnQgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXkuIEluIHRoZVxuICAgICAgICAgKiBleGFtcGxlIGJlbG93IHdlIGNyZWF0ZSBhIG5ldyB0eXBlIGNhbGxlZCBcIk15QWN0b3JcIlxuICAgICAgICAgKiA8YnIvPjxiPkV4YW1wbGU8L2I+PHByZT52YXIgTXlBY3RvciA9IEFjdG9yLmV4dGVuZCh7XG4gICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5uZXdwcm9wID0gJ3NvbWV0aGluZyc7XG4gICAgICAgIEFjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgIH0sXG4gICAgIHVwZGF0ZSA6IGZ1bmN0aW9uKGVuZ2luZSwgZGVsdGEpe1xuICAgICAgICAvLyBJbXBsZW1lbnQgY3VzdG9tIHVwZGF0ZVxuICBcbiAgICAgICAgICAgLy8gQ2FsbCBzdXBlciBjb25zdHJ1Y3RvciB1cGRhdGVcbiAgICAgICAgICAgQWN0b3IucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNvbWV0aGluZyBjb29sIVwiKTtcbiAgICAgfVxuICB9KTtcbiAgdmFyIG15QWN0b3IgPSBuZXcgTXlBY3RvcigxMDAsIDEwMCwgMTAwLCAxMDAsIENvbG9yLkF6dXJlKTs8L3ByZT5cbiAgICAgICAgICogQG1ldGhvZCBleHRlbmRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gbWV0aG9kcyB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgbWV0aG9kcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbWV0aG9kcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzaW5nIGNvbnN0cnVjdG9yIGFsbG93cyBKUyB0byBsYXppbHkgaW5zdGFudGlhdGUgc3VwZXIgY2xhc3Nlc1xuICAgICAgICAgICAgdmFyIFN1cGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTdXBlci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cGVyO1xuICAgICAgICAgICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZVtwcm9wXSA9IG1ldGhvZHNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1YmNsYXNzZXMgZXh0ZW5kYWJsZVxuICAgICAgICAgICAgY2hpbGQuZXh0ZW5kID0gQ2xhc3MuZXh0ZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2xhc3M7XG4gICAgfSkoKTtcbiAgICBleC5DbGFzcyA9IENsYXNzO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgVGltZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEV4Y2FsaWJ1ciB0aW1lciBob29rcyBpbnRvIHRoZSBpbnRlcm5hbCB0aW1lciBhbmQgZmlyZXMgY2FsbGJhY2tzLCBhZnRlciBhIGNlcnRhaW4gaW50ZXJ2YWwsIG9wdGlvbmFsbHkgcmVwZWF0aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgVGltZXJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB7Y2FsbGJhY2t9IFRoZSBjYWxsYmFjayB0byBiZSBmaXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgaXMgY29tcGxldGUuXG4gICAgICAgICAqIEBwYXJhbSBbcmVwZWF0cz1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoaXMgY2FsbCBiYWNrIHNob3VsZCBiZSBmaXJlZCBvbmx5IG9uY2UsIG9yIHJlcGVhdCBhZnRlciBldmVyeSBpbnRlcnZhbCBhcyBjb21wbGV0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBUaW1lcihmY24sIGludGVydmFsLCByZXBlYXRzKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAxMDtcbiAgICAgICAgICAgIHRoaXMuZmNuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWVBbGl2ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBUaW1lci5pZCsrO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsIHx8IHRoaXMuaW50ZXJ2YWw7XG4gICAgICAgICAgICB0aGlzLmZjbiA9IGZjbiB8fCB0aGlzLmZjbjtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IHJlcGVhdHMgfHwgdGhpcy5yZXBlYXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB0aW1lciBhZnRlciBhIGNlcnRhaW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBlbmdpbmUuXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBOdW1iZXIgb2YgZWxhcHNlZCBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgVGltZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lQWxpdmUgKz0gZGVsdGE7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxhcHNlZFRpbWUgPiB0aGlzLmludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mY24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUaW1lci5wcm90b3R5cGUuZ2V0VGltZVJ1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxUaW1lQWxpdmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWxzIHRoZSB0aW1lciwgcHJldmVudGluZyBhbnkgZnVydGhlciBleGVjdXRpb25zLlxuICAgICAgICAgKiBAbWV0aG9kIGNhbmNlbFxuICAgICAgICAgKi9cbiAgICAgICAgVGltZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5jYW5jZWxUaW1lcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVGltZXIuaWQgPSAwO1xuICAgICAgICByZXR1cm4gVGltZXI7XG4gICAgfSkoKTtcbiAgICBleC5UaW1lciA9IFRpbWVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9BY3Rvci50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTaWRlLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIklDb2xsaXNpb25SZXNvbHZlci50c1wiLz4gXG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOYWl2ZUNvbGxpc2lvblJlc29sdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgLy8gcGFzc1xuICAgICAgICB9O1xuICAgICAgICBOYWl2ZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodGFydGV0KSB7XG4gICAgICAgICAgICAvLyBwYXNzXG4gICAgICAgIH07XG4gICAgICAgIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIHBvdGVudGlhbCBjb2xsaWRlcnMsIGV4Y2x1ZGUga2lsbGVkLCBwcmV2ZW50ZWQsIGFuZCBzZWxmXG4gICAgICAgICAgICB2YXIgcG90ZW50aWFsQ29sbGlkZXJzID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdGhlci5pc0tpbGxlZCgpICYmIG90aGVyLmNvbGxpc2lvblR5cGUgIT09IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGFjdG9yMTtcbiAgICAgICAgICAgIHZhciBhY3RvcjI7XG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gcG90ZW50aWFsQ29sbGlkZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgIGFjdG9yMSA9IHBvdGVudGlhbENvbGxpZGVyc1tqXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaiArIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IyID0gcG90ZW50aWFsQ29sbGlkZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluaW11bVRyYW5zbGF0aW9uVmVjdG9yID0gYWN0b3IxLmNvbGxpZGVzKGFjdG9yMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gYWN0b3IxLmdldFNpZGVGcm9tSW50ZXJzZWN0KG1pbmltdW1UcmFuc2xhdGlvblZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpciA9IG5ldyBleC5Db2xsaXNpb25QYWlyKGFjdG9yMSwgYWN0b3IyLCBtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25QYWlycy5zb21lKGZ1bmN0aW9uIChjcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcC5lcXVhbHMoY29sbGlzaW9uUGFpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvblBhaXJzLnB1c2goY29sbGlzaW9uUGFpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsaXNpb25QYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmV2YWx1YXRlKCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvblBhaXJzO1xuICAgICAgICB9O1xuICAgICAgICBOYWl2ZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgICAgIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOYWl2ZUNvbGxpc2lvblJlc29sdmVyO1xuICAgIH0pKCk7XG4gICAgZXguTmFpdmVDb2xsaXNpb25SZXNvbHZlciA9IE5haXZlQ29sbGlzaW9uUmVzb2x2ZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkJvdW5kaW5nQm94LnRzXCIvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBUcmVlTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyZWVOb2RlKHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy5hY3RvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyBleC5Cb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmxlZnQgJiYgIXRoaXMucmlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJlZU5vZGU7XG4gICAgfSkoKTtcbiAgICBleC5UcmVlTm9kZSA9IFRyZWVOb2RlO1xuICAgIHZhciBEeW5hbWljVHJlZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIER5bmFtaWNUcmVlKCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBub2RlcyBpbiB0aGUgdHJlZSwgbWFrZSB0aGlzIHRoZSByb290IGxlYWZcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBsZWFmO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlYXJjaCB0aGUgdHJlZSBmb3IgYSBub2RlIHRoYXQgaXMgbm90IGEgbGVhZiBhbmQgZmluZCB0aGUgYmVzdCBwbGFjZSB0byBpbnNlcnRcbiAgICAgICAgICAgIHZhciBsZWFmQUFCQiA9IGxlYWYuYm91bmRzO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJyZW50Um9vdC5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gY3VycmVudFJvb3QubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBjdXJyZW50Um9vdC5yaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgYXJlYSA9IGN1cnJlbnRSb290LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRBQUJCID0gY3VycmVudFJvb3QuYm91bmRzLmNvbWJpbmUobGVhZkFBQkIpO1xuICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZEFyZWEgPSBjb21iaW5lZEFBQkIuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNvc3QgaGV1cmlzdGljIGZvciBjcmVhdGluZyBhIG5ldyBwYXJlbnQgYW5kIGxlYWZcbiAgICAgICAgICAgICAgICB2YXIgY29zdCA9IDIgKiBjb21iaW5lZEFyZWE7XG4gICAgICAgICAgICAgICAgLy8gTWluaW11bSBjb3N0IG9mIHB1c2hpbmcgdGhlIGxlYWYgZG93biB0aGUgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBpbmhlcml0YW5jZUNvc3QgPSAyICogKGNvbWJpbmVkQXJlYSAtIGFyZWEpO1xuICAgICAgICAgICAgICAgIC8vIENvc3Qgb2YgZGVzY2VuZGluZ1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q29zdCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRDb21iaW5lZCA9IGxlYWZBQUJCLmNvbWJpbmUobGVmdC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdBcmVhO1xuICAgICAgICAgICAgICAgIHZhciBvbGRBcmVhO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0LmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDb3N0ID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJlYSA9IGxlZnQuYm91bmRzLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICBuZXdBcmVhID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q29zdCA9IChuZXdBcmVhIC0gb2xkQXJlYSkgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByaWdodENvc3QgPSAwO1xuICAgICAgICAgICAgICAgIHZhciByaWdodENvbWJpbmVkID0gbGVhZkFBQkIuY29tYmluZShyaWdodC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodENvc3QgPSByaWdodENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQXJlYSA9IHJpZ2h0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJlYSA9IHJpZ2h0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q29zdCA9IChuZXdBcmVhIC0gb2xkQXJlYSkgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvc3QgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgIGlmIChjb3N0IDwgbGVmdENvc3QgJiYgY29zdCA8IHJpZ2h0Q29zdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRGVzY2VuZCB0byB0aGUgZGVwdGhzXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRDb3N0IDwgcmlnaHRDb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb290ID0gbGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb290ID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgcGFyZW50IG5vZGUgYW5kIGluc2VydCBpbnRvIHRoZSB0cmVlXG4gICAgICAgICAgICB2YXIgb2xkUGFyZW50ID0gY3VycmVudFJvb3QucGFyZW50O1xuICAgICAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ldyBUcmVlTm9kZShvbGRQYXJlbnQpO1xuICAgICAgICAgICAgbmV3UGFyZW50LmJvdW5kcyA9IGxlYWZBQUJCLmNvbWJpbmUoY3VycmVudFJvb3QuYm91bmRzKTtcbiAgICAgICAgICAgIG5ld1BhcmVudC5oZWlnaHQgPSBjdXJyZW50Um9vdC5oZWlnaHQgKyAxO1xuICAgICAgICAgICAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIG5vZGUgd2FzIG5vdCB0aGUgcm9vdFxuICAgICAgICAgICAgICAgIGlmIChvbGRQYXJlbnQubGVmdCA9PT0gY3VycmVudFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50LmxlZnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQucmlnaHQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um9vdC5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyBub2RlIHdhcyB0aGUgcm9vdFxuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um9vdC5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FsayB1cCB0aGUgdHJlZSBmaXhpbmcgaGVpZ2h0cyBhbmQgQUFCQnNcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGxlYWYucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLmJhbGFuY2UoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgb2YgY3VycmVudCBsZWFmIGNhbm5vdCBoYXZlIGEgbnVsbCBsZWZ0IGNoaWxkXCIgKyBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IG9mIGN1cnJlbnQgbGVhZiBjYW5ub3QgaGF2ZSBhIG51bGwgcmlnaHQgY2hpbGRcIiArIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGN1cnJlbnROb2RlLmxlZnQuaGVpZ2h0LCBjdXJyZW50Tm9kZS5yaWdodC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcyA9IGN1cnJlbnROb2RlLmxlZnQuYm91bmRzLmNvbWJpbmUoY3VycmVudE5vZGUucmlnaHQuYm91bmRzKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgICAgICBpZiAobGVhZiA9PT0gdGhpcy5yb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbGVhZi5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgZ3JhbmRQYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgdmFyIHNpYmxpbmc7XG4gICAgICAgICAgICBpZiAocGFyZW50LmxlZnQgPT09IGxlYWYpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50LmxlZnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5sZWZ0ID0gc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LnJpZ2h0ID0gc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBncmFuZFBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBncmFuZFBhcmVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLmJhbGFuY2UoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMgPSBjdXJyZW50Tm9kZS5sZWZ0LmJvdW5kcy5jb21iaW5lKGN1cnJlbnROb2RlLnJpZ2h0LmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChjdXJyZW50Tm9kZS5sZWZ0LmhlaWdodCwgY3VycmVudE5vZGUucmlnaHQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gc2libGluZztcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5yZWdpc3RlckFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBUcmVlTm9kZSgpO1xuICAgICAgICAgICAgbm9kZS5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgbm9kZS5ib3VuZHMgPSBhY3Rvci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLmxlZnQgLT0gMjtcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLnRvcCAtPSAyO1xuICAgICAgICAgICAgbm9kZS5ib3VuZHMucmlnaHQgKz0gMjtcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLmJvdHRvbSArPSAyO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1thY3Rvci5pZF0gPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQobm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS51cGRhdGVBY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2FjdG9yLmlkXTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgYiA9IGFjdG9yLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgaWYgKG5vZGUuYm91bmRzLmNvbnRhaW5zKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICBiLmxlZnQgLT0gNTtcbiAgICAgICAgICAgIGIudG9wIC09IDU7XG4gICAgICAgICAgICBiLnJpZ2h0ICs9IDU7XG4gICAgICAgICAgICBiLmJvdHRvbSArPSA1O1xuICAgICAgICAgICAgdmFyIG11bHRkeCA9IGFjdG9yLmR4ICogMjtcbiAgICAgICAgICAgIHZhciBtdWx0ZHkgPSBhY3Rvci5keSAqIDI7XG4gICAgICAgICAgICBpZiAobXVsdGR4IDwgMCkge1xuICAgICAgICAgICAgICAgIGIubGVmdCArPSBtdWx0ZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiLnJpZ2h0ICs9IG11bHRkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdWx0ZHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgYi50b3AgKz0gbXVsdGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYi5ib3R0b20gKz0gbXVsdGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5ib3VuZHMgPSBiO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJlbW92ZUFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbYWN0b3IuaWRdO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1thY3Rvci5pZF0gPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbYWN0b3IuaWRdO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuYmFsYW5jZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBiYWxhbmNlIGF0IG51bGwgbm9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZigpIHx8IG5vZGUuaGVpZ2h0IDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGEgPSBub2RlO1xuICAgICAgICAgICAgdmFyIGIgPSBsZWZ0O1xuICAgICAgICAgICAgdmFyIGMgPSByaWdodDtcbiAgICAgICAgICAgIHZhciBkID0gbGVmdC5sZWZ0O1xuICAgICAgICAgICAgdmFyIGUgPSBsZWZ0LnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGYgPSByaWdodC5sZWZ0O1xuICAgICAgICAgICAgdmFyIGcgPSByaWdodC5yaWdodDtcbiAgICAgICAgICAgIHZhciBiYWxhbmNlID0gYy5oZWlnaHQgLSBiLmhlaWdodDtcbiAgICAgICAgICAgIC8vIFJvdGF0ZSBjIG5vZGUgdXBcbiAgICAgICAgICAgIGlmIChiYWxhbmNlID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFN3YXAgdGhlIHJpZ2h0IG5vZGUgd2l0aCBpdCdzIHBhcmVudFxuICAgICAgICAgICAgICAgIGMubGVmdCA9IGE7XG4gICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBhLnBhcmVudDtcbiAgICAgICAgICAgICAgICBhLnBhcmVudCA9IGM7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIG5vZGUncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byB0aGUgcmlnaHQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbWVnYSBjb25mdXNpbmdcbiAgICAgICAgICAgICAgICBpZiAoYy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMucGFyZW50LmxlZnQgPT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucGFyZW50LmxlZnQgPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQucmlnaHQgPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSb3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoZi5oZWlnaHQgPiBnLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjLnJpZ2h0ID0gZjtcbiAgICAgICAgICAgICAgICAgICAgYS5yaWdodCA9IGc7XG4gICAgICAgICAgICAgICAgICAgIGcucGFyZW50ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBiLmJvdW5kcy5jb21iaW5lKGcuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYy5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGYuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYi5oZWlnaHQsIGcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYy5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGYuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSBnO1xuICAgICAgICAgICAgICAgICAgICBhLnJpZ2h0ID0gZjtcbiAgICAgICAgICAgICAgICAgICAgZi5wYXJlbnQgPSBhO1xuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGIuYm91bmRzLmNvbWJpbmUoZi5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBjLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZy5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChiLmhlaWdodCwgZi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJvdGF0ZSBsZWZ0IG5vZGUgdXBcbiAgICAgICAgICAgIGlmIChiYWxhbmNlIDwgLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwXG4gICAgICAgICAgICAgICAgYi5sZWZ0ID0gYTtcbiAgICAgICAgICAgICAgICBiLnBhcmVudCA9IGEucGFyZW50O1xuICAgICAgICAgICAgICAgIGEucGFyZW50ID0gYjtcbiAgICAgICAgICAgICAgICAvLyBub2RlJ3Mgb2xkIHBhcmVudCBzaG91bGQgcG9pbnQgdG8gYlxuICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQubGVmdCA9PT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5wYXJlbnQubGVmdCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQucmlnaHQgIT09IGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvciByb3RhdGluZyBEeW5hbWljIFRyZWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucGFyZW50LnJpZ2h0ID0gYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcm90YXRlXG4gICAgICAgICAgICAgICAgaWYgKGQuaGVpZ2h0ID4gZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5yaWdodCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGEubGVmdCA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGUucGFyZW50ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBjLmJvdW5kcy5jb21iaW5lKGUuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYi5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGQuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYy5oZWlnaHQsIGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIucmlnaHQgPSBlO1xuICAgICAgICAgICAgICAgICAgICBhLmxlZnQgPSBkO1xuICAgICAgICAgICAgICAgICAgICBkLnBhcmVudCA9IGE7XG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYy5ib3VuZHMuY29tYmluZShkLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGIuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShlLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGMuaGVpZ2h0LCBkLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGIuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LmhlaWdodDtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGFjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZS5ib3VuZHMuY29sbGlkZXMoYm91bmRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkgJiYgY3VycmVudE5vZGUuYWN0b3IgIT09IGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChhY3RvciwgY3VycmVudE5vZGUuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpIHx8IGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGVscGVyKHRoaXMucm9vdCk7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5yYXlDYXN0ID0gZnVuY3Rpb24gKHJheSwgbWF4KSB7XG4gICAgICAgICAgICAvLyB0b2RvIGltcGxlbWVudFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjdXJyZW50Tm9kZV0uY29uY2F0KGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIodGhpcy5yb290KTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBkcmF3IGFsbCB0aGUgbm9kZXMgaW4gdGhlIER5bmFtaWMgVHJlZVxuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcy5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIoY3VycmVudE5vZGUubGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRHluYW1pY1RyZWU7XG4gICAgfSkoKTtcbiAgICBleC5EeW5hbWljVHJlZSA9IER5bmFtaWNUcmVlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJQ29sbGlzaW9uUmVzb2x2ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRHluYW1pY1RyZWUudHNcIi8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyKCkge1xuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUgPSBuZXcgZXguRHluYW1pY1RyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnJlZ2lzdGVyQWN0b3IodGFyZ2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucmVtb3ZlQWN0b3IodGFyZ2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgcG90ZW50aWFsIGNvbGxpZGVycywgZXhjbHVkZSBraWxsZWQsIHByZXZlbnRlZCwgYW5kIHNlbGZcbiAgICAgICAgICAgIHZhciBwb3RlbnRpYWxDb2xsaWRlcnMgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW90aGVyLmlzS2lsbGVkKCkgJiYgb3RoZXIuY29sbGlzaW9uVHlwZSAhPT0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYWN0b3I7XG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gcG90ZW50aWFsQ29sbGlkZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgIGFjdG9yID0gcG90ZW50aWFsQ29sbGlkZXJzW2pdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnF1ZXJ5KGFjdG9yLCBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLmNvbGxpc2lvblR5cGUgPT09IDAgLyogUHJldmVudENvbGxpc2lvbiAqLyB8fCBvdGhlci5pc0tpbGxlZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluaW11bVRyYW5zbGF0aW9uVmVjdG9yID0gYWN0b3IuY29sbGlkZXMob3RoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IGFjdG9yLmdldFNpZGVGcm9tSW50ZXJzZWN0KG1pbmltdW1UcmFuc2xhdGlvblZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uUGFpciA9IG5ldyBleC5Db2xsaXNpb25QYWlyKGFjdG9yLCBvdGhlciwgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sbGlzaW9uUGFpcnMuc29tZShmdW5jdGlvbiAoY3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3AuZXF1YWxzKGNvbGxpc2lvblBhaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25QYWlycy5wdXNoKGNvbGxpc2lvblBhaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sbGlzaW9uUGFpcnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5ldmFsdWF0ZSgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb25QYWlycztcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZCA9IDA7XG4gICAgICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnVwZGF0ZUFjdG9yKGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUuZGVidWdEcmF3KGN0eCwgZGVsdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlcjtcbiAgICB9KSgpO1xuICAgIGV4LkR5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIgPSBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb24gcGFpcnMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSBFeGNhbGlidXIgdG8gcmVzb2x2ZSBjb2xsaXNpb24gYmV0d2VlbiBhY3RvcnMuIFRoZVxuICAgICAqIFBhaXIgcHJldmVudHMgY29sbGlzaW9ucyBmcm9tIGJlaW5nIGV2YWx1YXRlZCBtb3JlIHRoYW4gb25lIHRpbWVcbiAgICAgKiBAY2xhc3MgQ29sbGlzaW9uUGFpclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBsZWZ0IHtBY3Rvcn0gVGhlIGZpcnN0IGFjdG9yIGluIHRoZSBjb2xsaXNpb24gcGFpclxuICAgICAqIEBwYXJhbSByaWdodCB7QWN0b3J9IFRoZSBzZWNvbmQgYWN0b3IgaW4gdGhlIGNvbGxpc2lvbiBwYWlyXG4gICAgICogQHBhcmFtIGludGVyc2VjdCB7VmVjdG9yfSBUaGUgbWluaW11bSB0cmFuc2xhdGlvbiB2ZWN0b3IgdG8gc2VwYXJhdGUgdGhlIGFjdG9ycyBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiB0aGUgbGVmdCBhY3RvclxuICAgICAqIEBwYXJhbSBzaWRlIHtTaWRlfSBUaGUgc2lkZSBvbiB3aGljaCB0aGUgY29sbGlzaW9uIG9jY3VyZWQgZnJvbSB0aGUgcGVyc3BlY3RpdmUgb2YgdGhlIGxlZnQgYWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ29sbGlzaW9uUGFpciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvblBhaXIobGVmdCwgcmlnaHQsIGludGVyc2VjdCwgc2lkZSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0ID0gaW50ZXJzZWN0O1xuICAgICAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIGNvbGxpc2lvbiBwYWlyIGFuZCBhbm90aGVyIGFyZSBlcXVpdmFsZW50LlxuICAgICAgICAgKiBAbWV0aG9kIGVxdWFsc1xuICAgICAgICAgKiBAcGFyYW0gY29sbGlzaW9uUGFpciB7Q29sbGlzaW9uUGFpcn1cbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uUGFpci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGNvbGxpc2lvblBhaXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29sbGlzaW9uUGFpci5sZWZ0ID09PSB0aGlzLmxlZnQgJiYgY29sbGlzaW9uUGFpci5yaWdodCA9PT0gdGhpcy5yaWdodCkgfHwgKGNvbGxpc2lvblBhaXIucmlnaHQgPT09IHRoaXMubGVmdCAmJiBjb2xsaXNpb25QYWlyLmxlZnQgPT09IHRoaXMucmlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZhbHVhdGVzIHRoZSBjb2xsaXNpb24gcGFpciwgcGVyZm9ybWluZyBjb2xsaXNpb24gcmVzb2x1dGlvbiBhbmQgZXZlbnQgcHVibGlzaGluZyBhcHByb3ByaWF0ZSB0byBlYWNoIGNvbGxpc2lvbiB0eXBlLlxuICAgICAgICAgKiBAbWV0aG9kIGV2YWx1YXRlXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25QYWlyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gZmlyZSBjb2xsaXNpb24gZXZlbnRzIG9uIGxlZnQgYW5kIHJpZ2h0IGFjdG9yXG4gICAgICAgICAgICAvLyB0b2RvIHJlc29sdmUgY29sbGlzaW9ucyAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXG4gICAgICAgICAgICB0aGlzLmxlZnQuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2NvbGxpc2lvbicsIG5ldyBleC5Db2xsaXNpb25FdmVudCh0aGlzLmxlZnQsIHRoaXMucmlnaHQsIHRoaXMuc2lkZSwgdGhpcy5pbnRlcnNlY3QpKTtcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2NvbGxpc2lvbicsIG5ldyBleC5Db2xsaXNpb25FdmVudCh0aGlzLnJpZ2h0LCB0aGlzLmxlZnQsIGV4LlV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHRoaXMuc2lkZSksIHRoaXMuaW50ZXJzZWN0LnNjYWxlKC0xLjApKSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYWN0b3IgaXMgYWN0aXZlIHB1c2ggdGhlIGFjdG9yIG91dCBpZiBpdHMgbm90IHBhc3NpdmVcbiAgICAgICAgICAgIHZhciBsZWZ0U2lkZSA9IHRoaXMuc2lkZTtcbiAgICAgICAgICAgIGlmICgodGhpcy5sZWZ0LmNvbGxpc2lvblR5cGUgPT09IDIgLyogQWN0aXZlICovIHx8IHRoaXMubGVmdC5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8pICYmIHRoaXMucmlnaHQuY29sbGlzaW9uVHlwZSAhPT0gMSAvKiBQYXNzaXZlICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnkgKz0gdGhpcy5pbnRlcnNlY3QueTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQueCArPSB0aGlzLmludGVyc2VjdC54O1xuICAgICAgICAgICAgICAgIC8vIE5haXZlIGVsYXN0aWMgYm91bmNlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdC5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRTaWRlID09PSAzIC8qIExlZnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5keCA9IE1hdGguYWJzKHRoaXMubGVmdC5keCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdFNpZGUgPT09IDQgLyogUmlnaHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5keCA9IC1NYXRoLmFicyh0aGlzLmxlZnQuZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRTaWRlID09PSAxIC8qIFRvcCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmR5ID0gTWF0aC5hYnModGhpcy5sZWZ0LmR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsZWZ0U2lkZSA9PT0gMiAvKiBCb3R0b20gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5keSA9IC1NYXRoLmFicyh0aGlzLmxlZnQuZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJpZ2h0U2lkZSA9IGV4LlV0aWwuZ2V0T3Bwb3NpdGVTaWRlKHRoaXMuc2lkZSk7XG4gICAgICAgICAgICB2YXIgcmlnaHRJbnRlcnNlY3QgPSB0aGlzLmludGVyc2VjdC5zY2FsZSgtMS4wKTtcbiAgICAgICAgICAgIGlmICgodGhpcy5yaWdodC5jb2xsaXNpb25UeXBlID09PSAyIC8qIEFjdGl2ZSAqLyB8fCB0aGlzLnJpZ2h0LmNvbGxpc2lvblR5cGUgPT09IDMgLyogRWxhc3RpYyAqLykgJiYgdGhpcy5sZWZ0LmNvbGxpc2lvblR5cGUgIT09IDEgLyogUGFzc2l2ZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQueSArPSByaWdodEludGVyc2VjdC55O1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQueCArPSByaWdodEludGVyc2VjdC54O1xuICAgICAgICAgICAgICAgIC8vIE5haXZlIGVsYXN0aWMgYm91bmNlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQuY29sbGlzaW9uVHlwZSA9PT0gMyAvKiBFbGFzdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFNpZGUgPT09IDMgLyogTGVmdCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5keCA9IE1hdGguYWJzKHRoaXMucmlnaHQuZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0U2lkZSA9PT0gNCAvKiBSaWdodCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5keCA9IC1NYXRoLmFicyh0aGlzLnJpZ2h0LmR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFNpZGUgPT09IDEgLyogVG9wICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmR5ID0gTWF0aC5hYnModGhpcy5yaWdodC5keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRTaWRlID09PSAyIC8qIEJvdHRvbSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5keSA9IC1NYXRoLmFicyh0aGlzLnJpZ2h0LmR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvblBhaXI7XG4gICAgfSkoKTtcbiAgICBleC5Db2xsaXNpb25QYWlyID0gQ29sbGlzaW9uUGFpcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRW5naW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAqIEEgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGNhbWVyYS4gVGhpcyBjbGFzcyBpcyBtZWFudCB0byBiZSBleHRlbmRlZC5cbiAgICAqIEBjbGFzcyBDYW1lcmFcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW5naW5lXG4gICAgKi9cbiAgICB2YXIgQmFzZUNhbWVyYSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJhc2VDYW1lcmEoKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzID0gbmV3IGV4LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgdGhpcy5sZXJwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxICogMTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgICAgICAgICB0aGlzLl90b3RhbExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbnVsbDtcbiAgICAgICAgICAgIC8vY2FtZXJhIGVmZmVjdHNcbiAgICAgICAgICAgIHRoaXMuaXNTaGFraW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWSA9IDA7XG4gICAgICAgICAgICB0aGlzLnNoYWtlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkU2hha2VUaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMuaXNab29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRab29tU2NhbGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5tYXhab29tU2NhbGUgPSAxO1xuICAgICAgICAgICAgdGhpcy56b29tRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkWm9vbVRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy56b29tSW5jcmVtZW50ID0gMC4wMTtcbiAgICAgICAgfVxuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5lYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC09IDI7XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDIpICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogU2V0cyB0aGUge3sjY3Jvc3NMaW5rIEFjdG9yfX17ey9jcm9zc0xpbmt9fSB0byBmb2xsb3cgd2l0aCB0aGUgY2FtZXJhXG4gICAgICAgICogQG1ldGhvZCBzZXRBY3RvclRvRm9sbG93XG4gICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRvIGZvbGxvd1xuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5zZXRBY3RvclRvRm9sbG93ID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmZvbGxvdyA9IGFjdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBSZXR1cm5zIHRoZSBmb2NhbCBwb2ludCBvZiB0aGUgY2FtZXJhXG4gICAgICAgICogQG1ldGhvZCBnZXRGb2N1c1xuICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmdldEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFNldHMgdGhlIGZvY2FsIHBvaW50IG9mIHRoZSBjYW1lcmEuIFRoaXMgdmFsdWUgY2FuIG9ubHkgYmUgc2V0IGlmIHRoZXJlIGlzIG5vIGFjdG9yIHRvIGJlIGZvbGxvd2VkLlxuICAgICAgICAqIEBtZXRob2Qgc2V0Rm9jdXNcbiAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBmb2NhbCBwb2ludFxuICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGZvY2FsIHBvaW50XG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnNldEZvY3VzID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb2xsb3cgJiYgIXRoaXMubGVycCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxlcnApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSB0aGlzLmZvY3VzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBleC5Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFNldHMgdGhlIGNhbWVyYSB0byBzaGFrZSBhdCB0aGUgc3BlY2lmaWVkIG1hZ25pdHVkZXMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb25cbiAgICAgICAgKiBAbWV0aG9kIHNoYWtlXG4gICAgICAgICogQHBhcmFtIG1hZ25pdHVkZVgge251bWJlcn0gdGhlIHggbWFnbml0dWRlIG9mIHRoZSBzaGFrZVxuICAgICAgICAqIEBwYXJhbSBtYWduaXR1ZGVZIHtudW1iZXJ9IHRoZSB5IG1hZ25pdHVkZSBvZiB0aGUgc2hha2VcbiAgICAgICAgKiBAcGFyYW0gZHVyYXRpb24ge251bWJlcn0gdGhlIGR1cmF0aW9uIG9mIHRoZSBzaGFrZVxuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5zaGFrZSA9IGZ1bmN0aW9uIChtYWduaXR1ZGVYLCBtYWduaXR1ZGVZLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5pc1NoYWtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaGFrZU1hZ25pdHVkZVggPSBtYWduaXR1ZGVYO1xuICAgICAgICAgICAgdGhpcy5zaGFrZU1hZ25pdHVkZVkgPSBtYWduaXR1ZGVZO1xuICAgICAgICAgICAgdGhpcy5zaGFrZUR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFpvb21zIHRoZSBjYW1lcmEgaW4gb3Igb3V0IGJ5IHRoZSBzcGVjaWZpZWQgc2NhbGUgb3ZlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICAgICAgICAqIElmIG5vIGR1cmF0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCB6b29tIGJ5IGEgc2V0IGFtb3VudCB1bnRpbCB0aGUgc2NhbGUgaXMgcmVhY2hlZC5cbiAgICAgICAgKiBAbWV0aG9kIHpvb21cbiAgICAgICAgKiBAcGFyYW0gc2NhbGUge251bWJlcn0gdGhlIHNjYWxlIG9mIHRoZSB6b29tXG4gICAgICAgICogQHBhcmFtIFtkdXJhdGlvbl0ge251bWJlcn0gdGhlIGR1cmF0aW9uIG9mIHRoZSB6b29tXG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbiAoc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heFpvb21TY2FsZSA9IHNjYWxlO1xuICAgICAgICAgICAgdGhpcy56b29tRHVyYXRpb24gPSBkdXJhdGlvbiB8IDA7XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21JbmNyZW1lbnQgPSBNYXRoLmFicyh0aGlzLm1heFpvb21TY2FsZSAtIHRoaXMuY3VycmVudFpvb21TY2FsZSkgLyBkdXJhdGlvbiAqIDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhab29tU2NhbGUgPCAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbUluY3JlbWVudCA9IC0xICogdGhpcy56b29tSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50Wm9vbVNjYWxlKHRoaXMubWF4Wm9vbVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNab29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFpvb21TY2FsZSh0aGlzLm1heFpvb21TY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ6b29tIGluY3JlbWVudDogXCIgKyB0aGlzLnpvb21JbmNyZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBnZXRzIHRoZSBjdXJyZW50IHpvb20gc2NhbGVcbiAgICAgICAgKiBAbWV0aG9kIGdldFpvb21cbiAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY3VycmVudCB6b29tIHNjYWxlXG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Wm9vbVNjYWxlO1xuICAgICAgICB9O1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5zZXRDdXJyZW50Wm9vbVNjYWxlID0gZnVuY3Rpb24gKHpvb21TY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Wm9vbVNjYWxlID0gem9vbVNjYWxlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBBcHBsaWVzIHRoZSByZWxldmFudCB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGdhbWUgY2FudmFzIHRvIFwibW92ZVwiIG9yIGFwcGx5IGVmZmVjdHMgdG8gdGhlIENhbWVyYVxuICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5nZXRGb2N1cygpO1xuICAgICAgICAgICAgdmFyIHhTaGFrZSA9IDA7XG4gICAgICAgICAgICB2YXIgeVNoYWtlID0gMDtcbiAgICAgICAgICAgIHZhciBjYW52YXNXaWR0aCA9IGN0eC5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbmV3Q2FudmFzV2lkdGggPSBjYW52YXNXaWR0aCAqIHRoaXMuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgdmFyIG5ld0NhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodCAqIHRoaXMuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVycCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24gJiYgdGhpcy5fY2FtZXJhTW92aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnggPCB0aGlzLl9sZXJwU3RhcnQueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cy54ID0gdGhpcy5fbGVycFN0YXJ0LnggLSAodGhpcy5lYXNlSW5PdXRDdWJpYyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLngpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cy54ID0gdGhpcy5lYXNlSW5PdXRDdWJpYyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueSA8IHRoaXMuX2xlcnBTdGFydC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLnkgPSB0aGlzLl9sZXJwU3RhcnQueSAtICh0aGlzLmVhc2VJbk91dEN1YmljKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLnkgPSB0aGlzLmVhc2VJbk91dEN1YmljKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycER1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb25lU2hha2luZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NoYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRTaGFrZVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hha2VNYWduaXR1ZGVYID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFrZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFNoYWtlVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB4U2hha2UgPSAoTWF0aC5yYW5kb20oKSAqIHRoaXMuc2hha2VNYWduaXR1ZGVYIHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIHlTaGFrZSA9IChNYXRoLnJhbmRvbSgpICogdGhpcy5zaGFrZU1hZ25pdHVkZVkgfCAwKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1mb2N1cy54ICsgeFNoYWtlICsgKG5ld0NhbnZhc1dpZHRoIC8gMiksIC1mb2N1cy55ICsgeVNoYWtlICsgKG5ld0NhbnZhc0hlaWdodCAvIDIpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRG9uZVpvb21pbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNab29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkWm9vbVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRab29tU2NhbGUodGhpcy5tYXhab29tU2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkWm9vbVRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50Wm9vbVNjYWxlKHRoaXMuZ2V0Wm9vbSgpICsgdGhpcy56b29tSW5jcmVtZW50ICogZGVsdGEgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLmdldFpvb20oKSwgdGhpcy5nZXRab29tKCkpO1xuICAgICAgICB9O1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmdldEZvY3VzKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKGZvY3VzLngsIGZvY3VzLnksIDE1LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9O1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5pc0RvbmVTaGFraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEodGhpcy5pc1NoYWtpbmcpIHx8ICh0aGlzLmVsYXBzZWRTaGFrZVRpbWUgPj0gdGhpcy5zaGFrZUR1cmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuaXNEb25lWm9vbWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnpvb21EdXJhdGlvbiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmVsYXBzZWRab29tVGltZSA+PSB0aGlzLnpvb21EdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhab29tU2NhbGUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jdXJyZW50Wm9vbVNjYWxlIDw9IHRoaXMubWF4Wm9vbVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jdXJyZW50Wm9vbVNjYWxlID49IHRoaXMubWF4Wm9vbVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCYXNlQ2FtZXJhO1xuICAgIH0pKCk7XG4gICAgZXguQmFzZUNhbWVyYSA9IEJhc2VDYW1lcmE7XG4gICAgLyoqXG4gICAgKiBBbiBleHRlbnNpb24gb2YgQmFzZUNhbWVyYSB0aGF0IGlzIGxvY2tlZCB2ZXJ0aWNhbGx5OyBpdCB3aWxsIG9ubHkgbW92ZSBzaWRlIHRvIHNpZGUuXG4gICAgKiBAY2xhc3MgU2lkZUNhbWVyYVxuICAgICogQGV4dGVuZHMgQmFzZUNhbWVyYVxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBlbmdpbmVcbiAgICAqL1xuICAgIHZhciBTaWRlQ2FtZXJhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFNpZGVDYW1lcmEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNpZGVDYW1lcmEoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTaWRlQ2FtZXJhLnByb3RvdHlwZS5nZXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbGxvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQodGhpcy5mb2xsb3cueCArIHRoaXMuZm9sbG93LmdldFdpZHRoKCkgLyAyLCB0aGlzLmZvY3VzLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTaWRlQ2FtZXJhO1xuICAgIH0pKEJhc2VDYW1lcmEpO1xuICAgIGV4LlNpZGVDYW1lcmEgPSBTaWRlQ2FtZXJhO1xuICAgIC8qKlxuICAgICogQW4gZXh0ZW5zaW9uIG9mIEJhc2VDYW1lcmEgdGhhdCBpcyBsb2NrZWQgdG8gYW4gYWN0b3Igb3IgZm9jYWwgcG9pbnQ7IHRoZSBhY3RvciB3aWxsIGFwcGVhciBpbiB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4uXG4gICAgKiBAY2xhc3MgVG9wQ2FtZXJhXG4gICAgKiBAZXh0ZW5kcyBCYXNlQ2FtZXJhXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVuZ2luZVxuICAgICovXG4gICAgdmFyIFRvcENhbWVyYSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUb3BDYW1lcmEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFRvcENhbWVyYSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFRvcENhbWVyYS5wcm90b3R5cGUuZ2V0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2xsb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KHRoaXMuZm9sbG93LnggKyB0aGlzLmZvbGxvdy5nZXRXaWR0aCgpIC8gMiwgdGhpcy5mb2xsb3cueSArIHRoaXMuZm9sbG93LmdldEhlaWdodCgpIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRvcENhbWVyYTtcbiAgICB9KShCYXNlQ2FtZXJhKTtcbiAgICBleC5Ub3BDYW1lcmEgPSBUb3BDYW1lcmE7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNsYXNzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUaW1lci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uL05haXZlQ29sbGlzaW9uUmVzb2x2ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uL0R5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uUGFpci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ2FtZXJhLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBY3RvcnMgYXJlIGNvbXBvc2VkIHRvZ2V0aGVyIGludG8gZ3JvdXBpbmdzIGNhbGxlZCBTY2VuZXMgaW5cbiAgICAgKiBFeGNhbGlidXIuIFRoZSBtZXRhcGhvciBtb2RlbHMgdGhlIHNhbWUgaWRlYSBiZWhpbmQgcmVhbCB3b3JsZFxuICAgICAqIGFjdG9ycyBpbiBhIHNjZW5lLiBPbmx5IGFjdG9ycyBpbiBzY2VuZXMgd2lsbCBiZSB1cGRhdGVkIGFuZCBkcmF3bi5cbiAgICAgKiBAY2xhc3MgU2NlbmVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgU2NlbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU2NlbmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNjZW5lKGVuZ2luZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBhY3RvcnMgaW4gdGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBjaGlsZHJlbiB7QWN0b3JbXX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy50aWxlTWFwcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy51aUFjdG9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIgPSBuZXcgZXguRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlcigpO1xuICAgICAgICAgICAgdGhpcy5fa2lsbFF1ZXVlID0gW107XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlID0gW107XG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBleC5CYXNlQ2FtZXJhKCk7XG4gICAgICAgICAgICBpZiAoZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0Rm9jdXMoZW5naW5lLndpZHRoIC8gMiwgZW5naW5lLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBtYWRlIGFjdGl2ZSBhbmQgc3RhcnRlZC4gSXQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuLFxuICAgICAgICAgKiB0aGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgc2V0dXAgYW55IERPTSBVSSBvciBldmVudCBoYW5kbGVycyBuZWVkZWQgZm9yIHRoZSBzY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBvbkFjdGl2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2NlbmUgaXMgbWFkZSB0cmFuc2l0aW9uZWQgYXdheSBmcm9tIGFuZCBzdG9wcGVkLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4sXG4gICAgICAgICAqIHRoaXMgaXMgd2hlcmUgeW91IHNob3VsZCBjbGVhbnVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXG4gICAgICAgICAqIEBtZXRob2Qgb25EZWFjdGl2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXG4gICAgICAgICAqIG92ZXJyaWRkZW4uIFRoaXMgaXMgd2hlcmUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGQgYWN0b3JzIHNob3VsZCB0YWtlIHBsYWNlLlxuICAgICAgICAgKiBAbWV0aG9kIG9uSW5pdGlhbGl6ZVxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIGFsbCBhY3RvcnMgaW4gdGhlIHNjZW5lXG4gICAgICAgICAqIEBtZXRob2QgcHVibGlzaFxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBwdWJsaXNoXG4gICAgICAgICAqIEBwYXJhbSBldmVudCB7R2FtZUV2ZW50fSBUaGUgZXZlbnQgb2JqZWN0IHRvIHNlbmRcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBhY3Rvci50cmlnZ2VyRXZlbnQoZXZlbnRUeXBlLCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIHRoZSBhY3RvcnMgYW5kIHRpbWVycyBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgRW5naW5lLlxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBFbmdpbmVcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZShlbmdpbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2luaXRpYWxpemUnLCBuZXcgZXguSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh1aSkge1xuICAgICAgICAgICAgICAgIHVpLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5mb3JFYWNoKGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgIGNtLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWd5XG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25SZXNvbHZlci51cGRhdGUodGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIuZXZhbHVhdGUodGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWN0b3JzIGZyb20gc2NlbmUgZ3JhcGggYWZ0ZXIgYmVpbmcga2lsbGVkXG4gICAgICAgICAgICB2YXIgYWN0b3JJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fa2lsbFF1ZXVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWN0b3JJbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZih0aGlzLl9raWxsUXVldWVbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChhY3RvckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoYWN0b3JJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fa2lsbFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGltZXJzIGluIHRoZSBjYW5jZWwgcXVldWUgYmVmb3JlIHVwZGF0aW5nIHRoZW1cbiAgICAgICAgICAgIHZhciB0aW1lckluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9jYW5jZWxRdWV1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIodGhpcy5fY2FuY2VsUXVldWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggdGltZXJzIHVwZGF0aW5nIHRpbWVyc1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fdGltZXJzID0gdGhpcy5fdGltZXJzLmZpbHRlcihmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aW1lci51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGltZXIuY29tcGxldGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgYWN0b3JzIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBFbmdpbmUuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBkcmF3XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlKGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5mb3JFYWNoKGZ1bmN0aW9uIChjbSkge1xuICAgICAgICAgICAgICAgIGNtLmRyYXcoY3R4LCBkZWx0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHZhciBlbmQgPSAwO1xuICAgICAgICAgICAgdmFyIGFjdG9yO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY3RvciA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgLy8gb25seSBkcmF3IGFjdG9ycyB0aGF0IGFyZSB2aXNpYmxlXG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kcmF3KGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZSAmJiB0aGlzLmVuZ2luZS5pc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3llbGxvdyc7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB0aGlzLnVpQWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHVpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVpLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkuZHJhdyhjdHgsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZSAmJiB0aGlzLmVuZ2luZS5pc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh1aSkge1xuICAgICAgICAgICAgICAgICAgICB1aS5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgYWN0b3JzJyBkZWJ1ZyBpbmZvcm1hdGlvbiBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgRW5naW5lLlxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZU1hcHMuZm9yRWFjaChmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYWN0b3IuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRvZG8gcG9zc2libHkgZW5hYmxlIHRoaXMgd2l0aCBleGNhbGlidXIgZmxhZ3MgZmVhdHVyZXM/XG4gICAgICAgICAgICAvL3RoaXMuX2NvbGxpc2lvblJlc29sdmVyLmRlYnVnRHJhdyhjdHgsIDIwKTtcbiAgICAgICAgICAgIC8vdGhpcy5jYW1lcmEuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgIH07XG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVUlBY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVUlBY3RvcihlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5BY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGltZXIoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaWxlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaWxlTWFwKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVUlBY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVUlBY3RvcihlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5BY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblJlc29sdmVyLnJlbW92ZShlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaWxlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlTWFwKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIGFjdCBhcyBhIHBpZWNlIG9mIFVJLCBtZWFuaW5nIGl0IGlzIGFsd2F5cyBwb3NpdGlvbmVkXG4gICAgICAgICAqIGluIHNjcmVlbiBjb29yZGluYXRlcy4gVUkgYWN0b3JzIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zXG4gICAgICAgICAqIEBtZXRob2QgYWRkVUlBY3RvclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZFVJQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudWlBY3RvcnMucHVzaChhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGFzIGEgcGllYyBvZiBVSVxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVVJQWN0b3JcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVVSUFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnVpQWN0b3JzLmluZGV4T2YoYWN0b3IpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIHRoZSBTY2VuZSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIGFjdG9yIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgYWRkQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIucmVnaXN0ZXIoYWN0b3IpO1xuICAgICAgICAgICAgYWN0b3Iuc2NlbmUgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFjdG9yKTtcbiAgICAgICAgICAgIGFjdG9yLnBhcmVudCA9IHRoaXMuYWN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgVGlsZU1hcCB0byB0aGUgU2NlbmUsIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBUaWxlTWFwIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgYWRkVGlsZU1hcFxuICAgICAgICAgKiBAcGFyYW0gdGlsZU1hcCB7VGlsZU1hcH1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcbiAgICAgICAgICAgIHRoaXMudGlsZU1hcHMucHVzaCh0aWxlTWFwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBUaWxlTWFwIGZyb20gdGhlIFNjZW5lLCBpdCB3aWxsbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlVGlsZU1hcFxuICAgICAgICAgKiBAcGFyYW0gdGlsZU1hcCB7VGlsZU1hcH1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMudGlsZU1hcHMuaW5kZXhPZih0aWxlTWFwKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBmcm9tIHRoZSBTY2VuZSwgaXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gcmVtb3ZlXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblJlc29sdmVyLnJlbW92ZShhY3Rvcik7XG4gICAgICAgICAgICB0aGlzLl9raWxsUXVldWUucHVzaChhY3Rvcik7XG4gICAgICAgICAgICBhY3Rvci5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIHRpbWVyIHRvIHRoZSBTY2VuZVxuICAgICAgICAgKiBAbWV0aG9kIGFkZFRpbWVyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byBhZGRcbiAgICAgICAgICogQHJldHVybnMgVGltZXJcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgdGhpcy5fdGltZXJzLnB1c2godGltZXIpO1xuICAgICAgICAgICAgdGltZXIuc2NlbmUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIHRpbWVyIHRvIHRoZSBTY2VuZSwgY2FuIGJlIGRhbmdlcm91c1xuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVRpbWVyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byByZW1vdmVcbiAgICAgICAgICogQHJldHVybnMgVGltZXJcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl90aW1lcnMuaW5kZXhPZih0aW1lcik7XG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuY2VscyBhIHRpbWVyLCByZW1vdmluZyBpdCBmcm9tIHRoZSBzY2VuZSBuaWNlbHlcbiAgICAgICAgICogQG1ldGhvZCBjYW5jZWxUaW1lclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIge1RpbWVyfSBUaGUgdGltZXIgdG8gY2FuY2VsXG4gICAgICAgICAqIEByZXR1cm5zIFRpbWVyXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuY2FuY2VsVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlLnB1c2godGltZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgd2hldGhlciBhIHRpbWVyIGlzIGFjdGl2ZSBpbiB0aGUgc2NlbmVcbiAgICAgICAgICogQG1ldGhvZCBpc1RpbWVyQWN0aXZlXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9XG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5pc1RpbWVyQWN0aXZlID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3RpbWVycy5pbmRleE9mKHRpbWVyKSA+IC0xKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNjZW5lO1xuICAgIH0pKGV4LkNsYXNzKTtcbiAgICBleC5TY2VuZSA9IFNjZW5lO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgSW50ZXJuYWw7XG4gICAgKGZ1bmN0aW9uIChJbnRlcm5hbCkge1xuICAgICAgICB2YXIgQWN0aW9ucztcbiAgICAgICAgKGZ1bmN0aW9uIChBY3Rpb25zKSB7XG4gICAgICAgICAgICB2YXIgRWFzZVRvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBFYXNlVG8oYWN0b3IsIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhc2luZ0ZjbiA9IGVhc2luZ0ZjbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gMSAqIDEwMDA7IC8vIDUgc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBuZXcgZXguUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgZXguUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBleC5Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbmV3IGV4LlBvaW50KHRoaXMuYWN0b3IueCwgdGhpcy5hY3Rvci55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sZXJwU3RhcnQudG9WZWN0b3IoKS5kaXN0YW5jZSh0aGlzLl9sZXJwRW5kLnRvVmVjdG9yKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRWFzZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdYID0gdGhpcy5hY3Rvci54O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WSA9IHRoaXMuYWN0b3IueTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueCA8IHRoaXMuX2xlcnBTdGFydC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WCA9IHRoaXMuX2xlcnBTdGFydC54IC0gKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdYID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueSA8IHRoaXMuX2xlcnBTdGFydC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WSA9IHRoaXMuX2xlcnBTdGFydC55IC0gKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdZID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gbmV3WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IG5ld1k7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnggPSB0aGlzLl9sZXJwRW5kLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSB0aGlzLl9sZXJwRW5kLnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEVhc2VUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAobmV3IGV4LlZlY3RvcihhY3Rvci54LCBhY3Rvci55KSkuZGlzdGFuY2UodGhpcy5fbGVycFN0YXJ0LnRvVmVjdG9yKCkpID49IHRoaXMuX2Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEVhc2VUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRWFzZVRvO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuRWFzZVRvID0gRWFzZVRvO1xuICAgICAgICAgICAgdmFyIE1vdmVUbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTW92ZVRvKGFjdG9yLCBkZXN0eCwgZGVzdHksIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IGV4LlZlY3RvcihkZXN0eCwgZGVzdHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE1vdmVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IGV4LlZlY3Rvcih0aGlzLmFjdG9yLngsIHRoaXMuYWN0b3IueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy5zdGFydC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuZW5kLm1pbnVzKHRoaXMuc3RhcnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5kaXIuc2NhbGUodGhpcy5zcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSBtLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSBtLnk7XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gdGhpcy5lbmQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IHRoaXMuZW5kLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBleC5WZWN0b3IoYWN0b3IueCwgYWN0b3IueSkpLmRpc3RhbmNlKHRoaXMuc3RhcnQpID49IHRoaXMuZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTW92ZVRvO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuTW92ZVRvID0gTW92ZVRvO1xuICAgICAgICAgICAgdmFyIE1vdmVCeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTW92ZUJ5KGFjdG9yLCBkZXN0eCwgZGVzdHksIHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgZXguVmVjdG9yKGRlc3R4LCBkZXN0eSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKFwiQXR0ZW1wdGVkIHRvIG1vdmVCeSB0aW1lIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvIDogXCIgKyB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGluIHRpbWUgPD0gMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBleC5WZWN0b3IodGhpcy5hY3Rvci54LCB0aGlzLmFjdG9yLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMuc3RhcnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmVuZC5taW51cyh0aGlzLnN0YXJ0KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSB0aGlzLmRpc3RhbmNlIC8gKHRoaXMudGltZSAvIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5kaXIuc2NhbGUodGhpcy5zcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSBtLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSBtLnk7XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gdGhpcy5lbmQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IHRoaXMuZW5kLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBleC5WZWN0b3IoYWN0b3IueCwgYWN0b3IueSkpLmRpc3RhbmNlKHRoaXMuc3RhcnQpID49IHRoaXMuZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNb3ZlQnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTW92ZUJ5O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuTW92ZUJ5ID0gTW92ZUJ5O1xuICAgICAgICAgICAgdmFyIEZvbGxvdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRm9sbG93KGFjdG9yLCBhY3RvclRvRm9sbG93LCBmb2xsb3dEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yVG9Gb2xsb3cgPSBhY3RvclRvRm9sbG93O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgZXguVmVjdG9yKHRoaXMuYWN0b3IueCwgdGhpcy5hY3Rvci55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgZXguVmVjdG9yKGFjdG9yVG9Gb2xsb3cueCwgYWN0b3JUb0ZvbGxvdy55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhpbXVtRGlzdGFuY2UgPSAoZm9sbG93RGlzdGFuY2UgIT0gdW5kZWZpbmVkKSA/IGZvbGxvd0Rpc3RhbmNlIDogdGhpcy5jdXJyZW50LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEZvbGxvdy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlQmV0d2VlbiA9IHRoaXMuY3VycmVudC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuZW5kLm1pbnVzKHRoaXMuY3VycmVudCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yVG9Gb2xsb3dTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLmFjdG9yVG9Gb2xsb3cuZHgsIDIpICsgTWF0aC5wb3codGhpcy5hY3RvclRvRm9sbG93LmR5LCAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RvclRvRm9sbG93U3BlZWQgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IGFjdG9yVG9Gb2xsb3dTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmFjdG9yLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kLnggPSB0aGlzLmFjdG9yVG9Gb2xsb3cueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQueSA9IHRoaXMuYWN0b3JUb0ZvbGxvdy55O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlQmV0d2VlbiA9IHRoaXMuY3VycmVudC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyID0gdGhpcy5lbmQubWludXModGhpcy5jdXJyZW50KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzdGFuY2VCZXR3ZWVuID49IHRoaXMubWF4aW11bURpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuZGlyLnNjYWxlKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IG0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSBtLnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgbmV2ZXIgb2NjdXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueCA9IHRoaXMuZW5kLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSB0aGlzLmVuZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRm9sbG93LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRm9sbG93LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3RvciBmb2xsb3dpbmcgc2hvdWxkIG5ldmVyIHN0b3AgdW5sZXNzIHNwZWNpZmllZCB0byBkbyBzb1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZvbGxvdy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBGb2xsb3c7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5Gb2xsb3cgPSBGb2xsb3c7XG4gICAgICAgICAgICB2YXIgTWVldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTWVldChhY3RvciwgYWN0b3JUb01lZXQsIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JUb01lZXQgPSBhY3RvclRvTWVldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IGV4LlZlY3Rvcih0aGlzLmFjdG9yLngsIHRoaXMuYWN0b3IueSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IGV4LlZlY3RvcihhY3RvclRvTWVldC54LCBhY3RvclRvTWVldC55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVlZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNZWV0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5jdXJyZW50LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyID0gdGhpcy5lbmQubWludXModGhpcy5jdXJyZW50KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3JUb01lZXRTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLmFjdG9yVG9NZWV0LmR4LCAyKSArIE1hdGgucG93KHRoaXMuYWN0b3JUb01lZXQuZHksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChhY3RvclRvTWVldFNwZWVkICE9IDApICYmICghdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gYWN0b3JUb01lZXRTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmFjdG9yLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kLnggPSB0aGlzLmFjdG9yVG9NZWV0Lng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kLnkgPSB0aGlzLmFjdG9yVG9NZWV0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5jdXJyZW50LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmVuZC5taW51cyh0aGlzLmN1cnJlbnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuZGlyLnNjYWxlKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gbS54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gbS55O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1lZXRpbmcgaXMgY29tcGxldGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueCA9IHRoaXMuZW5kLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSB0aGlzLmVuZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWVldC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5kaXN0YW5jZUJldHdlZW4gPD0gMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNZWV0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWVldC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNZWV0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuTWVldCA9IE1lZXQ7XG4gICAgICAgICAgICB2YXIgUm90YXRlVG8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFJvdGF0ZVRvKGFjdG9yLCBhbmdsZVJhZGlhbnMsIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gYW5nbGVSYWRpYW5zO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLmFjdG9yLnJvdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IE1hdGguYWJzKHRoaXMuZW5kIC0gdGhpcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IHRoaXMuc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yb3RhdGlvbiA9IHRoaXMuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChNYXRoLmFicyh0aGlzLmFjdG9yLnJvdGF0aW9uIC0gdGhpcy5zdGFydCkgPj0gdGhpcy5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUm90YXRlVG87XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5Sb3RhdGVUbyA9IFJvdGF0ZVRvO1xuICAgICAgICAgICAgdmFyIFJvdGF0ZUJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSb3RhdGVCeShhY3RvciwgYW5nbGVSYWRpYW5zLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gYW5nbGVSYWRpYW5zO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gKHRoaXMuZW5kIC0gdGhpcy5hY3Rvci5yb3RhdGlvbikgLyB0aW1lICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuYWN0b3Iucm90YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gTWF0aC5hYnModGhpcy5lbmQgLSB0aGlzLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gdGhpcy5zcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5sb2coXCJQb3MgeDogXCIgKyB0aGlzLmFjdG9yLnggK1wiICB5OlwiICsgdGhpcy5hY3Rvci55LCBMb2cuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJvdGF0aW9uID0gdGhpcy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKE1hdGguYWJzKHRoaXMuYWN0b3Iucm90YXRpb24gLSB0aGlzLnN0YXJ0KSA+PSB0aGlzLmRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBSb3RhdGVCeTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlJvdGF0ZUJ5ID0gUm90YXRlQnk7XG4gICAgICAgICAgICB2YXIgU2NhbGVUbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2NhbGVUbyhhY3Rvciwgc2NhbGVYLCBzY2FsZVksIHNwZWVkWCwgc3BlZWRZKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRZID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkWCA9IHNwZWVkWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZFkgPSBzcGVlZFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFggPSB0aGlzLmFjdG9yLnNjYWxlLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0WSA9IHRoaXMuYWN0b3Iuc2NhbGUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VYID0gTWF0aC5hYnModGhpcy5lbmRYIC0gdGhpcy5zdGFydFgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLmVuZFkgLSB0aGlzLnN0YXJ0WSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnModGhpcy5hY3Rvci5zY2FsZS54IC0gdGhpcy5zdGFydFgpID49IHRoaXMuZGlzdGFuY2VYKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblggPSB0aGlzLmVuZFkgPCB0aGlzLnN0YXJ0WSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSB0aGlzLnNwZWVkWCAqIGRpcmVjdGlvblg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnkgLSB0aGlzLnN0YXJ0WSkgPj0gdGhpcy5kaXN0YW5jZVkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRoaXMuZW5kWSA8IHRoaXMuc3RhcnRZID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IHRoaXMuc3BlZWRZICogZGlyZWN0aW9uWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zY2FsZS54ID0gdGhpcy5lbmRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zY2FsZS55ID0gdGhpcy5lbmRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2NhbGVUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoKE1hdGguYWJzKHRoaXMuYWN0b3Iuc2NhbGUueSAtIHRoaXMuc3RhcnRYKSA+PSB0aGlzLmRpc3RhbmNlWCkgJiYgKE1hdGguYWJzKHRoaXMuYWN0b3Iuc2NhbGUueSAtIHRoaXMuc3RhcnRZKSA+PSB0aGlzLmRpc3RhbmNlWSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2NhbGVUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2NhbGVUbztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlNjYWxlVG8gPSBTY2FsZVRvO1xuICAgICAgICAgICAgdmFyIFNjYWxlQnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNjYWxlQnkoYWN0b3IsIHNjYWxlWCwgc2NhbGVZLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kWCA9IHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRZID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkWCA9ICh0aGlzLmVuZFggLSB0aGlzLmFjdG9yLnNjYWxlLngpIC8gdGltZSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWRZID0gKHRoaXMuZW5kWSAtIHRoaXMuYWN0b3Iuc2NhbGUueSkgLyB0aW1lICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0WCA9IHRoaXMuYWN0b3Iuc2NhbGUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRZID0gdGhpcy5hY3Rvci5zY2FsZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZVggPSBNYXRoLmFicyh0aGlzLmVuZFggLSB0aGlzLnN0YXJ0WCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlWSA9IE1hdGguYWJzKHRoaXMuZW5kWSAtIHRoaXMuc3RhcnRZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWCA9IHRoaXMuZW5kWCA8IHRoaXMuc3RhcnRYID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWSA9IHRoaXMuZW5kWSA8IHRoaXMuc3RhcnRZID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gdGhpcy5zcGVlZFggKiBkaXJlY3Rpb25YO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gdGhpcy5zcGVlZFkgKiBkaXJlY3Rpb25ZO1xuICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIlBvcyB4OiBcIiArIHRoaXMuYWN0b3IueCArXCIgIHk6XCIgKyB0aGlzLmFjdG9yLnksIExvZy5ERUJVRyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc2NhbGUueCA9IHRoaXMuZW5kWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc2NhbGUueSA9IHRoaXMuZW5kWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlQnkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKChNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnggLSB0aGlzLnN0YXJ0WCkgPj0gdGhpcy5kaXN0YW5jZVgpICYmIChNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnkgLSB0aGlzLnN0YXJ0WSkgPj0gdGhpcy5kaXN0YW5jZVkpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNjYWxlQnk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5TY2FsZUJ5ID0gU2NhbGVCeTtcbiAgICAgICAgICAgIHZhciBEZWxheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRGVsYXkoYWN0b3IsIGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIERlbGF5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLmFjdG9yLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuYWN0b3IueTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIERlbGF5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLmVsYXBzZWRUaW1lID49IHRoaXMuZGVsYXkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGVsYXkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGVsYXkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbGF5O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuRGVsYXkgPSBEZWxheTtcbiAgICAgICAgICAgIHZhciBCbGluayA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQmxpbmsoYWN0b3IsIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1CbGlua3MgPT09IHZvaWQgMCkgeyBudW1CbGlua3MgPSAxOyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZVZpc2libGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVOb3RWaXNpYmxlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lVmlzaWJsZSA9IHRpbWVWaXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVOb3RWaXNpYmxlID0gdGltZU5vdFZpc2libGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSAodGltZVZpc2libGUgKyB0aW1lTm90VmlzaWJsZSkgKiBudW1CbGlua3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEJsaW5rLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0b3IudmlzaWJsZSAmJiB0aGlzLmVsYXBzZWRUaW1lID49IHRoaXMudGltZVZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjdG9yLnZpc2libGUgJiYgdGhpcy5lbGFwc2VkVGltZSA+PSB0aGlzLnRpbWVOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmxpbmsucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMudG90YWxUaW1lID49IHRoaXMuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmxpbmsucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmxpbmsucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmxpbms7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5CbGluayA9IEJsaW5rO1xuICAgICAgICAgICAgdmFyIEZhZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZhZGUoYWN0b3IsIGVuZE9wYWNpdHksIHNwZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbHllciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kT3BhY2l0eSA9IGVuZE9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZE9wYWNpdHkgPCBhY3Rvci5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGx5ZXIgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBGYWRlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iub3BhY2l0eSArPSB0aGlzLm11bHRpcGx5ZXIgKiAoTWF0aC5hYnModGhpcy5hY3Rvci5vcGFjaXR5IC0gdGhpcy5lbmRPcGFjaXR5KSAqIGRlbHRhKSAvIHRoaXMuc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgZXguTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoXCJhY3RvciBvcGFjaXR5OiBcIiArIHRoaXMuYWN0b3Iub3BhY2l0eSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iub3BhY2l0eSA9IHRoaXMuZW5kT3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmFkZS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoTWF0aC5hYnModGhpcy5hY3Rvci5vcGFjaXR5IC0gdGhpcy5lbmRPcGFjaXR5KSA8IDAuMDUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmFkZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGYWRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhZGU7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5GYWRlID0gRmFkZTtcbiAgICAgICAgICAgIHZhciBEaWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIERpZShhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBEaWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmFjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmtpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEaWUucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGllLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGllLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBEaWU7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5EaWUgPSBEaWU7XG4gICAgICAgICAgICB2YXIgQ2FsbE1ldGhvZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQ2FsbE1ldGhvZChhY3RvciwgbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRob2QuY2FsbCh0aGlzLl9hY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzQmVlbkNhbGxlZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBDYWxsTWV0aG9kO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuQ2FsbE1ldGhvZCA9IENhbGxNZXRob2Q7XG4gICAgICAgICAgICB2YXIgUmVwZWF0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSZXBlYXQoYWN0b3IsIHJlcGVhdCwgYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25RdWV1ZShhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0ID0gcmVwZWF0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsUmVwZWF0ID0gcmVwZWF0O1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3Rpb25RdWV1ZS5hZGQoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJlcGVhdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5hY3Rvci55O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aW9uUXVldWUuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdC5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMucmVwZWF0IDw9IDApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVwZWF0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0ID0gdGhpcy5vcmlnaW5hbFJlcGVhdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBSZXBlYXQ7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5SZXBlYXQgPSBSZXBlYXQ7XG4gICAgICAgICAgICB2YXIgUmVwZWF0Rm9yZXZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUmVwZWF0Rm9yZXZlcihhY3RvciwgYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IG5ldyBBY3Rpb25RdWV1ZShhY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGlvblF1ZXVlLmFkZChhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5hY3Rvci55O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY3Rpb25RdWV1ZS5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVwZWF0Rm9yZXZlcjtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlJlcGVhdEZvcmV2ZXIgPSBSZXBlYXRGb3JldmVyO1xuICAgICAgICAgICAgdmFyIEFjdGlvblF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBBY3Rpb25RdWV1ZShhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2FjdGlvbnMuaW5kZXhPZihhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuY2xlYXJBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuZ2V0QWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuY29uY2F0KHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMgPSB0aGlzLmdldEFjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gdGhpcy5fYWN0aW9uc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24udXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aW9uLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIkFjdGlvbiBjb21wbGV0ZSFcIiwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9ucy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFjdGlvblF1ZXVlO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuQWN0aW9uUXVldWUgPSBBY3Rpb25RdWV1ZTtcbiAgICAgICAgfSkoQWN0aW9ucyA9IEludGVybmFsLkFjdGlvbnMgfHwgKEludGVybmFsLkFjdGlvbnMgPSB7fSkpO1xuICAgIH0pKEludGVybmFsID0gZXguSW50ZXJuYWwgfHwgKGV4LkludGVybmFsID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIEVhc2luZ0Z1bmN0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEVhc2luZ0Z1bmN0aW9ucygpIHtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdCB9LFxuICAgICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogKDIgLSB0KSB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdCB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogdCB9LFxuICAgICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKC0tdCkgKiB0ICogdCArIDEgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDEgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gKC0tdCkgKiB0ICogdCAqIHQgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAoLS10KSAqIHQgKiB0ICogdCB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxICsgKC0tdCkgKiB0ICogdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogKC0tdCkgKiB0ICogdCAqIHQgKiB0IH1cbiAgICAgICAgKi9cbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkxpbmVhciA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgLyBkdXJhdGlvbiArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5RdWFkID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlT3V0UXVhZCA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvL2VuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiAtZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICAgICAgY3VycmVudFRpbWUtLTtcbiAgICAgICAgICAgIHJldHVybiAtZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgLSAxKSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5DdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZU91dEN1YmljID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIChjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyAxKSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC09IDI7XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDIpICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVhc2luZ0Z1bmN0aW9ucztcbiAgICB9KSgpO1xuICAgIGV4LkVhc2luZ0Z1bmN0aW9ucyA9IEVhc2luZ0Z1bmN0aW9ucztcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW50ZXJmYWNlcy9JRHJhd2FibGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vZHVsZXMvTW92ZW1lbnRNb2R1bGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vZHVsZXMvT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9kdWxlcy9DYXB0dXJlUG9pbnRlck1vZHVsZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9kdWxlcy9Db2xsaXNpb25EZXRlY3Rpb25Nb2R1bGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbGxpc2lvbi9TaWRlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVdGlsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUaWxlTWFwLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb2xsaXNpb24vQm91bmRpbmdCb3gudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNjZW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rpb24udHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVhc2luZ0Z1bmN0aW9ucy50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlcyBvZiBjb2xsaXNpb25zIGFjdG9ycyBjYW4gcGFydGljaXBhdGUgaW5cbiAgICAgKiBAY2xhc3MgQ29sbGlzaW9uVHlwZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoQ29sbGlzaW9uVHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIFByZXZlbnRDb2xsaXNpb24gc2V0dGluZyBkbyBub3QgcGFydGljaXBhdGUgaW4gYW55XG4gICAgICAgICAqIGNvbGxpc2lvbnMgYW5kIGRvIG5vdCByYWlzZSBjb2xsaXNpb24gZXZlbnRzLlxuICAgICAgICAgKiBAcHJvcGVydHkgUHJldmVudENvbGxpc2lvbiB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiUHJldmVudENvbGxpc2lvblwiXSA9IDBdID0gXCJQcmV2ZW50Q29sbGlzaW9uXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgUGFzc2l2ZSBzZXR0aW5nIG9ubHkgcmFpc2UgY29sbGlzaW9uIGV2ZW50cywgYnV0IGFyZSBub3RcbiAgICAgICAgICogaW5mbHVlbmNlZCBvciBtb3ZlZCBieSBvdGhlciBhY3RvcnMgYW5kIGRvIG5vdCBpbmZsdWVuY2Ugb3IgbW92ZSBvdGhlciBhY3RvcnMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBQYXNzaXZlIHtDb2xsaXNpb25UeXBlfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJQYXNzaXZlXCJdID0gMV0gPSBcIlBhc3NpdmVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBBY3RpdmUgc2V0dGluZyByYWlzZSBjb2xsaXNpb24gZXZlbnRzIGFuZCBwYXJ0aWNpcGF0ZVxuICAgICAgICAgKiBpbiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYWN0b3JzIGFuZCB3aWxsIGJlIHB1c2ggb3IgbW92ZWQgYnkgYWN0b3JzIHNoYXJpbmdcbiAgICAgICAgICogdGhlIEFjdGl2ZSBvciBGaXhlZCBzZXR0aW5nLlxuICAgICAgICAgKiBAcHJvcGVydHkgQWN0aXZlIHtDb2xsaXNpb25UeXBlfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJBY3RpdmVcIl0gPSAyXSA9IFwiQWN0aXZlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgRWxhc3RpYyBzZXR0aW5nIHdpbGwgYmVoYXZlIHRoZSBzYW1lIGFzIEFjdGl2ZSwgZXhjZXB0IHRoYXQgdGhleSB3aWxsXG4gICAgICAgICAqIFwiYm91bmNlXCIgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBnaXZlbiB0aGVpciB2ZWxvY2l0eSBkeC9keS4gVGhpcyBpcyBhIG5haXZlIGltcGxlbWVudGF0aW9uIG1lYW50IGZvclxuICAgICAgICAgKiBwcm90b3R5cGluZywgZm9yIGEgbW9yZSByb2J1c3QgZWxhc3RpYyBjb2xsaXNpb24gbGlzdGVuIHRvIHRoZSBcImNvbGxpc2lvblwiIGV2ZW50IGFuZCBwZXJmb3JtIHlvdXIgY3VzdG9tIGxvZ2ljLlxuICAgICAgICAgKiBAcHJvcGVydHkgRWxhc3RpYyB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiRWxhc3RpY1wiXSA9IDNdID0gXCJFbGFzdGljXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgRml4ZWQgc2V0dGluZyByYWlzZSBjb2xsaXNpb24gZXZlbnRzIGFuZCBwYXJ0aWNpcGF0ZSBpblxuICAgICAgICAgKiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYWN0b3JzLiBBY3RvcnMgd2l0aCB0aGUgRml4ZWQgc2V0dGluZyB3aWxsIG5vdCBiZVxuICAgICAgICAgKiBwdXNoZWQgb3IgbW92ZWQgYnkgb3RoZXIgYWN0b3JzIHNoYXJpbmcgdGhlIEZpeGVkIG9yIEFjdG9ycy4gVGhpbmsgb2YgRml4ZWRcbiAgICAgICAgICogYWN0b3JzIGFzIFwiaW1tb3ZhYmxlL29uc3RvcHBhYmxlXCIgb2JqZWN0cy4gSWYgdHdvIEZpeGVkIGFjdG9ycyBtZWV0IHRoZXkgd2lsbFxuICAgICAgICAgKiBub3QgYmUgcHVzaGVkIG9yIG1vdmVkIGJ5IGVhY2ggb3RoZXIsIHRoZXkgd2lsbCBub3QgaW50ZXJhY3QgZXhjZXB0IHRvIHRocm93XG4gICAgICAgICAqIGNvbGxpc2lvbiBldmVudHMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGaXhlZCB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiRml4ZWRcIl0gPSA0XSA9IFwiRml4ZWRcIjtcbiAgICB9KShleC5Db2xsaXNpb25UeXBlIHx8IChleC5Db2xsaXNpb25UeXBlID0ge30pKTtcbiAgICB2YXIgQ29sbGlzaW9uVHlwZSA9IGV4LkNvbGxpc2lvblR5cGU7XG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgaW1wb3J0YW50IHByaW1pdGl2ZSBpbiBFeGNhbGlidXIgaXMgYW4gXCJBY3Rvci5cIiBBbnl0aGluZyB0aGF0XG4gICAgICogY2FuIG1vdmUgb24gdGhlIHNjcmVlbiwgY29sbGlkZSB3aXRoIGFub3RoZXIgQWN0b3IsIHJlc3BvbmQgdG8gZXZlbnRzLFxuICAgICAqIG9yIGludGVyYWN0IHdpdGggdGhlIGN1cnJlbnQgc2NlbmUsIG11c3QgYmUgYW4gYWN0b3IuIEFuIEFjdG9yIDxiPm11c3Q8L2I+XG4gICAgICogYmUgcGFydCBvZiBhIHt7I2Nyb3NzTGluayBcIlNjZW5lXCJ9fXt7L2Nyb3NzTGlua319IGZvciBpdCB0byBiZSBkcmF3biB0byB0aGUgc2NyZWVuLlxuICAgICAqIEBjbGFzcyBBY3RvclxuICAgICAqIEBleHRlbmRzIENsYXNzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt4PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHggY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW3k9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgeSBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbd2lkdGg9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgd2lkdGggb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFtoZWlnaHQ9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgaGVpZ2h0IG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbY29sb3I9dW5kZWZpbmVkXSB7Q29sb3J9IFRoZSBzdGFydGluZyBjb2xvciBvZiB0aGUgYWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQWN0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYWN0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pZCA9IEFjdG9yLm1heElkKys7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yIChsZWZ0IGVkZ2UpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgeCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBhY3RvciAodG9wIGVkZ2UpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgeSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFuc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHJvdGF0aW9uIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwOyAvLyByYWRpYW5zXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiByYWRpYW5zL3NlY29uZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHJ4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucnggPSAwOyAvL3JhZGlvbnMvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBzY2FsZSB2ZWN0b3Igb2YgdGhlIGFjdG9yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgc2NhbGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBleC5WZWN0b3IoMSwgMSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB4IHNjYWxhciB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gc2NhbGUvc2Vjb25kXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgc3gge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zeCA9IDA7IC8vc2NhbGUvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB5IHNjYWxhciB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gc2NhbGUvc2Vjb25kXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgc3kge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zeSA9IDA7IC8vc2NhbGUvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB4IHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5keCA9IDA7IC8vIHBpeGVscy9zZWNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHggdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkeCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmR5ID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHggYWNjZWxlcmF0aW9uIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXjJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBheCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmF4ID0gMDsgLy8gcGl4ZWxzL3NlYy9zZWNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHkgYWNjZWxlcmF0aW9uIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXjJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBheSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmF5ID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdldGhlciB0aGUgYWN0b3IgaXMgcGh5c2ljYWxseSBpbiB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpc09mZlNjcmVlbiB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc09mZlNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHZpc2libGUge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBvcGFjaXR5IG9mIGFuIGFjdG9yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgb3BhY2l0eSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c09wYWNpdHkgPSAxO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBsb2dnZXJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBsb2dnZXIge0xvZ2dlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBUaGUgc2NlbmUgdGhhdCB0aGUgYWN0b3IgaXMgaW5cbiAgICAgICAgICAgICogQHByb3BlcnR5IHNjZW5lIHtTY2VuZX1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDsgLy9mb3JtZXJseSBcInBhcmVudFwiXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogVGhlIHBhcmVudCBvZiB0aGlzIGFjdG9yXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSBwYXJlbnQge0FjdG9yfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IGNvbGxpc2lvbiB0eXBlIG9mIHRoaXMgYWN0b3IuIEJ5XG4gICAgICAgICAgICAgKiBkZWZhdWx0IGFsbCBhY3RvcnMgcGFydGljaXBhdGUgaW4gQWN0aXZlIGNvbGxpc2lvbnMuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uVHlwZSB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25UeXBlID0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZyYW1lcyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBY2Nlc3MgdG8gdGhlIGN1cnJlbnQgZHJhd2luZyBvbiBmb3IgdGhlIGFjdG9yLCB0aGlzIGNhbiBiZSBhbiB7eyNjcm9zc0xpbmsgXCJBbmltYXRpb25cIn19e3svY3Jvc3NMaW5rfX0sXG4gICAgICAgICAgICAgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVcIn19e3svY3Jvc3NMaW5rfX0sIG9yIHt7I2Nyb3NzTGluayBcIlBvbHlnb25cIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICAgICAgICAgKiBTZXQgZHJhd2luZ3Mgd2l0aCB0aGUge3sjY3Jvc3NMaW5rIFwiQWN0b3Ivc2V0RHJhd2luZzptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY3VycmVudERyYXdpbmcge0lEcmF3YWJsZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNlbnRlckRyYXdpbmdYID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNlbnRlckRyYXdpbmdZID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1vZGlmeSB0aGUgY3VycmVudCBhY3RvciB1cGRhdGUgcGlwZWxpbmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZSA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBlbmFibGUgdGhlIENhcHR1cmVQb2ludGVyIHRyYWl0IHRoYXQgcHJvcG9nYXRlcyBwb2ludGVyIGV2ZW50cyB0byB0aGlzIGFjdG9yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2VuYWJsZUNhcHR1cmVQb2ludGVyPWZhbHNlXSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25maWd1cmF0aW9uIGZvciBDYXB0dXJlUG9pbnRlciB0cmFpdFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGNhcHR1cmVQb2ludGVyIHtJQ2FwdHVyZVBvaW50ZXJDb25maWd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZVBvaW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZU1vdmVFdmVudHM6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5faXNLaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICAgICAgICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBjb2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IG9wYWNpdHkgb2YgYW4gYWN0b3IgdG8gdGhlIGNvbG9yXG4gICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gY29sb3IuYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1aWxkIGRlZmF1bHQgcGlwZWxpbmVcbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUucHVzaChuZXcgZXguTW92ZW1lbnRNb2R1bGUoKSk7XG4gICAgICAgICAgICAvL3RoaXMucGlwZWxpbmUucHVzaChuZXcgZXguQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlKCkpO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5PZmZzY3JlZW5DdWxsaW5nTW9kdWxlKCkpO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5DYXB0dXJlUG9pbnRlck1vZHVsZSgpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUgPSBuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5BY3Rpb25RdWV1ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVOb2RlID0gbmV3IGV4LlNjZW5lKCk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lTm9kZS5hY3RvciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG5ldyBleC5Qb2ludCguNSwgLjUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXG4gICAgICAgICAqIG92ZXJyaWRkZW4uIFRoaXMgaXMgd2hlcmUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGQgYWN0b3JzIHNob3VsZCB0YWtlIHBsYWNlLlxuICAgICAgICAgKiBAbWV0aG9kIG9uSW5pdGlhbGl6ZVxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICB9O1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuX2NoZWNrRm9yUG9pbnRlck9wdEluID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAmJiAoZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwb2ludGVyZG93bicgfHwgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwb2ludGVyZG93bicgfHwgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwb2ludGVybW92ZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAncG9pbnRlcm1vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZU1vdmVFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyLiBZb3UgY2FuIGxpc3RlbiBmb3IgYSB2YXJpZXR5IG9mXG4gICAgICAgICogZXZlbnRzIG9mZiBvZiB0aGUgZW5naW5lOyBzZWUgdGhlIGV2ZW50cyBzZWN0aW9uIGJlbG93IGZvciBhIGNvbXBsZXRlIGxpc3QuXG4gICAgICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgICogQHBhcmFtIGhhbmRsZXIge2V2ZW50PT52b2lkfSBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG4gICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JQb2ludGVyT3B0SW4oZXZlbnROYW1lKTtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgXCJhZGRFdmVudExpc3RlbmVyXCIuIFlvdSBjYW4gbGlzdGVuIGZvciBhIHZhcmlldHkgb2ZcbiAgICAgICAgICogZXZlbnRzIG9mZiBvZiB0aGUgZW5naW5lOyBzZWUgdGhlIGV2ZW50cyBzZWN0aW9uIGJlbG93IGZvciBhIGNvbXBsZXRlIGxpc3QuXG4gICAgICAgICAqIEBtZXRob2Qgb25cbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyIHtldmVudD0+dm9pZH0gRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JQb2ludGVyT3B0SW4oZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnN1YnNjcmliZShldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGN1cnJlbnQgYWN0b3JzIGlzIGEgbWVtYmVyIG9mIHRoZSBzY2VuZS4gVGhpcyB3aWxsIHJlbW92ZVxuICAgICAgICAgKiBpdCBmcm9tIHRoZSBzY2VuZSBncmFwaC4gSXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCBraWxsXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0tpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQ2Fubm90IGtpbGwgYWN0b3IsIGl0IHdhcyBuZXZlciBhZGRlZCB0byB0aGUgU2NlbmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2V0aGVyIHRoZSBhY3RvciBoYXMgYmVlbiBraWxsZWQuXG4gICAgICAgICAqIEBtZXRob2QgaXNLaWxsZWRcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmlzS2lsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzS2lsbGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIGNoaWxkIGFjdG9yIHRvIHRoaXMgYWN0b3IuIEFsbCBtb3ZlbWVudCBvZiB0aGUgY2hpbGQgYWN0b3Igd2lsbCBiZVxuICAgICAgICAgKiByZWxhdGl2ZSB0byB0aGUgcGFyZW50IGFjdG9yLiBNZWFuaW5nIGlmIHRoZSBwYXJlbnQgbW92ZXMgdGhlIGNoaWxkIHdpbGxcbiAgICAgICAgICogbW92ZSB3aXRoXG4gICAgICAgICAqIEBtZXRob2QgYWRkQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGNoaWxkIGFjdG9yIHRvIGFkZFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICBhY3Rvci5jb2xsaXNpb25UeXBlID0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgdGhpcy5zY2VuZU5vZGUuYWRkQ2hpbGQoYWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIGNoaWxkIGFjdG9yIGZyb20gdGhpcyBhY3Rvci5cbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgY2hpbGQgYWN0b3IgdG8gcmVtb3ZlXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVOb2RlLnJlbW92ZUNoaWxkKGFjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGN1cnJlbnQgZHJhd2luZyBvZiB0aGUgYWN0b3IgdG8gdGhlIGRyYXdpbmcgY29ycmVzcG9kaW5nIHRvXG4gICAgICAgICAqIHRoZSBrZXkuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0RHJhd2luZ1xuICAgICAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9IFRoZSBrZXkgb2YgdGhlIGRyYXdpbmdcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zZXREcmF3aW5nID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcgIT0gdGhpcy5mcmFtZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2tleV0ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSB0aGlzLmZyYW1lc1trZXldO1xuICAgICAgICB9O1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuYWRkRHJhd2luZyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnREcmF3aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIGV4LlNwcml0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERyYXdpbmcoXCJkZWZhdWx0XCIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBleC5UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRHJhd2luZyhcImRlZmF1bHRcIiwgYXJndW1lbnRzWzBdLmFzU3ByaXRlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFydGlmaWNpYWxseSB0cmlnZ2VyIGFuIGV2ZW50IG9uIGFuIGFjdG9yLCB1c2VmdWwgd2hlbiBjcmVhdGluZyBjdXN0b20gZXZlbnRzLlxuICAgICAgICAgKiBAbWV0aG9kIHRyaWdnZXJFdmVudFxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmlnZ2VyXG4gICAgICAgICAqIEBwYXJhbSBbZXZlbnQ9dW5kZWZpbmVkXSB7R2FtZUV2ZW50fSBUaGUgZXZlbnQgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIGEgY29sbGlzaW9uIGdyb3VwLiBBY3RvcnMgd2l0aCBubyBuYW1lZCBjb2xsaXNpb24gZ3JvdXAgYXJlXG4gICAgICAgICAqIGNvbnNpZGVyZWQgdG8gYmUgaW4gZXZlcnkgY29sbGlzaW9uIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbmNlIGluIGEgY29sbGlzaW9uIGdyb3VwKHMpIGFjdG9ycyB3aWxsIG9ubHkgY29sbGlkZSB3aXRoIG90aGVyIGFjdG9ycyBpblxuICAgICAgICAgKiB0aGF0IGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGFkZENvbGxpc2lvbkdyb3VwXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hZGRDb2xsaXNpb25Hcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5wdXNoKG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFuIGFjdG9yIGZyb20gYSBjb2xsaXNpb24gZ3JvdXAuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQ29sbGlzaW9uR3JvdXBcbiAgICAgICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJlbW92ZUNvbGxpc2lvbkdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29sbGlzaW9uR3JvdXBzLmluZGV4T2YobmFtZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY2VudGVyIHBvaW50IG9mIGFuIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Q2VudGVyXG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9nZXRDYWxjdWxhdGVkQW5jaG9yKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlZlY3Rvcih0aGlzLnggKyB0aGlzLmdldFdpZHRoKCkgLyAyLCB0aGlzLnkgKyB0aGlzLmdldEhlaWdodCgpIC8gMik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIGFuIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0V2lkdGhcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuc2NhbGUueDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHdpZHRoIG9mIGFuIGFjdG9yLCBmYWN0b3JpbmcgaW4gdGhlIGN1cnJlbnQgc2NhbGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRXaWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggLyB0aGlzLnNjYWxlLng7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiBhbiBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldEhlaWdodFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQgKiB0aGlzLnNjYWxlLnk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgYW4gYWN0b3IsIGZhY3RvcmluZyBpbiB0aGUgY3VycmVudCBzY2FsZVxuICAgICAgICAgKiBAbWV0aG9kIHNldEhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gdGhpcy5zY2FsZS55O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2VudGVycyB0aGUgYWN0b3IncyBkcmF3aW5nIGFyb3VuZCB0aGUgY2VudGVyIG9mIHRoZSBhY3RvcidzIGJvdW5kaW5nIGJveFxuICAgICAgICAgKiBAbWV0aG9kIHNldENlbnRlckRyYXdpbmdcbiAgICAgICAgICogQHBhcmFtIGNlbnRlciB7Ym9vbGVhbn0gSW5kaWNhdGVzIHRvIGNlbnRlciB0aGUgZHJhd2luZyBhcm91bmQgdGhlIGFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2V0Q2VudGVyRHJhd2luZyA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyRHJhd2luZ1kgPSBjZW50ZXI7XG4gICAgICAgICAgICB0aGlzLmNlbnRlckRyYXdpbmdYID0gY2VudGVyO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldExlZnRcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSByaWdodCBlZGdlIG9mIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldFJpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHRvcCBlZGdlIG9mIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldFRvcFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Qm90dG9tXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBHZXRzIHRoZSB4IHZhbHVlIG9mIHRoZSBBY3RvciBpbiBnbG9iYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgKiBAbWV0aG9kIGdldEdsb2JhbFhcbiAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEdsb2JhbFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy5wYXJlbnQuc2NhbGUueSArIHRoaXMucGFyZW50LmdldEdsb2JhbFgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogR2V0cyB0aGUgeSB2YWx1ZSBvZiB0aGUgQWN0b3IgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICAgICogQG1ldGhvZCBnZXRHbG9iYWxZXG4gICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRHbG9iYWxZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSAqIHRoaXMucGFyZW50LnNjYWxlLnkgKyB0aGlzLnBhcmVudC5nZXRHbG9iYWxZKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBnbG9iYWwgc2NhbGUgb2YgdGhlIEFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0R2xvYmFsU2NhbGVcbiAgICAgICAgICogQHJldHVybnMgUG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludCh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XG4gICAgICAgICAgICB2YXIgcGFyZW50U2NhbGUgPSB0aGlzLnBhcmVudC5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludCh0aGlzLnNjYWxlLnggKiBwYXJlbnRTY2FsZS54LCB0aGlzLnNjYWxlLnkgKiBwYXJlbnRTY2FsZS55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFjdG9yJ3MgYm91bmRpbmcgYm94IGNhbGN1bGF0ZWQgZm9yIHRoaXMgaW5zdGFudC5cbiAgICAgICAgICogQG1ldGhvZCBnZXRCb3VuZHNcbiAgICAgICAgICogQHJldHVybnMgQm91bmRpbmdCb3hcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZEFuY2hvcigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Cb3VuZGluZ0JveCh0aGlzLmdldEdsb2JhbFgoKSAtIGFuY2hvci54LCB0aGlzLmdldEdsb2JhbFkoKSAtIGFuY2hvci55LCB0aGlzLmdldEdsb2JhbFgoKSArIHRoaXMuZ2V0V2lkdGgoKSAtIGFuY2hvci54LCB0aGlzLmdldEdsb2JhbFkoKSArIHRoaXMuZ2V0SGVpZ2h0KCkgLSBhbmNob3IueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyB3aGV0aGVyIHRoZSB4L3kgc3BlY2lmaWVkIGFyZSBjb250YWluZWQgaW4gdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgY29udGFpbnNcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn0gWCBjb29yZGluYXRlIHRvIHRlc3QgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBZIGNvb3JkaW5hdGUgdG8gdGVzdCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMobmV3IGV4LlBvaW50KHgsIHkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNpZGUgb2YgdGhlIGNvbGxpc2lvbiBiYXNlZCBvbiB0aGUgaW50ZXJzZWN0aW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2lkZUZyb21JbnRlcnNlY3RcbiAgICAgICAgICogQHBhcmFtIGludGVyc2VjdCB7VmVjdG9yfSBUaGUgZGlzcGxhY2VtZW50IHZlY3RvciByZXR1cm5lZCBieSBhIGNvbGxpc2lvblxuICAgICAgICAgKiBAcmV0dXJucyBTaWRlXG4gICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRTaWRlRnJvbUludGVyc2VjdCA9IGZ1bmN0aW9uIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW50ZXJzZWN0LngpID4gTWF0aC5hYnMoaW50ZXJzZWN0LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3QueCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIFJpZ2h0ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIExlZnQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0LnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBCb3R0b20gKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogVG9wICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGFjdG9yIGhhcyBjb2xsaWRlZCB3aXRoIGFub3RoZXIgYWN0b3IsIHJldHVybnMgdGhlIHNpZGUgb2YgdGhlIGN1cnJlbnQgYWN0b3IgdGhhdCBjb2xsaWRlZC5cbiAgICAgICAgICogQG1ldGhvZCBjb2xsaWRlc1xuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgb3RoZXIgYWN0b3IgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyBTaWRlXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY29sbGlkZXNXaXRoU2lkZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRpb25WZWN0b3IgPSB0aGlzLmNvbGxpZGVzKGFjdG9yKTtcbiAgICAgICAgICAgIGlmICghc2VwYXJhdGlvblZlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc2VwYXJhdGlvblZlY3Rvci54KSA+IE1hdGguYWJzKHNlcGFyYXRpb25WZWN0b3IueSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy54IDwgYWN0b3IueCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNCAvKiBSaWdodCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIExlZnQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMueSA8IGFjdG9yLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQm90dG9tICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogVG9wICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGFjdG9yIGhhcyBjb2xsaWRlZCB3aXRoIGFub3RoZXIgYWN0b3IsIHJldHVybnMgdGhlIGludGVyc2VjdGlvbiB2ZWN0b3Igb24gY29sbGlzaW9uLiBSZXR1cm5zXG4gICAgICAgICAqIG51bGwgd2hlbiB0aGVyZSBpcyBubyBjb2xsaXNpb247XG4gICAgICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIG90aGVyIGFjdG9yIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgdmFyIG90aGVyQm91bmRzID0gYWN0b3IuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gYm91bmRzLmNvbGxpZGVzKG90aGVyQm91bmRzKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Q7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgdG8gZmlyZSB3aGVuIHRoaXMgYWN0b3IgY29sbGlkZXMgd2l0aCBhbm90aGVyIGluIGEgc3BlY2lmaWVkIGdyb3VwXG4gICAgICAgICAqIEBtZXRob2Qgb25Db2xsaWRlc1dpdGhcbiAgICAgICAgICogQHBhcmFtIGdyb3VwIHtzdHJpbmd9IFRoZSBncm91cCBuYW1lIHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIGZ1bmMge2NhbGxiYWNrfSBUaGUgY2FsbGJhY2sgdG8gZmlyZSBvbiBjb2xsaXNpb24gd2l0aCBhbm90aGVyIGFjdG9yIGZyb20gdGhlIGdyb3VwLiBUaGUgY2FsbGJhY2sgaXMgcGFzc2VkIHRoZSBvdGhlciBhY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5vbkNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uIChncm91cCwgZnVuYykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXS5wdXNoKGZ1bmMpO1xuICAgICAgICB9O1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlzaW9uSGFuZGxlcnM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBjb2xsaXNpb24gaGFuZGxlcnMgZm9yIHRoaXMgZ3JvdXAgb24gdGhpcyBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbGxpZGVzV2l0aFxuICAgICAgICAgKiBAcGFyYW0gZ3JvdXAge3N0cmluZ30gR3JvdXAgdG8gcmVtb3ZlIGFsbCBoYW5kbGVycyBmb3Igb24gdGhpcyBhY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yZW1vdmVDb2xsaWRlc1dpdGggPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXSA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gYWN0b3JzIGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGRpc3RhbmNlIHNwZWNpZmllZCBmcm9tIGVhY2ggb3RoZXJcbiAgICAgICAgICogQG1ldGhvZCB3aXRoaW5cbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gQWN0b3IgdG8gdGVzdFxuICAgICAgICAgKiBAcGFyYW0gZGlzdGFuY2Uge251bWJlcn0gRGlzdGFuY2UgaW4gcGl4ZWxzIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uIChhY3RvciwgZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0gYWN0b3IueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSBhY3Rvci55LCAyKSkgPD0gZGlzdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIHF1ZXVlZCBhY3Rpb25zIGZyb20gdGhlIEFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJBY3Rpb25zXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY2xlYXJBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmVhc2VUbyA9IGZ1bmN0aW9uICh4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSB7XG4gICAgICAgICAgICBpZiAoZWFzaW5nRmNuID09PSB2b2lkIDApIHsgZWFzaW5nRmNuID0gZXguRWFzaW5nRnVuY3Rpb25zLkxpbmVhcjsgfVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuRWFzZVRvKHRoaXMsIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtb3ZlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBhdCB0aGVcbiAgICAgICAgICogc3BlZWQgc3BlY2lmaWVkIChpbiBwaXhlbHMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xuICAgICAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgbW92ZVRvXG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSB4IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZVxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5LCBzcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuTW92ZVRvKHRoaXMsIHgsIHksIHNwZWVkKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbW92ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gYnkgYVxuICAgICAgICAgKiBjZXJ0YWluIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yXG4gICAgICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIG1vdmVCeVxuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xuICAgICAgICAgKiBAcGFyYW0gdGltZSB7bnVtYmVyfSBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0aGUgYWN0b3IgdG8gbW92ZSB0byB0aGUgbmV3IGxvY2F0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uICh4LCB5LCB0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5Nb3ZlQnkodGhpcywgeCwgeSwgdGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGF0IHRoZSBzcGVlZFxuICAgICAgICAgKiBzcGVjaWZpZWQgKGluIHJhZGlhbnMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xuICAgICAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2Qgcm90YXRlVG9cbiAgICAgICAgICogQHBhcmFtIGFuZ2xlUmFkaWFucyB7bnVtYmVyfSBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcbiAgICAgICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSByb3RhdGlvbiBzcGVjaWZpZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucm90YXRlVG8gPSBmdW5jdGlvbiAoYW5nbGVSYWRpYW5zLCBzcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuUm90YXRlVG8odGhpcywgYW5nbGVSYWRpYW5zLCBzcGVlZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGJ5IGEgY2VydGFpblxuICAgICAgICAgKiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnRcbiAgICAgICAgICogb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHJvdGF0ZUJ5XG4gICAgICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnMge251bWJlcn0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0byBpbiByYWRpYW5zXG4gICAgICAgICAqIEBwYXJhbSB0aW1lIHtudW1iZXJ9IFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRoZSBhY3RvciB0byBjb21wbGV0ZSB0aGUgcm90YXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucm90YXRlQnkgPSBmdW5jdGlvbiAoYW5nbGVSYWRpYW5zLCB0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5Sb3RhdGVCeSh0aGlzLCBhbmdsZVJhZGlhbnMsIHRpbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBzY2FsZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHNpemUgYXQgdGhlIHNwZWVkXG4gICAgICAgICAqIHNwZWNpZmllZCAoaW4gbWFnbml0dWRlIGluY3JlYXNlIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGVcbiAgICAgICAgICogYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmdcbiAgICAgICAgICogYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHNjYWxlVG9cbiAgICAgICAgICogQHBhcmFtIHNpemUge251bWJlcn0gVGhlIHNjYWxpbmcgZmFjdG9yIHRvIGFwcGx5XG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgc3BlZWQgb2Ygc2NhbGluZyBzcGVjaWZpZWQgaW4gbWFnbml0dWRlIGluY3JlYXNlIHBlciBzZWNvbmRcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zY2FsZVRvID0gZnVuY3Rpb24gKHNpemVYLCBzaXplWSwgc3BlZWRYLCBzcGVlZFkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLlNjYWxlVG8odGhpcywgc2l6ZVgsIHNpemVZLCBzcGVlZFgsIHNwZWVkWSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNjYWxlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgc2l6ZSBieSBhIGNlcnRhaW4gdGltZVxuICAgICAgICAgKiAoaW4gbWlsbGlzZWNvbmRzKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZVxuICAgICAgICAgKiBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBzY2FsZUJ5XG4gICAgICAgICAqIEBwYXJhbSBzaXplIHtudW1iZXJ9IFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseVxuICAgICAgICAgKiBAcGFyYW0gdGltZSB7bnVtYmVyfSBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0byBjb21wbGV0ZSB0aGUgc2NhbGluZyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zY2FsZUJ5ID0gZnVuY3Rpb24gKHNpemVYLCBzaXplWSwgdGltZSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuU2NhbGVCeSh0aGlzLCBzaXplWCwgc2l6ZVksIHRpbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvciB0byBibGluayAoYmVjb21lIHZpc2libGUgYW5kIG5vdFxuICAgICAgICAgKiB2aXNpYmxlKS4gT3B0aW9uYWxseSwgeW91IG1heSBzcGVjaWZ5IHRoZSBudW1iZXIgb2YgYmxpbmtzLiBTcGVjaWZ5IHRoZSBhbW91bnQgb2YgdGltZVxuICAgICAgICAgKiB0aGUgYWN0b3Igc2hvdWxkIGJlIHZpc2libGUgcGVyIGJsaW5rLCBhbmQgdGhlIGFtb3VudCBvZiB0aW1lIG5vdCB2aXNpYmxlLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBibGlua1xuICAgICAgICAgKiBAcGFyYW0gdGltZVZpc2libGUge251bWJlcn0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEBwYXJhbSB0aW1lTm90VmlzaWJsZSB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSBub3QgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEBwYXJhbSBbbnVtQmxpbmtzXSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGJsaW5rXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuYmxpbmsgPSBmdW5jdGlvbiAodGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpIHtcbiAgICAgICAgICAgIGlmIChudW1CbGlua3MgPT09IHZvaWQgMCkgeyBudW1CbGlua3MgPSAxOyB9XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5CbGluayh0aGlzLCB0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yJ3Mgb3BhY2l0eSB0byBjaGFuZ2UgZnJvbSBpdHMgY3VycmVudCB2YWx1ZVxuICAgICAgICAgKiB0byB0aGUgcHJvdmlkZWQgdmFsdWUgYnkgYSBzcGVjaWZpZWQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXNcbiAgICAgICAgICogcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgZmFkZVxuICAgICAgICAgKiBAcGFyYW0gb3BhY2l0eSB7bnVtYmVyfSBUaGUgZW5kaW5nIG9wYWNpdHlcbiAgICAgICAgICogQHBhcmFtIHRpbWUge251bWJlcn0gVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gZmFkZSB0aGUgYWN0b3IgKGluIG1pbGxpc2Vjb25kcylcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5mYWRlID0gZnVuY3Rpb24gKG9wYWNpdHksIHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkZhZGUodGhpcywgb3BhY2l0eSwgdGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBmcm9tIGV4ZWN1dGluZyBmb3IgYSBjZXJ0YWluXG4gICAgICAgICAqIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxuICAgICAgICAgKiAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBkZWxheVxuICAgICAgICAgKiBAcGFyYW0gdGltZSB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIG5leHQgYWN0aW9uIGluIHRoZSBxdWV1ZSBmcm9tIGV4ZWN1dGluZyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5EZWxheSh0aGlzLCB0aW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIGFuIGFjdGlvbiB0byB0aGUgcXVldWUgdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWN0b3IgZnJvbSB0aGVcbiAgICAgICAgICogc2NlbmUgb25jZSBpdCBoYXMgY29tcGxldGVkIGl0cyBwcmV2aW91cyBhY3Rpb25zLiBBbnkgYWN0aW9ucyBvbiB0aGVcbiAgICAgICAgICogYWN0aW9uIHF1ZXVlIGFmdGVyIHRoaXMgYWN0aW9uIHdpbGwgbm90IGJlIGV4ZWN1dGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGRpZVxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmRpZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkRpZSh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gY2FsbCBhbiBhcmJpdHJhcnkgbWV0aG9kIGFzIHRoZSBuZXh0IGFjdGlvbiBpbiB0aGVcbiAgICAgICAgICogYWN0aW9uIHF1ZXVlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBleGVjdXRlIGNvZGUgaW4gYWZ0ZXIgYSBzcGVjaWZpY1xuICAgICAgICAgKiBhY3Rpb24sIGkuZSBBbiBhY3RvciBhcnJpdmVzIGF0IGEgZGVzdGluYXRpbm8gYWZ0ZXIgdHJhdmVyc2luZyBhIHBhdGhcbiAgICAgICAgICogQG1ldGhvZCBjYWxsTWV0aG9kXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkNhbGxNZXRob2QodGhpcywgbWV0aG9kKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIHByZXZpb3VzbHlcbiAgICAgICAgICogY2FsbGVkIGFjdGlvbnMgYSBjZXJ0YWluIG51bWJlciBvZiB0aW1lcy4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXG4gICAgICAgICAqIGlzIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCByZXBlYXQgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZlxuICAgICAgICAgKiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmdcbiAgICAgICAgICogQG1ldGhvZCByZXBlYXRcbiAgICAgICAgICogQHBhcmFtIFt0aW1lcz11bmRlZmluZWRdIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGFsbCB0aGUgcHJldmlvdXMgYWN0aW9ucyBpbiB0aGUgYWN0aW9uIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHNwZWNpZmllZCB0aGUgYWN0aW9ucyB3aWxsIHJlcGVhdCBmb3JldmVyXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucmVwZWF0ID0gZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgICAgICBpZiAoIXRpbWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRGb3JldmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5SZXBlYXQodGhpcywgdGltZXMsIHRoaXMuYWN0aW9uUXVldWUuZ2V0QWN0aW9ucygpKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIHByZXZpb3VzbHlcbiAgICAgICAgICogY2FsbGVkIGFjdGlvbnMgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbidcbiAgICAgICAgICogZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgcmVwZWF0Rm9yZXZlclxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJlcGVhdEZvcmV2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5SZXBlYXRGb3JldmVyKHRoaXMsIHRoaXMuYWN0aW9uUXVldWUuZ2V0QWN0aW9ucygpKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIGZvbGxvdyBhbm90aGVyIGF0IGEgc3BlY2lmaWVkIGRpc3RhbmNlXG4gICAgICAgICAqIEBtZXRob2QgZm9sbG93XG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0byBmb2xsb3dcbiAgICAgICAgICogQHBhcmFtIFtmb2xsb3dEaXN0YW5jZT1jdXJyZW50RGlzdGFuY2VdIHtudW1iZXJ9IFRoZSBkaXN0YW5jZSB0byBtYWludGFpbiB3aGVuIGZvbGxvd2luZywgaWYgbm90IHNwZWNpZmllZCB0aGUgYWN0b3Igd2lsbCBmb2xsb3cgYXQgdGhlIGN1cnJlbnQgZGlzdGFuY2UuXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZm9sbG93ID0gZnVuY3Rpb24gKGFjdG9yLCBmb2xsb3dEaXN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKGZvbGxvd0Rpc3RhbmNlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkZvbGxvdyh0aGlzLCBhY3RvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuRm9sbG93KHRoaXMsIGFjdG9yLCBmb2xsb3dEaXN0YW5jZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byBtb3ZlIHRvd2FyZHMgYW5vdGhlciB1bnRpbCB0aGV5XG4gICAgICAgICAqIGNvbGxpZGUgXCJtZWV0XCIgYXQgYSBzcGVjaWZpZWQgc3BlZWQuXG4gICAgICAgICAqIEBtZXRob2QgbWVldFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gbWVldFxuICAgICAgICAgKiBAcGFyYW0gW3NwZWVkPTBdIHtudW1iZXJ9IFRoZSBzcGVlZCBpbiBwaXhlbHMgcGVyIHNlY29uZCB0byBtb3ZlLCBpZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgbWF0Y2ggdGhlIHNwZWVkIG9mIHRoZSBvdGhlciBhY3RvclxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm1lZXQgPSBmdW5jdGlvbiAoYWN0b3IsIHNwZWVkKSB7XG4gICAgICAgICAgICBpZiAoc3BlZWQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuTWVldCh0aGlzLCBhY3RvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuTWVldCh0aGlzLCBhY3Rvciwgc3BlZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjdXJyZW50IGFjdGlvbiBxdWV1ZSB1cCB0byBub3dcbiAgICAgICAgICogaXMgZmluaXNoZWQuXG4gICAgICAgICAqIEBtZXRob2QgYXNQcm9taXNlXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hc1Byb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdGhpcy5jYWxsTWV0aG9kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLl9nZXRDYWxjdWxhdGVkQW5jaG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludCh0aGlzLmdldFdpZHRoKCkgKiB0aGlzLmFuY2hvci54LCB0aGlzLmdldEhlaWdodCgpICogdGhpcy5hbmNob3IueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgdXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gVGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIGVuZ2luZVxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplKGVuZ2luZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaCgnaW5pdGlhbGl6ZScsIG5ldyBleC5Jbml0aWFsaXplRXZlbnQoZW5naW5lKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXZlbnREaXNwYXRjaGVyID0gdGhpcy5ldmVudERpc3BhdGNoZXI7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aW9uIHF1ZXVlXG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGlwZWxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpcGVsaW5lW2ldLnVwZGF0ZSh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKGV4LkV2ZW50VHlwZVs1IC8qIFVwZGF0ZSAqL10sIG5ldyBleC5VcGRhdGVFdmVudChkZWx0YSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIGRyYXdzIHRoZSBhY3RvciB0byB0aGUgc2NyZWVuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZHJhdyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT2ZmU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFuY2hvclBvaW50ID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZEFuY2hvcigpO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgY2hhbmdpbmcgb3BhY2l0eVxuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNPcGFjaXR5ICE9IHRoaXMub3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRyYXdpbmcgaW4gdGhpcy5mcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbZHJhd2luZ10uYWRkRWZmZWN0KG5ldyBleC5FZmZlY3RzLk9wYWNpdHkodGhpcy5vcGFjaXR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgeERpZmYgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB5RGlmZiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyRHJhd2luZ1gpIHtcbiAgICAgICAgICAgICAgICAgICAgeERpZmYgPSAodGhpcy5jdXJyZW50RHJhd2luZy53aWR0aCAqIHRoaXMuY3VycmVudERyYXdpbmcuZ2V0U2NhbGVYKCkgLSB0aGlzLmdldFdpZHRoKCkpIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2VudGVyRHJhd2luZ1kpIHtcbiAgICAgICAgICAgICAgICAgICAgeURpZmYgPSAodGhpcy5jdXJyZW50RHJhd2luZy5oZWlnaHQgKiB0aGlzLmN1cnJlbnREcmF3aW5nLmdldFNjYWxlWSgpIC0gdGhpcy5nZXRIZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nLmRyYXcoY3R4LCAteERpZmYgLSBhbmNob3JQb2ludC54LCAteURpZmYgLSBhbmNob3JQb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgtYW5jaG9yUG9pbnQueCwgLWFuY2hvclBvaW50LnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lTm9kZS5kcmF3KGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCBkcmF3cyB0aGUgYWN0b3JzIGRlYnVnZ2luZyB0byB0aGUgc2NyZWVuXG4gICAgICAgICAqIEBtZXRob2QgZGVidWdEcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIGJiLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGV4LkNvbG9yLlllbGxvdy50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgMywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGUgbmV4dCBpZCB0byBiZSBzZXRcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLm1heElkID0gMDtcbiAgICAgICAgcmV0dXJuIEFjdG9yO1xuICAgIH0pKGV4LkNsYXNzKTtcbiAgICBleC5BY3RvciA9IEFjdG9yO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBMb2dnaW5nIGxldmVsIHRoYXQgRXhjYWxpYnVyIHdpbGwgdGFnXG4gICAgICogQGNsYXNzIExvZ0xldmVsXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgIEBwcm9wZXJ0eSBEZWJ1ZyB7TG9nTGV2ZWx9XG4gICAgICAgICBAc3RhdGljXG4gICAgICAgICBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgSW5mbyB7TG9nTGV2ZWx9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgV2FybiB7TG9nTGV2ZWx9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgRXJyb3Ige0xvZ0xldmVsfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEZhdGFsIHtMb2dMZXZlbH1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJEZWJ1Z1wiXSA9IDBdID0gXCJEZWJ1Z1wiO1xuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAxXSA9IFwiSW5mb1wiO1xuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5cIl0gPSAyXSA9IFwiV2FyblwiO1xuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVycm9yXCJdID0gM10gPSBcIkVycm9yXCI7XG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA0XSA9IFwiRmF0YWxcIjtcbiAgICB9KShleC5Mb2dMZXZlbCB8fCAoZXguTG9nTGV2ZWwgPSB7fSkpO1xuICAgIHZhciBMb2dMZXZlbCA9IGV4LkxvZ0xldmVsO1xuICAgIC8qKlxuICAgICAqIFN0YXRpYyBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzIHRoZSBsb2dnaW5nIGZhY2lsaXR5IGZvciBFeGNhbGlidXIuXG4gICAgICogRXhjYWxpYnVyIGNvbWVzIGJ1aWx0LWluIHdpdGggYSBDb25zb2xlQXBwZW5kZXIgYW5kIFNjcmVlbkFwcGVuZGVyLlxuICAgICAqIERlcml2ZSBmcm9tIElBcHBlbmRlciB0byBjcmVhdGUgeW91ciBvd24gbG9nZ2luZyBhcHBlbmRlcnMuXG4gICAgICogQGNsYXNzIExvZ2dlclxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YXIgTG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG9nZ2VyKCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRlcnMgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBkZWZhdWx0IGxvZ2dpbmcgbGV2ZWwuIEV4Y2FsaWJ1ciB3aWxsIG9ubHkgbG9nXG4gICAgICAgICAgICAgKiBtZXNzYWdlcyBpZiBlcXVhbCB0byBvciBhYm92ZSB0aGlzIGxldmVsLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRMZXZlbCB7TG9nTGV2ZWx9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExldmVsID0gMSAvKiBJbmZvICovO1xuICAgICAgICAgICAgaWYgKExvZ2dlci5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dnZXIgaXMgYSBzaW5nbGV0b25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2dnZXIuX2luc3RhbmNlID0gdGhpcztcbiAgICAgICAgICAgIC8vIERlZmF1bHQgY29uc29sZSBhcHBlbmRlclxuICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZS5hZGRBcHBlbmRlcihuZXcgQ29uc29sZUFwcGVuZGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIExvZ2dlci5faW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGljIGluc3RhbmNlIG9mIExvZ2dlclxuICAgICAgICAgKiBAbWV0aG9kIGdldEluc3RhbmNlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHJldHVybnMgTG9nZ2VyXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoTG9nZ2VyLl9pbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZSA9IG5ldyBMb2dnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBMb2dnZXIuX2luc3RhbmNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG5ldyBJQXBwZW5kZXIgdG8gdGhlIGxpc3Qgb2YgYXBwZW5kZXJzIHRvIHdyaXRlIHRvXG4gICAgICAgICAqIEBtZXRob2QgYWRkQXBwZW5kZXJcbiAgICAgICAgICogQHBhcmFtIGFwcGVuZGVyIHtJQXBwZW5kZXJ9IEFwcGVuZGVyIHRvIGFkZFxuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5hZGRBcHBlbmRlciA9IGZ1bmN0aW9uIChhcHBlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRlcnMucHVzaChhcHBlbmRlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIGFwcGVuZGVycyBmcm9tIHRoZSBsb2dnZXJcbiAgICAgICAgICogQG1ldGhvZCBjbGVhckFwcGVuZGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5jbGVhckFwcGVuZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIExvZ0xldmVsXG4gICAgICAgICAqIEBtZXRob2QgX2xvZ1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gbGV2ZWwge0xvZ0xldmVsfVRoZSBMb2dMZXZlbGB0byBsb2cgdGhlIG1lc3NhZ2UgYXRcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHdyaXRlIHRvIGFuIGFwcGVuZGVyXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldmVsID0gdGhpcy5kZWZhdWx0TGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChhcHBlbmRlcikge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSBfdGhpcy5kZWZhdWx0TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kZXIubG9nKGxldmVsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBMb2dMZXZlbC5EZWJ1ZyBsZXZlbFxuICAgICAgICAgKiBAbWV0aG9kIGRlYnVnXG4gICAgICAgICAqIEBwYXJhbSAuLi5hcmdzIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nKDAgLyogRGVidWcgKi8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIExvZ0xldmVsLkluZm8gbGV2ZWxcbiAgICAgICAgICogQG1ldGhvZCBpbmZvXG4gICAgICAgICAqIEBwYXJhbSAuLi5hcmdzIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2coMSAvKiBJbmZvICovLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBMb2dMZXZlbC5XYXJuIGxldmVsXG4gICAgICAgICAqIEBtZXRob2Qgd2FyblxuICAgICAgICAgKiBAcGFyYW0gLi4uYXJncyBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nKDIgLyogV2FybiAqLywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgTG9nTGV2ZWwuRXJyb3IgbGV2ZWxcbiAgICAgICAgICogQG1ldGhvZCBlcnJvclxuICAgICAgICAgKiBAcGFyYW0gLi4uYXJncyBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvZygzIC8qIEVycm9yICovLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBMb2dMZXZlbC5GYXRhbCBsZXZlbFxuICAgICAgICAgKiBAbWV0aG9kIGZhdGFsXG4gICAgICAgICAqIEBwYXJhbSAuLi5hcmdzIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nKDQgLyogRmF0YWwgKi8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBMb2dnZXIuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIExvZ2dlcjtcbiAgICB9KSgpO1xuICAgIGV4LkxvZ2dlciA9IExvZ2dlcjtcbiAgICAvKipcbiAgICAgKiBDb25zb2xlIGFwcGVuZGVyIGZvciBicm93c2VycyAoaS5lLiBjb25zb2xlLmxvZylcbiAgICAgKiBAY2xhc3MgQ29uc29sZUFwcGVuZGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgSUFwcGVuZGVyXG4gICAgICovXG4gICAgdmFyIENvbnNvbGVBcHBlbmRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbnNvbGVBcHBlbmRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBDb25zb2xlQXBwZW5kZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbnNvbGUgc3VwcG9ydFxuICAgICAgICAgICAgaWYgKCFjb25zb2xlICYmICFjb25zb2xlLmxvZyAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8gbWF5YmUgZG8gc29tZXRoaW5nIGJldHRlciB0aGFuIG5vdGhpbmdcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29uc29sZSBhcmdzIGFycmF5XG4gICAgICAgICAgICB2YXIgY29uc29sZUFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGNvbnNvbGVBcmdzLnVuc2hpZnQuYXBwbHkoY29uc29sZUFyZ3MsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc29sZUFyZ3MudW5zaGlmdChcIltcIiArIExvZ0xldmVsW2xldmVsXSArIFwiXSA6IFwiKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IDIgLyogV2FybiAqLykge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgLmxvZyBmb3IgRGVidWcvSW5mb1xuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIG9uIHNvbWUgb2xkZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGFwcGx5IG9uIGNvbnNvbGUubG9nIDooXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGV2ZWwgPCAzIC8qIEVycm9yICovKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCAud2FybiBmb3IgV2FyblxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4uYXBwbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybihjb25zb2xlQXJncy5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgLmVycm9yIGZvciBFcnJvci9GYXRhbFxuICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihjb25zb2xlQXJncy5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbnNvbGVBcHBlbmRlcjtcbiAgICB9KSgpO1xuICAgIGV4LkNvbnNvbGVBcHBlbmRlciA9IENvbnNvbGVBcHBlbmRlcjtcbiAgICAvKipcbiAgICAgKiBPbi1zY3JlZW4gKGNhbnZhcykgYXBwZW5kZXJcbiAgICAgKiBAdG9kbyBDbGVhbiB0aGlzIHVwXG4gICAgICogQGNsYXNzIFNjcmVlbkFwcGVuZGVyXG4gICAgICogQGV4dGVuZHMgSUFwcGVuZGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9IFdpZHRoIG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfSBIZWlnaHQgb2YgdGhlIHNjcmVlbiBhcHBlbmRlciBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICB2YXIgU2NyZWVuQXBwZW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTY3JlZW5BcHBlbmRlcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGggfHwgd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgfHwgd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgU2NyZWVuQXBwZW5kZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXMudW5zaGlmdChcIltcIiArIExvZ0xldmVsW2xldmVsXSArIFwiXSA6IFwiICsgbWVzc2FnZSk7XG4gICAgICAgICAgICB2YXIgcG9zID0gMTA7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IDEuMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwnICsgb3BhY2l0eS50b0ZpeGVkKDIpICsgJyknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KHRoaXMuX21lc3NhZ2VzW2ldLCAyMDAsIHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zICs9IDEwO1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5ID4gMCA/IG9wYWNpdHkgLSAuMDUgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2NyZWVuQXBwZW5kZXI7XG4gICAgfSkoKTtcbiAgICBleC5TY3JlZW5BcHBlbmRlciA9IFNjcmVlbkFwcGVuZGVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2cudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEFuIGVudW0gcmVwcmVzZW50aW5nIGFsbCBvZiB0aGUgYnVpbHQgaW4gZXZlbnQgdHlwZXMgZm9yIEV4Y2FsaWJ1clxuICAgICAqIEBjbGFzcyBFdmVudFR5cGVcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFVzZXJFdmVudCB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEJsdXIge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBGb2N1cyB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFVwZGF0ZSB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEVudGVyVmlld1BvcnQge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBFeGl0Vmlld1BvcnQge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBBY3RpdmF0ZSB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IERlYWN0aXZhdGUge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBJbml0aWFsaXplIHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJDb2xsaXNpb25cIl0gPSAwXSA9IFwiQ29sbGlzaW9uXCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJFbnRlclZpZXdQb3J0XCJdID0gMV0gPSBcIkVudGVyVmlld1BvcnRcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkV4aXRWaWV3UG9ydFwiXSA9IDJdID0gXCJFeGl0Vmlld1BvcnRcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkJsdXJcIl0gPSAzXSA9IFwiQmx1clwiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiRm9jdXNcIl0gPSA0XSA9IFwiRm9jdXNcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIlVwZGF0ZVwiXSA9IDVdID0gXCJVcGRhdGVcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkFjdGl2YXRlXCJdID0gNl0gPSBcIkFjdGl2YXRlXCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJEZWFjdGl2YXRlXCJdID0gN10gPSBcIkRlYWN0aXZhdGVcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkluaXRpYWxpemVcIl0gPSA4XSA9IFwiSW5pdGlhbGl6ZVwiO1xuICAgIH0pKGV4LkV2ZW50VHlwZSB8fCAoZXguRXZlbnRUeXBlID0ge30pKTtcbiAgICB2YXIgRXZlbnRUeXBlID0gZXguRXZlbnRUeXBlO1xuICAgIC8qKlxuICAgICAqIEJhc2UgZXZlbnQgdHlwZSBpbiBFeGNhbGlidXIgdGhhdCBhbGwgb3RoZXIgZXZlbnQgdHlwZXMgZGVyaXZlIGZyb20uXG4gICAgICpcbiAgICAgKiBAY2xhc3MgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHRhcmdldCB7YW55fSBFdmVudHMgY2FuIGhhdmUgdGFyZ2V0IGdhbWUgb2JqZWN0LCBsaWtlIHRoZSBFbmdpbmUsIG9yIGFuIEFjdG9yLlxuICAgICAqL1xuICAgIHZhciBHYW1lRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBHYW1lRXZlbnQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdhbWVFdmVudDtcbiAgICB9KSgpO1xuICAgIGV4LkdhbWVFdmVudCA9IEdhbWVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCByZWNlaXZlZCBieSB0aGUgRW5naW5lIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqIEBjbGFzcyBWaXNpYmxlRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVmlzaWJsZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFZpc2libGVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVmlzaWJsZUV2ZW50KCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFZpc2libGVFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LlZpc2libGVFdmVudCA9IFZpc2libGVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCByZWNlaXZlZCBieSB0aGUgRW5naW5lIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIGhpZGRlblxuICAgICAqXG4gICAgICogQGNsYXNzIEhpZGRlbkV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEhpZGRlbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEhpZGRlbkV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBIaWRkZW5FdmVudCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIaWRkZW5FdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkhpZGRlbkV2ZW50ID0gSGlkZGVuRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIGFjdG9yIHdoZW4gYSBjb2xsaXNpb24gaGFzIG9jY3VyZWRcbiAgICAgKlxuICAgICAqIEBjbGFzcyBDb2xsaXNpb25FdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0aGUgZXZlbnQgd2FzIHRocm93biBvblxuICAgICAqIEBwYXJhbSBvdGhlciB7QWN0b3J9IFRoZSBhY3RvciB0aGF0IHdhcyBjb2xsaWRlZCB3aXRoXG4gICAgICogQHBhcmFtIHNpZGUge1NpZGV9IFRoZSBzaWRlIHRoYXQgd2FzIGNvbGxpZGVkIHdpdGhcbiAgICAgKi9cbiAgICB2YXIgQ29sbGlzaW9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQ29sbGlzaW9uRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvbkV2ZW50KGFjdG9yLCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcbiAgICAgICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5Db2xsaXNpb25FdmVudCA9IENvbGxpc2lvbkV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIGdhbWUgb2JqZWN0IG9uIEV4Y2FsaWJ1ciB1cGRhdGVcbiAgICAgKlxuICAgICAqIEBjbGFzcyBVcGRhdGVFdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcbiAgICAgKi9cbiAgICB2YXIgVXBkYXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVXBkYXRlRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFVwZGF0ZUV2ZW50KGRlbHRhKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXBkYXRlRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5VcGRhdGVFdmVudCA9IFVwZGF0ZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBBY3RvciBvbmx5IG9uY2UgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgY2FsbFxuICAgICAqXG4gICAgICogQGNsYXNzIEluaXRpYWxpemVFdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gVGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBlbmdpbmVcbiAgICAgKi9cbiAgICB2YXIgSW5pdGlhbGl6ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEluaXRpYWxpemVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW5pdGlhbGl6ZUV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguSW5pdGlhbGl6ZUV2ZW50ID0gSW5pdGlhbGl6ZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIFNjZW5lIG9uIGFjdGl2YXRpb25cbiAgICAgKlxuICAgICAqIEBjbGFzcyBBY3RpdmF0ZUV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIG9sZFNjZW5lIHtTY2VuZX0gVGhlIHJlZmVyZW5jZSB0byB0aGUgb2xkIHNjZW5lXG4gICAgICovXG4gICAgdmFyIEFjdGl2YXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQWN0aXZhdGVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQWN0aXZhdGVFdmVudChvbGRTY2VuZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9sZFNjZW5lID0gb2xkU2NlbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFjdGl2YXRlRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5BY3RpdmF0ZUV2ZW50ID0gQWN0aXZhdGVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYSBTY2VuZSBvbiBkZWFjdGl2YXRpb25cbiAgICAgKlxuICAgICAqIEBjbGFzcyBEZWFjdGl2YXRlRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gbmV3U2NlbmUge1NjZW5lfSBUaGUgcmVmZXJlbmNlIHRvIHRoZSBuZXcgc2NlbmVcbiAgICAgKi9cbiAgICB2YXIgRGVhY3RpdmF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKERlYWN0aXZhdGVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGVhY3RpdmF0ZUV2ZW50KG5ld1NjZW5lKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubmV3U2NlbmUgPSBuZXdTY2VuZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVhY3RpdmF0ZUV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguRGVhY3RpdmF0ZUV2ZW50ID0gRGVhY3RpdmF0ZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBBY3RvciB3aGVuIGl0IGNvbXBsZXRlbHkgbGVhdmVzIHRoZSBzY3JlZW4uXG4gICAgICogQGNsYXNzIEV4aXRWaWV3UG9ydEV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEV4aXRWaWV3UG9ydEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEV4aXRWaWV3UG9ydEV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFeGl0Vmlld1BvcnRFdmVudCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFeGl0Vmlld1BvcnRFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkV4aXRWaWV3UG9ydEV2ZW50ID0gRXhpdFZpZXdQb3J0RXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIEFjdG9yIHdoZW4gaXQgY29tcGxldGVseSBsZWF2ZXMgdGhlIHNjcmVlbi5cbiAgICAgKiBAY2xhc3MgRW50ZXJWaWV3UG9ydEV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEVudGVyVmlld1BvcnRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhFbnRlclZpZXdQb3J0RXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVudGVyVmlld1BvcnRFdmVudCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFbnRlclZpZXdQb3J0RXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5FbnRlclZpZXdQb3J0RXZlbnQgPSBFbnRlclZpZXdQb3J0RXZlbnQ7XG4gICAgLyoqXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBtb3VzZSBidXR0b25zXG4gICAgICogQGNsYXNzIE1vdXNlQnV0dG9uXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChNb3VzZUJ1dHRvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IExlZnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlQnV0dG9uW01vdXNlQnV0dG9uW1wiTWlkZGxlXCJdID0gMV0gPSBcIk1pZGRsZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IExlZnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXCJSaWdodFwiXSA9IDJdID0gXCJSaWdodFwiO1xuICAgIH0pKGV4Lk1vdXNlQnV0dG9uIHx8IChleC5Nb3VzZUJ1dHRvbiA9IHt9KSk7XG4gICAgdmFyIE1vdXNlQnV0dG9uID0gZXguTW91c2VCdXR0b247XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50cy50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogRXhjYWxpYnVyJ3MgaW50ZXJuYWwgZXZlbnQgZGlzcGF0Y2hlciBpbXBsZW1lbnRhdGlvbi4gQ2FsbGJhY2tzIGFyZSBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciBhbiBldmVudCBpcyBwdWJsaXNoZWRcbiAgICAgKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHRhcmdldCB7YW55fSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0aGUgcmVjaXBpZW50IG9mIGV2ZW50cyBmcm9tIHRoaXMgZXZlbnQgZGlzcGF0Y2hlclxuICAgICAqL1xuICAgIHZhciBFdmVudERpc3BhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2cgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaXNoIGFuIGV2ZW50IGZvciB0YXJnZXRcbiAgICAgICAgICogQG1ldGhvZCBwdWJsaXNoXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICAgICAgICogQHBhcmFtIFtldmVudD11bmRlZmluZWRdIHtHYW1lRXZlbnR9IE9wdGlvbmFsbHkgcGFzcyBhbiBldmVudCBkYXRhIG9iamVjdCB0byB0aGUgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8ga2V5IG5vdCBtYXBwZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBleC5HYW1lRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXIgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWUsIG11bHRpcGxlIGhhbmRsZXJzIHBlciBldmVudCBuYW1lIGFyZSBhbGxvd2VkLlxuICAgICAgICAgKiBAbWV0aG9kIHN1YnNjcmliZVxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG9cbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIge0dhbWVFdmVudD0+dm9pZH0gVGhlIGhhbmRsZXIgY2FsbGJhY2sgdG8gZmlyZSBvbiB0aGlzIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5zdWJzY3JpYmUgYSBldmVudCBoYW5kbGVyKHMpIGZyb20gYW4gZXZlbnQuIElmIGEgc3BlY2lmaWMgaGFuZGxlclxuICAgICAgICAgKiBpcyBzcGVjaWZpZWQgZm9yIGFuIGV2ZW50LCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogT3RoZXJ3aXNlIGFsbCBoYW5kbGVycyB3aWxsIGJlIHVuc3Vic2NyaWJlZCBmb3IgdGhhdCBldmVudC5cbiAgICAgICAgICogQG1ldGhvZCB1bnN1YnNjcmliZVxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB1bnN1YnNjcmliZVxuICAgICAgICAgKiBAcGFyYW0gW2hhbmRsZXI9dW5kZWZpbmVkXSBPcHRpb25hbGx5IHRoZSBzcGVjaWZpYyBoYW5kbGVyIHRvIHVuc3Vic2NyaWJlXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGV4cGxpY2l0IGhhbmRsZXIgaXMgZ2l2ZSB3aXRoIHRoZSBldmVudCBuYW1lIGNsZWFyIGFsbCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudERpc3BhdGNoZXI7XG4gICAgfSkoKTtcbiAgICBleC5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBDb2xvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYW4gciwgZywgYiwgYVxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgQ29sb3JcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSByIHtudW1iZXJ9IFRoZSByZWQgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcbiAgICAgICAgICogQHBhcmFtIGcge251bWJlcn0gVGhlIGdyZWVuIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBiIHtudW1iZXJ9IFRoZSBibHVlIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBbYT0xXSB7bnVtYmVyfSBUaGUgYWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICgwLTEuMClcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENvbG9yKHIsIGcsIGIsIGEpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLmcgPSBnO1xuICAgICAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgICAgICB0aGlzLmEgPSAoYSAhPSBudWxsID8gYSA6IDEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYW4gciwgZywgYiwgYVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGZyb21SR0JcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gciB7bnVtYmVyfSBUaGUgcmVkIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBnIHtudW1iZXJ9IFRoZSBncmVlbiBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxuICAgICAgICAgKiBAcGFyYW0gYiB7bnVtYmVyfSBUaGUgYmx1ZSBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxuICAgICAgICAgKiBAcGFyYW0gW2E9MV0ge251bWJlcn0gVGhlIGFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAoMC0xLjApXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5mcm9tUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2NhbmNlIG9mIENvbG9yIGZyb20gYSBoZXggc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZnJvbUhleFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSBoZXgge3N0cmluZ30gQ1NTIGNvbG9yIHN0cmluZyBvZiB0aGUgZm9ybSAjZmZmZmZmLCB0aGUgYWxwaGEgY29tcG9uZW50IGlzIG9wdGlvbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5mcm9tSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgICAgICAgICAgdmFyIGhleFJlZ0V4ID0gL14jPyhbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSk/JC9pO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9IGhleC5tYXRjaChoZXhSZWdFeCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBwYXJzZUludChtYXRjaFs0XSwgMTYpIC8gMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBoZXggc3RyaW5nOiBcIiArIGhleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxuICAgICAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICAgICAqIEByZXR1cm5zIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFN0cmluZyh0aGlzLnIudG9GaXhlZCgwKSkgKyBcIiwgXCIgKyBTdHJpbmcodGhpcy5nLnRvRml4ZWQoMCkpICsgXCIsIFwiICsgU3RyaW5nKHRoaXMuYi50b0ZpeGVkKDApKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmEgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmVzdWx0ICsgXCIsIFwiICsgU3RyaW5nKHRoaXMuYSkgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcInJnYihcIiArIHJlc3VsdCArIFwiKVwiO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cbiAgICAgICAgICogQG1ldGhvZCBmaWxsU3R5bGVcbiAgICAgICAgICogQHJldHVybnMgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5wcm90b3R5cGUuZmlsbFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBjb2xvci5cbiAgICAgICAgICogQG1ldGhvZCBjbG9uZVxuICAgICAgICAgKiBAcmV0dXJucyBDb2xvclxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEJsYWNrIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkJsYWNrID0gQ29sb3IuZnJvbUhleCgnIzAwMDAwMCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFdoaXRlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLldoaXRlID0gQ29sb3IuZnJvbUhleCgnI0ZGRkZGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEdyYXkge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuR3JheSA9IENvbG9yLmZyb21IZXgoJyM4MDgwODAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBMaWdodEdyYXkge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuTGlnaHRHcmF5ID0gQ29sb3IuZnJvbUhleCgnI0QzRDNEMycpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IERhcmtHcmF5IHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkRhcmtHcmF5ID0gQ29sb3IuZnJvbUhleCgnI0E5QTlBOScpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFllbGxvdyB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5ZZWxsb3cgPSBDb2xvci5mcm9tSGV4KCcjRkZGRjAwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgT3JhbmdlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLk9yYW5nZSA9IENvbG9yLmZyb21IZXgoJyNGRkE1MDAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBSZWQge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuUmVkID0gQ29sb3IuZnJvbUhleCgnI0ZGMDAwMCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFZlcm1pbGxpb24ge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuVmVybWlsbGlvbiA9IENvbG9yLmZyb21IZXgoJyNGRjVCMzEnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBSb3NlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLlJvc2UgPSBDb2xvci5mcm9tSGV4KCcjRkYwMDdGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgTWFnZW50YSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5NYWdlbnRhID0gQ29sb3IuZnJvbUhleCgnI0ZGMDBGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFZpb2xldCB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5WaW9sZXQgPSBDb2xvci5mcm9tSGV4KCcjN0YwMEZGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgQmx1ZSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5CbHVlID0gQ29sb3IuZnJvbUhleCgnIzAwMDBGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEF6dXJlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkF6dXJlID0gQ29sb3IuZnJvbUhleCgnIzAwN0ZGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEN5YW4ge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuQ3lhbiA9IENvbG9yLmZyb21IZXgoJyMwMEZGRkYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBWaXJpZGlhbiB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5WaXJpZGlhbiA9IENvbG9yLmZyb21IZXgoJyM1OTk3OEYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBHcmVlbiB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5HcmVlbiA9IENvbG9yLmZyb21IZXgoJyMwMEZGMDAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBDaGFydHJldXNlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkNoYXJ0cmV1c2UgPSBDb2xvci5mcm9tSGV4KCcjN0ZGRjAwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgVHJhbnNwYXJlbnQge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuVHJhbnNwYXJlbnQgPSBDb2xvci5mcm9tSGV4KCcjRkZGRkZGMDAnKTtcbiAgICAgICAgcmV0dXJuIENvbG9yO1xuICAgIH0pKCk7XG4gICAgZXguQ29sb3IgPSBDb2xvcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBBY3RvciBwcmltaXRpdmUgZm9yIGRyYXdpbmcgVUkncywgb3B0aW1pemVkIGZvciBVSSBkcmF3aW5nLiBEb2VzXG4gICAgICogbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMuXG4gICAgICogQGNsYXNzIFVJQWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBBY3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbeD0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyB4IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFt5PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHkgY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW3dpZHRoPTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHdpZHRoIG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbaGVpZ2h0PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIGhlaWdodCBvZiB0aGUgYWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVUlBY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhVSUFjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBVSUFjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5Nb3ZlbWVudE1vZHVsZSgpKTtcbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUucHVzaChuZXcgZXguQ2FwdHVyZVBvaW50ZXJNb2R1bGUoKSk7XG4gICAgICAgICAgICB0aGlzLmFuY2hvci5zZXRUbygwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2FwdHVyZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFVJQWN0b3IucHJvdG90eXBlLm9uSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfTtcbiAgICAgICAgVUlBY3Rvci5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoeCwgeSwgdXNlV29ybGQpIHtcbiAgICAgICAgICAgIGlmICh1c2VXb3JsZCA9PT0gdm9pZCAwKSB7IHVzZVdvcmxkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHVzZVdvcmxkKVxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbnRhaW5zLmNhbGwodGhpcywgeCwgeSk7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5fZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhuZXcgZXguUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29udGFpbnMuY2FsbCh0aGlzLCBjb29yZHMueCwgY29vcmRzLnkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVUlBY3RvcjtcbiAgICB9KShleC5BY3Rvcik7XG4gICAgZXguVUlBY3RvciA9IFVJQWN0b3I7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgbWV0aG9kIG9mIGZpcmluZyBhcmJpdHJhcnkgY29kZSBvbiBjb2xsaXNpb24uIFRoZXNlIGFyZSB1c2VmdWxcbiAgICAgKiBhcyAnYnV0dG9ucycsICdzd2l0Y2hlcycsIG9yIHRvIHRyaWdnZXIgZWZmZWN0cyBpbiBhIGdhbWUuIEJ5IGRlZnVhbHQgdHJpZ2dlcnNcbiAgICAgKiBhcmUgaW52aXNpYmxlLCBhbmQgY2FuIG9ubHkgYmUgc2VlbiB3aXRoIGRlYnVnIG1vZGUgZW5hYmxlZCBvbiB0aGUgRW5naW5lLlxuICAgICAqIEBjbGFzcyBUcmlnZ2VyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt4PTBdIHtudW1iZXJ9IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIFt5PTBdIHtudW1iZXJ9IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIFt3aWR0aD0wXSB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0gW2hlaWdodD0wXSB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIFthY3Rpb249bnVsbF0geygpPT52b2lkfSBDYWxsYmFjayB0byBmaXJlIHdoZW4gdHJpZ2dlciBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAcGFyYW0gW3JlcGVhdHM9MV0ge251bWJlcn0gVGhlIG51bWJlciBvZiB0aW1lcyB0aGF0IHRoaXMgdHJpZ2dlciBzaG91bGQgZmlyZSwgYnkgZGVmYXVsdCBpdCBpcyAxLCBpZiAtMSBpcyBzdXBwbGllZCBpdCB3aWxsIGZpcmUgaW5kZWZpbml0ZWx5XG4gICAgICovXG4gICAgdmFyIFRyaWdnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVHJpZ2dlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVHJpZ2dlcih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBhY3Rpb24sIHJlcGVhdHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRzID0gMTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IHJlcGVhdHMgfHwgdGhpcy5yZXBlYXRzO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb24gfHwgdGhpcy5hY3Rpb247XG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblR5cGUgPSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBleC5FdmVudERpc3BhdGNoZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlID0gbmV3IGV4LkludGVybmFsLkFjdGlvbnMuQWN0aW9uUXVldWUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpb24gcXVldWVcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwbGFjZW1lbnRzIGJhc2VkIG9uIGxpbmVhciBhbGdlYnJhXG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy5keCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLmR5ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiArPSB0aGlzLnJ4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy5zY2FsZS54ICs9IHRoaXMuc3ggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgKz0gdGhpcy5zeSAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0cmlnZ2VyIGNvbGxpc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbGxpZGVzKHRoaXMudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoQWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmdpbmUuY3VycmVudFNjZW5lLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGVuZ2luZS5jdXJyZW50U2NlbmUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlciAhPT0gdGhpcyAmJiBvdGhlci5jb2xsaXNpb25UeXBlICE9PSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi8gJiYgdGhpcy5jb2xsaWRlcyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hBY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmlnZ2VyIGlmIGl0cyBkb25lLCAtMSByZXBlYXQgZm9yZXZlclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMua2lsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS5kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdHMtLTtcbiAgICAgICAgfTtcbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBkb2VzIG5vdCBkcmF3XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcbiAgICAgICAgICAgIC8vIE1lYW50IHRvIGRyYXcgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgYWN0b3JzXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgYmIubGVmdCA9IGJiLmxlZnQgLSB0aGlzLmdldEdsb2JhbFgoKTtcbiAgICAgICAgICAgIGJiLnJpZ2h0ID0gYmIucmlnaHQgLSB0aGlzLmdldEdsb2JhbFgoKTtcbiAgICAgICAgICAgIGJiLnRvcCA9IGJiLnRvcCAtIHRoaXMuZ2V0R2xvYmFsWSgpO1xuICAgICAgICAgICAgYmIuYm90dG9tID0gYmIuYm90dG9tIC0gdGhpcy5nZXRHbG9iYWxZKCk7XG4gICAgICAgICAgICAvLyBDdXJyZW50bHkgY29sbGlzaW9uIHByaW1pdGl2ZXMgY2Fubm90IHJvdGF0ZSBcbiAgICAgICAgICAgIC8vIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZXguQ29sb3IuVmlvbGV0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBleC5Db2xvci5WaW9sZXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnVHJpZ2dlcicsIDEwLCAxMCk7XG4gICAgICAgICAgICBiYi5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUcmlnZ2VyO1xuICAgIH0pKGV4LkFjdG9yKTtcbiAgICBleC5UcmlnZ2VyID0gVHJpZ2dlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRW5naW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbGdlYnJhLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVdGlsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQW4gZW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHR5cGVzIG9mIGVtaXR0ZXIgbm96emxlc1xuICAgICAqIEBjbGFzcyBFbWl0dGVyVHlwZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoRW1pdHRlclR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IGZvciB0aGUgY2lyY3VsYXIgZW1pdHRlciB0eXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBDaXJjbGUge0VtaXR0ZXJUeXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJDaXJjbGVcIl0gPSAwXSA9IFwiQ2lyY2xlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCBmb3IgdGhlIHJlY3Rhbmd1bGFyIGVtaXR0ZXIgdHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkgUmVjdGFuZ2xlIHtFbWl0dGVyVHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIEVtaXR0ZXJUeXBlW0VtaXR0ZXJUeXBlW1wiUmVjdGFuZ2xlXCJdID0gMV0gPSBcIlJlY3RhbmdsZVwiO1xuICAgIH0pKGV4LkVtaXR0ZXJUeXBlIHx8IChleC5FbWl0dGVyVHlwZSA9IHt9KSk7XG4gICAgdmFyIEVtaXR0ZXJUeXBlID0gZXguRW1pdHRlclR5cGU7XG4gICAgdmFyIFBhcnRpY2xlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGUoZW1pdHRlciwgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgZXguVmVjdG9yKDAsIDApO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBleC5WZWN0b3IoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBleC5WZWN0b3IoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gMDtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBleC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5lbmRDb2xvciA9IGV4LkNvbG9yLldoaXRlLmNsb25lKCk7XG4gICAgICAgICAgICAvLyBMaWZlIGlzIGNvdW50ZWQgaW4gbXNcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IDMwMDtcbiAgICAgICAgICAgIHRoaXMuZmFkZUZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENvbG9yIHRyYW5zaXRpb25zXG4gICAgICAgICAgICB0aGlzLnJSYXRlID0gMTtcbiAgICAgICAgICAgIHRoaXMuZ1JhdGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5iUmF0ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmFSYXRlID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yID0gZXguQ29sb3IuV2hpdGUuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IDU7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2l6ZVJhdGUgPSAwO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IDA7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgICAgICAgICAgdGhpcy5saWZlID0gbGlmZSB8fCB0aGlzLmxpZmU7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5IHx8IHRoaXMub3BhY2l0eTtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sb3IgPSBlbmRDb2xvciB8fCB0aGlzLmVuZENvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBiZWdpbkNvbG9yIHx8IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IgPSB0aGlzLmJlZ2luQ29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiB8fCB0aGlzLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5IHx8IHRoaXMudmVsb2NpdHk7XG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGFjY2VsZXJhdGlvbiB8fCB0aGlzLmFjY2VsZXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuclJhdGUgPSAodGhpcy5lbmRDb2xvci5yIC0gdGhpcy5iZWdpbkNvbG9yLnIpIC8gdGhpcy5saWZlO1xuICAgICAgICAgICAgdGhpcy5nUmF0ZSA9ICh0aGlzLmVuZENvbG9yLmcgLSB0aGlzLmJlZ2luQ29sb3IuZykgLyB0aGlzLmxpZmU7XG4gICAgICAgICAgICB0aGlzLmJSYXRlID0gKHRoaXMuZW5kQ29sb3IuYiAtIHRoaXMuYmVnaW5Db2xvci5iKSAvIHRoaXMubGlmZTtcbiAgICAgICAgICAgIHRoaXMuYVJhdGUgPSB0aGlzLm9wYWNpdHkgLyB0aGlzLmxpZmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2l6ZSA9IHN0YXJ0U2l6ZSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5lbmRTaXplID0gZW5kU2l6ZSB8fCAwO1xuICAgICAgICAgICAgaWYgKCh0aGlzLmVuZFNpemUgPiAwKSAmJiAodGhpcy5zdGFydFNpemUgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZVJhdGUgPSAodGhpcy5lbmRTaXplIC0gdGhpcy5zdGFydFNpemUpIC8gdGhpcy5saWZlO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gdGhpcy5zdGFydFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUGFydGljbGUucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlUGFydGljbGUodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IHRoaXMubGlmZSAtIGRlbHRhO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgKyBkZWx0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpZmUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5raWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mYWRlRmxhZykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGV4LlV0aWwuY2xhbXAodGhpcy5hUmF0ZSAqIHRoaXMubGlmZSwgMC4wMDAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5zdGFydFNpemUgPiAwKSAmJiAodGhpcy5lbmRTaXplID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IGV4LlV0aWwuY2xhbXAodGhpcy5zaXplUmF0ZSAqIGRlbHRhICsgdGhpcy5wYXJ0aWNsZVNpemUsIE1hdGgubWluKHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpLCBNYXRoLm1heCh0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvci5yID0gZXguVXRpbC5jbGFtcCh0aGlzLmN1cnJlbnRDb2xvci5yICsgdGhpcy5yUmF0ZSAqIGRlbHRhLCAwLCAyNTUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IuZyA9IGV4LlV0aWwuY2xhbXAodGhpcy5jdXJyZW50Q29sb3IuZyArIHRoaXMuZ1JhdGUgKiBkZWx0YSwgMCwgMjU1KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yLmIgPSBleC5VdGlsLmNsYW1wKHRoaXMuY3VycmVudENvbG9yLmIgKyB0aGlzLmJSYXRlICogZGVsdGEsIDAsIDI1NSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvci5hID0gZXguVXRpbC5jbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1cykge1xuICAgICAgICAgICAgICAgIHZhciBhY2NlbCA9IHRoaXMuZm9jdXMubWludXModGhpcy5wb3NpdGlvbikubm9ybWFsaXplKCkuc2NhbGUodGhpcy5mb2N1c0FjY2VsKS5zY2FsZShkZWx0YSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZChhY2NlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eS5hZGQodGhpcy5hY2NlbGVyYXRpb24uc2NhbGUoZGVsdGEgLyAxMDAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5hZGQodGhpcy52ZWxvY2l0eS5zY2FsZShkZWx0YSAvIDEwMDApKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Um90YXRpb24gPSAodGhpcy5jdXJyZW50Um90YXRpb24gKyB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICogZGVsdGEgLyAxMDAwKSAlICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFydGljbGVTcHJpdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLnNldFJvdGF0aW9uKHRoaXMuY3VycmVudFJvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLnNldFNjYWxlWCh0aGlzLnBhcnRpY2xlU2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5zZXRTY2FsZVkodGhpcy5wYXJ0aWNsZVNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUuZHJhdyhjdHgsIHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvci5hID0gZXguVXRpbC5jbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50Q29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIHRoaXMucGFydGljbGVTaXplLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGFydGljbGU7XG4gICAgfSkoKTtcbiAgICBleC5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xuICAgIC8qKlxuICAgICAqIFVzaW5nIGEgcGFydGljbGUgZW1pdHRlciBpcyBhIGdyZWF0IHdheSB0byBjcmVhdGUgaW50ZXJlc3RpbmcgZWZmZWN0c1xuICAgICAqIGluIHlvdXIgZ2FtZSwgbGlrZSBzbW9rZSwgZmlyZSwgd2F0ZXIsIGV4cGxvc2lvbnMsIGV0Yy4gUGFydGljbGUgRW1pdHRlcnNcbiAgICAgKiBleHRlbmQgQWN0b3IgYWxsb3dpbmcgeW91IHRvIHVzZSBhbGwgb2YgdGhlIGZlYXR1cmVzIHRoYXQgY29tZSB3aXRoIEFjdG9yXG4gICAgICogQGNsYXNzIFBhcnRpY2xlRW1pdHRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbeD0wXSB7bnVtYmVyfSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgZW1pdHRlclxuICAgICAqIEBwYXJhbSBbeT0wXSB7bnVtYmVyfSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgZW1pdHRlclxuICAgICAqIEBwYXJhbSBbd2lkdGg9MF0ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBlbWl0dGVyXG4gICAgICogQHBhcmFtIFtoZWlnaHQ9MF0ge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgZW1pdHRlclxuICAgICAqL1xuICAgIHZhciBQYXJ0aWNsZUVtaXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUGFydGljbGVFbWl0dGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBQYXJ0aWNsZUVtaXR0ZXIoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIGhlaWdodCwgZXguQ29sb3IuV2hpdGUpO1xuICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ID0gMDtcbiAgICAgICAgICAgIHRoaXMubnVtUGFydGljbGVzID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBpc0VtaXR0aW5nIGZsYWdcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpc0VtaXR0aW5nIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzRW1pdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgcGFydGljbGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHBhcnRpY2xlcyB7VXRpbC5Db2xsZWN0aW9uJmx0O1BhcnRpY2xlJmd0O31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgZGVhZFBhcnRpY2xlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBwYXJ0aWNsZXMge1V0aWwuQ29sbGVjdGlvbiZsdDtQYXJ0aWNsZSZndDt9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcyA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBwYXJ0aWNhbCB2ZWxvY2l0eVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFttaW5WZWw9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5taW5WZWwgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gcGFydGljYWwgdmVsb2NpdHlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWF4VmVsPTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWF4VmVsID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIGZvciBhbGwgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2FjY2VsZXJhdGlvbj1uZXcgVmVjdG9yKDAsMCldIHtWZWN0b3J9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IGV4LlZlY3RvcigwLCAwKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWluQW5nbGU9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5taW5BbmdsZSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBhbmdsZSBpbiByYWRpYW5zXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW21heEFuZ2xlPTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWF4QW5nbGUgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXNzaW9uIHJhdGUgZm9yIHBhcnRpY2xlcyAocGFydGljbGVzL3NlYylcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZW1pdFJhdGU9MV0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbWl0UmF0ZSA9IDE7IC8vcGFydGljbGVzL3NlY1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxpZmUgb2YgZWFjaCBwYXJ0aWNsZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcGFydGljbGVMaWZlPTIwMDBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFydGljbGVMaWZlID0gMjAwMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcGFjaXR5IG9mIGVhY2ggcGFydGljbGUgZnJvbSAwIHRvIDEuMFxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtvcGFjaXR5PTEuMF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBmYWRlIGZsYWcgd2hpY2ggY2F1c2VzIHBhcnRpY2xlcyB0byBncmFkdWFsbHkgZmFkZSBvdXQgb3ZlciB0aGUgY291cnNlIG9mIHRoZWlyIGxpZmUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2ZhZGU9ZmFsc2VdIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZhZGVGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgZm9jdXMgd2hlcmUgYWxsIHBhcnRpY2xlcyBzaG91bGQgYWNjZWxlcmF0ZSB0b3dhcmRzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2ZvY3VzPW51bGxdIHtWZWN0b3J9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGFjY2VsZXJhdGlvbiBmb3IgZm9jdXNpbmcgcGFydGljbGVzIGlmIGEgZm9jdXMgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2ZvY3VzQWNjZWw9MV0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gMTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIHN0YXJ0aW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbc3RhcnRTaXplPW51bGxdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaXplID0gbnVsbDtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIGVuZGluZyBzaXplIGZvciB0aGUgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2VuZFNpemU9bnVsbF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbmRTaXplID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFttaW5TaXplPTVdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWluU2l6ZSA9IDU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBzaXplIG9mIGFsbCBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWF4U2l6ZT01XSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1heFNpemUgPSA1O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJlZ2lubmluZyBjb2xvciBvZiBhbGwgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2JlZ2luQ29sb3I9Q29sb3IuV2hpdGVdIHtDb2xvcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gZXguQ29sb3IuV2hpdGU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW5kaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZW5kQ29sb3I9Q29sb3IuV2hpdGVdIHtDb2xvcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbmRDb2xvciA9IGV4LkNvbG9yLldoaXRlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHNwcml0ZSB0aGF0IGEgcGFydGljbGUgc2hvdWxkIHVzZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtwYXJ0aWNsZVNwcml0ZT1udWxsXSB7U3ByaXRlfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWl0dGVyIHR5cGUgZm9yIHRoZSBwYXJ0aWNsZSBlbWl0dGVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2VtaXR0ZXJUeXBlPUVtaXR0ZXJUeXBlLlJlY3RhbmdsZV0ge0VtaXR0ZXJUeXBlfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXJUeXBlID0gMSAvKiBSZWN0YW5nbGUgKi87XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pdHRlciByYWRpdXMsIG9ubHkgdGFrZXMgZWZmZWN0IHdoZW4gdGhlIGVtaXR0ZXJUeXBlIGlzIENpcmNsZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtyYWRpdXM9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHBhcnRpY2xlIHJvdGF0aW9uYWwgc3BlZWQgdmVsb2NpdHlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHk9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHBhcnRpY2xlcyBzaG91bGQgc3RhcnQgd2l0aCBhIHJhbmRvbSByb3RhdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtyYW5kb21Sb3RhdGlvbj1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmFuZG9tUm90YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzID0gbmV3IGV4LlV0aWwuQ29sbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzID0gbmV3IGV4LlV0aWwuQ29sbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlUGFydGljbGUgPSBmdW5jdGlvbiAocGFydGljbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcy5wdXNoKHBhcnRpY2xlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdXNlcyB0aGUgZW1pdHRlciB0byBlbWl0IHBhcnRpY2xlc1xuICAgICAgICAgKiBAbWV0aG9kIGVtaXRcbiAgICAgICAgICogQHBhcmFtIHBhcnRpY2xlQ291bnQge251bWJlcn0gTnVtYmVyIG9mIHBhcnRpY2xlcyB0byBlbWl0IHJpZ2h0IG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHBhcnRpY2xlQ291bnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGljbGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaCh0aGlzLmNyZWF0ZVBhcnRpY2xlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmNsZWFyUGFydGljbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuY2xlYXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5ldyBwYXJ0aWNsZSBnaXZlbiB0aGUgY29udHJhaW50cyBvZiB0aGUgZW1pdHRlclxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmNyZWF0ZVBhcnRpY2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdG9kbyBpbXBsZW1lbnQgZW1pdHRlciBjb250cmFpbnRzO1xuICAgICAgICAgICAgdmFyIHJhblggPSAwO1xuICAgICAgICAgICAgdmFyIHJhblkgPSAwO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gZXguVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluQW5nbGUsIHRoaXMubWF4QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHZlbCA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLm1pblZlbCwgdGhpcy5tYXhWZWwpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnN0YXJ0U2l6ZSB8fCBleC5VdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5taW5TaXplLCB0aGlzLm1heFNpemUpO1xuICAgICAgICAgICAgdmFyIGR4ID0gdmVsICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgdmFyIGR5ID0gdmVsICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW1pdHRlclR5cGUgPT09IDEgLyogUmVjdGFuZ2xlICovKSB7XG4gICAgICAgICAgICAgICAgcmFuWCA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLngsIHRoaXMueCArIHRoaXMuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgcmFuWSA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLnksIHRoaXMueSArIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gMCAvKiBDaXJjbGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gZXguVXRpbC5yYW5kb21JblJhbmdlKDAsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgICAgICAgICByYW5YID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpICsgdGhpcy54O1xuICAgICAgICAgICAgICAgIHJhblkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkgKyB0aGlzLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQYXJ0aWNsZSh0aGlzLCB0aGlzLnBhcnRpY2xlTGlmZSwgdGhpcy5vcGFjaXR5LCB0aGlzLmJlZ2luQ29sb3IsIHRoaXMuZW5kQ29sb3IsIG5ldyBleC5WZWN0b3IocmFuWCwgcmFuWSksIG5ldyBleC5WZWN0b3IoZHgsIGR5KSwgdGhpcy5hY2NlbGVyYXRpb24sIHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpO1xuICAgICAgICAgICAgcC5mYWRlRmxhZyA9IHRoaXMuZmFkZUZsYWc7XG4gICAgICAgICAgICBwLnBhcnRpY2xlU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xuICAgICAgICAgICAgICAgIHAucGFydGljbGVTcHJpdGUgPSB0aGlzLnBhcnRpY2xlU3ByaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5kb21Sb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHAuY3VycmVudFJvdGF0aW9uID0gZXguVXRpbC5yYW5kb21JblJhbmdlKDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgcC5mb2N1cyA9IHRoaXMuZm9jdXMuYWRkKG5ldyBleC5WZWN0b3IodGhpcy54LCB0aGlzLnkpKTtcbiAgICAgICAgICAgICAgICBwLmZvY3VzQWNjZWwgPSB0aGlzLmZvY3VzQWNjZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZW5naW5lLCBkZWx0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VtaXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ICs9IHRoaXMuZW1pdFJhdGUgKiAoZGVsdGEgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtUGFydGljbGVzID0gTWF0aC5jZWlsKHRoaXMuZW1pdFJhdGUgKiBkZWx0YSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPiAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA9IHRoaXMuX3BhcnRpY2xlc1RvRW1pdCAtIE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydGljbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFydGljbGVzLnJlbW92ZUVsZW1lbnQocGFydGljbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMuY2xlYXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8gaXMgdGhlcmUgYSBtb3JlIGVmZmljaWVudCB0byBkcmF3IFxuICAgICAgICAgICAgICAgIC8vIHBvc3NpYmx5IHVzZSBhIHdlYmdsIG9mZnNjcmVlbiBjYW52YXMgYW5kIHNoYWRlcnMgdG8gZG8gcGFydGljbGVzP1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBleC5Db2xvci5CbGFjay50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiUGFydGljbGVzOiBcIiArIHRoaXMucGFydGljbGVzLmNvdW50KCksIHRoaXMueCwgdGhpcy55ICsgMjApO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodGhpcy5mb2N1cy54ICsgdGhpcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnksIDMsIDMpO1xuICAgICAgICAgICAgICAgIGV4LlV0aWwuZHJhd0xpbmUoY3R4LCBcInllbGxvd1wiLCB0aGlzLmZvY3VzLnggKyB0aGlzLngsIHRoaXMuZm9jdXMueSArIHRoaXMueSwgX3N1cGVyLnByb3RvdHlwZS5nZXRDZW50ZXIuY2FsbCh0aGlzKS54LCBfc3VwZXIucHJvdG90eXBlLmdldENlbnRlci5jYWxsKHRoaXMpLnkpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIkZvY3VzXCIsIHRoaXMuZm9jdXMueCArIHRoaXMueCwgdGhpcy5mb2N1cy55ICsgdGhpcy55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlRW1pdHRlcjtcbiAgICB9KShleC5BY3Rvcik7XG4gICAgZXguUGFydGljbGVFbWl0dGVyID0gUGFydGljbGVFbWl0dGVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBbmltYXRpb25zIGFsbG93IHlvdSB0byBkaXNwbGF5IGEgc2VyaWVzIG9mIGltYWdlcyBvbmUgYWZ0ZXIgYW5vdGhlcixcbiAgICAgKiBjcmVhdGluZyB0aGUgaWxsdXNpb24gb2YgY2hhbmdlLiBHZW5lcmFsbHkgdGhlc2UgaW1hZ2VzIHdpbGwgY29tZSBmcm9tIGEgc3ByaXRlIHNoZWV0IHNvdXJjZS5cbiAgICAgKiBAY2xhc3MgQW5pbWF0aW9uXG4gICAgICogQGV4dGVuZHMgSURyYXdhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcbiAgICAgKiBAcGFyYW0gaW1hZ2VzIHtTcHJpdGVbXX0gQW4gYXJyYXkgb2Ygc3ByaXRlcyB0byBjcmVhdGUgdGhlIGZyYW1lcyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBbbG9vcD1mYWxzZV0ge2Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3AgYWZ0ZXIgaXQgaXMgY29tcGxldGVkXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQsIGxvb3ApIHtcbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMub2xkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMC4wO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSAxLjA7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IDEuMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcCBhZnRlciBpdCBpcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbG9vcD1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZSA9IC0xO1xuICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gaW1hZ2VzO1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgICAgICBpZiAobG9vcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaW1hZ2VzWzBdID8gaW1hZ2VzWzBdLmhlaWdodCA6IDA7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gaW1hZ2VzWzBdID8gaW1hZ2VzWzBdLndpZHRoIDogMDtcbiAgICAgICAgfVxuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmFkZEVmZmVjdChlZmZlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnJlbW92ZUVmZmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0ucmVtb3ZlRWZmZWN0KHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5jbGVhckVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5jbGVhckVmZmVjdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS50cmFuc2Zvcm1BYm91dFBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS50cmFuc2Zvcm1BYm91dFBvaW50KHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIChyYWRpYW5zKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gcmFkaWFucztcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnNldFJvdGF0aW9uKHJhZGlhbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb247XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2V0U2NhbGVYID0gZnVuY3Rpb24gKHNjYWxlWCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5zZXRTY2FsZVgoc2NhbGVYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRTY2FsZVkgPSBmdW5jdGlvbiAoc2NhbGVZKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnNldFNjYWxlWShzY2FsZVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmdldFNjYWxlWCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWDtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRTY2FsZVkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGFuaW1hdGlvbiB0byBmaXJzdCBmcmFtZS5cbiAgICAgICAgICogQG1ldGhvZCByZXNldFxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUsIGFuaW1hdGlvbnMgdGhhdCBsb29wIGFyZSBuZXZlciBjb21wbGV0ZS5cbiAgICAgICAgICogQG1ldGhvZCBpc0RvbmVcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmxvb3AgJiYgdGhpcy5jdXJySW5kZXggPj0gdGhpcy5zcHJpdGVzLmxlbmd0aCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGdhbWUgZGV2ZWxvcGVycy4gVGlja3MgdGhlIGFuaW1hdGlvbiBmb3J3YXJkIGludGVybmFsbHkgYW5cbiAgICAgICAgICogY2FsY3VsYXRlcyB3aGV0aGVyIHRvIGNoYW5nZSB0byB0ZWggZnJhbWUuXG4gICAgICAgICAqIEBtZXRob2QgdGlja1xuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKCh0aW1lIC0gdGhpcy5vbGRUaW1lKSA+IHRoaXMuc3BlZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJJbmRleCA9ICh0aGlzLmxvb3AgPyAodGhpcy5jdXJySW5kZXggKyAxKSAlIHRoaXMuc3ByaXRlcy5sZW5ndGggOiB0aGlzLmN1cnJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2xkVGltZSA9IHRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTa2lwcyBhaGVhZCBhIHNwZWNpZmllZCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZCBza2lwXG4gICAgICAgICAqIEBwYXJhbSBmcmFtZXMge251bWJlcn0gRnJhbWVzIHRvIHNraXAgYWhlYWRcbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIChmcmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gKHRoaXMuY3VyckluZGV4ICsgZnJhbWVzKSAlIHRoaXMuc3ByaXRlcy5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyckluZGV4IDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyU3ByaXRlID0gdGhpcy5zcHJpdGVzW3RoaXMuY3VyckluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyclNwcml0ZS5mbGlwVmVydGljYWwgPSB0aGlzLmZsaXBWZXJ0aWNhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxpcEhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyclNwcml0ZS5mbGlwSG9yaXpvbnRhbCA9IHRoaXMuZmxpcEhvcml6b250YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZHJhdyhjdHgsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZnJlZXplRnJhbWUgIT09IC0xICYmIHRoaXMuY3VyckluZGV4ID49IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclNwcml0ZSA9IHRoaXMuc3ByaXRlc1tleC5VdGlsLmNsYW1wKHRoaXMuZnJlZXplRnJhbWUsIDAsIHRoaXMuc3ByaXRlcy5sZW5ndGggLSAxKV07XG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGN0eCwgeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGF5cyBhbiBhbmltYXRpb24gYXQgYW4gYXJiaXRyYXJ5IGxvY2F0aW9uIGluIHRoZSBnYW1lLlxuICAgICAgICAgKiBAbWV0aG9kIHBsYXlcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn0gVGhlIHggcG9zaXRpb24gaW4gdGhlIGdhbWUgdG8gcGxheVxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB0byBwbGF5XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUucGxheUFuaW1hdGlvbih0aGlzLCB4LCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbjtcbiAgICB9KSgpO1xuICAgIGV4LkFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9ua2V5UGF0Y2gudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlV0aWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvZy50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIEludGVybmFsO1xuICAgIChmdW5jdGlvbiAoSW50ZXJuYWwpIHtcbiAgICAgICAgdmFyIEZhbGxiYWNrQXVkaW8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRmFsbGJhY2tBdWRpbyhwYXRoLCB2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJVc2luZyBuZXcgV2ViIEF1ZGlvIEFwaSBmb3IgXCIgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwgPSBuZXcgV2ViQXVkaW8ocGF0aCwgdm9sdW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwiRmFsbGluZyBiYWNrIHRvIEF1ZGlvIEVsZW1lbnQgZm9yIFwiICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsID0gbmV3IEF1ZGlvVGFnKHBhdGgsIHZvbHVtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLnNldFZvbHVtZSh2b2x1bWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLnNldExvb3AobG9vcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5vbmxvYWQgPSB0aGlzLm9ubG9hZDtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwubG9hZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZEltcGwuaXNQbGF5aW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZEltcGwucGxheSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLnBhdXNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5zdG9wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrQXVkaW87XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEludGVybmFsLkZhbGxiYWNrQXVkaW8gPSBGYWxsYmFja0F1ZGlvO1xuICAgICAgICB2YXIgQXVkaW9UYWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQXVkaW9UYWcocGF0aCwgdm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50cyA9IG5ldyBBcnJheSg1KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZWRBdWRpbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXVkaW9FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvRWxlbWVudHNbaV0gPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWb2x1bWUoZXguVXRpbC5jbGFtcCh2b2x1bWUsIDAsIDEuMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWb2x1bWUoMS4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLmF1ZGlvTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYS52b2x1bWUgPSB2b2x1bWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEubG9vcCA9IGxvb3A7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLmdldExvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEubG9vcDsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgYXVkaW8gcmVzb3VyY2UgXCIsIF90aGlzLnBhdGgsIFwiIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlXCIsIHJlcXVlc3Quc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2FkZWRBdWRpbyA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5zcmMgPSBfdGhpcy5fbG9hZGVkQXVkaW87XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmxvYWQoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50c1t0aGlzLmluZGV4XS5sb2FkKCk7XG4gICAgICAgICAgICAgICAgLy90aGlzLmF1ZGlvRWxlbWVudHNbdGhpcy5pbmRleF0uY3VycmVudFRpbWUgPSB0aGlzLl9jdXJyZW50T2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50c1t0aGlzLmluZGV4XS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdldExvb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHNbdGhpcy5pbmRleF0uYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gKHRoaXMuaW5kZXggKyAxKSAlIHRoaXMuYXVkaW9FbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAodGhpcy5pbmRleCAtIDEgKyB0aGlzLmF1ZGlvRWxlbWVudHMubGVuZ3RoKSAlIHRoaXMuYXVkaW9FbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IHRoaXMuYXVkaW9FbGVtZW50c1t0aGlzLmluZGV4XS5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBhLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICAvL2EuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBBdWRpb1RhZztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgSW50ZXJuYWwuQXVkaW9UYWcgPSBBdWRpb1RhZztcbiAgICAgICAgaWYgKHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb0NvbnRleHQgPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBXZWJBdWRpbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBXZWJBdWRpbyhzb3VuZFBhdGgsIHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHNvdW5kUGF0aDtcbiAgICAgICAgICAgICAgICBpZiAodm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLmdhaW4udmFsdWUgPSBleC5VdGlsLmNsYW1wKHZvbHVtZSwgMCwgMS4wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLmdhaW4udmFsdWUgPSAxLjA7IC8vIG1heCB2b2x1bWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLmdhaW4udmFsdWUgPSB2b2x1bWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgdGhpcy5wYXRoKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGF1ZGlvIHJlc291cmNlIFwiLCBfdGhpcy5wYXRoLCBcIiBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZVwiLCByZXF1ZXN0LnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YShyZXF1ZXN0LnJlc3BvbnNlLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmxvYWQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSBcIiArIF90aGlzLnBhdGggKyBcIiB0aGlzIGJyb3dzZXIgbWF5IG5vdCBmdWxseSBzdXBwb3J0IHRoaXMgZm9ybWF0LCBvciB0aGUgZmlsZSBtYXkgYmUgY29ycnVwdCwgXCIgKyBcImlmIHRoaXMgaXMgYW4gbXAzIHRyeSByZW1vdmluZyBpZDMgdGFncyBhbmQgYWxidW0gYXJ0IGZyb20gdGhlIGZpbGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9ubG9hZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHNvdW5kISBJZiB0aGlzIGlzIGEgY3Jvc3Mgb3JpZ2luIGVycm9yLCB5b3UgbXVzdCBob3N0IHlvdXIgc291bmQgd2l0aCB5b3VyIGh0bWwgYW5kIGphdmFzY3JpcHQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLmxvb3AgPSB0aGlzLmxvb3A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQuY29ubmVjdCh0aGlzLnZvbHVtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5zdGFydCgwLCB0aGlzLl9jdXJyZW50T2Zmc2V0ICUgdGhpcy5idWZmZXIuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQgfHwgIXRoaXMuX3BsYXlQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0aGlzLl9wbGF5UHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5vbmVuZGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxheVByb21pc2UgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleC5Qcm9taXNlLndyYXAodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3BsYXlpbmdUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLnN0b3AoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGUgc291bmQgY2xpcFwiLCB0aGlzLnBhdGgsIFwiaGFzIGFscmVhZHkgYmVlbiBwYXVzZWQhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3BsYXlpbmdUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc3RvcCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoZSBzb3VuZCBjbGlwXCIsIHRoaXMucGF0aCwgXCJoYXMgYWxyZWFkeSBiZWVuIHN0b3BwZWQhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBXZWJBdWRpbztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgSW50ZXJuYWwuV2ViQXVkaW8gPSBXZWJBdWRpbztcbiAgICB9KShJbnRlcm5hbCA9IGV4LkludGVybmFsIHx8IChleC5JbnRlcm5hbCA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvZy50c1wiIC8+XG4vLyBQcm9taXNlcy9BKyBTcGVjIGh0dHA6Ly9wcm9taXNlcy1hcGx1cy5naXRodWIuaW8vcHJvbWlzZXMtc3BlYy9cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBWYWxpZCBzdGF0ZXMgZm9yIGEgcHJvbWlzZSB0byBiZSBpblxuICAgICAqIEBjbGFzcyBQcm9taXNlU3RhdGVcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKFByb21pc2VTdGF0ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFJlc29sdmVkIHtQcm9taXNlU3RhdGV9XG4gICAgICAgICovXG4gICAgICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJSZXNvbHZlZFwiXSA9IDBdID0gXCJSZXNvbHZlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFJlamVjdGVkIHtQcm9taXNlU3RhdGV9XG4gICAgICAgICovXG4gICAgICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJSZWplY3RlZFwiXSA9IDFdID0gXCJSZWplY3RlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFBlbmRpbmcge1Byb21pc2VTdGF0ZX1cbiAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlBlbmRpbmdcIl0gPSAyXSA9IFwiUGVuZGluZ1wiO1xuICAgIH0pKGV4LlByb21pc2VTdGF0ZSB8fCAoZXguUHJvbWlzZVN0YXRlID0ge30pKTtcbiAgICB2YXIgUHJvbWlzZVN0YXRlID0gZXguUHJvbWlzZVN0YXRlO1xuICAgIC8qKlxuICAgICAqIFByb21pc2VzL0ErIHNwZWMgaW1wbGVtZW50YXRpb24gb2YgcHJvbWlzZXNcbiAgICAgKiBAY2xhc3MgUHJvbWlzZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUHJvbWlzZSgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMiAvKiBQZW5kaW5nICovO1xuICAgICAgICAgICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICB0aGlzLnJlamVjdENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXAgYSB2YWx1ZSBpbiBhIHJlc29sdmVkIHByb21pc2VcbiAgICAgICAgICogQG1ldGhvZCB3cmFwPFQ+XG4gICAgICAgICAqIEBwYXJhbSBbdmFsdWU9dW5kZWZpbmVkXSB7VH0gQW4gb3B0aW9uYWwgdmFsdWUgdG8gd3JhcCBpbiBhIHJlc29sdmVkIHByb21pc2VcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtUJmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS53cmFwID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IChuZXcgUHJvbWlzZSgpKS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgdGhlIHByb21pc2VzIHBhc3NlZCB0byBpdCByZXNvbHZlLCBvciByZWplY3RzXG4gICAgICAgICAqIHdoZW4gYXQgbGVhc3QgMSBwcm9taXNlIHJlamVjdHMuXG4gICAgICAgICAqIEBwYXJhbSBwcm9taXNlcyB7UHJvbWlzZVtdfVxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlXG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLmpvaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgam9pbmVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XG4gICAgICAgICAgICBpZiAoIXByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpvaW5lZFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvdGFsID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NlcyA9IDA7XG4gICAgICAgICAgICB2YXIgcmVqZWN0cyA9IDA7XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICBwcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2VzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgPT09IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdWNjZXNzZXMgKyByZWplY3RzICsgZXJyb3JzLmxlbmd0aCA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdHMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIHJlamVjdHMgKyBlcnJvcnMubGVuZ3RoID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGVycm9ycy5sZW5ndGggKyBzdWNjZXNzZXMgKyByZWplY3RzKSA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW5lZFByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFpbiBzdWNjZXNzIGFuZCByZWplY3QgY2FsbGJhY2tzIGFmdGVyIHRoZSBwcm9taXNlIGlzIHJlc292bGVkXG4gICAgICAgICAqIEBtZXRob2QgdGhlblxuICAgICAgICAgKiBAcGFyYW0gc3VjY2Vzc0NhbGxiYWNrIHtUPT5hbnl9IENhbGwgb24gcmVzb2x1dGlvbiBvZiBwcm9taXNlXG4gICAgICAgICAqIEBwYXJhbSByZWplY3RDYWxsYmFjayB7YW55PT5hbnl9IENhbGwgb24gcmVqZWN0aW9uIG9mIHByb21pc2VcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtUJmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChzdWNjZXNzQ2FsbGJhY2ssIHJlamVjdENhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2tzLnB1c2goc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc292bGVkIGNhbGwgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID09PSAwIC8qIFJlc29sdmVkICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWplY3RDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0Q2FsbGJhY2sgPSByZWplY3RDYWxsYmFjaztcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlamVjdGVkIGNhbGwgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID09PSAxIC8qIFJlamVjdGVkICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW4gZXJyb3IgY2FsbGJhY2sgdG8gdGhlIHByb21pc2VcbiAgICAgICAgICogQG1ldGhvZCBlcnJvclxuICAgICAgICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFjayB7YW55PT5hbnl9IENhbGwgaWYgdGhlcmUgd2FzIGFuIGVycm9yIGluIGEgY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtUJmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yQ2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlIHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcbiAgICAgICAgICogQG1ldGhvZCByZXNvbHZlXG4gICAgICAgICAqIEBwYXJhbSBbdmFsdWU9dW5kZWZpbmVkXSB7VH0gVmFsdWUgdG8gcGFzcyB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcbiAgICAgICAgICovXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDIgLyogUGVuZGluZyAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDAgLyogUmVzb2x2ZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChfdGhpcywgX3RoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB0aGF0IGlzIG5vdCBpbiBhIHBlbmRpbmcgc3RhdGUhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlamVjdCB0aGUgcHJvbWlzZSBhbmQgcGFzcyBhbiBvcHRpb24gdmFsdWUgdG8gdGhlIHJlamVjdCBjYWxsYmFja3NcbiAgICAgICAgICogQG1ldGhvZCByZWplY3RcbiAgICAgICAgICogQHBhcmFtIFt2YWx1ZT11bmRlZmluZWRdIHtUfSBWYWx1ZSB0byBwYXNzIHRvIHRoZSByZWplY3QgY2FsbGJhY2tzXG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMiAvKiBQZW5kaW5nICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBSZWplY3RlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlamVjdCBhIHByb21pc2UgdGhhdCBpcyBub3QgaW4gYSBwZW5kaW5nIHN0YXRlIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnBlY3QgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBwcm9taXNlXG4gICAgICAgICAqIEBtZXRob2Qgc3RhdGVcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVN0YXRlXG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JDYWxsYmFjay5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb21pc2U7XG4gICAgfSkoKTtcbiAgICBleC5Qcm9taXNlID0gUHJvbWlzZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW50ZXJmYWNlcy9JTG9hZGFibGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBSZXNvdXJjZSB0eXBlIGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBnZW5lcmljIHJlc291cmNlcy5cbiAgICAgKiBGb3IgYW55IHR5cGUgb2YgcmVtb3RlIHJlc291cmNlIGl0IGlzIHJlY29tZVxuICAgICAqIEBjbGFzcyBSZXNvdXJjZVxuICAgICAqIEBleHRlbmQgSUxvYWRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gUGF0aCB0byB0aGUgcmVtb3RlIHJlc291cmNlXG4gICAgICovXG4gICAgdmFyIFJlc291cmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVzb3VyY2UocGF0aCwgcmVzcG9uc2VUeXBlLCBidXN0Q2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChidXN0Q2FjaGUgPT09IHZvaWQgMCkgeyBidXN0Q2FjaGUgPSB0cnVlOyB9XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICAgICAgICB0aGlzLmJ1c3RDYWNoZSA9IGJ1c3RDYWNoZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFJlc291cmNlIGlzIGNvbXBsZXRlbHkgbG9hZGVkIGFuZCBpcyByZWFkeVxuICAgICAgICAgKiB0byBiZSBkcmF3bi5cbiAgICAgICAgICogQG1ldGhvZCBpc0xvYWRlZFxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICB9O1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuY2FjaGVCdXN0ID0gZnVuY3Rpb24gKHVyaSkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gL1xcP1xcdyo9XFx3Ki87XG4gICAgICAgICAgICBpZiAocXVlcnkudGVzdCh1cmkpKSB7XG4gICAgICAgICAgICAgICAgdXJpICs9IChcIiZfXz1cIiArIERhdGUubm93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJpICs9IChcIj9fXz1cIiArIERhdGUubm93KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVyaTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN0YXJ0ZWQgbG9hZGluZyByZXNvdXJjZSBcIiArIHRoaXMucGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWdpbiBsb2FkaW5nIHRoZSByZXNvdXJjZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDthbnkmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB0aGlzLmJ1c3RDYWNoZSA/IHRoaXMuY2FjaGVCdXN0KHRoaXMucGF0aCkgOiB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2Fkc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdGFydChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcmVzb3VyY2UgXCIsIF90aGlzLnBhdGgsIFwiIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlXCIsIHJlcXVlc3Quc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRhID0gX3RoaXMucHJvY2Vzc0Rvd25sb2FkKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoXCJDb21wbGV0ZWQgbG9hZGluZyByZXNvdXJjZVwiLCBfdGhpcy5wYXRoKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLmRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbG9hZGVkIGRhdGEgb25jZSB0aGUgcmVzb3VyY2UgaXMgbG9hZGVkXG4gICAgICAgICAqIEBtZXRob2QgR2V0RGF0YVxuICAgICAgICAgKiBAcmV0dXJucyBhbnlcbiAgICAgICAgICovXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiB0byBoYW5kbGUgYW55IGFkZGl0aW9uYWxcbiAgICAgICAgICogcHJvY2Vzc2luZy4gU3VjaCBhcyBkZWNvZGluZyBkb3dubG9hZGVkIGF1ZGlvIGJpdHMuXG4gICAgICAgICAqIEBtZXRob2QgUHJvY2Vzc0Rvd25sb2FkXG4gICAgICAgICAqL1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUucHJvY2Vzc0Rvd25sb2FkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhbnkgYWRkaXRpb25hbCBsb2FkaW5nIGFmdGVyIHRoZSB4aHIgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVzb3VyY2U7XG4gICAgfSkoKTtcbiAgICBleC5SZXNvdXJjZSA9IFJlc291cmNlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTb3VuZC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVXRpbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUHJvbWlzZXMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlc291cmNlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJbnRlcmZhY2VzL0lMb2FkYWJsZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogVGhlIFRleHR1cmUgb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBpbWFnZSByZXNvdXJjZXMuXG4gICAgICogSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkIHRvIHByZWxvYWQgaW1hZ2VzIHVzaW5nIHRoZSBcIlRleHR1cmVcIiBvYmplY3QuXG4gICAgICogQGNsYXNzIFRleHR1cmVcbiAgICAgKiBAZXh0ZW5kIFJlc291cmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gUGF0aCB0byB0aGUgaW1hZ2UgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0gW2J1c3RDYWNoZT10cnVlXSB7Ym9vbGVhbn0gT3B0aW9uYWxseSBsb2FkIHRleHR1cmUgd2l0aCBjYWNoZSBidXN0aW5nXG4gICAgICovXG4gICAgdmFyIFRleHR1cmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVGV4dHVyZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVGV4dHVyZShwYXRoLCBidXN0Q2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChidXN0Q2FjaGUgPT09IHZvaWQgMCkgeyBidXN0Q2FjaGUgPSB0cnVlOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBwYXRoLCAnYmxvYicsIGJ1c3RDYWNoZSk7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZSA9IG5ldyBleC5TcHJpdGUodGhpcywgMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVGV4dHVyZSBpcyBjb21wbGV0ZWx5IGxvYWRlZCBhbmQgaXMgcmVhZHlcbiAgICAgICAgICogdG8gYmUgZHJhd24uXG4gICAgICAgICAqIEBtZXRob2QgaXNMb2FkZWRcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMb2FkZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgdGV4dHVyZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtIVE1MSW1hZ2VFbGVtZW50Jmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdmFyIGxvYWRlZCA9IF9zdXBlci5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgbG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy53aWR0aCA9IF90aGlzLl9zcHJpdGUuc3dpZHRoID0gX3RoaXMuX3Nwcml0ZS53aWR0aCA9IF90aGlzLmltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZS5zaGVpZ2h0ID0gX3RoaXMuX3Nwcml0ZS5oZWlnaHQgPSBfdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2FkZWQucmVzb2x2ZShfdGhpcy5pbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuaW1hZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlLnNyYyA9IF9zdXBlci5wcm90b3R5cGUuZ2V0RGF0YS5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZWplY3QoXCJFcnJvciBsb2FkaW5nIHRleHR1cmUuXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIFRleHR1cmUucHJvdG90eXBlLmFzU3ByaXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nwcml0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRleHR1cmU7XG4gICAgfSkoZXguUmVzb3VyY2UpO1xuICAgIGV4LlRleHR1cmUgPSBUZXh0dXJlO1xuICAgIC8qKlxuICAgICAqIFRoZSBTb3VuZCBvYmplY3QgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGF1ZGlvXG4gICAgICogY29tcG9uZW50cywgZnJvbSBzb3VuZHRyYWNrcyB0byBzb3VuZCBlZmZlY3RzLiBJdCBpcyBnZW5lcmFsbHlcbiAgICAgKiByZWNvbW1lbmRlZCB0byBsb2FkIHNvdW5kIHJlc291cmNlcyB3aGVuIHVzaW5nIEV4Y2FsaWJ1clxuICAgICAqIEBjbGFzcyBTb3VuZFxuICAgICAqIEBleHRlbmQgUmVzb3VyY2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gLi4ucGF0aHMge3N0cmluZ1tdfSBBIGxpc3Qgb2YgYXVkaW8gc291cmNlcyAoY2xpcC53YXYsIGNsaXAubXAzLCBjbGlwLm9nZykgZm9yIHRoaXMgYXVkaW8gY2xpcC4gVGhpcyBpcyBkb25lIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgdmFyIFNvdW5kID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU291bmQoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIENocm9tZSA6IE1QMywgV0FWLCBPZ2dcbiAgICAgICAgICAgICAqIEZpcmVmb3ggOiBXQVYsIE9nZyxcbiAgICAgICAgICAgICAqIElFIDogTVAzLCBXQVYgY29taW5nIHNvb25cbiAgICAgICAgICAgICAqIFNhZmFyaSBNUDMsIFdBViwgT2dnXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsZSA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFNvdW5kLmNhblBsYXlGaWxlKHBhdGhzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEZpbGUgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RlZEZpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYW55IG9mIHRoZSBmaWxlcyBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWxlID0gcGF0aHNbMF07IC8vIHNlbGVjdCB0aGUgZmlyc3Qgc3BlY2lmaWVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvdW5kID0gbmV3IGV4LkludGVybmFsLkZhbGxiYWNrQXVkaW8odGhpcy5fc2VsZWN0ZWRGaWxlLCAxLjApO1xuICAgICAgICB9XG4gICAgICAgIFNvdW5kLmNhblBsYXlGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXR5cGUgPSAvLipcXC4oW0EtWmEtejAtOV0rKSQvO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmlsZS5tYXRjaChmaWxldHlwZSlbMV07XG4gICAgICAgICAgICAgICAgaWYgKGEuY2FuUGxheVR5cGUoJ2F1ZGlvLycgKyB0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKFwiQ2Fubm90IGRldGVybWluZSBhdWRpbyBzdXBwb3J0LCBhc3N1bWluZyBubyBzdXBwb3J0IGZvciB0aGUgQXVkaW8gVGFnXCIsIGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU291bmQucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGVuZ2luZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ2hpZGRlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2luZS5wYXVzZUF1ZGlvV2hlbkhpZGRlbiAmJiBfdGhpcy5pc1BsYXlpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCd2aXNpYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5naW5lLnBhdXNlQXVkaW9XaGVuSGlkZGVuICYmIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdm9sdW1lIG9mIHRoZSBzb3VuZCBjbGlwXG4gICAgICAgICAqIEBtZXRob2Qgc2V0Vm9sdW1lXG4gICAgICAgICAqIEBwYXJhbSB2b2x1bWUge251bWJlcn0gQSB2b2x1bWUgdmFsdWUgYmV0d2VlbiAwLTEuMFxuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2b2x1bWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2xpcCBzaG91bGQgbG9vcCB3aGVuIGNvbXBsZXRlXG4gICAgICAgICAqIEBtZXRob2Qgc2V0TG9vcFxuICAgICAgICAgKiBAcGFyYW0gbG9vcCB7Ym9vbGVhbn0gU2V0IHRoZSBsb29waW5nIGZsYWdcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc2V0TG9vcChsb29wKTtcbiAgICAgICAgfTtcbiAgICAgICAgU291bmQucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdW5kLmlzUGxheWluZygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxheSB0aGUgc291bmQsIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc291bmQgaXMgZG9uZSBwbGF5aW5nXG4gICAgICAgICAqIEBtZXRob2QgcGxheVxuICAgICAgICAgKiBAcmV0dXJuIGV4LlByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291bmQucGxheSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCB0aGUgc291bmQsIGFuZCBkbyBub3QgcmV3aW5kXG4gICAgICAgICAqIEBtZXRob2QgcGF1c2VcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuc291bmQucGF1c2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgdGhlIHNvdW5kIGFuZCByZXdpbmRcbiAgICAgICAgICogQG1ldGhvZCBzdG9wXG4gICAgICAgICAqL1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc3RvcCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzb3VuZCBpcyBsb2FkZWRcbiAgICAgICAgICogQG1ldGhvZCBpc0xvYWRlZFxuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHNvdW5kIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXG4gICAgICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlJmx0O1NvdW5kJmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3RhcnRlZCBsb2FkaW5nIHNvdW5kXCIsIHRoaXMuX3NlbGVjdGVkRmlsZSk7XG4gICAgICAgICAgICB0aGlzLnNvdW5kLm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICB0aGlzLnNvdW5kLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoXCJDb21wbGV0ZWQgbG9hZGluZyBzb3VuZFwiLCBfdGhpcy5fc2VsZWN0ZWRGaWxlKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLnNvdW5kKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNvdW5kLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNvdW5kLmxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNvdW5kO1xuICAgIH0pKCk7XG4gICAgZXguU291bmQgPSBTb3VuZDtcbiAgICAvKipcbiAgICAgKiBUaGUgbG9hZGVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHByZWxvYWQgbXVsdGlwbGUgcmVzb3VyY2VzIGF0XG4gICAgICogb25lIHRpbWUuIFRoZSBsb2FkZXIgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGVuZ2luZSBpbiBvcmRlciB0b1xuICAgICAqIHRyaWdnZXIgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgYmFyXG4gICAgICogQGNsYXNzIExvYWRlclxuICAgICAqIEBleHRlbmQgSUxvYWRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFtsb2FkYWJsZXM9dW5kZWZpbmVkXSB7SUxvYWRhYmxlW119IE9wdGlvbmFsbHkgcHJvdmlkZSB0aGUgbGlzdCBvZiByZXNvdXJjZXMgeW91IHdhbnQgdG8gbG9hZCBhdCBjb25zdHJ1Y3RvciB0aW1lXG4gICAgICovXG4gICAgdmFyIExvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExvYWRlcihsb2FkYWJsZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VMaXN0ID0gW107XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLm51bUxvYWRlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzQ291bnRzID0ge307XG4gICAgICAgICAgICB0aGlzLnRvdGFsQ291bnRzID0ge307XG4gICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobG9hZGFibGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRSZXNvdXJjZXMobG9hZGFibGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBMb2FkZXIucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSByZXNvdXJjZSB0byB0aGUgbG9hZGVyIHRvIGxvYWRcbiAgICAgICAgICogQG1ldGhvZCBhZGRSZXNvdXJjZVxuICAgICAgICAgKiBAcGFyYW0gbG9hZGFibGUge0lMb2FkYWJsZX0gUmVzb3VyY2UgdG8gYWRkXG4gICAgICAgICAqL1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmFkZFJlc291cmNlID0gZnVuY3Rpb24gKGxvYWRhYmxlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUxpc3QucHVzaChsb2FkYWJsZSk7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzQ291bnRzW2tleV0gPSAwO1xuICAgICAgICAgICAgdGhpcy50b3RhbENvdW50c1trZXldID0gMTtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VDb3VudCsrO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgbGlzdCBvZiByZXNvdXJjZXMgdG8gdGhlIGxvYWRlciB0byBsb2FkXG4gICAgICAgICAqIEBtZXRob2QgYWRkUmVzb3VyY2VzXG4gICAgICAgICAqIEBwYXJhbSBsb2FkYWJsZXMge0lMb2FkYWJsZVtdfSBUaGUgbGlzdCBvZiByZXNvdXJjZXMgdG8gbG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5hZGRSZXNvdXJjZXMgPSBmdW5jdGlvbiAobG9hZGFibGVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgbG9hZGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRSZXNvdXJjZShsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLnN1bUNvdW50cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgdmFyIHByZXYgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gb2JqW2ldIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxvYWRlciBoYXMgY29tcGxldGVseSBsb2FkZWQgYWxsIHJlc291cmNlc1xuICAgICAgICAgKiBAbWV0aG9kIGlzTG9hZGVkXG4gICAgICAgICAqL1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtTG9hZGVkID09PSB0aGlzLnJlc291cmNlQ291bnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWdpbiBsb2FkaW5nIGFsbCBvZiB0aGUgc3VwcGxpZWQgcmVzb3VyY2VzLCByZXR1cm5pbmcgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIG9mIGFsbCBpcyBjb21wbGV0ZVxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHJldHVybnMgUHJvbXNpZSZsdDthbnkmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvdXJjZUxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWUub25jb21wbGV0ZS5jYWxsKG1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NBcnJheSA9IG5ldyBBcnJheSh0aGlzLnJlc291cmNlTGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzQ2h1bmtzID0gdGhpcy5yZXNvdXJjZUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHIud2lyZUVuZ2luZShfdGhpcy5fZW5naW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0FycmF5W2ldID0geyBsb2FkZWQ6ICgobG9hZGVkIC8gdG90YWwpICogKDEwMCAvIHByb2dyZXNzQ2h1bmtzKSksIHRvdGFsOiAxMDAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzUmVzdWx0ID0gcHJvZ3Jlc3NBcnJheS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsb2FkZWQ6IChhY2N1bS5sb2FkZWQgKyBuZXh0LmxvYWRlZCksIHRvdGFsOiAxMDAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgeyBsb2FkZWQ6IDAsIHRvdGFsOiAxMDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLm9ucHJvZ3Jlc3MuY2FsbChtZSwgcHJvZ3Jlc3NSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgci5vbmNvbXBsZXRlID0gci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5udW1Mb2FkZWQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLm51bUxvYWRlZCA9PT0gbWUucmVzb3VyY2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUub25wcm9ncmVzcy5jYWxsKG1lLCB7IGxvYWRlZDogMTAwLCB0b3RhbDogMTAwIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWUub25jb21wbGV0ZS5jYWxsKG1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWROZXh0KGxpc3QsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0W2luZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxpc3RbaW5kZXhdLmxvYWQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZE5leHQobGlzdCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWROZXh0KHRoaXMucmVzb3VyY2VMaXN0LCAwKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIExvYWRlcjtcbiAgICB9KSgpO1xuICAgIGV4LkxvYWRlciA9IExvYWRlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUHJvbWlzZXMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvYWRlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTG9nLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBFeGNhbGlidXIncyBidWlsdCBpbiB0ZW1wbGF0aW5nIGNsYXNzLCBpdCBpcyBhIGxvYWRhYmxlIHRoYXQgd2lsbCBsb2FkXG4gICAgICogYW5kIGh0bWwgZnJhZ21lbnQgZnJvbSBhIHVybC4gRXhjYWxpYnVyIHRlbXBsYXRpbmcgaXMgdmVyeSBiYXNpYyBvbmx5XG4gICAgICogYWxsb3dpbmcgYmluZGluZ3Mgb2YgdGhlIHR5cGUgZGF0YS10ZXh0PVwidGhpcy5vYmouc29tZXByb3BcIixcbiAgICAgKiBkYXRhLXN0eWxlPVwiY29sb3I6dGhpcy5vYmouY29sb3IudG9TdHJpbmcoKVwiLiBCaW5kaW5ncyBhbGxvdyBhbGwgdmFsaWRcbiAgICAgKiBqYXZhc2NyaXB0IGV4cHJlc3Npb25zLlxuICAgICAqIEBjbGFzcyBUZW1wbGF0ZVxuICAgICAqIEBleHRlbmRzIElMb2FkYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBwYXRoIHtzdHJpbmd9IExvY2F0aW9uIG9mIHRoZSBodG1sIHRlbXBsYXRlXG4gICAgICovXG4gICAgdmFyIFRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGUocGF0aCkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5faW5uZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9pbm5lckVsZW1lbnQuY2xhc3NOYW1lID0gXCJleGNhbGlidXItdGVtcGxhdGVcIjtcbiAgICAgICAgfVxuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUud2lyZUVuZ2luZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZ1bGwgaHRtbCB0ZW1wbGF0ZSBzdHJpbmcgb25jZSBsb2FkZWQuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0VGVtcGxhdGVTdHJpbmdcbiAgICAgICAgICogQHJldHVybnMgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuZ2V0VGVtcGxhdGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzTG9hZGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2h0bWxTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9odG1sU3RyaW5nO1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVFbGVtZW50cyA9IHRoaXMuX2lubmVyRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zdHlsZV0nKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRFbGVtZW50cyA9IHRoaXMuX2lubmVyRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10ZXh0XScpO1xuICAgICAgICB9O1xuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuX2V2YWx1YXRlRXhwcmVzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGN0eCkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIgKyBleHByZXNzaW9uICsgXCI7XCIpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IGZ1bmMuY2FsbChjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgYW55IGN0eCBvYmplY3QgeW91IHdpc2ggYW5kIGV2YWx1YXRlcyB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAqIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvIGluY2x1ZGUgeW91ciBmYXZvcml0ZSB0ZW1wbGF0ZSBsaWJyYXJ5LlxuICAgICAgICAgKiBZb3UgbWF5IHJldHVybiBlaXRoZXIgYW4gSFRNTCBzdHJpbmcgb3IgYSBEb20gbm9kZS5cbiAgICAgICAgICogQG1ldGhvZCBhcHBseVxuICAgICAgICAgKiBAcGFyYW0gY3R4IHthbnl9IEFueSBvYmplY3QgeW91IHdpc2ggdG8gYXBwbHkgdG8gdGhlIHRlbXBsYXRlXG4gICAgICAgICAqIEByZXR1cm5zIGFueVxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc3R5bGVFbGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBvb3IgbWFuJ3MganNvbiBwYXJzZSBmb3IgdGhpbmdzIHRoYXQgYXJlbid0IGV4YWN0bHkganNvbiA6KFxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHN0eWxlIGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0eWxlRWxlbWVudHNbal0uZGF0YXNldFtcInN0eWxlXCJdLnNwbGl0KFwiO1wiKS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxzID0gcy5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3ZhbHNbMF0udHJpbSgpXSA9IHZhbHNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gc3R5bGVzW3N0eWxlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3R5bGVFbGVtZW50c1tqXS5zdHlsZVtzdHlsZV0gPSBfdGhpcy5fZXZhbHVhdGVFeHByZXNpb24oZXhwcmVzc2lvbiwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXh0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0ZXh0IGV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gX3RoaXMuX3RleHRFbGVtZW50c1tpXS5kYXRhc2V0W1widGV4dFwiXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFbGVtZW50c1tpXS5pbm5lclRleHQgPSBfdGhpcy5fZXZhbHVhdGVFeHByZXNpb24oZXhwcmVzc2lvbiwgY3R4KTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHRlbXBsYXRlIEhUTUwgaGFzIGEgcm9vdCBlbGVtZW50IHJldHVybiB0aGF0LCBvdGhlcndpc2UgdXNlIGNvbnN0cnVjdGVkIHJvb3RcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbm5lckVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5uZXJFbGVtZW50ID0gdGhpcy5faW5uZXJFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJFbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHRlbXBsYXRlLiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHRlbXBsYXRlIHN0cmluZyB3aGVuIGxvYWRlZC5cbiAgICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdGhpcy5wYXRoLCB0cnVlKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgaHRtbCB0ZW1wbGF0ZSByZXNvdXJjZSBcIiwgX3RoaXMucGF0aCwgXCIgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIGNvZGVcIiwgcmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9odG1sU3RyaW5nID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiQ29tcGxldGVkIGxvYWRpbmcgdGVtcGxhdGVcIiwgX3RoaXMucGF0aCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuX2h0bWxTdHJpbmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRlbXBsYXRlIGhhcyBiZWVuIGxvYWRlZFxuICAgICAgICAgKiBAbWV0aG9kIGlzTG9hZGVkXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGVtcGxhdGU7XG4gICAgfSkoKTtcbiAgICBleC5UZW1wbGF0ZSA9IFRlbXBsYXRlO1xuICAgIC8qKlxuICAgICAqIEV4Y2FsaWJ1cidzIGJpbmRpbmcgbGlicmFyeSB0aGF0IGFsbG93cyB5b3UgdG8gYmluZCBhbiBodG1sXG4gICAgICogdGVtcGxhdGUgdG8gdGhlIGRvbSBnaXZlbiBhIGNlcnRhaW4gY29udGV4dC4gRXhjYWxpYnVyIGJpbmRpbmdzIGFyZSBvbmx5IHVwZGF0ZWRcbiAgICAgKiB3aGVuIHRoZSB1cGRhdGUoKSBtZXRob2QgaXMgY2FsbGVkXG4gICAgICogQGNsYXNzIEJpbmRpbmdcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcGFyZW50RWxlbWVudElkIHtzdHJpbmd9IFRoZSBpZCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgZG9tIHRvIGF0dGFjaCB0aGUgdGVtcGxhdGUgYmluZGluZ1xuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSB7VGVtcGxhdGV9IFRoZSB0ZW1wbGF0ZSB5b3Ugd2lzaCB0byBiaW5kXG4gICAgICogQHBhcmFtIGN0eCB7YW55fSBUaGUgY29udGV4dCBvZiB0aGUgYmluZGluZywgd2hpY2ggY2FuIGJlIGFueSBvYmplY3RcbiAgICAgKi9cbiAgICB2YXIgQmluZGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJpbmRpbmcocGFyZW50RWxlbWVudElkLCB0ZW1wbGF0ZSwgY3R4KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhcmVudEVsZW1lbnRJZCk7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW4gdG8gYW55IGFyYml0cmFyeSBvYmplY3QncyBldmVudHMgdG8gdXBkYXRlIHRoaXMgYmluZGluZ1xuICAgICAgICAgKiBAbWV0aG9kIGxpc3RlblxuICAgICAgICAgKiBAcGFyYW0gb2JqIHthbnl9IEFueSBvYmplY3QgdGhhdCBzdXBwb3J0cyBhZGRFdmVudExpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSBldmVudHMge3N0cmluZ1tdfSBBIGxpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIFtoYW5kZXI9ZGVmYXVsdEhhbmRsZXJdIHtjYWxsYmFja30gQSBvcHRpb25hbCBoYW5kbGVyIHRvIGZpcmUgb24gYW55IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBCaW5kaW5nLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAob2JqLCBldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyB0b2RvXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhpcyB0ZW1wbGF0ZSBiaW5kaW5nIHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSB0aGUgY3R4IHJlZmVyZW5jZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBCaW5kaW5nLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IHRoaXMuX2FwcGx5VGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgdGhpcy5fY3R4KTtcbiAgICAgICAgICAgIGlmIChodG1sIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChodG1sIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5sYXN0Q2hpbGQgIT09IGh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQoaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCaW5kaW5nLnByb3RvdHlwZS5fYXBwbHlUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGUuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5hcHBseShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQmluZGluZztcbiAgICB9KSgpO1xuICAgIGV4LkJpbmRpbmcgPSBCaW5kaW5nO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50c1xuICAgICAqIEBjbGFzcyBUZXh0QWxpZ25cbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKFRleHRBbGlnbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgaXMgbGVmdC1hbGlnbmVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBpcyByaWdodC1hbGlnbmVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgUmlnaHRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBjZW50ZXJlZC5cbiAgICAgICAgICogQHByb3BlcnR5IENlbnRlclxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiQ2VudGVyXCJdID0gMl0gPSBcIkNlbnRlclwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIHN0YXJ0IG9mIHRoZSBsaW5lIChsZWZ0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcywgcmlnaHQtYWxpZ25lZCBmb3IgcmlnaHQtdG8tbGVmdCBsb2NhbGVzKS5cbiAgICAgICAgICogQHByb3BlcnR5IFN0YXJ0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJTdGFydFwiXSA9IDNdID0gXCJTdGFydFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIGVuZCBvZiB0aGUgbGluZSAocmlnaHQtYWxpZ25lZCBmb3IgbGVmdC10by1yaWdodCBsb2NhbGVzLCBsZWZ0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBFbmRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIkVuZFwiXSA9IDRdID0gXCJFbmRcIjtcbiAgICB9KShleC5UZXh0QWxpZ24gfHwgKGV4LlRleHRBbGlnbiA9IHt9KSk7XG4gICAgdmFyIFRleHRBbGlnbiA9IGV4LlRleHRBbGlnbjtcbiAgICAvKipcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGJhc2VsaW5lIHRleHQgYWxpZ25tZW50c1xuICAgICAqIEBjbGFzcyBCYXNlQWxpZ25cbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKEJhc2VBbGlnbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIHRvcCBvZiB0aGUgZW0gc3F1YXJlLlxuICAgICAgICAgKiBAcHJvcGVydHkgVG9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJUb3BcIl0gPSAwXSA9IFwiVG9wXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgaGFuZ2luZyBiYXNlbGluZS4gIEN1cnJlbnRseSB1bnN1cHBvcnRlZDsgdGhpcyB3aWxsIGFjdCBsaWtlIGFscGhhYmV0aWMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBIYW5naW5nXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJIYW5naW5nXCJdID0gMV0gPSBcIkhhbmdpbmdcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBtaWRkbGUgb2YgdGhlIGVtIHNxdWFyZS5cbiAgICAgICAgICogQHByb3BlcnR5IE1pZGRsZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiTWlkZGxlXCJdID0gMl0gPSBcIk1pZGRsZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIG5vcm1hbCBhbHBoYWJldGljIGJhc2VsaW5lLlxuICAgICAgICAgKiBAcHJvcGVydHkgQWxwaGFiZXRpY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiQWxwaGFiZXRpY1wiXSA9IDNdID0gXCJBbHBoYWJldGljXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgaWRlb2dyYXBoaWMgYmFzZWxpbmU7IHRoaXMgaXMgdGhlIGJvdHRvbSBvZlxuICAgICAgICAgKiB0aGUgYm9keSBvZiB0aGUgY2hhcmFjdGVycywgaWYgdGhlIG1haW4gYm9keSBvZiBjaGFyYWN0ZXJzIHByb3RydWRlc1xuICAgICAgICAgKiBiZW5lYXRoIHRoZSBhbHBoYWJldGljIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGxcbiAgICAgICAgICogYWN0IGxpa2UgYWxwaGFiZXRpYy5cbiAgICAgICAgICogQHByb3BlcnR5IElkZW9ncmFwaGljXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJJZGVvZ3JhcGhpY1wiXSA9IDRdID0gXCJJZGVvZ3JhcGhpY1wiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgYm91bmRpbmcgYm94LiAgVGhpcyBkaWZmZXJzXG4gICAgICAgICAqIGZyb20gdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lIGluIHRoYXQgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lXG4gICAgICAgICAqIGRvZXNuJ3QgY29uc2lkZXIgZGVzY2VuZGVycy5cbiAgICAgICAgICogQHByb3BlcnR5IEJvdHRvbVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiQm90dG9tXCJdID0gNV0gPSBcIkJvdHRvbVwiO1xuICAgIH0pKGV4LkJhc2VBbGlnbiB8fCAoZXguQmFzZUFsaWduID0ge30pKTtcbiAgICB2YXIgQmFzZUFsaWduID0gZXguQmFzZUFsaWduO1xuICAgIC8qKlxuICAgICAqIExhYmVscyBhcmUgdGhlIHdheSB0byBkcmF3IHNtYWxsIGFtb3VudHMgb2YgdGV4dCB0byB0aGUgc2NyZWVuIGluIEV4Y2FsaWJ1ci4gVGhleSBhcmVcbiAgICAgKiBhY3RvcnMgYW5kIGluaGVyaXQgYWxsIG9mIHRoZSBiZW5pZml0cyBhbmQgY2FwYWJpbGl0aWVzLlxuICAgICAqIEBjbGFzcyBMYWJlbFxuICAgICAqIEBleHRlbmRzIEFjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt0ZXh0PWVtcHR5XSB7c3RyaW5nfSBUaGUgdGV4dCBvZiB0aGUgbGFiZWxcbiAgICAgKiBAcGFyYW0gW3g9MF0ge251bWJlcn0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGxhYmVsXG4gICAgICogQHBhcmFtIFt5PTBdIHtudW1iZXJ9IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBsYWJlbFxuICAgICAqIEBwYXJhbSBbZm9udD1zYW5zLXNlcmlmXSB7c3RyaW5nfSBVc2UgYW55IHZhbGlkIGNzcyBmb250IHN0cmluZyBmb3IgdGhlIGxhYmVsJ3MgZm9udC4gRGVmYXVsdCBpcyBcIjEwcHggc2Fucy1zZXJpZlwiLlxuICAgICAqIEBwYXJhbSBbc3ByaXRlRm9udD11bmRlZmluZWRdIHtTcHJpdGVGb250fSBVc2UgYW4gRXhjYWxpYnVyIHNwcml0ZSBmb250IGZvciB0aGUgbGFiZWwncyBmb250LCBpZiBhIFNwcml0ZUZvbnQgaXMgcHJvdmlkZWQgaXQgd2lsbCB0YWtlIHByZWNlbmRlbmNlIG92ZXIgYSBjc3MgZm9udC5cbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBMYWJlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhMYWJlbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTGFiZWwodGV4dCwgeCwgeSwgZm9udCwgc3ByaXRlRm9udCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeCwgeSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGV0dGVyIHNwYWNpbmcgb24gYSBMYWJlbC4gT25seSBzdXBwb3J0ZWQgd2l0aCBTcHJpdGUgRm9udHMuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2xldHRlclNwYWNpbmc9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5sZXR0ZXJTcGFjaW5nID0gMDsgLy9weFxuICAgICAgICAgICAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSAwO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3IgPSBleC5Db2xvci5CbGFjay5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3JEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fdGV4dFNwcml0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Nwcml0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gZXguQ29sb3IuQmxhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRleHQgfHwgXCJcIjtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBleC5Db2xvci5CbGFjay5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVGb250ID0gc3ByaXRlRm9udDtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMuZm9udCA9IGZvbnQgfHwgXCIxMHB4IHNhbnMtc2VyaWZcIjsgLy8gY29hbGxlc2NlIHRvIGRlZmF1bHQgY2FudmFzIGZvbnRcbiAgICAgICAgICAgIGlmIChzcHJpdGVGb250KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNwcml0ZXMgPSBzcHJpdGVGb250LmdldFRleHRTcHJpdGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGluIHRoZSBsYWJlbCAoaW4gcGl4ZWxzKTtcbiAgICAgICAgICogQG1ldGhvZCBnZXRUZXh0V2lkdGgge251bWJlcn1cbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBSZW5kaW5nIGNvbnRleHQgdG8gbWVhc3VyZSB0aGUgc3RyaW5nIHdpdGhcbiAgICAgICAgICovXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5nZXRUZXh0V2lkdGggPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgb2xkRm9udCA9IGN0eC5mb250O1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcbiAgICAgICAgICAgIGN0eC5mb250ID0gb2xkRm9udDtcbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgc3RyaW5nIGVudW1zIDooXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5fbG9va3VwVGV4dEFsaWduID0gZnVuY3Rpb24gKHRleHRBbGlnbikge1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogTGVmdCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGVmdFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogUmlnaHQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBDZW50ZXIgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNlbnRlclwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogRW5kICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFN0YXJ0ICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLl9sb29rdXBCYXNlQWxpZ24gPSBmdW5jdGlvbiAoYmFzZUFsaWduKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGJhc2VBbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBBbHBoYWJldGljICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhbHBoYWJldGljXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBCb3R0b20gKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJvdHRvbVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogSGFuZ2luZyAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaGFuZ2luXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBJZGVvZ3JhcGhpYyAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaWRlb2dyYXBoaWNcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIE1pZGRsZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibWlkZGxlXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBUb3AgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRvcFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhbHBoYWJldGljXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdGV4dCBzaGFkb3cgZm9yIHNwcml0ZSBmb250c1xuICAgICAgICAgKiBAbWV0aG9kIHNldFRleHRTaGFkb3dcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFgge251bWJlcn0gVGhlIHggb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXRZIHtudW1iZXJ9IFRoZSB5IG9mZnNldCBpbiBwaXhsZXMgdG8gcGxhY2UgdGhlIHNoYWRvd1xuICAgICAgICAgKiBAcGFyYW0gc2hhZG93Q29sb3Ige0NvbG9yfSBUaGUgY29sb3Igb2YgdGhlIHRleHQgc2hhZG93XG4gICAgICAgICAqL1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuc2V0VGV4dFNoYWRvdyA9IGZ1bmN0aW9uIChvZmZzZXRYLCBvZmZzZXRZLCBzaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSBvZmZzZXRYO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGNoYXJhY3RlciBpbiB0aGlzLl90ZXh0U3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXSA9IHRoaXMuX3RleHRTcHJpdGVzW2NoYXJhY3Rlcl0uY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyB0aGUgY3VycmVudCB0ZXh0IHNoYWRvd1xuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyVGV4dFNoYWRvd1xuICAgICAgICAgKi9cbiAgICAgICAgTGFiZWwucHJvdG90eXBlLmNsZWFyVGV4dFNoYWRvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NvbG9yID0gZXguQ29sb3IuQmxhY2suY2xvbmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlRm9udCAmJiB0aGlzLl9jb2xvciAhPT0gdGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXJhY3RlciBpbiB0aGlzLl90ZXh0U3ByaXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U3ByaXRlc1tjaGFyYWN0ZXJdLmNsZWFyRWZmZWN0cygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U3ByaXRlc1tjaGFyYWN0ZXJdLmFkZEVmZmVjdChuZXcgZXguRWZmZWN0cy5GaWxsKHRoaXMuY29sb3IuY2xvbmUoKSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlRm9udCAmJiB0aGlzLl90ZXh0U2hhZG93T24gJiYgdGhpcy5fc2hhZG93Q29sb3JEaXJ0eSAmJiB0aGlzLl9zaGFkb3dDb2xvcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNoYXJhY3RlciBpbiB0aGlzLl9zaGFkb3dTcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5jbGVhckVmZmVjdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLmFkZEVmZmVjdChuZXcgZXguRWZmZWN0cy5GaWxsKHRoaXMuX3NoYWRvd0NvbG9yLmNsb25lKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3JEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0U2hhZG93T24pIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5fc2hhZG93T2Zmc2V0WCwgdGhpcy5fc2hhZG93T2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9udERyYXcoY3R4LCBkZWx0YSwgdGhpcy5fc2hhZG93U3ByaXRlcyk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZvbnREcmF3KGN0eCwgZGVsdGEsIHRoaXMuX3RleHRTcHJpdGVzKTtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMsIGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLl9mb250RHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhLCBzcHJpdGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVGb250KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJYID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gdGhpcy50ZXh0W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhclNwcml0ZSA9IHNwcml0ZXNbY2hhcmFjdGVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzT3BhY2l0eSAhPT0gdGhpcy5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhclNwcml0ZS5jbGVhckVmZmVjdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLmFkZEVmZmVjdChuZXcgZXguRWZmZWN0cy5PcGFjaXR5KHRoaXMub3BhY2l0eSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhclNwcml0ZS5kcmF3KGN0eCwgY3VyclgsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyclggKz0gKGNoYXJTcHJpdGUuc3dpZHRoICsgdGhpcy5sZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXguTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoXCJTcHJpdGVGb250IEVycm9yIGRyYXdpbmcgY2hhciBcIiArIGNoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNPcGFjaXR5ICE9PSB0aGlzLm9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c09wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEFsaWduID0gY3R4LnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVGV4dEJhc2VsaW5lID0gY3R4LnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy5fbG9va3VwVGV4dEFsaWduKHRoaXMudGV4dEFsaWduKTtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy5fbG9va3VwQmFzZUFsaWduKHRoaXMuYmFzZUFsaWduKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yLmEgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgMCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IG9sZEFsaWduO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvbGRUZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlYnVnRHJhdy5jYWxsKHRoaXMsIGN0eCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMYWJlbDtcbiAgICB9KShleC5BY3Rvcik7XG4gICAgZXguTGFiZWwgPSBMYWJlbDtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnRzLnRzXCIvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBJbnB1dDtcbiAgICAoZnVuY3Rpb24gKElucHV0KSB7XG4gICAgICAgIChmdW5jdGlvbiAoUG9pbnRlclR5cGUpIHtcbiAgICAgICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiVG91Y2hcIl0gPSAwXSA9IFwiVG91Y2hcIjtcbiAgICAgICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiTW91c2VcIl0gPSAxXSA9IFwiTW91c2VcIjtcbiAgICAgICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiUGVuXCJdID0gMl0gPSBcIlBlblwiO1xuICAgICAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJVbmtub3duXCJdID0gM10gPSBcIlVua25vd25cIjtcbiAgICAgICAgfSkoSW5wdXQuUG9pbnRlclR5cGUgfHwgKElucHV0LlBvaW50ZXJUeXBlID0ge30pKTtcbiAgICAgICAgdmFyIFBvaW50ZXJUeXBlID0gSW5wdXQuUG9pbnRlclR5cGU7XG4gICAgICAgIChmdW5jdGlvbiAoUG9pbnRlckJ1dHRvbikge1xuICAgICAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJNaWRkbGVcIl0gPSAxXSA9IFwiTWlkZGxlXCI7XG4gICAgICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJSaWdodFwiXSA9IDJdID0gXCJSaWdodFwiO1xuICAgICAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XG4gICAgICAgIH0pKElucHV0LlBvaW50ZXJCdXR0b24gfHwgKElucHV0LlBvaW50ZXJCdXR0b24gPSB7fSkpO1xuICAgICAgICB2YXIgUG9pbnRlckJ1dHRvbiA9IElucHV0LlBvaW50ZXJCdXR0b247XG4gICAgICAgIHZhciBQb2ludGVyRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFBvaW50ZXJFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBvaW50ZXJFdmVudCh4LCB5LCBpbmRleCwgcG9pbnRlclR5cGUsIGJ1dHRvbiwgZXYpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ID0gZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUG9pbnRlckV2ZW50O1xuICAgICAgICB9KShleC5HYW1lRXZlbnQpO1xuICAgICAgICBJbnB1dC5Qb2ludGVyRXZlbnQgPSBQb2ludGVyRXZlbnQ7XG4gICAgICAgIDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgcG9pbnRlciBldmVudHMgKG1vdXNlLCB0b3VjaCwgc3R5bHVzLCBldGMuKSBhbmQgbm9ybWFsaXplcyB0byBXM0MgUG9pbnRlciBFdmVudHMuXG4gICAgICAgICAqIFRoZXJlIGlzIGFsd2F5cyBhdCBsZWFzdCBvbmUgcG9pbnRlciBhdmFpbGFibGUgKHByaW1hcnkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgUG9pbnRlcnNcbiAgICAgICAgICogQGV4dGVuZHMgQ2xhc3NcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgUG9pbnRlcnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFBvaW50ZXJzLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUG9pbnRlcnMoZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlckRvd24gPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyVXAgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyTW92ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJzLnB1c2gobmV3IFBvaW50ZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnMgPSBbLTFdO1xuICAgICAgICAgICAgICAgIHRoaXMucHJpbWFyeSA9IHRoaXMuX3BvaW50ZXJzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyBwb2ludGVyIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBUb3VjaCBFdmVudHNcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlVG91Y2hFdmVudChcImRvd25cIiwgdGhpcy5fcG9pbnRlckRvd24pKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoXCJ1cFwiLCB0aGlzLl9wb2ludGVyVXApKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KFwibW92ZVwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5faGFuZGxlVG91Y2hFdmVudChcImNhbmNlbFwiLCB0aGlzLl9wb2ludGVyQ2FuY2VsKSk7XG4gICAgICAgICAgICAgICAgLy8gVzNDIFBvaW50ZXIgRXZlbnRzXG4gICAgICAgICAgICAgICAgLy8gQ3VycmVudDogSUUxMSwgSUUxMFxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFMTFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcImRvd25cIiwgdGhpcy5fcG9pbnRlckRvd24pKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwidXBcIiwgdGhpcy5fcG9pbnRlclVwKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwibW92ZVwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwiY2FuY2VsXCIsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRTEwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5jYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJEb3duJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwiZG93blwiLCB0aGlzLl9wb2ludGVyRG93bikpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJVcCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcInVwXCIsIHRoaXMuX3BvaW50ZXJVcCkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJNb3ZlJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwibW92ZVwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJDYW5jZWwnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJjYW5jZWxcIiwgdGhpcy5fcG9pbnRlck1vdmUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdXNlIEV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KFwiZG93blwiLCB0aGlzLl9wb2ludGVyRG93bikpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VFdmVudChcInVwXCIsIHRoaXMuX3BvaW50ZXJVcCkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KFwibW92ZVwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlclVwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlckRvd24ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyTW92ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNhZmVseSBnZXRzIGEgUG9pbnRlciBhdCBhIHNwZWNpZmljIGluZGV4IGFuZCBpbml0aWFsaXplcyBvbmUgaWYgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBUaGUgcG9pbnRlciBpbmRleCB0byByZXRyaWV2ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fcG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9wb2ludGVycy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnMucHVzaCgtMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzW2luZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBudW1iZXIgb2YgcG9pbnRlcnMgYmVpbmcgd2F0Y2hlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BvZ2F0ZXMgZXZlbnRzIHRvIGFjdG9yIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUucHJvcG9nYXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVUlBY3RvciA9IGFjdG9yIGluc3RhbmNlb2YgZXguVUlBY3RvcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyVXAuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnMoZS54LCBlLnksICFpc1VJQWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIucHVibGlzaChcInBvaW50ZXJ1cFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJEb3duLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKGUueCwgZS55LCAhaXNVSUFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJwb2ludGVyZG93blwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jYXB0dXJlUG9pbnRlci5jYXB0dXJlTW92ZUV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyTW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnMoZS54LCBlLnksICFpc1VJQWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJwb2ludGVybW92ZVwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnMoZS54LCBlLnksICFpc1VJQWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIucHVibGlzaChcInBvaW50ZXJjYW5jZWxcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZU1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gZXguVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBlLnBhZ2VZIC0gZXguVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgZXguUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCAwLCAxIC8qIE1vdXNlICovLCBlLmJ1dHRvbiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdCgwKS5ldmVudERpc3BhdGNoZXIucHVibGlzaChldmVudE5hbWUsIHBlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlVG91Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyBfdGhpcy5fZ2V0UG9pbnRlckluZGV4KGUuY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcikgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWCAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGUuY2hhbmdlZFRvdWNoZXNbaV0ucGFnZVkgLSBleC5VdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgZXguUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlID0gbmV3IFBvaW50ZXJFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgaW5kZXgsIDAgLyogVG91Y2ggKi8sIDMgLyogVW5rbm93biAqLywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5ldmVudERpc3BhdGNoZXIucHVibGlzaChldmVudE5hbWUsIHBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcInVwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiZG93blwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIElEIHRvIGdpdmVuIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSBlLmNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZVBvaW50ZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGZvciB0aGlzIHBvaW50ZXIgSUQgaWYgbXVsdGktcG9pbnRlciBpcyBhc2tlZCBmb3JcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyBfdGhpcy5fZ2V0UG9pbnRlckluZGV4KGUucG9pbnRlcklkKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KHgsIHkpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlID0gbmV3IFBvaW50ZXJFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgaW5kZXgsIF90aGlzLl9zdHJpbmdUb1BvaW50ZXJUeXBlKGUucG9pbnRlclR5cGUpLCBlLmJ1dHRvbiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goZXZlbnROYW1lLCBwZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJ1cFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiZG93blwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgSUQgdG8gZ2l2ZW4gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5wb2ludGVySWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgc3BlY2lmaWVkIGZvciB0aGUgZ2l2ZW4gcG9pbnRlciBJRCBvciBmaW5kcyB0aGUgbmV4dCBlbXB0eSBwb2ludGVyIHNsb3QgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIElFMTAvMTEgdXNlcyBpbmNyZW1lbnRpbmcgcG9pbnRlciBJRHMgc28gd2UgbmVlZCB0byBzdG9yZSBhIG1hcHBpbmcgb2YgSUQgPT4gaWR4XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2dldFBvaW50ZXJJbmRleCA9IGZ1bmN0aW9uIChwb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4O1xuICAgICAgICAgICAgICAgIGlmICgoaWR4ID0gdGhpcy5fYWN0aXZlUG9pbnRlcnMuaW5kZXhPZihwb2ludGVySWQpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYWN0aXZlUG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVBvaW50ZXJzW2ldID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgcG9pbnRlciBiZWNhdXNlIGdhbWUgaXNuJ3Qgd2F0Y2hpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9zdHJpbmdUb1BvaW50ZXJUeXBlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvdWNoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBUb3VjaCAqLztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBNb3VzZSAqLztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBlblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogUGVuICovO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogVW5rbm93biAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJzO1xuICAgICAgICB9KShleC5DbGFzcyk7XG4gICAgICAgIElucHV0LlBvaW50ZXJzID0gUG9pbnRlcnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXB0dXJlcyBhbmQgZGlzcGF0Y2hlcyBQb2ludGVyRXZlbnRzXG4gICAgICAgICAqIEBjbGFzcyBQb2ludGVyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBDbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFBvaW50ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFBvaW50ZXIsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBQb2ludGVyKCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXI7XG4gICAgICAgIH0pKGV4LkNsYXNzKTtcbiAgICAgICAgSW5wdXQuUG9pbnRlciA9IFBvaW50ZXI7XG4gICAgfSkoSW5wdXQgPSBleC5JbnB1dCB8fCAoZXguSW5wdXQgPSB7fSkpO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgSW5wdXQ7XG4gICAgKGZ1bmN0aW9uIChJbnB1dCkge1xuICAgICAgICAvKipcbiAgICAgICAgKiBFbnVtIHJlcHJlc2VudGluZyBpbnB1dCBrZXkgY29kZXNcbiAgICAgICAgKiBAY2xhc3MgS2V5c1xuICAgICAgICAqXG4gICAgICAgICovXG4gICAgICAgIChmdW5jdGlvbiAoS2V5cykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtMSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW0yIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTMge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtNCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW01IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTYge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtNyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW04IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTkge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtMCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW0xXCJdID0gOTddID0gXCJOdW0xXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW0yXCJdID0gOThdID0gXCJOdW0yXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW0zXCJdID0gOTldID0gXCJOdW0zXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW00XCJdID0gMTAwXSA9IFwiTnVtNFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtNVwiXSA9IDEwMV0gPSBcIk51bTVcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTZcIl0gPSAxMDJdID0gXCJOdW02XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW03XCJdID0gMTAzXSA9IFwiTnVtN1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtOFwiXSA9IDEwNF0gPSBcIk51bThcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTlcIl0gPSAxMDVdID0gXCJOdW05XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW0wXCJdID0gOTZdID0gXCJOdW0wXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW1sb2NrIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bWxvY2tcIl0gPSAxNDRdID0gXCJOdW1sb2NrXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBTZW1pY29sb24ge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiU2VtaWNvbG9uXCJdID0gMTg2XSA9IFwiU2VtaWNvbG9uXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBBIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEIge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgQyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBEIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEUge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgRiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBHIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEgge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgSSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBKIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEsge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBNIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE4ge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBQIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFEge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgUiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBTIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgVSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBWIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFcge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgWCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBZIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFoge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiQVwiXSA9IDY1XSA9IFwiQVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiQlwiXSA9IDY2XSA9IFwiQlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiQ1wiXSA9IDY3XSA9IFwiQ1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRFwiXSA9IDY4XSA9IFwiRFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRVwiXSA9IDY5XSA9IFwiRVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRlwiXSA9IDcwXSA9IFwiRlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiR1wiXSA9IDcxXSA9IFwiR1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiSFwiXSA9IDcyXSA9IFwiSFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiSVwiXSA9IDczXSA9IFwiSVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiSlwiXSA9IDc0XSA9IFwiSlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiS1wiXSA9IDc1XSA9IFwiS1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTFwiXSA9IDc2XSA9IFwiTFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTVwiXSA9IDc3XSA9IFwiTVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTlwiXSA9IDc4XSA9IFwiTlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiT1wiXSA9IDc5XSA9IFwiT1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiUFwiXSA9IDgwXSA9IFwiUFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiUVwiXSA9IDgxXSA9IFwiUVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiUlwiXSA9IDgyXSA9IFwiUlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiU1wiXSA9IDgzXSA9IFwiU1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiVFwiXSA9IDg0XSA9IFwiVFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiVVwiXSA9IDg1XSA9IFwiVVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiVlwiXSA9IDg2XSA9IFwiVlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiV1wiXSA9IDg3XSA9IFwiV1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiWFwiXSA9IDg4XSA9IFwiWFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiWVwiXSA9IDg5XSA9IFwiWVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiWlwiXSA9IDkwXSA9IFwiWlwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgU2hpZnQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgQWx0IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFVwIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IERvd24ge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTGVmdCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBSaWdodCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBTcGFjZSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBFc2Mge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiU2hpZnRcIl0gPSAxNl0gPSBcIlNoaWZ0XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJBbHRcIl0gPSAxOF0gPSBcIkFsdFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiVXBcIl0gPSAzOF0gPSBcIlVwXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJEb3duXCJdID0gNDBdID0gXCJEb3duXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJMZWZ0XCJdID0gMzddID0gXCJMZWZ0XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJSaWdodFwiXSA9IDM5XSA9IFwiUmlnaHRcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRXNjXCJdID0gMjddID0gXCJFc2NcIjtcbiAgICAgICAgfSkoSW5wdXQuS2V5cyB8fCAoSW5wdXQuS2V5cyA9IHt9KSk7XG4gICAgICAgIHZhciBLZXlzID0gSW5wdXQuS2V5cztcbiAgICAgICAgO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgdGhyb3duIG9uIGEgZ2FtZSBvYmplY3QgZm9yIGEga2V5IGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBLZXlFdmVudFxuICAgICAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBrZXkge0lucHV0S2V5fSBUaGUga2V5IHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyB0aGUgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBLZXlFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoS2V5RXZlbnQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBLZXlFdmVudChrZXkpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBLZXlFdmVudDtcbiAgICAgICAgfSkoZXguR2FtZUV2ZW50KTtcbiAgICAgICAgSW5wdXQuS2V5RXZlbnQgPSBLZXlFdmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbmFnZXMgS2V5Ym9hcmQgaW5wdXQgZXZlbnRzIHRoYXQgeW91IGNhbiBxdWVyeSBvciBsaXN0ZW4gZm9yIGV2ZW50cyBvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgS2V5Ym9hcmRcbiAgICAgICAgICogQGV4dGVuZHMgQ2xhc3NcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgS2V5Ym9hcmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEtleWJvYXJkLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gS2V5Ym9hcmQoZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXNVcCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXNEb3duID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplIEtleWJvYXJkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLmxlbmd0aCA9IDA7IC8vIGVtcHRpZXMgYXJyYXkgZWZmaWNpZW50bHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBrZXkgdXAgaXMgb24gd2luZG93IGJlY2F1c2UgY2FudmFzIGNhbm5vdCBoYXZlIGZvY3VzXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfdGhpcy5fa2V5cy5pbmRleE9mKGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXNVcC5wdXNoKGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5RXZlbnQgPSBuZXcgS2V5RXZlbnQoZXYua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwidXBcIiwga2V5RXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGtleSBkb3duIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fa2V5cy5pbmRleE9mKGV2LmtleUNvZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXMucHVzaChldi5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzRG93bi5wdXNoKGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleUV2ZW50ID0gbmV3IEtleUV2ZW50KGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJkb3duXCIsIGtleUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBrZXlzRG93biBhbmQga2V5c1VwIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXNEb3duLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5c1VwLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIGxpc3Qgb2Yga2V5cyBiZWluZyBwcmVzc2VkIGRvd25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgVGVzdHMgaWYgYSBjZXJ0YWluIGtleSBpcyBkb3duLlxuICAgICAgICAgICAgICogQG1ldGhvZCBpc0tleURvd25cbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkge0tleXN9IFRlc3Qgd2V0aGVyIGEga2V5IGlzIGRvd25cbiAgICAgICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmlzS2V5RG93biA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5c0Rvd24uaW5kZXhPZihrZXkpID4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgVGVzdHMgaWYgYSBjZXJ0YWluIGtleSBpcyBwcmVzc2VkLlxuICAgICAgICAgICAgICogQG1ldGhvZCBpc0tleVByZXNzZWRcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkge0tleXN9IFRlc3Qgd2V0aGVyIGEga2V5IGlzIHByZXNzZWRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmlzS2V5UHJlc3NlZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5cy5pbmRleE9mKGtleSkgPiAtMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IGlzIHVwLlxuICAgICAgICAgICAgICogQG1ldGhvZCBpc0tleVVwXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5IHtLZXlzfSBUZXN0IHdldGhlciBhIGtleSBpcyB1cFxuICAgICAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuaXNLZXlVcCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5c1VwLmluZGV4T2Yoa2V5KSA+IC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBLZXlib2FyZDtcbiAgICAgICAgfSkoZXguQ2xhc3MpO1xuICAgICAgICBJbnB1dC5LZXlib2FyZCA9IEtleWJvYXJkO1xuICAgIH0pKElucHV0ID0gZXguSW5wdXQgfHwgKGV4LklucHV0ID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIElucHV0O1xuICAgIChmdW5jdGlvbiAoSW5wdXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hbmFnZXMgR2FtZXBhZCBBUEkgaW5wdXQuIFlvdSBjYW4gcXVlcnkgdGhlIGdhbWVwYWRzIHRoYXQgYXJlIGNvbm5lY3RlZFxuICAgICAgICAgKiBvciBsaXN0ZW4gdG8gZXZlbnRzIChcImJ1dHRvblwiIGFuZCBcImF4aXNcIikuXG4gICAgICAgICAqIEBjbGFzcyBHYW1lcGFkc1xuICAgICAgICAgKiBAZXh0ZW5kcyBDbGFzc1xuICAgICAgICAgKiBAcGFyYW0gcGFkcyB7R2FtZXBhZFtdfSBUaGUgY29ubmVjdGVkIGdhbWVwYWRzLlxuICAgICAgICAgKiBAcGFyYW0gc3VwcG9ydGVkIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgR2FtZXBhZCBBUEkgaXMgcHJlc2VudFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEdhbWVwYWRzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkcywgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRzKGVuZ2luZSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHBvbGwgZm9yIEdhbWVwYWQgaW5wdXQgKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkIHtib29sZWFufVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IEdhbWVwYWQgQVBJIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzdXBwb3J0ZWQge2Jvb2xlYW59XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdXBwb3J0ZWQgPSAhIW5hdmlnYXRvci5nZXRHYW1lcGFkcztcbiAgICAgICAgICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wcyA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmF2aWdhdG9yID0gbmF2aWdhdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5pdFN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBJbiBDaHJvbWUsIHRoaXMgd2lsbCByZXR1cm4gNCB1bmRlZmluZWQgaXRlbXMgdW50aWwgYSBidXR0b24gaXMgcHJlc3NlZFxuICAgICAgICAgICAgICAgIC8vIEluIEZGLCB0aGlzIHdpbGwgbm90IHJldHVybiBhbnkgaXRlbXMgdW50aWwgYSBidXR0b24gaXMgcHJlc3NlZFxuICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHMgPSB0aGlzLl9jbG9uZVBhZHModGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbGRQYWRzLmxlbmd0aCAmJiB0aGlzLl9vbGRQYWRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGVzIEdhbWVwYWQgc3RhdGUgYW5kIHB1Ymxpc2hlcyBHYW1lcGFkIGV2ZW50c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuc3VwcG9ydGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGdhbWVwYWRzID0gdGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lcGFkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdhbWVwYWRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBjb25uZWN0aW9uIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnRlZCBpbiBDaHJvbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLnRpbWVzdGFtcCAmJiBnYW1lcGFkc1tpXS50aW1lc3RhbXAgPT09IHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSA9IGdhbWVwYWRzW2ldLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0dG9uc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiwgYSwgdmFsdWUsIGJ1dHRvbkluZGV4LCBheGVzSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoYiBpbiBCdXR0b25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEJ1dHRvbnNbYl0gIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25JbmRleCA9IEJ1dHRvbnNbYl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdhbWVwYWRzW2ldLmJ1dHRvbnNbYnV0dG9uSW5kZXhdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vbGRQYWRzW2ldLmdldEJ1dHRvbihidXR0b25JbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0uYnV0dG9uc1tidXR0b25JbmRleF0ucHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihidXR0b25JbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwiYnV0dG9uXCIsIG5ldyBHYW1lcGFkQnV0dG9uRXZlbnQoYnV0dG9uSW5kZXgsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihidXR0b25JbmRleCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSBpbiBBeGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEF4ZXNbYV0gIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGVzSW5kZXggPSBBeGVzW2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnYW1lcGFkc1tpXS5heGVzW2F4ZXNJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX29sZFBhZHNbaV0uZ2V0QXhlcyhheGVzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS51cGRhdGVBeGVzKGF4ZXNJbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJheGlzXCIsIG5ldyBHYW1lcGFkQXhpc0V2ZW50KGF4ZXNJbmRleCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzW2ldID0gdGhpcy5fY2xvbmVQYWQoZ2FtZXBhZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNhZmVseSByZXRyaWV2ZXMgYSBHYW1lcGFkIGF0IGEgc3BlY2lmaWMgaW5kZXggYW5kIGNyZWF0ZXMgb25lIGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9wYWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fcGFkcy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHNbaW5kZXhdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbm5lY3RlZCBnYW1lcGFkc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmNvbm5lY3RlZDsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5fY2xvbmVQYWRzID0gZnVuY3Rpb24gKHBhZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5fY2xvbmVQYWQocGFkc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFzdGVzdCB3YXkgdG8gY2xvbmUgYSBrbm93biBvYmplY3QgaXMgdG8gZG8gaXQgeW91cnNlbGZcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9jbG9uZVBhZCA9IGZ1bmN0aW9uIChwYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgbGVuO1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWRQYWQgPSBuZXcgR2FtZXBhZCgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFkO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhZC5idXR0b25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVCdXR0b24oaSwgcGFkLmJ1dHRvbnNbaV0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYXhlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWRQYWQudXBkYXRlQXhlcyhpLCBwYWQuYXhlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbWluaW11bSB2YWx1ZSBhbiBheGlzIGhhcyB0byBtb3ZlIGJlZm9yZSBjb25zaWRlcmluZyBpdCBhIGNoYW5nZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IE1pbkF4aXNNb3ZlVGhyZXNob2xkIHtudW1iZXJ9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkID0gMC4wNTtcbiAgICAgICAgICAgIHJldHVybiBHYW1lcGFkcztcbiAgICAgICAgfSkoZXguQ2xhc3MpO1xuICAgICAgICBJbnB1dC5HYW1lcGFkcyA9IEdhbWVwYWRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaXZpZHVhbCBzdGF0ZSBmb3IgYSBHYW1lcGFkXG4gICAgICAgICAqIEBjbGFzcyBHYW1lcGFkXG4gICAgICAgICAqIEBleHRlbmRzIENsYXNzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgR2FtZXBhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdhbWVwYWQoKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25zID0gbmV3IEFycmF5KDE2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9heGVzID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9idXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvbnNbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9heGVzW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBidXR0b24gaXMgcHJlc3NlZFxuICAgICAgICAgICAgICogQHBhcmFtIGJ1dHRvbiB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBwYXJhbSBbdGhyZXNob2xkPTFdIHtudW1iZXJ9IFRoZSB0aHJlc2hvbGQgb3ZlciB3aGljaCB0aGUgYnV0dG9uIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc3NlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5pc0J1dHRvblByZXNzZWQgPSBmdW5jdGlvbiAoYnV0dG9uLCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHsgdGhyZXNob2xkID0gMTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idXR0b25zW2J1dHRvbl0gPj0gdGhyZXNob2xkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgZ2l2ZW4gYnV0dG9uIHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gYnV0dG9uIHtCdXR0b25zfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5nZXRCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGdpdmVuIGF4aXMgdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBheGVzIHtBeGVzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS5nZXRBeGVzID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9heGVzW2F4ZXNdO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCBHYW1lcGFkcy5NaW5BeGlzTW92ZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUudXBkYXRlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbkluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvbnNbYnV0dG9uSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUudXBkYXRlQXhlcyA9IGZ1bmN0aW9uIChheGVzSW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhlc1theGVzSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEdhbWVwYWQ7XG4gICAgICAgIH0pKGV4LkNsYXNzKTtcbiAgICAgICAgSW5wdXQuR2FtZXBhZCA9IEdhbWVwYWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHYW1lcGFkIEJ1dHRvbnMgZW51bWVyYXRpb25cbiAgICAgICAgICogQGNsYXNzIEJ1dHRvbnNcbiAgICAgICAgICovXG4gICAgICAgIChmdW5jdGlvbiAoQnV0dG9ucykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYWNlIDEgYnV0dG9uIChlLmcuIEEpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRmFjZTEge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFjZSAyIGJ1dHRvbiAoZS5nLiBCKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IEZhY2UyIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZhY2UgMyBidXR0b24gKGUuZy4gWClcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBGYWNlMyB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYWNlIDQgYnV0dG9uIChlLmcuIFkpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRmFjZTQge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UxXCJdID0gMF0gPSBcIkZhY2UxXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlMlwiXSA9IDFdID0gXCJGYWNlMlwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTNcIl0gPSAyXSA9IFwiRmFjZTNcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2U0XCJdID0gM10gPSBcIkZhY2U0XCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlZnQgYnVtcGVyIGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IExlZnRCdW1wZXIge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmlnaHQgYnVtcGVyIGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFJpZ2h0QnVtcGVyIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0QnVtcGVyXCJdID0gNF0gPSBcIkxlZnRCdW1wZXJcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0QnVtcGVyXCJdID0gNV0gPSBcIlJpZ2h0QnVtcGVyXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlZnQgdHJpZ2dlciBidXR0b25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0VHJpZ2dlciB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaWdodCB0cmlnZ2VyIGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFJpZ2h0VHJpZ2dlciB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdFRyaWdnZXJcIl0gPSA2XSA9IFwiTGVmdFRyaWdnZXJcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0VHJpZ2dlclwiXSA9IDddID0gXCJSaWdodFRyaWdnZXJcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VsZWN0IGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFNlbGVjdCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGFydCBidXR0b25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBTdGFydCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiU2VsZWN0XCJdID0gOF0gPSBcIlNlbGVjdFwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiU3RhcnRcIl0gPSA5XSA9IFwiU3RhcnRcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVmdCBhbmFsb2cgc3RpY2sgcHJlc3MgKGUuZy4gTDMpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFN0aWNrIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJpZ2h0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBSMylcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBTdGFydCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdFN0aWNrXCJdID0gMTBdID0gXCJMZWZ0U3RpY2tcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0U3RpY2tcIl0gPSAxMV0gPSBcIlJpZ2h0U3RpY2tcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRC1wYWQgdXBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBEcGFkVXAge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRC1wYWQgZG93blxuICAgICAgICAgICAgICogQHByb3BlcnR5IERwYWREb3duIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEQtcGFkIGxlZnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBEcGFkTGVmdCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBELXBhZCByaWdodFxuICAgICAgICAgICAgICogQHByb3BlcnR5IERwYWRSaWdodCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZFVwXCJdID0gMTJdID0gXCJEcGFkVXBcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWREb3duXCJdID0gMTNdID0gXCJEcGFkRG93blwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZExlZnRcIl0gPSAxNF0gPSBcIkRwYWRMZWZ0XCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkUmlnaHRcIl0gPSAxNV0gPSBcIkRwYWRSaWdodFwiO1xuICAgICAgICB9KShJbnB1dC5CdXR0b25zIHx8IChJbnB1dC5CdXR0b25zID0ge30pKTtcbiAgICAgICAgdmFyIEJ1dHRvbnMgPSBJbnB1dC5CdXR0b25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2FtZXBhZCBBeGVzIGVudW1lcmF0aW9uXG4gICAgICAgICAqIEBjbGFzcyBBeGVzXG4gICAgICAgICAqL1xuICAgICAgICAoZnVuY3Rpb24gKEF4ZXMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVmdCBhbmFsb2d1ZSBzdGljayBYIGRpcmVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IExlZnRTdGlja1gge0F4ZXN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVmdCBhbmFsb2d1ZSBzdGljayBZIGRpcmVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IExlZnRTdGlja1kge0F4ZXN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmlnaHQgYW5hbG9ndWUgc3RpY2sgWCBkaXJlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBSaWdodFN0aWNrWCB7QXhlc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaWdodCBhbmFsb2d1ZSBzdGljayBZIGRpcmVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFJpZ2h0U3RpY2tZIHtBeGVzfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBeGVzW0F4ZXNbXCJMZWZ0U3RpY2tYXCJdID0gMF0gPSBcIkxlZnRTdGlja1hcIjtcbiAgICAgICAgICAgIEF4ZXNbQXhlc1tcIkxlZnRTdGlja1lcIl0gPSAxXSA9IFwiTGVmdFN0aWNrWVwiO1xuICAgICAgICAgICAgQXhlc1tBeGVzW1wiUmlnaHRTdGlja1hcIl0gPSAyXSA9IFwiUmlnaHRTdGlja1hcIjtcbiAgICAgICAgICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tZXCJdID0gM10gPSBcIlJpZ2h0U3RpY2tZXCI7XG4gICAgICAgIH0pKElucHV0LkF4ZXMgfHwgKElucHV0LkF4ZXMgPSB7fSkpO1xuICAgICAgICB2YXIgQXhlcyA9IElucHV0LkF4ZXM7XG4gICAgICAgIHZhciBHYW1lcGFkQnV0dG9uRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEdhbWVwYWRCdXR0b25FdmVudCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRCdXR0b25FdmVudChidXR0b24sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24gPSBidXR0b247XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdhbWVwYWRCdXR0b25FdmVudDtcbiAgICAgICAgfSkoZXguR2FtZUV2ZW50KTtcbiAgICAgICAgSW5wdXQuR2FtZXBhZEJ1dHRvbkV2ZW50ID0gR2FtZXBhZEJ1dHRvbkV2ZW50O1xuICAgICAgICB2YXIgR2FtZXBhZEF4aXNFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZEF4aXNFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdhbWVwYWRBeGlzRXZlbnQoYXhpcywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF4aXMgPSBheGlzO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBHYW1lcGFkQXhpc0V2ZW50O1xuICAgICAgICB9KShleC5HYW1lRXZlbnQpO1xuICAgICAgICBJbnB1dC5HYW1lcGFkQXhpc0V2ZW50ID0gR2FtZXBhZEF4aXNFdmVudDtcbiAgICB9KShJbnB1dCA9IGV4LklucHV0IHx8IChleC5JbnB1dCA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vbmtleVBhdGNoLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudHMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50RGlzcGF0Y2hlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ2xhc3MudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2cudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbGxpc2lvbi9TaWRlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTY2VuZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlVJQWN0b3IudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRyaWdnZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlBhcnRpY2xlcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQW5pbWF0aW9uLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDYW1lcmEudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNvdW5kLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2FkZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlByb21pc2VzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVdGlsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJCaW5kaW5nLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUaWxlTWFwLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMYWJlbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUG9zdFByb2Nlc3NpbmcvSVBvc3RQcm9jZXNzb3IudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW5wdXQvSUVuZ2luZUlucHV0LnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIklucHV0L1BvaW50ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW5wdXQvS2V5Ym9hcmQudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW5wdXQvR2FtZXBhZC50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGRpc3BsYXkgbW9kZXMgYXZhaWxhYmxlIHRvIEV4Y2FsaWJ1clxuICAgICAqIEBjbGFzcyBEaXNwbGF5TW9kZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoRGlzcGxheU1vZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGdhbWUgYXMgZnVsbCBzY3JlZW5cbiAgICAgICAgICogQHByb3BlcnR5IEZ1bGxTY3JlZW4ge0Rpc3BsYXlNb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJGdWxsU2NyZWVuXCJdID0gMF0gPSBcIkZ1bGxTY3JlZW5cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlIHRoZSBnYW1lIHRvIHRoZSBwYXJlbnQgRE9NIGNvbnRhaW5lclxuICAgICAgICAgKiBAcHJvcGVydHkgQ29udGFpbmVyIHtEaXNwbGF5TW9kZX1cbiAgICAgICAgICovXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiQ29udGFpbmVyXCJdID0gMV0gPSBcIkNvbnRhaW5lclwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZ2FtZSBhcyBhIGZpeGVkIHNpemVcbiAgICAgICAgICogQFByb3BlcnR5IEZpeGVkIHtEaXNwbGF5TW9kZX1cbiAgICAgICAgICovXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiRml4ZWRcIl0gPSAyXSA9IFwiRml4ZWRcIjtcbiAgICB9KShleC5EaXNwbGF5TW9kZSB8fCAoZXguRGlzcGxheU1vZGUgPSB7fSkpO1xuICAgIHZhciBEaXNwbGF5TW9kZSA9IGV4LkRpc3BsYXlNb2RlO1xuICAgIC8vIGludGVybmFsXG4gICAgdmFyIEFuaW1hdGlvbk5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Ob2RlKGFuaW1hdGlvbiwgeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uTm9kZTtcbiAgICB9KSgpO1xuICAgIC8qKlxuICAgICAqIFRoZSAnRW5naW5lJyBpcyB0aGUgbWFpbiBkcml2ZXIgZm9yIGEgZ2FtZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yXG4gICAgICogc3RhcnRpbmcvc3RvcHBpbmcgdGhlIGdhbWUsIG1haW50YWluaW5nIHN0YXRlLCB0cmFuc21pdHRpbmcgZXZlbnRzLFxuICAgICAqIGxvYWRpbmcgcmVzb3VyY2VzLCBhbmQgbWFuYWdpbmcgdGhlIHNjZW5lLlxuICAgICAqXG4gICAgICogQGNsYXNzIEVuZ2luZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbd2lkdGhdIHtudW1iZXJ9IFRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgdGhlIEV4Y2FsaWJ1ciBnYW1lIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIFtoZWlnaHRdIHtudW1iZXJ9IFRoZSBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBFeGNhbGlidXIgZ2FtZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBbY2FudmFzRWxlbWVudElkXSB7c3RyaW5nfSBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gYSBuZXcgY2FudmFzIHdpbGwgYmUgY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgaW50byB0aGUgYm9keS5cbiAgICAgKiBAcGFyYW0gW2Rpc3BsYXlNb2RlXSB7RGlzcGxheU1vZGV9IElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlbiBpdCB3aWxsIGZhbGwgYmFjayB0byBmaXhlZCBpZiBhIGhlaWdodCBhbmQgd2lkdGggYXJlIHNwZWNpZmllZCwgZWxzZSB0aGUgZGlzcGxheSBtb2RlIHdpbGwgYmUgRnVsbFNjcmVlbi5cbiAgICAgKi9cbiAgICB2YXIgRW5naW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVuZ2luZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRW5naW5lKHdpZHRoLCBoZWlnaHQsIGNhbnZhc0VsZW1lbnRJZCwgZGlzcGxheU1vZGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGNvbGxpc2lvbiBzdHJhdGVneSBmb3IgRXhjYWxpYnVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uU3RyYXRlZ3kge0NvbGxpc2lvblN0cmF0ZWd5fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblN0cmF0ZWd5ID0gMSAvKiBEeW5hbWljQUFCQlRyZWUgKi87XG4gICAgICAgICAgICB0aGlzLmhhc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZnBzID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVIYXNoID0ge307XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBpcyBzZXQgdG8gZnVsbHNjcmVlbiBvciBub3RcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpc0Z1bGxzY3JlZW4ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB0aGUgY3VycmVudCBEaXNwbGF5TW9kZSBvZiB0aGUgZW5naW5lLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtkaXNwbGF5TW9kZT1GdWxsU2NyZWVuXSB7RGlzcGxheU1vZGV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheU1vZGUgPSAwIC8qIEZ1bGxTY3JlZW4gKi87XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGF1ZGlvIHNob3VsZCBiZSBwYXVzZWQgd2hlbiB0aGUgZ2FtZSBpcyBubyBsb25nZXIgdmlzaWJsZS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcGF1c2VBdWRpb1doZW5IaWRkZW49dHJ1ZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGF1c2VBdWRpb1doZW5IaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZW5naW5lIHNob3VsZCBkcmF3IHdpdGggZGVidWcgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbaXNEZWJ1Zz1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNEZWJ1ZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z0NvbG9yID0gbmV3IGV4LkNvbG9yKDI1NSwgMjU1LCAyNTUpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGZvciB0aGUgZW5naW5lLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtiYWNrZ3JvdW5kQ29sb3I9bmV3IENvbG9yKDAsIDAsIDEwMCldIHtDb2xvcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgZXguQ29sb3IoMCwgMCwgMTAwKTtcbiAgICAgICAgICAgIHRoaXMuaXNTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIHRoaXMudG90YWwgPSAxO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oXCJQb3dlcmVkIGJ5IEV4Y2FsaWJ1ci5qcyB2aXNpdFwiLCBcImh0dHA6Ly9leGNhbGlidXJqcy5jb21cIiwgXCJmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIik7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkJ1aWxkaW5nIGVuZ2luZS4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzRWxlbWVudElkID0gY2FudmFzRWxlbWVudElkO1xuICAgICAgICAgICAgaWYgKGNhbnZhc0VsZW1lbnRJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiVXNpbmcgQ2FudmFzIGVsZW1lbnQgc3BlY2lmaWVkOiBcIiArIGNhbnZhc0VsZW1lbnRJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNFbGVtZW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJVc2luZyBnZW5lcmF0ZWQgY2FudmFzIGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheU1vZGUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU1vZGUgPSAyIC8qIEZpeGVkICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkVuZ2luZSB2aWV3cG9ydCBpcyBzaXplIFwiICsgd2lkdGggKyBcIiB4IFwiICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGlzcGxheU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkVuZ2luZSB2aWV3cG9ydCBpcyBmdWxsc2NyZWVuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU1vZGUgPSAwIC8qIEZ1bGxTY3JlZW4gKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBleC5Mb2FkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yb290U2NlbmUgPSB0aGlzLmN1cnJlbnRTY2VuZSA9IG5ldyBleC5TY2VuZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkU2NlbmUoJ3Jvb3QnLCB0aGlzLnJvb3RTY2VuZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYXlzIGEgc3ByaXRlIGFuaW1hdGlvbiBvbiB0aGUgc2NyZWVuIGF0IHRoZSBzcGVjaWZpZWQgeCBhbmQgeVxuICAgICAgICAgKiAoaW4gZ2FtZSBjb29yZGluYXRlcywgbm90IHNjcmVlbiBwaXhlbHMpLiBUaGVzZSBhbmltYXRpb25zIHBsYXlcbiAgICAgICAgICogaW5kZXBlbmRlbnQgb2YgYWN0b3JzLCBhbmQgd2lsbCBiZSBjbGVhbmVkIHVwIGludGVybmFsbHkgYXMgc29vblxuICAgICAgICAgKiBhcyB0aGV5IGFyZSBjb21wbGV0ZS4gTm90ZSBhbmltYXRpb25zIHRoYXQgbG9vcCB3aWxsIG5ldmVyIGJlXG4gICAgICAgICAqIGNsZWFuZWQgdXAuXG4gICAgICAgICAqIEBtZXRob2QgcGxheUFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIHtBbmltYXRpb259IEFuaW1hdGlvbiB0byBwbGF5XG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IHggZ2FtZSBjb29yZGluYXRlIHRvIHBsYXkgdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSB5IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltYXRpb24sIHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKG5ldyBBbmltYXRpb25Ob2RlKGFuaW1hdGlvbiwgeCwgeSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byB0aGUgY3VycmVudCBzY2VuZSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyBzeW5vbnltb3VzXG4gICAgICAgICAqIHRvIGNhbGxpbmcgZW5naW5lLmN1cnJlbnRTY2VuZS5hZGRDaGlsZChhY3RvciA6IEFjdG9yKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQWN0b3JzIGNhbiBvbmx5IGJlIGRyYXduIGlmIHRoZXkgYXJlIGEgbWVtYmVyIG9mIGEgc2NlbmUsIGFuZCBvbmx5XG4gICAgICAgICAqIHRoZSAnY3VycmVudFNjZW5lJyBtYXkgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gYWRkIHRvIHRoZSBjdXJyZW50IHNjZW5lXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRDaGlsZChhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gdGhlIGN1cnJlbnRTY2VuZSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyBzeW5vbnltb3VzXG4gICAgICAgICAqIHRvIGNhbGxpbmcgZW5naW5lLmN1cnJlbnRTY2VuZS5yZW1vdmVDaGlsZChhY3RvciA6IEFjdG9yKS5cbiAgICAgICAgICogQWN0b3JzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBhIHNjZW5lIHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRvIHJlbW92ZSBmcm9tIHRoZSBjdXJyZW50IHNjZW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlQ2hpbGQoYWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIFRpbGVNYXAgdG8gdGhlIFNjZW5lLCBvbmNlIHRoaXMgaXMgZG9uZSB0aGUgVGlsZU1hcCB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGFkZFRpbGVNYXBcbiAgICAgICAgICogQHBhcmFtIHRpbGVNYXAge1RpbGVNYXB9XG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZFRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuYWRkVGlsZU1hcCh0aWxlTWFwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBUaWxlTWFwIGZyb20gdGhlIFNjZW5lLCBpdCB3aWxsbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlVGlsZU1hcFxuICAgICAgICAgKiBAcGFyYW0gdGlsZU1hcCB7VGlsZU1hcH1cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVUaWxlTWFwKHRpbGVNYXApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBleGNhbGlidXIgdGltZXIgdG8gdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byBhZGQgdG8gdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgICAgICAqIEBtZXRob2QgYWRkVGltZXJcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5hZGRUaW1lcih0aW1lcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGV4Y2FsaWJ1ciB0aW1lciBmcm9tIHRoZSBjdXJyZW50IHNjZW5lLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVRpbWVyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byByZW1vdmUgdG8gdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVGltZXIodGltZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIHNjZW5lIHRvIHRoZSBlbmdpbmUsIHRoaW5rIG9mIHNjZW5lcyBpbiBleGNhbGlidXIgYXMgeW91XG4gICAgICAgICAqIHdvdWxkIHNjZW5lcyBpbiBhIHBsYXkuXG4gICAgICAgICAqIEBtZXRob2QgYWRkU2NlbmVcbiAgICAgICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHNjZW5lLCBtdXN0IGJlIHVuaXF1ZVxuICAgICAgICAgKiBAcGFyYW0gc2NlbmUge1NjZW5lfSBUaGUgc2NlbmUgdG8gYWRkIHRvIHRoZSBlbmdpbmVcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkU2NlbmUgPSBmdW5jdGlvbiAobmFtZSwgc2NlbmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lSGFzaFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJTY2VuZVwiLCBuYW1lLCBcImFscmVhZHkgZXhpc3RzIG92ZXJ3cml0aW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2VuZUhhc2hbbmFtZV0gPSBzY2VuZTtcbiAgICAgICAgICAgIHNjZW5lLmVuZ2luZSA9IHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlU2NlbmUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguU2NlbmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zY2VuZUhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVIYXNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lSGFzaFtrZXldID09PSBlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2VuZUhhc2hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50aXR5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNjZW5lXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVIYXNoW2VudGl0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlVJQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRVSUFjdG9yKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LkFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaW1lcihlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbGVNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbGVNYXAoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2VuZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlVJQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVVSUFjdG9yKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LkFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcihlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbGVNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGVNYXAoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5TY2VuZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NlbmUoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50aXR5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgY3VycmVudGx5IHVwZGF0aW5nIGFuZCBkcmF3aW5nIHNjZW5lIHRvIGEgZGlmZmVyZW50LFxuICAgICAgICAgKiBuYW1lZCBzY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBnb1RvU2NlbmVcbiAgICAgICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHNjZW5lIHRvIHRyYXNpdGlvbiB0by5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ29Ub1NjZW5lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lSGFzaFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRGVhY3RpdmF0ZS5jYWxsKHRoaXMuY3VycmVudFNjZW5lKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU2NlbmUgPSB0aGlzLmN1cnJlbnRTY2VuZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9IHRoaXMuc2NlbmVIYXNoW25hbWVdO1xuICAgICAgICAgICAgICAgIG9sZFNjZW5lLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdkZWFjdGl2YXRlJywgbmV3IGV4LkRlYWN0aXZhdGVFdmVudCh0aGlzLmN1cnJlbnRTY2VuZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uQWN0aXZhdGUuY2FsbCh0aGlzLmN1cnJlbnRTY2VuZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2FjdGl2YXRlJywgbmV3IGV4LkFjdGl2YXRlRXZlbnQob2xkU2NlbmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2NlbmVcIiwgbmFtZSwgXCJkb2VzIG5vdCBleGlzdCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZW5naW5lcyBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzLlxuICAgICAgICAgKiBAbWV0aG9kIGdldFdpZHRoXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlciBUaGUgd2lkdGggb2YgdGhlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoIC8gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldFpvb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmVzIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0SGVpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlciBUaGUgaGVpZ2h0IG9mIHRoZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0IC8gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldFpvb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybXMgdGhlIGN1cnJlbnQgeCwgeSBmcm9tIHNjcmVlbiBjb29yZGluYXRlcyB0byB3b3JsZCBjb29yZGluYXRlc1xuICAgICAgICAgKiBAbWV0aG9kIHNjcmVlblRvV29ybGRDb29yZGluYXRlc1xuICAgICAgICAgKiBAcGFyYW0gcG9pbnQge1BvaW50fSBzY3JlZW4gY29vcmRpbmF0ZSB0byBjb252ZXJ0XG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgLy8gdG9kbyBzZXQgdGhlc2UgYmFjayB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aFxuICAgICAgICAgICAgdmFyIG5ld1ggPSBwb2ludC54O1xuICAgICAgICAgICAgdmFyIG5ld1kgPSBwb2ludC55O1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRGb2N1cygpO1xuICAgICAgICAgICAgICAgIG5ld1ggPSBmb2N1cy54ICsgKHBvaW50LnggLSAodGhpcy5nZXRXaWR0aCgpIC8gMikpO1xuICAgICAgICAgICAgICAgIG5ld1kgPSBmb2N1cy55ICsgKHBvaW50LnkgLSAodGhpcy5nZXRIZWlnaHQoKSAvIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1ggPSBNYXRoLmZsb29yKChuZXdYIC8gdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpICogdGhpcy5nZXRXaWR0aCgpKTtcbiAgICAgICAgICAgIG5ld1kgPSBNYXRoLmZsb29yKChuZXdZIC8gdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KSAqIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludChuZXdYLCBuZXdZKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybXMgYSB3b3JsZCBjb29yZGluYXRlLCB0byBhIHNjcmVlbiBjb29yZGluYXRlXG4gICAgICAgICAqIEBtZXRob2Qgd29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCB7UG9pbnR9IHdvcmxkIGNvb3JkaW5hdGUgdG8gY29udmVydFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gc2V0IHRoZXNlIGJhY2sgdGhpcy5jYW52YXMuY2xpZW50V2lkdGhcbiAgICAgICAgICAgIC8vIHRoaXMgaXNuJ3QgY29ycmVjdCBvbiB6b29tXG4gICAgICAgICAgICB2YXIgc2NyZWVuWCA9IHBvaW50Lng7XG4gICAgICAgICAgICB2YXIgc2NyZWVuWSA9IHBvaW50Lnk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldEZvY3VzKCk7XG4gICAgICAgICAgICAgICAgc2NyZWVuWCA9IChwb2ludC54IC0gZm9jdXMueCkgKyAodGhpcy5nZXRXaWR0aCgpIC8gMik7IC8vKHRoaXMuZ2V0V2lkdGgoKSAvIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgICAgICBzY3JlZW5ZID0gKHBvaW50LnkgLSBmb2N1cy55KSArICh0aGlzLmdldEhlaWdodCgpIC8gMik7IC8vICh0aGlzLmdldEhlaWdodCgpIC8gdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcmVlblggPSBNYXRoLmZsb29yKChzY3JlZW5YIC8gdGhpcy5nZXRXaWR0aCgpKSAqIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgIHNjcmVlblkgPSBNYXRoLmZsb29yKChzY3JlZW5ZIC8gdGhpcy5nZXRIZWlnaHQoKSkgKiB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludChzY3JlZW5YLCBzY3JlZW5ZKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGludGVybmFsIGNhbnZhcyBoZWlnaHQgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGRpc3BsYXkgbW9kZS5cbiAgICAgICAgICogQG1ldGhvZCBzZXRIZWlnaHRCeURpc3BsYXlNb2RlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNldEhlaWdodEJ5RGlzcGxheU1vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gMSAvKiBDb250YWluZXIgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IDAgLyogRnVsbFNjcmVlbiAqLykge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzBweCc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCA9IHBhcmVudC5pbm5lcldpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGFyZW50LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGNhbnZhcywgcmVuZGVyaW5nIGNvbnRleHQsIGRpc3BsYXltb2RlLCBhbmQgbmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gMCAvKiBGdWxsU2NyZWVuICovIHx8IHRoaXMuZGlzcGxheU1vZGUgPT09IDEgLyogQ29udGFpbmVyICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmRpc3BsYXlNb2RlID09PSAxIC8qIENvbnRhaW5lciAqLyA/ICh0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpIDogd2luZG93KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodEJ5RGlzcGxheU1vZGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIlZpZXcgcG9ydCByZXNpemVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRIZWlnaHRCeURpc3BsYXlNb2RlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5pbmZvKFwicGFyZW50LmNsaWVudEhlaWdodCBcIiArIHBhcmVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRBbnRpYWxpYXNpbmcoX3RoaXMuaXNTbW9vdGhpbmdFbmFibGVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgaW5wdXRzXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0ge1xuICAgICAgICAgICAgICAgIGtleWJvYXJkOiBuZXcgZXguSW5wdXQuS2V5Ym9hcmQodGhpcyksXG4gICAgICAgICAgICAgICAgcG9pbnRlcnM6IG5ldyBleC5JbnB1dC5Qb2ludGVycyh0aGlzKSxcbiAgICAgICAgICAgICAgICBnYW1lcGFkczogbmV3IGV4LklucHV0LkdhbWVwYWRzKHRoaXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMuaW5pdCgpO1xuICAgICAgICAgICAgLy8gSXNzdWUgIzM4NSBtYWtlIHVzZSBvZiB0aGUgdmlzaWJpbGl0eSBhcGlcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL1VzZXJfZXhwZXJpZW5jZS9Vc2luZ190aGVfUGFnZV9WaXNpYmlsaXR5X0FQSVxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4gfHwgZG9jdW1lbnQubXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2hpZGRlbicsIG5ldyBleC5IaWRkZW5FdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiV2luZG93IGhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCd2aXNpYmxlJywgbmV3IGV4LlZpc2libGVFdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiV2luZG93IHZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBpbiBmYXZvciBvZiB2aXNpYmlsaXR5IGFwaVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKEV2ZW50VHlwZVtFdmVudFR5cGUuQmx1cl0sIG5ldyBCbHVyRXZlbnQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgIFxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaChFdmVudFR5cGVbRXZlbnRUeXBlLkZvY3VzXSwgbmV3IEZvY3VzRXZlbnQoKSk7XG4gICAgICAgICAgICB9KTsqL1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbnZhc0VsZW1lbnRJZCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLCB0aGlzIHdpbGwgc2V0IHRoZSBhbnRpYWxpYXNpbmcgZmxhZyBvbiB0aGVcbiAgICAgICAgICogY2FudmFzLiBTZXQgdGhpcyB0byBmYWxzZSBpZiB5b3Ugd2FudCBhICdqYWdnZWQnIHBpeGVsIGFydCBsb29rIHRvIHlvdXJcbiAgICAgICAgICogaW1hZ2UgcmVzb3VyY2VzLlxuICAgICAgICAgKiBAbWV0aG9kIHNldEFudGlhbGlhc2luZ1xuICAgICAgICAgKiBAcGFyYW0gaXNTbW9vdGgge2Jvb2xlYW59IFNldCBzbW9vdGhpbmcgdG8gdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zZXRBbnRpYWxpYXNpbmcgPSBmdW5jdGlvbiAoaXNTbW9vdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XG4gICAgICAgICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcbiAgICAgICAgICAgIHRoaXMuY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xuICAgICAgICAgICAgdGhpcy5jdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XG4gICAgICAgICAgICB0aGlzLmN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIFJldHVybiB0aGUgY3VycmVudCBzbW9vdGhpbmcgc3RhdHVzIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICogQG1ldGhvZCBnZXRBbnRpYWxpYXNpbmdcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nZXRBbnRpYWxpYXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IHRoaXMuY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCB0aGlzLmN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgdGhpcy5jdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBlbnRpcmUgc3RhdGUgb2YgdGhlIGdhbWVcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gc3VzcGVuZCB1cGRhdGVzIHVudGlsbCBsb2FkaW5nIGlzIGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvY2VzcyBlbmdpbmUgbGV2ZWwgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS51cGRhdGUodGhpcywgZGVsdGEpO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWEuYW5pbWF0aW9uLmlzRG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgaW5wdXQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICAvLyBQdWJsaXNoIHVwZGF0ZSBldmVudFxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaChleC5FdmVudFR5cGVbNSAvKiBVcGRhdGUgKi9dLCBuZXcgZXguVXBkYXRlRXZlbnQoZGVsdGEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIHRoZSBlbnRpcmUgZ2FtZVxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIGRyYXcge251bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGRyYXcuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnYmxhY2snO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TG9hZGluZ0JhcihjdHgsIHRoaXMucHJvZ3Jlc3MsIHRoaXMudG90YWwpO1xuICAgICAgICAgICAgICAgIC8vIERyYXdpbmcgbm90aGluZyBlbHNlIHdoaWxlIGxvYWRpbmdcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvci50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmRyYXcodGhpcy5jdHgsIGRlbHRhKTtcbiAgICAgICAgICAgIC8vIHRvZG8gbmVlZHMgdG8gYmUgYSBiZXR0ZXIgd2F5IG9mIGRvaW5nIHRoaXNcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgYS5hbmltYXRpb24uZHJhdyhjdHgsIGEueCwgYS55KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mcHMgPSAxLjAgLyAoZGVsdGEgLyAxMDAwKTtcbiAgICAgICAgICAgIC8vIERyYXcgZGVidWcgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5mb250ID0gXCJDb25zb2xhc1wiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuZGVidWdDb2xvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5pbnB1dC5rZXlib2FyZC5nZXRLZXlzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KGtleXNbal0udG9TdHJpbmcoKSArIFwiIDogXCIgKyAoZXguSW5wdXQuS2V5c1trZXlzW2pdXSA/IGV4LklucHV0LktleXNba2V5c1tqXV0gOiBcIk5vdCBNYXBwZWRcIiksIDEwMCwgMTAgKiBqICsgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChcIkZQUzpcIiArIHRoaXMuZnBzLnRvRml4ZWQoMikudG9TdHJpbmcoKSwgMTAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb3N0UHJvY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnNbaV0ucHJvY2Vzcyh0aGlzLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCB0aGlzLmN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2N0eC5kcmF3SW1hZ2UoY3VycmVudEltYWdlLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgdGhlIGludGVybmFsIGdhbWUgbG9vcCBmb3IgRXhjYWxpYnVyIGFmdGVyIGxvYWRpbmdcbiAgICAgICAgICogYW55IHByb3ZpZGVkIGFzc2V0cy5cbiAgICAgICAgICogQG1ldGhvZCBzdGFydFxuICAgICAgICAgKiBAcGFyYW0gW2xvYWRlcj11bmRlZmluZWRdIHtJTG9hZGFibGV9IE9wdGlvbmFsIHJlc291cmNlcyB0byBsb2FkIGJlZm9yZVxuICAgICAgICAgKiBzdGFydGluZyB0aGUgbWFpbmxvb3AuIFNvbWUgbG9hZGFibGUgc3VjaCBhcyBhIExvYWRlciBjb2xsZWN0aW9uLCBTb3VuZCwgb3IgVGV4dHVyZS5cbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgICAgIHZhciBsb2FkaW5nQ29tcGxldGU7XG4gICAgICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyLndpcmVFbmdpbmUodGhpcyk7XG4gICAgICAgICAgICAgICAgbG9hZGluZ0NvbXBsZXRlID0gdGhpcy5sb2FkKGxvYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nQ29tcGxldGUgPSBleC5Qcm9taXNlLndyYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN0YXJ0aW5nIGdhbWUuLi5cIik7XG4gICAgICAgICAgICAgICAgLy8gTWFpbmxvb3BcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHZhciBnYW1lID0gdGhpcztcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gbWFpbmxvb3AoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2FtZS5oYXNTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtYWlubG9vcCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGltZSB0byBjYWxjdWxhdGUgdGltZS1lbGFwc2VkXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZCA9IE1hdGguZmxvb3Iobm93IC0gbGFzdFRpbWUpIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmVzIGlzc3VlICMxMzggaWYgdGhlIGdhbWUgaGFzIGJlZW4gcGF1c2VkLCBvciBibHVycmVkIGZvciBcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSB0aGFuIGEgMjAwIG1pbGxpc2Vjb25kcywgcmVzZXQgZWxhcHNlZCB0aW1lIHRvIDEuIFRoaXMgaW1wcm92ZXMgcmVsaWFiaWxpdHkgXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm92aWRlcyBtb3JlIGV4cGVjdGVkIGJlaGF2aW9yIHdoZW4gdGhlIGVuZ2luZSBjb21lcyBiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gZm9jdXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsYXBzZWQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdhbWUudXBkYXRlKGVsYXBzZWQpO1xuICAgICAgICAgICAgICAgICAgICBnYW1lLmRyYXcoZWxhcHNlZCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gbm93O1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJHYW1lIHN0YXJ0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2FkaW5nQ29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyBFeGNhbGlidXIncyBtYWlubG9vcCwgdXNlZnVsIGZvciBwYXVzaW5nIHRoZSBnYW1lLlxuICAgICAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdhbWUgc3RvcHBlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgc2NyZWVuIHNob3Qgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQgYW5kIHJldHVybnMgaXQgYXMgYW5cbiAgICAgICAgICogSFRNTCBJbWFnZSBFbGVtZW50LlxuICAgICAgICAgKiBAbWV0aG9kIHNjcmVlbnNob3RcbiAgICAgICAgICogQHJldHVybnMgSFRNTEltYWdlRWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zY3JlZW5zaG90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgIHJlc3VsdC5zcmMgPSByYXc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgdGhlIEV4Y2FsaWJ1ciBsb2FkaW5nIGJhclxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdMb2FkaW5nQmFyXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGNhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVkIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyBsb2FkZWRcbiAgICAgICAgICogQHBhcmFtIHRvdGFsIHtudW1iZXJ9IFRvdGFsIG51bWJlciBvZiBieXRlcyB0byBsb2FkXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmRyYXdMb2FkaW5nQmFyID0gZnVuY3Rpb24gKGN0eCwgbG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGluZ0RyYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdEcmF3KGN0eCwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyAzO1xuICAgICAgICAgICAgdmFyIHggPSB3aWR0aDtcbiAgICAgICAgICAgIC8vIGxvYWRpbmcgaW1hZ2VcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgLy8gNjQgYml0IHN0cmluZyBlbmNvZGluZyBvZiB0aGUgZXhjYWxpYnVyIGxvZ29cbiAgICAgICAgICAgIGltYWdlLnNyYyA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQXlBQUFBRXNDQVlBQUFBN0xkYzZBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVpkRVZZZEZOdlpuUjNZWEpsQUZCaGFXNTBMazVGVkNCMk15NDFMamVuaEozTUFBQTZZMGxFUVZSNFh1M2RVYWdrV1ozbmNVRUVRWVNpUlhCZG1pMktkUlVaeGdKWmhtVjlxT2Rta1dKWWxtWVloa0tXY1djZnBFRFFGeDlLMk80Rm02VWFWaG9haGk0R0Yyd1doMXBuWWF3SG9YenhwVnU2R2ltYXRxbmkwa3BUaUdMaGd5KyszUG45TWs2a2tYbFBacDRUR1NmaVJPVDNBMzlhcTI1RW5NaTZHZkgvWmNTSi9CQUFBQUFBQUFBQUFBQUFZQXcvKzluUExxbHVxTzZycm9jL0JnQUFBSURoaE5CeFYzVWU2bW40S3dBQUFBQTRua0xHZGRVZGg0MFFPcnAxSi93WUFBQUFBUFNqWUhIVjRVSVZDeDNkdWhvV0FRQUFBSUIwRGhPcTI2cXpFQzRPMVZsWUZBQUFBQUFPVTRpNHJMcnBNQkZDeFlWNjY2MjN6dDk5OTkzejk5OS8vL3lkZDk3cC90M3RzQm9BQUFBQWlGTndhRVBIZ3hBa290V0dqdC84NWplcit2V3ZmNzM5TTl4K0JRQUFBT0FpaFlYMnNibmRKMWhkS0YvaE9EczdXNFdOTm5pMDlmang0KzdQUGdpckJnQUFBSUNHZ3NMQjBQSHpuLzk4Witqb2xuK3VzOXpOc0FrQUFBQUFwMHpoWU45amMxZmxNT0VyR2srZVBJbUdqZTN5ejIydDQzTFlIQUFBQUlCVG8wQnc4TEc1YjcvOTl2bDc3NzJYSERxNnhlMVhBQUFBd0lsVEVEajQyTncyZEh6d3dRZlJZSkZhWGs5bnZUZkNFQUFBQUFBc21aci9yTWZteHNKRWJqbThiRzNqVWhnT0FBQUFnS1ZSdzkvcnNibERsYStnZExaek53d0xBQUFBd0ZLbzBULzZzYmxERmJkZkFRQUFBQXZsQmw4MXlHTnpoNmhmL2VwWDNXMTdnanUzWHdFQUFBQnpwcVorOE1mbURsVytyYXN6amp0aHlBQUFBQURtUk0xODBjZm1EbFdlME40WjAvVXdmQUFBQUFDMVV3TS8ybU56aHloUGFPK003V25ZRFFBQUFBQzFVd1B2dVIzZGhuNWRRejgyZDZqaTlpc0FBQUJnaHRTOFI4TkhqYUdqTFU5dzN4cnYxYkE3QUFBQUFHcWx4bjBqZlBocXgxaFBzRHFtUE1iT3VNL0M3Z0FBQUFDb2xScjNDK0dqaHJrZEtlWHZGK21NL1hiWUpRQUFBQUExVXRNKzIvREI3VmNBQUFEQWpLaGhuMjM0Y1BuN1JqcmpmeEIyQ3dBQUFFQnQxTERQT255NC9LV0huWDI0R1hZTkFBQUFRRTNVck04K2ZQaExEN3Y3b0xvY2RnOEFBQUJBTGRTb3p6NTh1QjQ5ZXRRTkg5eCtCUUFBQU5SR2pmcEcrUEF0VEhNTUh5NS9FM3RuWDI2RVhRUUFBQUJRQXpmcG5ZWjlGVDVxLzQ2UFhlWFExTjBYMWFXd213QUFBQUNtcGdaOU1lSEQ5ZDU3NzNYRHg5Mndtd0FBQUFDbXBnWjlVZUhEeGUxWEFBQUFRSVhjbkhjYTlVV0VqL2ZmZjc4YlBwNnF1UDBLQUFBQW1Kb2E4OFdGRDllNzc3N2JEU0Izd3U0Q0FBQUFtSW9hODBXR0Q1Y2ZHOXpadCt0aGx3RUFBQUJNUVUzNVlzUEg5dTFYWVpjQkFBQUFURUZOK1dMRGgrdWRkOTdwQnBEYlliY0JBQUFBakUwTithTERoL2VsdTMrcXEySFhBUUFBQUl4SnpmaWl3NGZyN095c0d6N093cTREQUFBQUdKT2E4Y1dIRHhlM1h3RUFBQUFUVXlOK0V1SGp5Wk1uM2ZEaHVoeGVBZ0FBQUFCalVCTitFdUhEOWZqeDQyNzRlQkJlQWdBQUFBQmpVQk4rTXVIRDVmM3I3Ty9OOERJQUFBQUFLRTBOK0VtRkQyNi9BZ0FBQUNhaTV2dWt3b2ZyMGFOSDNmQnhQN3dVQUFBQUFFcFM4MzF5NGNQMTl0dHZkd1BJamZCeUFBQUFBQ2pGalhlbkNUK1o4UEhCQng5MHc0ZnJVbmhKQUFBQUFKU2dwdnNrdzRmcnZmZmU2NGFQdStFbEFRQUFBRkNDbXU2VERSOHVicjhDQUFBQVJ1S0d1OU44bjF6NGVQLzk5N3ZoNDJsNFdRQUFBQUFNVFEzM1NZY1AxN3Z2dnRzTklIZkNTd01BQUFCZ1NHcTJUejU4dU41NjY2MXVBTGtlWGg0QUFBQUFRMUdqVGZoUVBYNzh1QnMrdVAwS0FBQUFHSm9hYmNLSDZ1enNyQnMrWExmRFN3UUFBQUJnQ0dxeUNSK3FTUGg0b09LN1B3QUFBSUNocU1FbWZLZ0lId0FBQUVCaGFyQUpIeXJDQndBQUFGQ1lHbXpDaDRyd0FRQUFBQlNtQnB2d29TSjhBQUFBQUlXcHdTWjhxQWdmQUFBQVFHRnFzQWtmS3NJSEFBQUFVSmdhYk1LSGl2QUJBQUFBRktZR20vQ2hJbndBQUFBQWhhbkJ2dDFwdUFrZmZ5ckNCd0FBQURBa05kaDNPZzAzNGVOUFJmZ0FBQUFBaHFRR20vQ2hJbndBQUFBQWhhbkJKbnlvQ0I4QUFBQkFZV3F3Q1I4cXdnY0FBQUJRbUJwc3dvZUs4QUVBQUFBVXBnYWI4S0VpZkFBQUFBQ0ZxY0VtZktnSUh3QUFBRUJoYXJBSkh5ckNCd0FBQUZDWUdtekNoNHJ3QVFBQUFCU21CcHZ3b1NKOEFBQUFBSVdwd1NaOHFBZ2ZBQUFBUUdGcXNBa2ZLc0lIQUFBQVVKZ2FiTUtIaXZBQkFBQUFGS1lHbS9DaElud0FBQUFBaGFuQkpueW9DQjhBQUFCQVlXcXdDUjhxd2djQUFBQlFtQnBzd29lSzhBRUFBQUFVcGdhYjhLRWlmQUFBQUFDRnFjRW1mS2dJSHdBQUFFQmhhckFKSHlyQ0J3QUFBRkNZR216Q2g0cndBUUFBQUJTbUJwdndvU0o4QUFBQUFJV3B3U1o4cUI0OWV0UU5IaTdDQndBQUFEQWtOZGlFRDlXNzc3N2JEUjR1d2djQUFBQXdKRFhZaEE4VjRRTUFBQUFvVEEwMjRVTkYrQUFBQUFBS1U0Tk4rRkFSUGdBQUFJREMxR0FUUGxTRUR3QUFBS0F3TmRpRUR4WGhBd0FBQUNoTURUYmhRMFg0QUFBQUFBcFRnMDM0VUJFK0FBQUFnTUxVWUJNK1ZJUVBBQUFBb0RBMTJJUVBGZUVEQUFBQUtFd05OdUZEUmZnQUFBQUFDbE9EVGZoUUVUNEFBQUNBd3RSZ0V6NVVoQThBQUFDZ01EWFloQThWNFFNQUFBQW9UQTAyNFVORitBQUFBQUFLVTROTitGQVJQZ0FBQUlEQzFHQVRQbFNFRHdBQUFLQXdOZGlFRHhYaEF3QUFBQ2hNRFRiaFEwWDRBQUFBQUFwVGcwMzRVQkUrQUFBQWdNTFVZQk0rVklRUEFBQUFvREExMklRUEZlRURBQUFBS0V3Tk51RkRSZmdBTUhmbjUrZmZVQ1VMaXhXaDFiL1FiQ1hKbTJHeElyVCtlODFta3R3TGl3RUFTbENEVGZoUUVUNEFMSUdhNXlvQ2lGYjlwV1lMV1Y0SWl3OU82eWFBQUVBTjFHQnZoSStIRHg4U1Bwb2FMWHo0Uk5lYzd4YmhHMkczQUV6RTc4UG03WmdtTERZNHJmck5aZ3Zacm9SVkRFcnJKWUFBd05UVVlHK0VEemZoc2VaODZUWDFsUStmNkpyejNTSVFRSUNKK1gzWXZCM1RoTVVHcGRWZWFkYmV5MWZEYWdhbDlSSkFBR0JLYXJBSkg2b2FicnZ5aWE0NTN5MENBUVNZbU4rSHpkc3hUVmhzVUZwdG45dXZXcStFMVF4SzZ5V0FBTUJVMUdBVFBsUTFoQS96aWE0NTN5MENBUVNZbU4rSHpkc3hUVmhzVUZydE1RR2tTUFB2OVRhclQwSUFBWUNocU1FbWZLaHFDUi9tRTExenZsc0VBZ2d3TWI4UG03ZGptckRZb0xSYXJvQUFBQWdmYmRVVVBzd251dVo4dHdnRUVHQmlmaDgyYjhjMFliRkJhYlhNQVFHQVU2Y0dtL0NocWkxOG1FOTB6Zmx1RVFnZ3dNVDhQbXplam1uQ1lvUFRxaDgxVzhqR1U3QUFZTzdVWUJNK1ZEV0dEL09KcmpuZkxRSUJCSmlZMzRmTjJ6Rk5XR3h3V3ZWenpSYXlGRHVHYU4wRUVBQVlneHBzd29lcTF2QmhQdEUxNTd0RklJQUFFL1A3c0hrN3BnbUxGYUhWdjlKc0pRbmZoQTRBYzZjR20vQ2hxamw4bUU5MHpmbHVFUWdnd01UOFBtemVqbW5DWXNWb0V5bmpjVkQ1UkZpa0NLMmZBQUlBSmFuQkpueW9hZzhmNWhOZGM3NWJCQUlJTURHL0Q1dTNZNXF3V0ZIYWpDZWx2NkRxZmp1NjU0ZzRlSHdwL0ZoUjJnNEJCQUJLVVlOTitGRE5JWHlZVDNUTitTNU5XQXdBb25TWXFDNkExRUM3U2dBQmdCTFVZQk0rVkhNSkgrWVRYWE8rU3hNV0E0QW9IU1lJSUJIYVZRSUlBQXhORFRiaFF6V244R0UrMFRYbnV6UmhNUUNJMG1HQ0FCS2hYU1dBQU1DUTFHQVRQbFJ6Q3gvbUUxMXp2a3NURmdPQUtCMG1DQ0FSMmxVQ0NBQU1SUTAyNFVNMXgvQmhQdEUxNTdzMFlURUFpTkpoZ2dBU29WMGxnQURBRU5SZ0V6NVVjdzBmNWhOZGM3NUxFeFlEZ0NnZEpnZ2dFZHBWQWdnQUhFc05OdUZETmVmd1lUN1JOZWU3TkdFeEFJalNZWUlBRXFGZEpZQUF3REhVWUJNK1ZITVBIK1lUWFhPK1N4TVdBNEFvSFNZSUlCSGFWUUlJQVBTbEJwdndvVnBDK0RDZjZKcnpYWnF3R0FCRTZUQkJBSW5RcmhKQUFLQVBOZGlFRDlWU3dvZjVSTmVjNzlLRXhRQWdTb2NKQWtpRWRwVUFBZ0M1MUdBVFBsUkxDaC9tRTExenZrc1RGZ09BS0IwbUNDQVIybFVDQ0FEa1VJTk4rRkJGd3NkOTFXekRoL2xFMTV6djBvVEZBQ0JLaHdrQ1NJUjJsUUFDQUtuVVlCTStWSkh3Y1NlOFJMUG1FMTF6dmtzVEZnT0FLQjBtQ0NBUjJsVUNDSUR5L3VudlBuUlpkUzJoYmlYVUhkWDlUdDBJbXluS1RYYTM2U1o4TEN0OG1FOTB6Zmt1VFZnTUFLSjBtQ0NBUkdoWENTQUFMbEpUN3pDdzNlanZxdk9KNjFZWWRqRnVzcnROTitGamVlSERmS0pyem5kcHdtSUFFS1hEQkFFa1FydWFjNndsZ0FDbndrMzlWcE5mYzkwTnd5N0NUWGEzNlNaOExETjhtRTkwemZrdVRWZ01BS0owbUNDQVJHaFhjNDYxQkJEZ1ZLaXBIelNBL09ockh6Ny82YmMrZHJBZXZ2VE0rUzllL3VUZWV2emRUNjJxcy83N1lkaURjNVBkYmJvSkg4c05IK1lUWFhPK1N4TVdBd2FqWDZzdnFaNVh1WEgxNzZQcmtXb1gvMTM3YzE3R3kzNGhySzU2R3F2Mzk2dGg3TzErdktuYTVYZXEyZXh2R0dPeXNOamlhVmY5NzVkcWtBQ2k5WHhCNWQrWEY3ek9VTHZNNW5jTTg2TGZwU3NxSC9OZVY4V09kZTB4N2hXVmYrNUtXUFEwcUtsZkI1QUhMMTQ2LyszM0x1K3NQLzd3cytmbi8vejVVZXNQUC9qTWFteHRoV0VQeWsxMnQra21mQ3c3ZkZoNDB5Y0xpd0c5NmRmSVRWSGJmQS9ONjZ6bUJLWnhmRUwxbk1vbjFuMGhvdytmdEwzZTU4TG1xcUR4RUVBaXRLczV2Kys5QTRpV2RjRDE3OFcrRUovSzY2anVkd3p6b044Yi95NzJPYzZmMWhWQU5mWHJBT0tyRHJFUU1IVzE0d3QxT1F4OUVHNnl1MDAzNFdQNTRjUDhSbS9lNzJuQ1lyT25YZkVuTW03Z2NqMGZWakVwamNPTmJlNzRKenVvYTl0K3ZmMHA3QkJOVVNvMy9QNGs5eE5oR0tQdzlzSjIvV25mV1B5NnV2RWZkVjlqd2ppU2hjV0swT3B6am05RjN4OWVmN09aSk5sajBUTCtuU3Y1L3ZLNkhlNXIrQjJiOVhsTFE4cDZqOGlYd3FLRDA3b0gvNzNVei9sRHBxeC9veTBFa05yS3QyeTFZMVJkRDBNL21wdnNidE5OK0RpTjhHRitvemZ2OXpSaHNVWFE3dmhrbXV0UldIeFNHb2ViK1J3T0s2TmZGZEEyL1FuWW1JMTRqUGY5RzJGSXhXZ2JEbG4rdExoUHNCMkt0ejFwU05iMkNTQVJYbit6bVNUSlk5SFBsZzRlMjJyNEhadjFlVXREV213QTBjLzBPYTl1TzdrQTRpZGduYnM4M3lJV0FLWXUzeHJXamxFMXlKT3czR1IzbTI3Q3grbUVEL01idlhtL3B3bUxMWVoyS1d2L2crTE43RDdhdmo5ZHl2WFZzUGdvdEQwMzQzMWUyMkxDMEFhblZmZTl6YUFrajJlU1Q2cTFYUUpJaE5mZmJDWkpTcU0zOVh2TVZ4Z25tU2VpN1didGQxaXNHaHJTSWdPSS90NGZ3QXpoNUFMSSt2RzZudWNSQ3dCVDF5OWYvZlJxZktHT25vanVKcnZiZEJNK1RpdDhtTi9vemZzOVRWaHNNYlJMZlpwNWZ3STQyVzBJMm5iV3Y1bU1kakRYdG56N1VlN1ZtVkdFSVE1R3EyeXZlTlRLdjZlak40amFKZ0Vrd3V0dk5wUGtVS1BuZVVWVFhtbHJUWEkxUk51YzlYbExRMXBjQU5IZkRYa3NKSURVVnI5Ly9jcHFmS0dlaHFIMzRpYTcyM1FUUGs0dmZKamY2TTM3UFUxWWJGRzBXN2tuQTNzbExENHFiZGUzVytSd2d6REtyVmZhanNQY21MZUNaQW5ESElSVzErZDNaZ3FqaHhCdGp3QVM0ZlUzbTBteXI5SExQUWFNWWRTcnd0cmVyTTliR3RLaUFvaitmT2dQWWdnZ05aWWY3OXVPVTNVMUREK0xtK3h1MDAzNE9NM3dZWDZqTisvM05HR3h4ZEd1OVhsQzBkaU5YWitKNTZQY2VxWHQxTmdVYlFoRFBacFc1VnV1NW1TMEVHcmFGZ0Vrd3V0dk5wTmtyRVp2U0tOOUtLTnR6ZnE4cFNFdEpvRG96NGFZODdHTkFGSmp2Zkh0ajYvR0dPcG1HSDRTTmRpWFZQYzdEVGZoNDA5MWN1SEQvRVp2M3U5cHdtS0xvMTNyMDFTT2VwRFU5bkp2YlJwbGZOcE96VTNSV2hqdTBiU3F1UVVRZXpNTXZ6aHRpd0FTNGZVM20wa1NhL1J5bTlZcHZCQ0dXNVMyTSt2emxvYTBpQUNpLzkvbkZ1WVVvNTViSjZkbWZoWUJwTzhYRXFyQmR2aDQwR200Q1I5L3FwTU1IK1kzZXZOK1R4TVdXeVR0WHArNUM2TThIMS9ieVQzUWovS3B0N1l4aS9CaFljaEgwNnJtR0VCc2xOdGt2SjFtYzJuQ1lrVm85VG5IdDJvRGlQNS85VmNZTzRyUENkRTJabjNlMHBDV0VrQ0cvbTZqRmdHa3h0citRa0xWcGJBTE82bkJKbnlFSW54czhodTllYituQ1lzdGtuYlB0empsem1FWTViRzgyazdXdjVNVXYvVksyeGd5ZkRndytYRzlQakc3d1krZWNQWG5EbUwrZTEvMjkvYVQvNzNDS282bVZSMGJRRHptZGw4OW1kanJ1L0JRQS85WitEdnZxMzgrOS9hN21ERkNLUUVrd3V0dk5wTmtQUmI5N3o2Zk12dDN6QitvT0xqNGQrakN2N3YvTFB4ZCsxNGE0dmVyVmZUMlZLMS8xdWN0RFduMkFVVC91OFN0VnkwQ1NLMzE0NjkvWkRYT1VEZkNMa1Nwd1NaOGhDSjhYT1EzZXZOK1R4TVdXeXp0b2h2Q1hFV2JmYTAvZDB6RkQ5N2F4bERodytzNTZpcVNsbmNqNVpQaDNqQVNmdnhvV2xXZkFPSUE0V2F3ZHdEUXN1MFhIT2FHNUs3aTkrbHJHd1NRQ0srLzJVeVMxVmowMzV3UFJSd2cvTm9mOHp2bVk4MFEzOXZqTVJkN1VxRFdQZXZ6bG9ZMDZ3Q2kvK2JNUi9Udms0L1BGL1pCZjlaK3lPTGpXdmNESlFKSXJmWHdwV2RXNHd4MU4rekNCV3F3Q1IraENCOXhmcU0zNy9jMFliRkYwMjdtbm9COUlDNXlzdlY2VlRrTnA4ZFM5Rk51clQvMzVCbmpkUXorbW1tZFBwbEZmNmZEanh4TnEwb05JUDUzODRsMzBQMzArbFRIQk1DcWZqL0NZa1ZvOVRuSHR4b0RTTXF4YUJVOFZoc1ppTmJucXk1WjU0YUlZdk5CdE81Wm43YzBwTGtIa0pUeCt4aVZmYXpSTWc3Qm84d2xxa2Fub1YvZDVoUnIvR3VwcmNmeHVxSzNZYW5KdnR0dHVna2ZoSTl0ZXFQZlV5VUxpeTJhZGpQbjA1MVdrUU9tMXB0N29xcnRhc3cyTjFSRkcyRFROaTRFa2ZCWFI5T3FEZ1VRM3hjOXhuM3dmZWNGRkQyNWEvMEVrQWl2djlsTUV2OXN5bnZONzZlU1Z4cU92YzJteUsxWVd1K3N6MXNhMHR3RHlMNFB4ZngzbzMvLzBLeDFHL3BZMDE5YnBkeUdwVWI3VnJmeC92V3ZmeDF0MEpkY2hJLzlkS0M0dHpwa0pBcUxMWjUydFU5ek4yaGo3ZlUxcTAxV3VvSHFFOHhhWG02S0x5enp2K05xek9HUGpxWlY3UW9nUHZHT3VvL2FYbTRqWTc4TGl4ZWg5Uk5BSXJ6K1pqTkpIR0lQWGZrYzZ4SGJ2aHJTOTMxZjVEWDFlcHZWcHdtTFZVTkRtbTBBVWUwTHh2NzdZb0Y0c1RyTmZMVGhyNjIyYnNPS1BnMUx6Ylp2d1hyYU50K1BIajJLTnVsTExjTEhZZUdBa1N3c2RoSzB1MW12alF4NnN2WDZtdFVtY1lOUSt0YWEzTmVqNWJGTjlvbVl0dTNnTk5pL2pkWVZDeUJ1S0NZNThXcTdmZjVkU2pZMEJKQUlyNy9aekNER0RyckhoSkRCZjllMHpxelhNaXhXRFExcHpnRmsxMjJCcjRkVklsZW5tWTgyL0xWVjVHbFlsOE91YkZEVHZiNEs4dFpiYjUzTVZSRENSeG9kTk80MXg0NDBZYkdUb04zMUZZamNrKzRnSndxdEovZFdwMXB2dmZJbnVjVnZ1UnFUOXFjYlFDYS8zY0RiWDQwa1Q3Rkg4bnJkelNiU2hNV0swT3B6am05ekNTQ2pYMGswYmJmUDc1a04vcnA2bmMycTA0VEZxcUVoelRXQTdMb3E1K004Vno3NjZqYnpzWWEveHZycHR6NjJIclBxZHRpVkRXcThUKzRxQ09Fam5RNGE5MWFIai9rcSt0MEdYbit6bVdSSFA1Wlg2OGlkZUY2NmNlcDc2MVh4cXpKVDBENjFBYVRvL2ZjNU5JN2NTZW5GZm1lMGJnSkloTmZmYk9Zb2s0U1BscmJmZDA3STBMZW5acjJXWWJGcWFFaHpEU0F4aXp6T2o2clR5RWViL1Jycmw2OStlajFtMVZQVnJzbm9HM05Cbmp4NUVtM2NsMUNFanp3NmNOeGJIVUxtcS9pWHEya2J1VisyZEZTVG9PVnpUazdGRC81YWYrN0owanl1UlU1RTFINDVnSXh5LzMwcWpTZjdDbFZZZEhCYU5RRWt3dXR2TnROYjhVY29wOUE0K3V6SG9BOCswUHF5eGhBV3E0YUd0S1FBTXNxWDhTNWFwNUdQTnZ1MTF0Wms5SnRoZHk1UUkzN1dOdVh2dlBOT3RIbWZleEUrOHVuZ2NhODVoc3pXR0FFazk5WUROOSs5UGhuWGNya1R6MHZmZXRYMzZnY25wWkhwTmMvOWR5cjFoQ0lDU0lUWDMyeW1GMThScmVWcVc1OWJVd2Q5OElIV2wvVmFoc1dxb1NFdEpZQVVmYytjakU0VEgyMzBhNjFmdlB6SjliaFZaMkYzTGxBemZyM2JuUC9xVjcrS052RnpMY0pIUHo2QU5NZVIyU29lUU16YmFUYVhyTmU0dEZ6T3YwZnhnNysya2J2ZmRsclBjSytFWHZmYzI3Q0tORFZhTHdFa3d1dHZOdE5Mc1FhMEQ0Mm56M0Zoc0E4bHRLNnMxeklzVmcwTmFTa0JoRnV2anFYRy9WS25pWTgyK3JYV0gzLzQyZk1mZmUzRDY3R3JkbjR6dXByeSsyMkQvdmJiYnk5bVFqcmhvejhkUU80MXg1SFpHaXVBNU03THNLeURzMzQrNXpZYWZ3SlovT0N2YmVUdWN6V2YxSjRhdmU2NTkrY1hlZTk0dmMzcTA0VEZpdERxYzQ1dnRRYVE2ajVsMXBoOFBNdzEyQWNUV2xmV2F4a1dxNGFHdElRQVVzVXRnYk9ucHYxYTI4QjdZbmVzMGErNU1xNkNYRmF0SjZTLzk5NTcwWVorVGtYNE9JNE9JbjBQUHJVWUpZQ1l0clhyK3g5MlNYNHNvWDQyTitBVW40T2diZlI1OHRXa2syUlBtVjc3M045UEFzaW1XZ05JVlZjL1docFg3aFczb3gvUTBkSzZzbDdMc0ZnMU5LUWxCQkMrYkhBSWF0cG5IVUFpVjBGdWhWMjdRQTM2eG9UME9kK0tSZmc0bmc0aWZROCt0Umd0Z0ppMlYrUTJGLzFjemdscGxFOUV0WjFkejN2ZlpiQUdBL24wK3VkK0tsM0Z0L2VIeFlyUTZuT09ielVHa09xdWZyUTB0ajZQNVIza3FxM1drL1ZhaHNXcW9TSE5QWUM4R1JiSHNkU3d6enFBdUxhdWd1eDhJcGFwVVgvUU51MXovVzRRd3Njd2RDRHBjL0NweWRnQkpIZFM5c0VEdFg0bVoxTG5XTGRlOWJuRmdxc2ZFd3YvRHFtS05MZGFMd0Vrd3V0dk5wT2w2dmVVeHBkN2krWWc4MEMwbnF6WE1peFdEUTFwN2dHa3FxY0F6cHFhOWRrSGtNaFZrT2ozZ3BpYTlhdXE5YTFZYzNzcUZ1RmpPRHFROURuNDFHVFVBR0xhWnU2dFNYdWJDUDE5enBXR1VRNzgyczd6emVhU2NmV2pBdnAzeUFuSEJKQk5OUWFRcXVkVGFYeTVWNFFIT1Y1clBWbXZaVmlzR2hyUzNBTUl0MThOUmMzNjdBT0k2L0YzUDdYYWgwNWREYnQ0Z1pyMm05MG1maTVmVUVqNEdKWU9KUGVhNDhsc2pSNUFUTnZOQ1EwN0oyYnJ6M1B1MngvdGRneHRLN2V4NE1sWEZkQy9RODc3bVFDeXFiWUFNdHI3dlMrTk1mZURpa0gyeWV0cFZwY21MRllORFduT0FZUVBtNGFrUm4wUkFjVDFrMjkrZExVZm9lNkhYWXhTODM2MzI4elhQaCtFOERFOEhVeHlEejYxbVNxQTVENExQenBPL1hucUxReWozSHJWMHJaeWI2M2dFN0VLNk44aDUvMU1BTmxVV3dDWjVOaVdRMlBNL2Q2aVFacFhyU2ZydFF5TFZVTkRtbk1BU1g2NENoS29VVjlNQVBudDl5NnY5cU5UKzc2YzhKSnFZejdJQng5OEVHMytweTdDUnhrNm1OeHJqaWxwd21JUXZSdzVqejExZ05pNENxTC9uM01TR3UyZVcyMXJrcVlDNmZTYSs4cVpid1gwNzVDdlZ2bDluQk9JalFDeXFiWUFVcXpwSEZJWWE3S3cyRkcwbWxtZnR6U2tPUWVRNm9QeHJLaEpYMHdBY1QxNDhkSnFYMEo1UXZybHNLc1hxSkhmbUEveTg1Ly92S3BKNlI2TDU2aTA0d3RGK0JpSURpWlpCNSt3R0FLOUpEbXYzL3E1NmZyZk9WZFFpalpHMjdTOTNEa3VQQSsrQUwydVE0U01mUWdnbTJvTElMUDRQaDJOTTNlL2pyNlNxM1ZrYlRNc1ZnME5hYzRCWkJiQmVEYlVvTjlvRy9ZM3Z2M3hhRk0vcDRwTVNEOTBLOWJHdDZUWEVrSThCbytsT3pZVjRXTkFPcGhrSFh6Q1lnajBrdVEraW5KMTh0Vi9VK2VRakhycmxXbDd1U2RIbm43VmsxNjcwaUZqSHdMSXBxb0NTRmlzZWhwcTd1TzZqMjVndFk1WnY1WWEwcHdEeUtqbm84VlRnMzZyYmRiOU9OdFlVeiszZXZMYXM2djk2ZFRPN3dZeE5mWTN1bzMrdzRjUG82RmdyQ0o4akVNSGszdk5NU1ZOV0F3ZGVsbHlUaVp1TW5NbW5vLyt1RU50TTdlaFlQN0hBWDZOVkw1bDd3V1YzM05qaFl4OUNDQ2JhZ29ncy9tZUJZMTE5R1phNjVqMWVVdERtbTBBQ1l0aEtHN08yMFo5S1FIRTlmQ2xaMWI3MUtscllaZWozT0IzRzM3UHU0aUZnOUpGK0JpUGppZjNtc05LbXJBWXR1aWxlYk41aFpLa05wK1ROQ0hhTHI4VFI5TEw0dTlSOFJPQ0hPWnFDQnN4QkpCTk5RV1FvbU1aa3NaS0FNbWtJUkZBMEZCanZzZ0E0bHV4dHA2S3RmY0xDczJOZnJmeEh6dUVFRDdHcGVNSkI1OEI2S1hKdWFxUmFwSXJDMkhicVppQTNxSFh3N2RUNVY1Qm1nb0JaQk1CcEFlTk5iZVpQbm9TczlZeDYvT1doalRYQURLYjM4dlpVRk8reUFEaSt2M3JWN2JuZ3p3SXU3MlRHLzV1QUhBSUdXTk9DT0ZqZkQ2Z05NZVZOR0V4Uk9qbDhlMDFRNW5zU1NOaCs2azRJWWxlQjEvdHlIMTA4ZFFJSUpzSUlEMW9yQVNRVEJvU0FRUU5OZVdMRFNDdVg3NzY2ZFcrZGVwZ1UrL0d2eHNFSEF4S2hoREN4elI4UUdtT0sybkNZb2pReStQYmJvWm9RaWU3LzF2YjlqN2tPT2tUa3ZiZlY3N21GanhhQkpCTkJKQWVORllDU0NZTmlRQ0NoaHJ5UlFjUVYyUSt5TjVKNmVZQTBBMEVwVUlJNFdNNlBxQTB4NVUwWVRIc29KY285eEcyTVpOTjZ0YTJjMjhsTzhsdlFOZCtPNmdOZWNWckNnU1FUUVNRSGpSV0FrZ21EWWtBZ29hYjhiWXhYMm9BY2ZrUncrMStocm9SWG9LZEhBUzZ3V0RvTHlza2ZFekxCNVRtdUpJbUxJWTk5RElkTXdkZ3NsdXZUTnZQRFNDVGpuY0sybWVIajV5SERwVGc5NjEvejl6SStQWXYvN3Q1WERudlp3TElKZ0pJRHhvckFTU1Roa1FBUVVPTitEcUErSXNJL1czaWYvakJaNkpOL0p3ck1pbmRsUkpDYm5VRGdrUEkyZGxaTkZEa0ZPRmplajZnTk1lVk5HRXg3S0dYS2ZjMnBxNUp2M3hNMnllQTdLSDk5ZU4weDNpcWxiZmg5NllmMjd3Uk1zSlFvdlQzT2U5bkFzZ21Ba2dQR2lzQkpKT0dSQUJCUTAzNDNhMm1mRjBPSkw1OXlkK3I0UVkrMXRqUHFid1BQLzc2UjdiM015V0ViSHhQaU91WUoyUVJQdXJnQTBwelhFa1RGc01lZXBuOGZROTlUWHBMazdaUEFObEIrK3BnT1hUNDhKV1VObVQ0OXIyakdnMHRuL04rSm9Cc0lvRDBvTEdPM2t4ckhiTStiMmxJQkJBMDFJRGYzMnJJZDVhdklMU0JKTmJnejZFaVQ4WnlwWVNRcTZxbm5jQ3dDaEc1dDJRUlB1cmhBMHB6WEVrVEZzTU9lb2x5dnhrOXB0ako1aEJ2dXhsQ3NsTUtJRVBjZHVWMXVQa284bStzOWVhOG53a2dtd2dnUFdpc0JKQk1HaElCQkEwMTMxZFYxMVcrRmV1T0tqbVFlRjZGbnpJMXQ2c2pSNFNRUzZvSG5lQ3d1aVhyOGVQSDBiQ3hYWVNQdXZpQTBoeFgwb1RGc0lOZW9pR2FWRDlWYVpKYnNiVGQzQUJ5RWljazdlY3hFODc5NyttRzQwcFlYVEhhUnM3N21RQ3lpUURTZzhhYU8rZU5BRUlBd1NGcXlCMU1icWh1cXg2b3p2ZlZneGN2emVyS1NOOFFZZ29OdDdkQ3hQbkRody9Qbnp4NUVnMGVMc0pIZlh4QWFZNHJhY0ppaU5ETGszdFMyV2VTVzdHMFhRTElGdTFqMzZ0YXZsM3IrYkNhVVdoN09lOW5Bc2dtQWtnUEhtc3o1R1JIQjNHdFk5Ym5MUTJKQUlJOGFzNHZxWHlseEZkSnpsVG5zZkljQ3o5TmF3NVhSWGFFa0tSUW9QQndUWFhXQ1JPcmV2VG8wU3BzRUQ3cTV3TktjMXhKRXhiREZyMDB1WTE3aW1Jbm5WMjB6ZHdKOUtjUVFMTGVJNEUvRlI3OUtwYTJtVE5XQXNnbUFrZ1BHbXZXOStDRXhZNmkxY3o2dktVaEVVQndIRFhxdmtMaXF5UFJNT0xHM2xkRmFuK2kxbzZuWS9rMnRFdGhWM2RTaVBBdFdSdVA2blc5L2ZiYjUrKy8vejdobzNJK29EVEhsVFJoTVhUb1pYSFRYdUxMNkNhNUZhdlpkTHF3MkNKcDkvcGMvWGdsTEQ0NmJUdm4vVXdBMlVRQTZTR01OOVh2d21KSDBYcG1mZDdTa0FnZ0dJNmE5V3NxWHhrNWoxWHRRV1JIQ1BGdFoxZkRMdTZsUUJHOUd1TGJzZ2dmOWZJQnBUbXVwQW1Mb1VNdmk1OWlsTW9ubnB5d012cXRXTnBtN3BPZUpuMTBjRW5hdDV4L1c1djBCTzN0TjhOSVFnRFpSQURKcEhGT2NzdW0xcE0xSnlzc1ZnME5pUUNDNGFsaDkyMWFOMVhScXlLMUJ4R1BiMnZNVDFXcDgwSjhOY1RmR2JMeHBLeXRJbnhVeEFlVTVyaVNKaXlHUUM5SnpqZWZ2eG1XOFhjNjVCajFWaXh0TCt0M1FrYS9WV3dzMnJmY01GWjhvdmsrMm43T2VBa2dtd2dnbVRUTzNFZU9EL0tCaXRaVHplOVlIeG9TQVFSbHVYRlhYWmk4N2x1emFwNGo4dmk3bjlvWWJ5aC9WOHJCVzdKTUllT3lnMFluZEJBK0t1VURTbk5jU1JNV2cramx5UDFlaUMrRVJiMXN6dE95UnIwVlM5dksvZFIva1kvaTFYN2xmcm83MmExWHJUQ09WQVNRVFRVRmtFZGhzYXBwbkxuSGlxK0dSWStpOWN3OWdPUStWWThBZ243VXVQdjJyQXRYUkR4WnZkYW5adm5iNENPVDA3MFAxOEp1SGFUQTRlOE51VS80cUpjUEtNMXhKVTFZREtLWEkrZnhreHVmL09uLzV6YTNvOTJLcFczbGZqcTN5Sk9TOWl2M2RYZ3VMRG9KYmY5S000eGtCSkJOTlFXUVdSeHJOY3pjdVcvckQyR09vZlhrdmplcnVrcXI4V1Q5TGdnQkJNZFI4KzRySWhlQ2lMOUxwTWFySVI2VHZ3bCtlN3dxejNWSnVocGlEaUxoZjZJeVBxQTB4NVUwWWJHVHA1Y2k1OVlEWHlXNWNBVkRmNWI3NmVFb0oxRnZwOWxjbHNYTkE5RStaYjAzWk5MWFFOdWY1SDc4YlZvdkFTVEM2MjgyazJ5UVpyMFVqNjhaWnJxdzZORzBxcmtIa054Yk93a2dHSWFhZDMvaG9lZFduTGZscXcyMVhnM3hMVm1ScXlISmMwTlFMeDlRbXVOS21yRFlTZFBMNEUrYWMwNGcwZStDMEovbnJtZTBXN0dheldVWjlmc3V4cUI5eXZsMGQvSmJaalNHM0thTUFMS3B0Z0F5eU8xS3BXaDh1YmNSRGZiNmFsMjV2K3ZWM0NhcXNlUmVxVFFDQ0lhajV2Mnk2c0kzcnRkNk5jUVQ1M2RjRGZFY2wrVGJzbEFYSDFDYTQwcWFzTmhKMDh1UU0zOWo3d0ZiZnovSkpNNUR0SjJzM3d0WjNJa3A3RmVxeWZmZlkyaUdrcXpJbUxWZUFraUUxOTlzSnRucllkRXFhWHk1dDE4TkZxaTBydG5OejJwcExMa1BJVEVDQ05MOHErZit4K1h3UHc5UzgrNHZOdHk0R3VLNUlmNkN3RmdRbUxwMlhBMXhPVXdSUkdiR0I1VG11SkltTEhheTlCTGtmdkoyOEtsSStwbWNRR1BGYnlmUU5uS0RrVlY5eTBnTzdjdXN2cEJSMjg4ZHJ4RkFOdFVXUUt6S1d4czFyajYzYVE1MmZOQzZjcmUvZWdKaERUU1duTG1ETFFJSURsUDR1S1U2RC85Tm1pZWh4dDJQN3Ixd05lU1hyMzQ2R2dLbUxsK2hpVHl1dHkyQ3lJejRnTkljVjlLRXhVNlNkai8zbnVla3kvNzZ1ZHlUYWZGYnNiVCtQcmNKVlBNcDQ3RzBMMVhNcDBpbDdmY0pqQVNRVFRVR2tDcHZiZFM0Y3B2b1FXOVIxUHI2Qk83Snc1ekgwQXdsR3dFRSt5bHdYQS9obzYybnFwdmhydzlTNCs3dkQzRVR2eTQzK3JFUVVFUDVLczJPMjdKY0RpTFh3NjZoVWo2Z05NZVZOR0d4azZOZDk0bWoyS056OWJPNUU5S0wzNHFsYmVSZW1iRkZYQVhSZnN3dGdPVGVEbU1Fa0UwMUJwRHFIc2VyTWZYNWNHTHdPUmhhWis1RTdzbkRuTWFRZXdXOVJRREJiZ29hVjBQZzZBYVF0aDZva3A0RXBhYjlxbXJqU1ZsdThtdjl6aENYSDltN0o0aDRYenpwUHZtMk5JekhCNVRtdUpJbUxIWnl0T3RGbjl1dW4zZkFxZWJKS0tiMTk3bFhlUkVuS08zSGJBS0l0dDNuMzhrSUlKdHFEQ0JXMVZVUWphZlBmZ3orQloxYVorNDRKcDFUbyszM09jYTNDQ0NJVTdpNEZFTEdLbkQ4Ni8vMFAxZlYvdjlPM1ZZZHZDMUx6YnB2eWRyNEFzT2ZmUE9qVlljUTE0RWc0dkpWRVQrS09Qa1J2aWpMQjVUbXVKSW1MSFpTdE51NXpXaXZFNTJXeTcyTnB1aXRXRjYzcXM4SnMrcW45NlRRUHVUZWJqZkpKOVhhcnYrTitsejlNQUxJcGxvRGlOK0RWY3dGMFRpZVc0MG9UNm5mczl3UGhXendJSlJLMis1NzljTUlJSWhUcUxqYkNSbm5YL3pLOTgvL3czLzdmK2VmZS83VmJ2aG9LK2RxaUw5dnc0Mzdxano1dTliSjZkM3lFN044NjlpT3llcHRPWXo0bGpPdWpFeklCNVRtdUpJbUxIWXl0TXU1VGJoL3R2ZEpUc3ZtM3ZaVTlGWXNyYi92U1hQMnQyS0YvY2d4ZW5PamJmWnB3bG9Fa0UyMUJoQ2IvSWxZR2tQZkR5U0tOTTlhYjU4d05NbmplTFZkMzdiVzU3VnJFVUJ3a2NKRU8rbDhWWC8yMTYrZC84Zi8vdi9YNVREeWI2Ny9yMjRBYWV0V1dNVmVvVWwzdzc2cXVZUVFsNi9ZZUNLOXI5NTA5eUZTdmszTFljdFhSL2pTd2hINWdOSWNWOUtFeFU2R2RqbDNzdVZSbi81citkeXJMVmJ5NU5TMzZmQXlzdzRoelc1a0diVzUwZmI2L0s1MEVVQTIxUnhBYk5KYnNiVDlQazl2S3ZhYWF0MCtOdVU2NmdPaXZyVE5QdlBwdWdnZzJLUVFzVEhwL04vOWwxYzJ3a2UzUHY5WGY5OE5IMjNkVjZYY2t1WEczSTM2cXVZVVF0cnlWWkdITHoyemVzUndkMS8ybEsrUTNGWjUvc2cxRmNHa0FCOVFtdU5LbXJEWVNkRHU1bjdDTnNpakhyV2UzRSsxUzkrSzFmY3FpTWMxMlMwUHg5TFlzOTRiNHVabWxGdGx0QjNmSW5iTUo2cEdBTmxVZXdDeDU4THFScVh0NWo0a28xV3NjVGF0djA5alArclZKRzJ2NzJ2WFJRREJueWc0YkV3NjkxVU8zM1lWQ3g5dC9mdi8rbi9Qbi8zeWQ3WkR5Sm5xWUhPdEJuejJJYVF0aHhGL244aUIrU0xSQ2k4SEJ1SURTbk5jU1JNV1d6enRhcDlMNW9OODRxLzE5TG5xVU94V0xLM2I0K2s3ejhEN01lbVZFRzlmbGYzNmVCbFZyakdlVGpaRStEQUN5S1k1QkJEL3V4ZHQ2cmRwZTMwYjZPTE5xcmJSNS9IVE5zclZKRzJuNy9pMkVVRFFVR0M0TU9uOEwvNzJINk9oWTdzY1VueWxwRjAybElQTWpiRDZuZFNBWHdnaHRVOU1UeWxQWHYvRnk1OWNCWklEODBZSUlBUHpBYVU1cnFRSml5MmVkalhyZFpGQkcwK3RyN1p2eXozbWRoODNUWlBjUHFMdHRzMXc5b2xUeS9TNXg5eUs3YXZXUFZUNE1BTElwamtFa05aWURmUXhuOTRYLytCQjIvQUhSWDBWZlEyMS9yNVhqbU1JSUdnb0xGeVlkQjRMRy92S2MwVzY2d2gxOER0RDFJUnZoSkE1UEIwcnQzeUY1TWxyejY1Q3lSdmYvdmg2WDFYM3c4dUFnZmlBMGh4WDBvVEZGazI3bWZ1cGxSdkN3Vys5MFRxei9tMms5SzFZeDB4NE50OURQdFl0U2c1dzNhczJmUUpJbjN2TVc0TTNOMTZuYWwvNDhOL2xoQk1DeUtZNUJSRHorN0hJKzBucmRXTi96SGhIbXcrbGJmV1ptOUlxOFQ3MWNlUFFtSEkvUkNDQTRQQ2s4NXp5TFZtUngvWGVDWnZhU1kzNGhSQVNhK1NYVUw0NjB0bFhBc2pBZkVCcGppdUwwdnNncVdYN2ZNSmM1TDVzcmRkanlWWDZxVmpIVHFiMGErc0d0VVJnODRsL08zaTBldjFPYUxsalBnRWVwQW5UZWxLYlFiK3VPZTluQXNpbW1nS0lmNGRUamtQK3VjR2FhSzNMN3lILysrVWVBN3NHbVF1WFN0czc5bUVNZzMwd292WDRxbW5zK05QbHY4OTZqd2dCNU5RcEhDUlBPazh0MzdvVmVVcFdTZ2paZURwV3pkK1lma3dSUU1yeUFhVTVyaXpLTVFFa3Q4RXUzYlQwdWVwUThtVFZaMjdNTG03dWp3NXZYa2RZMTc1eDlmcDMwbkxITmplOUcwUXQ1MjJuQnFCVjA2Zi81cnlmaS96dWFyMEVrQWl2djlsTUV2OXN6dXU0K2oxVDlXcWt0WnpmMThjR0QvUHlVenhsNnRqem1NZnQvZTgxZGkzbjF6NTFESDVmRTBDUVRxRWdlOUo1YW5rOVBVUEl4dmVFK0pHM3NTWit6a1VBS2NzSGxPYTRzaWg5bTgzY2s0SVZQZGxxL2Y1RU1yY3BjRE5TN0ZZbnJYdkllUWptZGZuMzBLKy93NFJQMEJmRzd6OExmK2VmOGMvbS9PNzJQbkY2MldZVlIvRStPa3k0VWJuUVRPalAybjN6My92bkRuMkt1bTExdjczK084cHJzby9XbS9VK0Nvc1ZvZFZQL25xMHZQNW1NMGxXWTlGLysxeHg5SGI4YitEZnB3dnpNUFJuM2Q4MWY4Qng3RlhOcnFtZTB0WG5hdkV1ZmozYVk5RysxOCszNnZycVNjNnhjSFdGV3YvTmVvOElBZVJVS1F6MG5uU2VXanNtcDZlRUVEK3U5cnl0dVQ0WmExY1JRTXJ5QWFVNXJpeEs5a0ZTeS9pRWttdVUrNXkxSFRjS3VVcmZpalYwQ0NtdDk0bFR5dzdaM0pTdy91NFovZStjOTNPUlprTHJKWUJFZVAzTlpwS3N4cUwvRG5uRnNiU2lrN29QMGZhUG5hTldtb1BONm9NVi9aY0FnalFLQWtkUE9rK3QzQkNpcHZ5U3lsL2tkKzd5OTJ3c2FWSTZBYVFzSDFDYTQ4cWlaQjBrOWZQK1JDdjNFK2RIWWZGUmFIdDkvcDJLbmJSTTY1OVRDRG5xeEtubGN4dUdzYndTaHJpaS81L3plMUtrbWRCNkNTQVJYbit6bVNUcnNlaC8rNVA0MmswYVBsb2F4NUJYYzRiazQrVDZhb3IrTndFRWh5a0FERGJwUExWNmhKQ3JuU1o5OWVTb1dETS94eUtBbE9VRFNuTmNXWlNzZzZSK3ZxcDVGakhhbmo4SnpWWDBWaXpUK2gxQ2NzUGJGSTQrY1dvZHh6eHRwNFFMKytRL2EvNHFTWkZtUXVzbGdFUjQvYzFta215TVJmKy96MVhRc1ZRUlBreGo4WWRKTlg0b3NuRyswUDhuZ0dBL05mNkRUenBQclVnSTJmdUlYalhuRzVQUy9VVi9zWVorYmtVQUtjc0hsT2E0c2lqSkIwbjliSjlQRnpjK2RSNkx0dHZuVS9neHZoalBKLzNhZjQrT1BuRnFIZDdQV2o1aDllc2RteWVUOCs5UXBKblFlZ2tnRVY1L3M1a2tGOGFpUDZzdGhMalJyeVo4dERTbTJxN01YbmlOOUdjRUVPeW1oci9ZcFBPVTJqRXhmZStYRmFwQnY5czI2LzVDUDMrZlJxeXBuMU01U0xYN3BEbzRKd1o1ZkVCcGppdUxrblNRMU0vMStiVE1QMS8wcXNJdTNxNnF6OVdHVWE3V2FEdWVsRm5qcDQ4MnlJbFQ2NmtoaE93TXdQcTduUGR6a1daQzZ5V0FSSGo5eldhU1JNZWlQNjhsaFBnOVVQeUxCdnZ5MkZSVFg1bjFzVEQ2R3VuUENTQ0lVNk5mZk5KNVNrVkNpQVBSMVRETUM5U2dlejdJMDdaaDl6ZUx4NXI2T1pXL2pMRGRIOVd0c0tzWWlBOG96WEZsVVpJT2t2cTVQcmZVckNmOFRrSGI3M1BGcHZpdFdDMXR4N2VLMWZZNzVmRU0rclF5clcrS0NhOXVhUGIrL3VudmMxNTdBc2ltNmdPSTZlK21icTVIKzVMQlkyaWNVMTZaZFVEYmVjelIzeEZBRUtjbWY3Uko1NGZLd1dmcnl3clBWSmZDVUM5UWszNjkwN0N2dmxFODF0alBwUWdnWmZtQTBoeFhGdVhnUVZJL2svdHQ1MWJGd2RmamFJYVRwZml0V0YzYW5wOHFOdlh2bHJkZjhzVHRNRGhXSStoOU9SaWl3cytsS3ZMN3JQVVNRQ0s4L21ZelNmYU9SWC92NW5yc0VPekhReGQ5N0hnSkdyT3ZHbzExWmRiYk9SalEvRE9ybjA1SEFEa0ZhdTVIbjNSK3FQeU42ZDB4cWZiT2hWQ2p2cjRWYSs1UHhTS0FsT1VEU25OY1daUkRKKysrajdhczRwWURqYVBQaEhRYjVWYXNMbTNUbjlZZStwTEFJVGtRdURFYnJWSFN0dHhNbEFvaWZuOG0vN3VGbjA5RkFOazBtd0RTMHMvNVdKRDZaWlY5K0gwN3krRFJwZkU3c1BuM3N0UnhLT3QxMHM4UlFMQkpqZjFrazg0UDFaLy96VDkwQTRoclp6T3VSdjJ5YW4wcmxwdjRXSE0vaHlLQUFNdWdrNWV2R1Bna1BYU3o3dHNkSERvbURZamF2dmN2OTR2Sll0cG1wdHA3N0ZFWC9hNDRpQXdWaE52ZnYrb21tQTlCKzlVZWg0WUlJejcyK0dyNkpQTUNzUkJxNkNlZGRKNVNrU2RqN1pzUGNxdlR1TTkyUWpvQkJGZ2VuYkRkTUxrUmNOUGtwdjJlYXQva2JqZFcvaG1YbC9GSmYvUXJPcWs4dGpCR056cjc5cTNkTC8rY2Y1N1FnYVBvZDhqdkxkOTI1RkMrNzNmUERYajNQZVZsVHVyM3ovdXI4dnV1ZmExY3UzUmZLeCs3Q0IwNG5ocjVLaWFkSHlvSG9tZS8vSjF1QURrMEgyVDlCWVVQWHJ3VWJmQnJMd0lJQUFBQUZrZE5mRFdUemc5VlpEN0k3YkFiRjZoaDM1aVFQc2VySUFRUUFBQUFMSW9hK09vbW5SK3F6Ly9WMzNjRGlHdmZyVmozMndaK2psZEJIcjcwREFFRUFBQUF5NkRHdmRwSjU0ZHE2L3RCSG9SZHVrQk4rN1ZPQXorN3F5RCtMcFBPK0srRjNRSUFBQURtUlUxNzlaUE85MVhrVnF5YllkY3VVT00rMjZzZ0JCQUFBQURNbnByMUM1UE8zZERIR3YyYUsvSXQ2ZEVKNldyY1p6c1hoQUFDQUFDQTJWT2p2akhwL09xTi94TnQ4R3N0WDZtNThwY3ZkOE9IeXdIa2N0akZDOVM4cjUrSU5hZnZCU0dBQUFBQVlOYlVwRzlNT3ZlRTdsaVRYMnY1U3MzV28zaGR2cHF6TTN5WW12Y2JiU1B2YjBlUE5mczFGZ0VFQUFBQXM2VW1mV1BTK2IvOXovODcydVRYV3Y0MmROOHUxdDBIMVIzVnp1OENhYWw1djZSYWZ6djZrOWVlalRiOHRSVUJCQUFBQUxPa0puM1drODQvOS95cjI4SER0WFBpZVl3YStEdHRNLy9HdHo4ZWJmaHJLd0lJQUFBQVprZU4rbXdubmUrWjc3SHp1ejkyVVFOL3RkUE1uLy94aDUrTk52MDFGUUVFQUFBQXM2Tm1mWmFUenZmTTl6aDR5OVV1YXVMWGs5Ri8rZXFubzAxL1RmV2pyMzI0RzBEMnpuTUJBQUFBSnFkbWZaYVR6bmZOOXdpNzFadWErTnR0UXorSDI3RGFzYnJDTGdBQUFBQjFVc00reTBubi9rYjI3cmhEM1FpN2RSUTE4ck82RGFzNzFyQUxBQUFBUUgzVXNNOXUwcm5IdC9YbGdxNWU4ejMyVVRPL3ZnMnI5cWRodGVOMGhlRURBQUFBZFZIRFBydEo1eDVmNUphcm8rWjc3S0ptZm4wYjFvTVhMMFViLzFxcUhhY3JEQjhBQUFDb2k1cjJXVTA2OTN5UDduaERIVDNmWXhjMTg5ZmJwcjcyTHlWc3gra0t3d2NBQUFEcW9jWjlWcFBPUzg3MzJLZmIyUC9oQjUrSk52ODFWSGVjWWVnQUFBQkFIZFM0ejJiUytZNzVIbWVxUWVkNzdLS0cvbjdiMk5mOE9ONTJqSzR3ZEFBQUFHQjZidHhWczVoMHZtTyt4MzNWNFBNOWRsRkRmNnR0N0IrKzlFeTArWis2L0lTdWRveXVNSFFBQUFCZ1dtN2NWYk9ZZEw1anZzZnRzQ3VqVVVPL25nZmlieHVQQllDcDY3ZmZ1OXdOSVBmRDBBRUFBSUJwcVlHdmZ0SzVyOFpFNW52NGlrM3grUjR4YXVndmQ1cjdhQUNZdWdnZ0FBQUFxSTRhK0p1ZGhyN0tTZWQvOGJmL09PbDhqMTNVMUQ5dEcvemZ2MzRsR2dLbUxBSUlBQUFBcXFJRy9scW5vYTl5MHZrWHYvTDl5ZWQ3N09LbXZtM3dhL3hDUWdJSUFBQUFxcUVHL3JLcTZrbm5mL2JYcjIwSEQ5Zm84ejEyVVZPLzhZV0VidmdQMWVQdmZ1cjhGeTkvOG1CNVhzbWgrc2szUDlvTkdJZUtBQUlBQUlCcHFJbXZldEo1YmZNOWRsRlR2MzRTMWd5S0FBSUFBSUJwcUpHLzAybnNxNXAwWHV0OGp4ZzE5ZGUybXZ4YXkzTlZxcmx5QkFBQWdCT2lScjdhU2VjMXovZUlVVlBmRFNCdThqMG41RkRkVWZuS3lhSHlZMzY5L3IwVmhnSUFBQURVUjQxOHRaUE9kOHozdUJXR0RnQUFBR0JPMU14WE9lbDh6M3lQNjJIb0FBQUFBT1pFelh5Vms4NTN6UGZ3T0t1Yjd3RUFBQUFna1JyNjZpYWRld3lSK1I3K1J2WXE1M3NBQUFBQVNLQ0d2cnBKNXg1RGQweWhtTzhCQUFBQXpKbWErcW9tblh1K2g4ZlFIWk9LK1I0QUFBREEzS21wcjJyU3VlZWNNTjhEQUFBQVdDQTE5UnVUemwzK2pvMVlNQmlqbU84QkFBQUFMSmdhKzQxSjV5NEhBTSs5R1BzcUNQTTlBQUFBZ0lWVGcrKzVIdzRoNjF1dzJucjJ5OThaNVNsWWUrWjc4TzNkQUFBQXdCS3AyZmV0V0g0SzFwbHFJd3o0eS85S1hRM1pNOS9qY2hnYUFBQUFnS1ZTNCs4Z2NrdTFjVVhFSVdIb0x5VGNNZC9EVjJPWTd3RUFBQUNjRW9VQVB4bnJmZ2dGcXhyeVc5RS85L3lyM2REUjFzMndlUUFBQUFDblNLSEFWMFBXSWVIWUVPSmJ1YTc4NWN2ZDBPRml2Z2NBQUFBd1YvLzBkeCs2cHJxdXV0V3BteXIvZWZiY0NvV0RHeUVrSEJWQ3ZJd250cmZyQ2NWOER3QUFBR0JPSENwQ3dMaXZPaytvcDZvN3F1UnZGVmRJdUtyYUNDRTVFOVAvL0cvK2dma2VBQUFBd0p3cFFEaDRPRWpFUWtacW5hbHVoRlh1cGJEZ0VMSU9FSjZZSGdzYjI4VjhEd0FBQUdER0ZCZ3VxVzZIQUhHaGZ2ejFqNXovOUZzZk8zLzQwalBudjNqNWs2dDY4T0tsMVovRmZqNlVnOGpCZVJnS0RyNGRheDBrL09XQnNkRGhZcjRIQUFBQU1ITUtDVmRWRDBKb1dOZFB2dm5SODhmZi9kVDVIMzd3bWZQemYvNzgzbnJ5MnJPclFQS2pyMzE0WXgyaGJvZE43YVFBY2JzVEtLTHpRWmp2QVFBQUFNeWN3b0hEaCtkdnJBT0RyM2I4OW51WG8wSGpVUDN4aDU5ZFhSM3ByaStVNTVMc25KdWhFT0h2Q2xsL1lhR3ZjblREeDY3NUhtRnhBQUFBQUxWVElMZ1FQaHdlWXNFaXQzelZ4RmRRdXV0VytTckx2aEJ5clJzd3Z2aVY3Ni9DeDQ3NUhrbHpUQUFBQUFCVVFFRmdJM3o0MXFtK1Z6MzJsVy9MYXJjUmF1OVZDd1VMUDhWcUZUSjhGY1NUMHR2L0g4cnpQYTZHSHdjQUFBQlFPNFVBVHpoZnovbHcrUGo5NjFlaUFXS0lpb1NRblUrclVyand0NlZ2aDQ2MlBOK0RSK3dDQUFBQWM2SUFzUEcwcXhKWFByYnJqVzkvdkJ0QVhEc25qaXRrcksrQ2RJcjVIZ0FBQU1EY3VQSHZCb0doNW53Y0trOU85K1QyenJidmh5RmRvTEN4TVJkRXhYd1BBQUFBWUk3VStLKy9aTkNUeEdOaG9WVDVTa3U3N1ZBN3Y3dERvY05QeEdLK0J3QUFBREJYYXZnM3JuNk1jZXZWZG0xOWNlSE8yNm9VUEs2cm1POEJBQUFBekpVYS9wdHQ4ei8yMVkrMklsZEJDQmtBQUFEQUVxblpYei81eXQ5d0hnc0lZOVRXWEJEbWR3QUFBQUJMMUduNlYxOFVHQXNIWTlURGw1N3BCcERiWVhnQUFBQUFsa0tOL3JXMjZmY1ZpRmd3R0t1ZXZQWnNONERzZkJvV0FBQUFnSmxTbzMramJmbzlFVHdXRE1ZcVgzMXB4K0lLUXdRQUFBQ3dGR3IwYjdVTi8xamYvYkd2MnJHNHdoQUJBQUFBTElVYWZRSUlBQUFBZ0hHbzBTZUFBQUFBQUJpSEd2MTFBUEZUcUdLaFlNeHF4K0lLUXdRQUFBQ3dGR3IwMTAvQm1ub1MrdGFYRVo2RklRSUFBQUJZQ2pYNlY5dW0vMGRmKzNBMEdJeFZ2M3oxMDkwQXdtTjRBUUFBZ0NWU3MvKzBiZngvLy9xVmFEZ1lvOTc0OXNlN0FlUldHQjRBQUFDQUpWR3pmN2R0L0tlYUIvTEhIMzUyZFFXbUhZZnFhaGdlQUFBQWdDVlJzNy8rTWtLSEFJZUJXRWdvV1Z1M1h6SC9Bd0FBQUZneU5mM3IyN0RHZmh5dkE4K1B2LzZSYmdEaDlpc0FBQUJneWR6MHR3SEFWMEgrOElQUFJNTkNpWExnYWJldGNoQzZGSVlGQUFBQVlJbmM5S3ZPUWdnWTdaRzhudlRlYmpNVVZ6OEFBQUNBVTZEbS8zbzNERHg0OFZJME5BeFZ2c3F5TmZIOFFSZ0tBQUFBZ0ZPZ0VIQ25Fd2lLaFJDSGo1OTg4NlBkOE9GYnIzanlGUUFBQUhCcUZBUWVkSUxCS29RTStXUXMzM2ExZGVYRGRTTnNIZ0FBQU1BcFVSandmSkNORU9LckZiLzkzdVZvb01pcHJRbm5iUkUrQUFBQWdGT21VT0FRY3I4VEVsYmxxeUc1MzVidXF5Zitubyt0UisyMlJmZ0FBQUFBMEZCQVdEK2V0MXUrSXVLckdiNHFFcnM5eXlIRm9jT0JKWEs3bGN0UDNHTE9Cd0FBQUlCTkRncXFDMWREZXBZbm16dlU4RjBmQUFBQUFIWlRhTGltdXF1S0JZdERSZkFBQUFBQWtNOGhRblZENVVmMmJreFc3NVFEaDYrYU9IUmNDNHNDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFnMVljKzlDK0N5WUZRc25wanhnQUFBQUJKUlU1RXJrSmdnZz09JztcbiAgICAgICAgICAgIHZhciBpbWFnZUhlaWdodCA9IHdpZHRoICogMyAvIDg7XG4gICAgICAgICAgICB2YXIgb2xkQW50aWFsaWFzID0gdGhpcy5nZXRBbnRpYWxpYXNpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QW50aWFsaWFzaW5nKHRydWUpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgODAwLCAzMDAsIHgsIHkgLSBpbWFnZUhlaWdodCAtIDIwLCB3aWR0aCwgaW1hZ2VIZWlnaHQpO1xuICAgICAgICAgICAgLy8gbG9hZGluZyBib3hcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHgsIHksIHdpZHRoLCAyMCk7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB3aWR0aCAqIChsb2FkZWQgLyB0b3RhbCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIHZhciBtYXJnaW4gPSA1O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcHJvZ3Jlc3MgLSBtYXJnaW4gKiAyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IDIwIC0gbWFyZ2luICogMjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4ICsgbWFyZ2luLCB5ICsgbWFyZ2luLCB3aWR0aCA+IDAgPyB3aWR0aCA6IDAsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnNldEFudGlhbGlhc2luZyhvbGRBbnRpYWxpYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbG9hZGluZyBzY3JlZW4gZHJhdyBmdW5jdGlvbiBpZiB5b3Ugd2FudCB0byBjdXN0b21pemUgdGhlIGRyYXdcbiAgICAgICAgICogQG1ldGhvZCBzZXRMb2FkaW5nRHJhd0Z1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSBmY24ge2N0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBsb2FkZWQ6IG51bWJlciwgdG90YWw6IG51bWJlcikgPT4gdm9pZH1cbiAgICAgICAgICogQ2FsbGJhY2sgdG8gZHJhdyB0aGUgbG9hZGluZyBzY3JlZW4gd2hpY2ggaXMgcGFzc2VkIGEgcmVuZGVyaW5nIGNvbnRleHQsIHRoZSBudW1iZXIgb2YgYnl0ZXMgbG9hZGVkLCBhbmQgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyB0byBsb2FkLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zZXRMb2FkaW5nRHJhd0Z1bmN0aW9uID0gZnVuY3Rpb24gKGZjbikge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nRHJhdyA9IGZjbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFub3RoZXIgb3B0aW9uIGF2YWlsYWJsZSB0byB5b3UgdG8gbG9hZCByZXNvdXJjZXMgaW50byB0aGUgZ2FtZS5cbiAgICAgICAgICogSW1tZWRpYXRlbHkgYWZ0ZXIgY2FsbGluZyB0aGlzIHRoZSBnYW1lIHdpbGwgcGF1c2UgYW5kIHRoZSBsb2FkaW5nIHNjcmVlblxuICAgICAgICAgKiB3aWxsIGFwcGVhci5cbiAgICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICAqIEBwYXJhbSBsb2FkZXIge0lMb2FkYWJsZX0gU29tZSBsb2FkYWJsZSBzdWNoIGFzIGEgTG9hZGVyIGNvbGxlY3Rpb24sIFNvdW5kLCBvciBUZXh0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICBsb2FkZXIub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvZ3Jlc3MgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgICAgICBfdGhpcy50b3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKCdMb2FkaW5nICcgKyAoMTAwICogX3RoaXMucHJvZ3Jlc3MgLyBfdGhpcy50b3RhbCkudG9GaXhlZCgwKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9hZGVyLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2FkZXIubG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRW5naW5lO1xuICAgIH0pKGV4LkNsYXNzKTtcbiAgICBleC5FbmdpbmUgPSBFbmdpbmU7XG4gICAgO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2FsaWJ1ci0wLjIuNS5qcy5tYXBcbjtcbi8vIENvbmNhdGVuYXRlZCBvbnRvIGV4Y2FsaWJ1ciBhZnRlciBidWlsZFxuLy8gRXhwb3J0cyB0aGUgZXhjYWxpYnVyIG1vZHVsZSBzbyBpdCBjYW4gYmUgdXNlZCB3aXRoIGJyb3dzZXJpZnlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvaXNzdWVzLzMxMlxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7bW9kdWxlLmV4cG9ydHMgPSBleDt9IiwiLypqc2xpbnQgbm9kZTp0cnVlLG5vbWVuOnRydWUqL1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXJcbiAgICAgICAgcGFydHMgPSBvcHRzLnBhcnRzLFxuICAgICAgICBleCA9IG9wdHMuZXgsXG4gICAgICAgIGdhbWUgPSBvcHRzLmdhbWUsXG4gICAgICAgIGNvbG9yID0gb3B0cy5jb2xvcixcbiAgICAgICAgdyA9IGdhbWUud2lkdGgsXG4gICAgICAgIGggPSBnYW1lLmhlaWdodCxcbiAgICAgICAgc2l6ZSA9IG9wdHMuc2l6ZSxcbiAgICAgICAgZmluZFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNpemUgKiBfLnJhbmRvbSgyLCBNYXRoLmZsb29yKHcgLyBzaXplKSAtIDIpO1xuICAgICAgICAgICAgcmV0dXJuIF8ucGx1Y2socGFydHMsICd4JykuaW5kZXhPZih4KSA9PT0gLTEgPyB4IDogZmluZFgoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHNpemUgKiBfLnJhbmRvbSgyLCBNYXRoLmZsb29yKGggLyBzaXplKSAtIDIpO1xuICAgICAgICAgICAgcmV0dXJuIF8ucGx1Y2socGFydHMsICd5JykuaW5kZXhPZih5KSA9PT0gLTEgPyB5IDogZmluZFkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWN0b3IgPSBuZXcgZXguQWN0b3IoZmluZFgoKSwgZmluZFkoKSwgc2l6ZSwgc2l6ZSwgY29sb3IpO1xuICAgIHRoaXMuZWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhY3Rvci5raWxsKCk7XG4gICAgfTtcbiAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgZ2FtZS5hZGQoYWN0b3IpO1xufTtcbiIsIi8qanNsaW50IG5vZGU6dHJ1ZSxub21lbjp0cnVlKi9cbnZhciBGb29kID0gcmVxdWlyZSgnLi9mb29kJyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhclxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgdiA9IHt9LFxuICAgICAgICBydW5uaW5nID0gZmFsc2UsXG4gICAgICAgIHNwZWVkID0gMTUwLFxuICAgICAgICBnYW1lID0gb3B0cy5nYW1lLFxuICAgICAgICBzaXplID0gTWF0aC5mbG9vcihNYXRoLm1pbihnYW1lLndpZHRoLCBnYW1lLmhlaWdodCkgLyAzMiksXG4gICAgICAgIGV4ID0gb3B0cy5leCxcbiAgICAgICAgY29sb3IgPSBvcHRzLmNvbG9yLFxuICAgICAgICBwYXJ0ID0gZnVuY3Rpb24gKHgsIHksIGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgYWN0b3IgPSBuZXcgZXguQWN0b3IoeCwgeSwgc2l6ZSwgc2l6ZSwgY29sb3IpO1xuICAgICAgICAgICAgZ2FtZS5hZGQoYWN0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIGFjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzdGFydFBsYWNlUmFuZFggPSBfLnJhbmRvbSgyLCBNYXRoLmZsb29yKGdhbWUud2lkdGggLyBzaXplKSAtIDIpLFxuICAgICAgICBzdGFydFBsYWNlUmFuZFkgPSBfLnJhbmRvbSgyLCBNYXRoLmZsb29yKGdhbWUuaGVpZ2h0IC8gc2l6ZSkgLSAyKSxcbiAgICAgICAgcGFydHMgPSBbXG4gICAgICAgICAgICBwYXJ0KChzdGFydFBsYWNlUmFuZFggKyAxKSAqIHNpemUsIHN0YXJ0UGxhY2VSYW5kWSAqIHNpemUsIGNvbG9yLmJvZHkpLFxuICAgICAgICAgICAgcGFydChzdGFydFBsYWNlUmFuZFggKiBzaXplLCBzdGFydFBsYWNlUmFuZFkgKiBzaXplLCBjb2xvci5ib2R5KVxuICAgICAgICBdLFxuICAgICAgICBmb29kID0gbmV3IEZvb2Qoe1xuICAgICAgICAgICAgZXg6IGV4LFxuICAgICAgICAgICAgZ2FtZTogZ2FtZSxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvci5mb29kLFxuICAgICAgICAgICAgcGFydHM6IHBhcnRzLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICB9KSxcbiAgICAgICAgY3V0VGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gcGFydHMucG9wKCksXG4gICAgICAgICAgICAgICAgcHJlbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGFzdC5tb3ZlVG8oXG4gICAgICAgICAgICAgICAgcHJlbGFzdC54LFxuICAgICAgICAgICAgICAgIHByZWxhc3QueSxcbiAgICAgICAgICAgICAgICAyICogc3BlZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkTmVjayA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RQYXJ0ID0gcGFydHNbMF0sXG4gICAgICAgICAgICAgICAgeCA9IGZpcnN0UGFydC54LFxuICAgICAgICAgICAgICAgIHkgPSAgZmlyc3RQYXJ0LnksXG4gICAgICAgICAgICAgICAgbmV3UGFydCA9IHBhcnQoeCwgeSwgY29sb3IuYm9keSk7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KG5ld1BhcnQpO1xuICAgICAgICAgICAgbmV3UGFydC5vbignY29sbGlzaW9uJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5vdGhlci5jb2xvciAhPT0gY29sb3IuZm9vZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uTG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3UGFydC5tb3ZlVG8oXG4gICAgICAgICAgICAgICAgeCArIHYueCAqIHNpemUsXG4gICAgICAgICAgICAgICAgeSArIHYueSAqIHNpemUsXG4gICAgICAgICAgICAgICAgc3BlZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBuZXdQYXJ0Lm9uKCdleGl0dmlld3BvcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbkxvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1BhcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZGROZWNrKCkuY2FsbE1ldGhvZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2NvbGxpc2lvbicpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpdGhpbihmb29kLmFjdG9yLCBzaXplIC8gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgKz0gNTA7XG4gICAgICAgICAgICAgICAgICAgIGZvb2QuZWF0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvb2QgPSBuZXcgRm9vZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBleDogZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYW1lOiBnYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLmZvb2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogcGFydHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGVwKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0VGFpbCgpLmNhbGxNZXRob2QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5raWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC50aXRsZSA9ICdTY29yZTogJyArIChwYXJ0cy5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgdGhpcy5yaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdi54ID0gMTtcbiAgICAgICAgdi55ID0gMDtcbiAgICB9O1xuICAgIHRoaXMubGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdi54ID0gLTE7XG4gICAgICAgIHYueSA9IDA7XG4gICAgfTtcbiAgICB0aGlzLnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2LnggPSAwO1xuICAgICAgICB2LnkgPSAtMTtcbiAgICB9O1xuICAgIHRoaXMuZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdi54ID0gMDtcbiAgICAgICAgdi55ID0gMTtcbiAgICB9O1xuICAgIHRoaXMucnVuID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2LnggPSBvYmoueCB8fCAwO1xuICAgICAgICB2LnkgPSBvYmoueSB8fCAwO1xuICAgICAgICBzdGVwKCk7XG4gICAgfTtcbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBmb29kLmFjdG9yLmtpbGwoKTtcbiAgICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge3BhcnQua2lsbCgpOyB9KTtcbiAgICB9O1xufTtcbiIsIi8qIVxuICAqIGRvbXJlYWR5IChjKSBEdXN0aW4gRGlheiAyMDE0IC0gTGljZW5zZSBNSVRcbiAgKi9cbiFmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIHRoaXNbbmFtZV0gPSBkZWZpbml0aW9uKClcblxufSgnZG9tcmVhZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGZucyA9IFtdLCBsaXN0ZW5lclxuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIGhhY2sgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsXG4gICAgLCBkb21Db250ZW50TG9hZGVkID0gJ0RPTUNvbnRlbnRMb2FkZWQnXG4gICAgLCBsb2FkZWQgPSAoaGFjayA/IC9ebG9hZGVkfF5jLyA6IC9ebG9hZGVkfF5pfF5jLykudGVzdChkb2MucmVhZHlTdGF0ZSlcblxuXG4gIGlmICghbG9hZGVkKVxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lcilcbiAgICBsb2FkZWQgPSAxXG4gICAgd2hpbGUgKGxpc3RlbmVyID0gZm5zLnNoaWZ0KCkpIGxpc3RlbmVyKClcbiAgfSlcblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgbG9hZGVkID8gZm4oKSA6IGZucy5wdXNoKGZuKVxuICB9XG5cbn0pO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogbG9kYXNoIDMuMS4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIC1kIC1vIC4vaW5kZXguanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjcuMCA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICczLjEuMCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3Igd3JhcHBlciBtZXRhZGF0YS4gKi9cbiAgdmFyIEJJTkRfRkxBRyA9IDEsXG4gICAgICBCSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIENVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgQ1VSUllfRkxBRyA9IDgsXG4gICAgICBDVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBQQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFBBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgUkVBUkdfRkxBRyA9IDEyOCxcbiAgICAgIEFSWV9GTEFHID0gMjU2O1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgd2hlbiBhIGZ1bmN0aW9uIGJlY29tZXMgaG90LiAqL1xuICB2YXIgSE9UX0NPVU5UID0gMTUwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAwLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDEsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOXwjOTYpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIidgXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG5hbWVkIGZ1bmN0aW9ucy4gKi9cbiAgdmFyIHJlRnVuY05hbWUgPSAvXlxccypmdW5jdGlvblsgXFxuXFxyXFx0XStcXHcvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVIZXhQcmVmaXggPSAvXjBbeFhdLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xuICB2YXIgcmVIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4xID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGRlXFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzLlxuICAgKiBTZWUgdGhpcyBbYXJ0aWNsZSBvbiBgUmVnRXhwYCBjaGFyYWN0ZXJzXShodHRwOi8vd3d3LnJlZ3VsYXItZXhwcmVzc2lvbnMuaW5mby9jaGFyYWN0ZXJzLmh0bWwjc3BlY2lhbClcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXJzID0gL1suKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFycyA9IFJlZ0V4cChyZVJlZ0V4cENoYXJzLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZS4gKi9cbiAgdmFyIHJlVGhpcyA9IC9cXGJ0aGlzXFxiLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyB0byBjcmVhdGUgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVdvcmRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cHBlciA9ICdbQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlXScsXG4gICAgICAgIGxvd2VyID0gJ1thLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmZdKyc7XG5cbiAgICByZXR1cm4gUmVnRXhwKHVwcGVyICsgJ3syLH0oPz0nICsgdXBwZXIgKyBsb3dlciArICcpfCcgKyB1cHBlciArICc/JyArIGxvd2VyICsgJ3wnICsgdXBwZXIgKyAnK3xbMC05XSsnLCAnZycpO1xuICB9KCkpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCBmb3Igd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHdoaXRlc3BhY2UgPSAoXG4gICAgLy8gQmFzaWMgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICcgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmYnICtcblxuICAgIC8vIExpbmUgdGVybWluYXRvcnMuXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyBVbmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzLlxuICAgICdcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwJ1xuICApO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQXJyYXlCdWZmZXInLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXRoJywgJ051bWJlcicsXG4gICAgJ09iamVjdCcsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdfJywgJ2NsZWFyVGltZW91dCcsICdkb2N1bWVudCcsXG4gICAgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnd2luZG93JywgJ1dpblJURXJyb3InXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2RhdGVUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1ttYXBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCBieSBgXy50aHJvdHRsZWAuICovXG4gIHZhciBkZWJvdW5jZU9wdGlvbnMgPSB7XG4gICAgJ2xlYWRpbmcnOiBmYWxzZSxcbiAgICAnbWF4V2FpdCc6IDAsXG4gICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y0MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlQyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJ2AnOiAnJiM5NjsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiLFxuICAgICcmIzk2Oyc6ICdgJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKipcbiAgICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGB0aGlzYCB2YWx1ZSBpcyB1c2VkIGlmIGl0IGlzIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGF2b2lkIEdyZWFzZW1vbmtleSdzXG4gICAqIHJlc3RyaWN0ZWQgYHdpbmRvd2Agb2JqZWN0LCBvdGhlcndpc2UgdGhlIGB3aW5kb3dgIG9iamVjdCBpcyB1c2VkLlxuICAgKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93ICE9PSAodGhpcyAmJiB0aGlzLndpbmRvdykpID8gd2luZG93IDogdGhpcztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YC4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBjb21wYXJlQXNjZW5kaW5nYCB3aGljaCBjb21wYXJlcyB2YWx1ZXMgYW5kXG4gICAqIHNvcnRzIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyIHdpdGhvdXQgZ3VhcmFudGVlaW5nIGEgc3RhYmxlIHNvcnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUgdG8gYG90aGVyYC5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgdmFsdWUgdG8gY29tcGFyZSB0byBgdmFsdWVgLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VDb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgIHZhciB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcjtcblxuICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgIXZhbElzUmVmbGV4aXZlIHx8ICh0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcgJiYgb3RoSXNSZWZsZXhpdmUpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgIW90aElzUmVmbGV4aXZlIHx8ICh0eXBlb2Ygb3RoZXIgPT0gJ3VuZGVmaW5lZCcgJiYgdmFsSXNSZWZsZXhpdmUpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCBhbmQgYF8uc29ydEJ5QWxsYCB3aGljaCB1c2VzIGBjb21wYXJlcmBcbiAgICogdG8gZGVmaW5lIHRoZSBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpclxuICAgKiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCBpcyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgICogZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6ICh2YWx1ZSArICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLm1heGAgYW5kIGBfLm1pbmAgYXMgdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIHN0cmluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2soc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICogb2YgYHN0cmluZ2AgdGhhdCBpcyBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFycyBUaGUgY2hhcmFjdGVycyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCBjaGFycykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVJpZ2h0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzIFRoZSBjaGFyYWN0ZXJzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlciBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIGNoYXJzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGNoYXJzLmluZGV4T2Yoc3RyaW5nLmNoYXJBdChpbmRleCkpID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiBhbmQgc3RhYmxlXG4gICAqIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBvdGhlcmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYG9iamVjdGAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmplY3QuY3JpdGVyaWEsIG90aGVyLmNyaXRlcmlhKSB8fCAob2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5QWxsYCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgZWFjaCBlbGVtZW50XG4gICAqIGluIGEgY29sbGVjdGlvbiBhbmQgc3RhYmxlIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBvdGhlcmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYG9iamVjdGAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZUFzY2VuZGluZyhvYmplY3QsIG90aGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvL1xuICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVycyB0byBiYXNpYyBsYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIGZ1bmN0aW9uIGRlYnVyckxldHRlcihsZXR0ZXIpIHtcbiAgICByZXR1cm4gZGVidXJyZWRMZXR0ZXJzW2xldHRlcl07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIoY2hyKSB7XG4gICAgcmV0dXJuIGh0bWxFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZFxuICAgKiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYE5hTmAgaXMgZm91bmQgaW4gYGFycmF5YC5cbiAgICogSWYgYGZyb21SaWdodGAgaXMgcHJvdmlkZWQgZWxlbWVudHMgb2YgYGFycmF5YCBhcmUgaXRlcmF0ZWQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgYE5hTmAsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyAoZnJvbUluZGV4IHx8IGxlbmd0aCkgOiAoKGZyb21JbmRleCB8fCAwKSAtIDEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChvdGhlciAhPT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRyaW1tZWRMZWZ0SW5kZXhgIGFuZCBgdHJpbW1lZFJpZ2h0SW5kZXhgIHRvIGRldGVybWluZSBpZiBhXG4gICAqIGNoYXJhY3RlciBjb2RlIGlzIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyQ29kZSBUaGUgY2hhcmFjdGVyIGNvZGUgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBjaGFyQ29kZWAgaXMgd2hpdGVzcGFjZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNTcGFjZShjaGFyQ29kZSkge1xuICAgIHJldHVybiAoKGNoYXJDb2RlIDw9IDE2MCAmJiAoY2hhckNvZGUgPj0gOSAmJiBjaGFyQ29kZSA8PSAxMykgfHwgY2hhckNvZGUgPT0gMzIgfHwgY2hhckNvZGUgPT0gMTYwKSB8fCBjaGFyQ29kZSA9PSA1NzYwIHx8IGNoYXJDb2RlID09IDYxNTggfHxcbiAgICAgIChjaGFyQ29kZSA+PSA4MTkyICYmIChjaGFyQ29kZSA8PSA4MjAyIHx8IGNoYXJDb2RlID09IDgyMzIgfHwgY2hhckNvZGUgPT0gODIzMyB8fCBjaGFyQ29kZSA9PSA4MjM5IHx8IGNoYXJDb2RlID09IDgyODcgfHwgY2hhckNvZGUgPT0gMTIyODggfHwgY2hhckNvZGUgPT0gNjUyNzkpKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgb3B0aW1pemVkIGZvciBzb3J0ZWQgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgc2VlbixcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgIGlmICghaW5kZXggfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltTGVmdGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBpc1NwYWNlKHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1SaWdodGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltbWVkUmlnaHRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgaXNTcGFjZShzdHJpbmcuY2hhckNvZGVBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB1bmVzY2FwZUh0bWxDaGFyKGNocikge1xuICAgIHJldHVybiBodG1sVW5lc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdhZGQnOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhICsgYjsgfSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdzdWInOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uYWRkKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5zdWIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYWRkKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLnN1Yik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gdXNpbmcgYGNvbnRleHRgIHRvIG1vY2sgYERhdGUjZ2V0VGltZWAgdXNlIGluIGBfLm5vd2BcbiAgICogdmFyIG1vY2sgPSBfLnJ1bkluQ29udGV4dCh7XG4gICAqICAgJ0RhdGUnOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7ICdnZXRUaW1lJzogZ2V0VGltZU1vY2sgfTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBvciBjcmVhdGluZyBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qc1xuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAvLyBBdm9pZCBpc3N1ZXMgd2l0aCBzb21lIEVTMyBlbnZpcm9ubWVudHMgdGhhdCBhdHRlbXB0IHRvIHVzZSB2YWx1ZXMsIG5hbWVkXG4gICAgLy8gYWZ0ZXIgYnVpbHQtaW4gY29uc3RydWN0b3JzIGxpa2UgYE9iamVjdGAsIGZvciB0aGUgY3JlYXRpb24gb2YgbGl0ZXJhbHMuXG4gICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDExLjEuNSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIE5hdGl2ZSBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBOdW1iZXIgPSBjb250ZXh0Lk51bWJlcixcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgRE9NIHN1cHBvcnQuICovXG4gICAgdmFyIGRvY3VtZW50ID0gKGRvY3VtZW50ID0gY29udGV4dC53aW5kb3cpICYmIGRvY3VtZW50LmRvY3VtZW50O1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gdGhlIGxlbmd0aCBvZiBuLXR1cGxlcyBmb3IgYF8udW56aXBgLiAqL1xuICAgIHZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZSBgdG9TdHJpbmdUYWdgIG9mIHZhbHVlcy5cbiAgICAgKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIHZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IGNvbnRleHQuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBlc2NhcGVSZWdFeHAob2JqVG9TdHJpbmcpXG4gICAgICAucmVwbGFjZSgvdG9TdHJpbmd8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXlCdWZmZXIgPSBpc05hdGl2ZShBcnJheUJ1ZmZlciA9IGNvbnRleHQuQXJyYXlCdWZmZXIpICYmIEFycmF5QnVmZmVyLFxuICAgICAgICBidWZmZXJTbGljZSA9IGlzTmF0aXZlKGJ1ZmZlclNsaWNlID0gQXJyYXlCdWZmZXIgJiYgbmV3IEFycmF5QnVmZmVyKDApLnNsaWNlKSAmJiBidWZmZXJTbGljZSxcbiAgICAgICAgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIHB1c2ggPSBhcnJheVByb3RvLnB1c2gsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIFNldCA9IGlzTmF0aXZlKFNldCA9IGNvbnRleHQuU2V0KSAmJiBTZXQsXG4gICAgICAgIHNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBVaW50OEFycmF5ID0gaXNOYXRpdmUoVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSkgJiYgVWludDhBcnJheSxcbiAgICAgICAgdW5zaGlmdCA9IGFycmF5UHJvdG8udW5zaGlmdCxcbiAgICAgICAgV2Vha01hcCA9IGlzTmF0aXZlKFdlYWtNYXAgPSBjb250ZXh0LldlYWtNYXApICYmIFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBjbG9uZSBhcnJheSBidWZmZXJzLiAqL1xuICAgIHZhciBGbG9hdDY0QXJyYXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBTYWZhcmkgNSBlcnJvcnMgd2hlbiB1c2luZyBhbiBhcnJheSBidWZmZXIgdG8gaW5pdGlhbGl6ZSBhIHR5cGVkIGFycmF5XG4gICAgICAvLyB3aGVyZSB0aGUgYXJyYXkgYnVmZmVyJ3MgYGJ5dGVMZW5ndGhgIGlzIG5vdCBhIG11bHRpcGxlIG9mIHRoZSB0eXBlZFxuICAgICAgLy8gYXJyYXkncyBgQllURVNfUEVSX0VMRU1FTlRgLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc05hdGl2ZShmdW5jID0gY29udGV4dC5GbG9hdDY0QXJyYXkpICYmIGZ1bmMsXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgZnVuYyhuZXcgQXJyYXlCdWZmZXIoMTApLCAwLCAxKSAmJiBmdW5jO1xuICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KCkpO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlSXNBcnJheSA9IGlzTmF0aXZlKG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlS2V5cyA9IGlzTmF0aXZlKG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cykgJiYgbmF0aXZlS2V5cyxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBpc05hdGl2ZShuYXRpdmVOb3cgPSBEYXRlLm5vdykgJiYgbmF0aXZlTm93LFxuICAgICAgICBuYXRpdmVOdW1Jc0Zpbml0ZSA9IGlzTmF0aXZlKG5hdGl2ZU51bUlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlKSAmJiBuYXRpdmVOdW1Jc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIGAtSW5maW5pdHlgIGFuZCBgSW5maW5pdHlgLiAqL1xuICAgIHZhciBORUdBVElWRV9JTkZJTklUWSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgUE9TSVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICAgIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gTWF0aC5wb3coMiwgMzIpIC0gMSxcbiAgICAgICAgTUFYX0FSUkFZX0lOREVYID0gIE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gICAgLyoqIFVzZWQgYXMgdGhlIHNpemUsIGluIGJ5dGVzLCBvZiBlYWNoIGBGbG9hdDY0QXJyYXlgIGVsZW1lbnQuICovXG4gICAgdmFyIEZMT0FUNjRfQllURVNfUEVSX0VMRU1FTlQgPSBGbG9hdDY0QXJyYXkgPyBGbG9hdDY0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBhcyB0aGUgbWF4aW11bSBsZW5ndGggb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAgICAgKiBTZWUgdGhlIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGludHVpdGl2ZSBjaGFpbmluZy5cbiAgICAgKiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsIGFuZCBmdW5jdGlvbnMgY2FuXG4gICAgICogYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHVybiBhIGJvb2xlYW4gb3Igc2luZ2xlIHZhbHVlIHdpbGxcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gcmV0dXJuaW5nIHRoZSB1bndyYXBwZWQgdmFsdWUuIEV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogbWF5IGJlIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LFxuICAgICAqIHRoYXQgaXMsIGV4ZWN1dGlvbiBpcyBkZWZlcnJlZCB1bnRpbCBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5XG4gICAgICogY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uIFNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0aGF0IG1lcmdlcyBpdGVyYXRlZXMgdG8gYXZvaWQgY3JlYXRpbmcgaW50ZXJtZWRpYXRlXG4gICAgICogYXJyYXlzIGFuZCByZWR1Y2UgdGhlIG51bWJlciBvZiBpdGVyYXRlZSBleGVjdXRpb25zLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGFsc28gaGF2ZSB0aGUgZm9sbG93aW5nIGBBcnJheWAgbWV0aG9kczpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCwgYHNwbGljZWAsXG4gICAgICogYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgZnVuY3Rpb25zIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpcnN0YCxcbiAgICAgKiBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGBwbHVja2AsIGByZWplY3RgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNsaWNlYCxcbiAgICAgKiBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB3aGVyZWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBmdW5jdGlvbnMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGF0YCwgYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsXG4gICAgICogYGNhbGxiYWNrYCwgYGNoYWluYCwgYGNodW5rYCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbnN0YW50YCwgYGNvdW50QnlgLFxuICAgICAqIGBjcmVhdGVgLCBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmZXJgLCBgZGVsYXlgLCBgZGlmZmVyZW5jZWAsXG4gICAgICogYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmxhdHRlbmAsXG4gICAgICogYGZsYXR0ZW5EZWVwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCxcbiAgICAgKiBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZnVuY3Rpb25zYCwgYGdyb3VwQnlgLCBgaW5kZXhCeWAsXG4gICAgICogYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsIGBpbnZva2VgLCBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCxcbiAgICAgKiBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtaXhpbmAsIGBuZWdhdGVgLCBgbm9vcGAsXG4gICAgICogYG9taXRgLCBgb25jZWAsIGBwYWlyc2AsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBsdWNrYCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsXG4gICAgICogYHJlYXJnYCwgYHJlamVjdGAsIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNodWZmbGVgLCBgc2xpY2VgLCBgc29ydGAsXG4gICAgICogYHNvcnRCeWAsIGBzb3J0QnlBbGxgLCBgc3BsaWNlYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCxcbiAgICAgKiBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRpbWVzYCwgYHRvQXJyYXlgLCBgdG9QbGFpbk9iamVjdGAsXG4gICAgICogYHRyYW5zZm9ybWAsIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdmFsdWVzYCwgYHZhbHVlc0luYCxcbiAgICAgKiBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB6aXBgLCBhbmQgYHppcE9iamVjdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9ucyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjbG9uZWAsIGBjbG9uZURlZXBgLCBgZGVidXJyYCxcbiAgICAgKiBgZW5kc1dpdGhgLCBgZXNjYXBlYCwgYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCxcbiAgICAgKiBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaW5kV2hlcmVgLCBgZmlyc3RgLCBgaGFzYCxcbiAgICAgKiBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsXG4gICAgICogYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLFxuICAgICAqIGBpc0Z1bmN0aW9uYCwgYGlzTWF0Y2hgLCBgaXNOYXRpdmVgLCBgaXNOYU5gLCBgaXNOdWxsYCwgYGlzTnVtYmVyYCxcbiAgICAgKiBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsXG4gICAgICogYGlzVHlwZWRBcnJheWAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCwgYG1heGAsIGBtaW5gLFxuICAgICAqIGBub0NvbmZsaWN0YCwgYG5vd2AsIGBwYWRgLCBgcGFkTGVmdGAsIGBwYWRSaWdodGAsIGBwYXJzZUludGAsIGBwb3BgLFxuICAgICAqIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCwgYHJlcGVhdGAsIGByZXN1bHRgLCBgcnVuSW5Db250ZXh0YCxcbiAgICAgKiBgc2hpZnRgLCBgc2l6ZWAsIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1MZWZ0YCwgYHRyaW1SaWdodGAsXG4gICAgICogYHRydW5jYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIGBzYW1wbGVgIHdpbGwgcmV0dXJuIGEgd3JhcHBlZCB2YWx1ZSB3aGVuIGBuYCBpcyBwcm92aWRlZCxcbiAgICAgKiBvdGhlcndpc2UgYW4gdW53cmFwcGVkIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG4pIHsgcmV0dXJuIHN1bSArIG47IH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYSB3cmFwcGVkIHZhbHVlXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBuICogbjsgfSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZS5fX3dyYXBwZWRfXywgdmFsdWUuX19jaGFpbl9fLCBhcnJheUNvcHkodmFsdWUuX19hY3Rpb25zX18pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgY2hhaW5pbmcgZm9yIGFsbCB3cmFwcGVyIG1ldGhvZHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FjdGlvbnM9W11dIEFjdGlvbnMgdG8gcGVmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCwgYWN0aW9ucykge1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IGFjdGlvbnMgfHwgW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGVudmlyb25tZW50IGZlYXR1cmUgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAoZnVuY3Rpb24oeCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBmdW5jdGlvbnMgY2FuIGJlIGRlY29tcGlsZWQgYnkgYEZ1bmN0aW9uI3RvU3RyaW5nYFxuICAgICAgICogKGFsbCBidXQgRmlyZWZveCBPUyBjZXJ0aWZpZWQgYXBwcywgb2xkZXIgT3BlcmEgbW9iaWxlIGJyb3dzZXJzLCBhbmRcbiAgICAgICAqIHRoZSBQbGF5U3RhdGlvbiAzOyBmb3JjZWQgYGZhbHNlYCBmb3IgV2luZG93cyA4IGFwcHMpLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgc3VwcG9ydC5mdW5jRGVjb21wID0gIWlzTmF0aXZlKGNvbnRleHQuV2luUlRFcnJvcikgJiYgcmVUaGlzLnRlc3QocnVuSW5Db250ZXh0KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3QgaWYgYEZ1bmN0aW9uI25hbWVgIGlzIHN1cHBvcnRlZCAoYWxsIGJ1dCBJRSkuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiB0aGUgRE9NIGlzIHN1cHBvcnRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgIHRyeSB7XG4gICAgICAgIHN1cHBvcnQuZG9tID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLm5vZGVUeXBlID09PSAxMTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBzdXBwb3J0LmRvbSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGUuXG4gICAgICAgKlxuICAgICAgICogSW4gRmlyZWZveCA8IDQsIElFIDwgOSwgUGhhbnRvbUpTLCBhbmQgU2FmYXJpIDwgNS4xIGBhcmd1bWVudHNgIG9iamVjdFxuICAgICAgICogaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGUuIENocm9tZSA8IDI1IGFuZCBOb2RlLmpzIDwgMC4xMS4wIHRyZWF0XG4gICAgICAgKiBgYXJndW1lbnRzYCBvYmplY3QgaW5kZXhlcyBhcyBub24tZW51bWVyYWJsZSBhbmQgZmFpbCBgaGFzT3duUHJvcGVydHlgXG4gICAgICAgKiBjaGVja3MgZm9yIGluZGV4ZXMgdGhhdCBleGNlZWQgdGhlaXIgZnVuY3Rpb24ncyBmb3JtYWwgcGFyYW1ldGVycyB3aXRoXG4gICAgICAgKiBhc3NvY2lhdGVkIHZhbHVlcyBvZiBgMGAuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICB0cnkge1xuICAgICAgICBzdXBwb3J0Lm5vbkVudW1BcmdzID0gIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBzdXBwb3J0Lm5vbkVudW1BcmdzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KDAsIDApKTtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlXG4gICAgICogYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLmFjdGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy5kaXIgPSAxO1xuICAgICAgdGhpcy5kcm9wQ291bnQgPSAwO1xuICAgICAgdGhpcy5maWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pdGVyYXRlZXMgPSBudWxsO1xuICAgICAgdGhpcy50YWtlQ291bnQgPSBQT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIHRoaXMudmlld3MgPSBudWxsO1xuICAgICAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucyxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLml0ZXJhdGVlcyxcbiAgICAgICAgICB2aWV3cyA9IHRoaXMudmlld3MsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMud3JhcHBlZCk7XG5cbiAgICAgIHJlc3VsdC5hY3Rpb25zID0gYWN0aW9ucyA/IGFycmF5Q29weShhY3Rpb25zKSA6IG51bGw7XG4gICAgICByZXN1bHQuZGlyID0gdGhpcy5kaXI7XG4gICAgICByZXN1bHQuZHJvcENvdW50ID0gdGhpcy5kcm9wQ291bnQ7XG4gICAgICByZXN1bHQuZmlsdGVyZWQgPSB0aGlzLmZpbHRlcmVkO1xuICAgICAgcmVzdWx0Lml0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA/IGFycmF5Q29weShpdGVyYXRlZXMpIDogbnVsbDtcbiAgICAgIHJlc3VsdC50YWtlQ291bnQgPSB0aGlzLnRha2VDb3VudDtcbiAgICAgIHJlc3VsdC52aWV3cyA9IHZpZXdzID8gYXJyYXlDb3B5KHZpZXdzKSA6IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJlZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuZGlyID0gLTE7XG4gICAgICAgIHJlc3VsdC5maWx0ZXJlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5kaXIgKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy53cmFwcGVkLnZhbHVlKCk7XG4gICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLmFjdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIGRpciA9IHRoaXMuZGlyLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFycmF5Lmxlbmd0aCwgdGhpcy52aWV3cyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGRyb3BDb3VudCA9IHRoaXMuZHJvcENvdW50LFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMudGFrZUNvdW50IC0gZHJvcENvdW50KSxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiBzdGFydCAtIDEsXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5pdGVyYXRlZXMsXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcyA/IGl0ZXJhdGVlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSksXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGU7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkcm9wQ291bnQpIHtcbiAgICAgICAgICBkcm9wQ291bnQtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS92YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBuYW1lIENhY2hlXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwRGVsZXRlKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNhY2hlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBHZXQoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ID09ICdfX3Byb3RvX18nID8gdW5kZWZpbmVkIDogdGhpcy5fX2RhdGFfX1trZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGNhY2hlZCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgIT0gJ19fcHJvdG9fXycgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9fZGF0YV9fLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byBga2V5YCBvZiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSAhPSAnX19wcm90b19fJykge1xuICAgICAgICB0aGlzLl9fZGF0YV9fW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gICAgICB0aGlzLmRhdGEgPSB7ICdoYXNoJzogbmF0aXZlQ3JlYXRlKG51bGwpLCAnc2V0JzogbmV3IFNldCB9O1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRoaXMucHVzaCh2YWx1ZXNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNhY2hlYCBtaW1pY2tpbmcgdGhlIHJldHVybiBzaWduYXR1cmUgb2ZcbiAgICAgKiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGNhY2hlLmRhdGEsXG4gICAgICAgICAgcmVzdWx0ID0gKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpID8gZGF0YS5zZXQuaGFzKHZhbHVlKSA6IGRhdGEuaGFzaFt2YWx1ZV07XG5cbiAgICAgIHJldHVybiByZXN1bHQgPyAwIDogLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcHVzaFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBkYXRhLnNldC5hZGQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5oYXNoW3ZhbHVlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5Q29weShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBjYWxsYmFjayBzaG9ydGhhbmRzIG9yIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBvciBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBvciBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWF4YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TWF4KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1pbmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheU1pbihhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEZyb21BcnJheV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChpbml0RnJvbUFycmF5ICYmIGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogY2FsbGJhY2sgc2hvcnRoYW5kcyBvciBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGluaXRGcm9tQXJyYXkgJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VWYWx1ZSBUaGUgc291cmNlIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iamVjdFZhbHVlID09ICd1bmRlZmluZWQnID8gc291cmNlVmFsdWUgOiBvYmplY3RWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYGFzc2lnbkRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCBpZ25vcmVzXG4gICAgICogaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlcyB3aGVuIGNoZWNraW5nIGlmIGEgcHJvcGVydHkgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIG9iamVjdCBhbmQgc291cmNlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk93bkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdFZhbHVlID09ICd1bmRlZmluZWQnIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSlcbiAgICAgICAgPyBzb3VyY2VWYWx1ZVxuICAgICAgICA6IG9iamVjdFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcbiAgICAgKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgaWYgKCFjdXN0b21pemVyKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29weShzb3VyY2UsIG9iamVjdCwgcHJvcHMpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoXG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplcih2YWx1ZSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuXG4gICAgICAgIGlmICgocmVzdWx0ID09PSByZXN1bHQgPyByZXN1bHQgIT09IHZhbHVlIDogdmFsdWUgPT09IHZhbHVlKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJyAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0cmluZ3MgYW5kIGluZGl2aWR1YWxcbiAgICAgKiBrZXkgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gW3Byb3BzXSBUaGUgcHJvcGVydHkgbmFtZXMgb3IgaW5kZXhlcyBvZiBlbGVtZW50cyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQoY29sbGVjdGlvbiwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgIGlzQXJyID0gaXNMZW5ndGgobGVuZ3RoKSxcbiAgICAgICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShwcm9wc0xlbmd0aCk7XG5cbiAgICAgIHdoaWxlKCsraW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBrZXkgPSBwYXJzZUZsb2F0KGtleSk7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGlzSW5kZXgoa2V5LCBsZW5ndGgpID8gY29sbGVjdGlvbltrZXldIDogdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjb2xsZWN0aW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvcHkoc291cmNlLCBvYmplY3QsIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYmluZEFsbGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIG5hbWUgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZEFsbChvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2ROYW1lc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgQklORF9GTEFHLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jYWxsYmFja2Agd2hpY2ggc3VwcG9ydHMgc3BlY2lmeWluZyB0aGVcbiAgICAgKiBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmICh0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpc0FyZyAhPSAndW5kZWZpbmVkJyAmJiBpc0JpbmRhYmxlKGZ1bmMpKVxuICAgICAgICAgID8gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KVxuICAgICAgICAgIDogZnVuYztcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgLy8gSGFuZGxlIFwiXy5wcm9wZXJ0eVwiIGFuZCBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHMuXG4gICAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0J1xuICAgICAgICA/IGJhc2VNYXRjaGVzKGZ1bmMpXG4gICAgICAgIDogYmFzZVByb3BlcnR5KGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IGB2YWx1ZWAgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCkgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWc7XG5cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VDb3B5KHZhbHVlLCByZXN1bHQsIGtleXModmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lYWJsZVRhZ3NbdGFnXVxuICAgICAgICAgICAgPyBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApXG4gICAgICAgICAgICA6IChvYmplY3QgPyB2YWx1ZSA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZS5cbiAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3Q7XG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBjb250ZXh0Lk9iamVjdCgpO1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBhbiBpbmRleFxuICAgICAqIG9mIHdoZXJlIHRvIHNsaWNlIHRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIGBhcmd1bWVudHNgIG9iamVjdCB0byBzbGljZSBhbmQgcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MsIGZyb21JbmRleCkge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYmFzZVNsaWNlKGFyZ3MsIGZyb21JbmRleCkpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kaWZmZXJlbmNlYCB3aGljaCBhY2NlcHRzIGEgc2luZ2xlIGFycmF5XG4gICAgICogb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaW5kZXhPZiA9PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBjYWNoZSA9IGlzQ29tbW9uICYmIHZhbHVlcy5sZW5ndGggPj0gMjAwICYmIGNyZWF0ZUNhY2hlKHZhbHVlcyksXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIHZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZUZvck93bihjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpdGVyYWJsZSA9IHRvT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZUZvck93blJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYWJsZSA9IHRvT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtsZW5ndGhdLCBsZW5ndGgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kYCwgYF8uZmluZExhc3RgLCBgXy5maW5kS2V5YCwgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlc1xuICAgICAqIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIHRoZSBwcm92aWRlZCBgZWFjaEZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEtleV0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudFxuICAgICAqICBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaW5kKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMsIHJldEtleSkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJldEtleSA/IGtleSA6IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggYWRkZWQgc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmdcbiAgICAgKiBmbGF0dGVuaW5nIGFuZCBzcGVjaWZ5aW5nIHRoZSBzdGFydCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgaXNTdHJpY3QsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzRGVlcCwgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgcmVzdWx0Lmxlbmd0aCArPSB2YWxMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsrdmFsSW5kZXggPCB2YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlW3ZhbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JJbmAgYW5kIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlc1xuICAgICAqIG92ZXIgYG9iamVjdGAgcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGludm9raW5nIGBpdGVyYXRlZWAgZm9yXG4gICAgICogZWFjaCBwcm9wZXJ0eS4gSXRlcmF0b3IgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5XG4gICAgICogcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXRlcmFibGUgPSB0b09iamVjdChvYmplY3QpLFxuICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgIHZhciBpdGVyYWJsZSA9IHRvT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdO1xuICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9ySW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSB0aG9zZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aGljaCByZXF1aXJlcyBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHRvIGJlIHByb3ZpZGVkIGFzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyByYXRoZXIgdGhhbiBpbmRpdmlkdWFsbHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52b2tlKGNvbGxlY3Rpb24sIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBtZXRob2ROYW1lID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBpc0xlbmd0aChsZW5ndGgpID8gQXJyYXkobGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZE5hbWUgOiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVttZXRob2ROYW1lXSk7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGZ1bmMgPyBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzYCBiaW5kaW5nXG4gICAgICogYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNXaGVyZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzLlxuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICAvLyBUcmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAwIHx8ICgxIC8gdmFsdWUgPT0gMSAvIG90aGVyKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWxUeXBlID0gdHlwZW9mIHZhbHVlLFxuICAgICAgICAgIG90aFR5cGUgPSB0eXBlb2Ygb3RoZXI7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHVubGlrZSBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgaWYgKCh2YWxUeXBlICE9ICdmdW5jdGlvbicgJiYgdmFsVHlwZSAhPSAnb2JqZWN0JyAmJiBvdGhUeXBlICE9ICdmdW5jdGlvbicgJiYgb3RoVHlwZSAhPSAnb2JqZWN0JykgfHxcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwpIHtcbiAgICAgICAgLy8gUmV0dXJuIGBmYWxzZWAgdW5sZXNzIGJvdGggdmFsdWVzIGFyZSBgTmFOYC5cbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzV2hlcmVdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICAgICAgaWYgKCFvYmpJc0Fycikge1xuICAgICAgICBvYmpUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmpUYWcgPT0gYXJnc1RhZykge1xuICAgICAgICAgIG9ialRhZyA9IG9iamVjdFRhZztcbiAgICAgICAgfSBlbHNlIGlmIChvYmpUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgb2JqSXNBcnIgPSBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvdGhJc0Fycikge1xuICAgICAgICBvdGhUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG90aGVyKTtcbiAgICAgICAgaWYgKG90aFRhZyA9PSBhcmdzVGFnKSB7XG4gICAgICAgICAgb3RoVGFnID0gb2JqZWN0VGFnO1xuICAgICAgICB9IGVsc2UgaWYgKG90aFRhZyAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgICBvdGhJc0FyciA9IGlzVHlwZWRBcnJheShvdGhlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIShvYmpJc0FyciB8fCBvYmpJc09iaikpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWxXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgIG90aFdyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgaWYgKHZhbFdyYXBwZWQgfHwgb3RoV3JhcHBlZCkge1xuICAgICAgICByZXR1cm4gZXF1YWxGdW5jKHZhbFdyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCwgb3RoV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlciwgY3VzdG9taXplciwgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGV0ZWN0aW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgc2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jSk8uXG4gICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgYG9iamVjdGAgYW5kIGBvdGhlcmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgc3RhY2tBLnB1c2gob2JqZWN0KTtcbiAgICAgIHN0YWNrQi5wdXNoKG90aGVyKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IChvYmpJc0FyciA/IGVxdWFsQXJyYXlzIDogZXF1YWxPYmplY3RzKShvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcblxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgc291cmNlIHByb3BlcnR5IG5hbWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgc291cmNlIHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdHJpY3RDb21wYXJlRmxhZ3MgU3RyaWN0IGNvbXBhcmlzb24gZmxhZ3MgZm9yIHNvdXJjZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHByb3BzLCB2YWx1ZXMsIHN0cmljdENvbXBhcmVGbGFncywgY3VzdG9taXplcikge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBzdHJpY3RDb21wYXJlRmxhZ3NbaW5kZXhdKVxuICAgICAgICAgICAgICA/IHZhbHVlc1tpbmRleF0gIT09IG9iamVjdFtwcm9wc1tpbmRleF1dXG4gICAgICAgICAgICAgIDogIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wc1tpbmRleF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIHN0cmljdENvbXBhcmVGbGFnc1tpbmRleF0pIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICAgIHNyY1ZhbHVlID0gdmFsdWVzW2luZGV4XTtcblxuICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogb3IgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQucHVzaChpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggc3VwcG9ydHMgc3BlY2lmeWluZyB3aGV0aGVyXG4gICAgICogYHNvdXJjZWAgc2hvdWxkIGJlIGNsb25lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChsZW5ndGggPT0gMSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChpc1N0cmljdENvbXBhcmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHZhbHVlID09PSBvYmplY3Rba2V5XSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBzdHJpY3RDb21wYXJlRmxhZ3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFsdWUgPSBzb3VyY2VbcHJvcHNbbGVuZ3RoXV07XG4gICAgICAgIHZhbHVlc1tsZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIHN0cmljdENvbXBhcmVGbGFnc1tsZW5ndGhdID0gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgcHJvcHMsIHZhbHVlcywgc3RyaWN0Q29tcGFyZUZsYWdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIGlzU3JjQXJyID0gaXNMZW5ndGgoc291cmNlLmxlbmd0aCkgJiYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSk7XG5cbiAgICAgIChpc1NyY0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSwgc291cmNlKSB7XG4gICAgICAgIGlmIChpc09iamVjdExpa2Uoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNDb21tb24gPSB0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaXNTcmNBcnIgfHwgdHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgIChpc0NvbW1vbiB8fCAocmVzdWx0ID09PSByZXN1bHQgPyByZXN1bHQgIT09IHZhbHVlIDogdmFsdWUgPT09IHZhbHVlKSkpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aCxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHNyY1ZhbHVlKSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgaXNDb21tb24gPSB0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0xlbmd0aChzcmNWYWx1ZS5sZW5ndGgpICYmIChpc0FycmF5KHNyY1ZhbHVlKSB8fCBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6ICh2YWx1ZSA/IGFycmF5Q29weSh2YWx1ZSkgOiBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNBcmd1bWVudHModmFsdWUpXG4gICAgICAgICAgICA/IHRvUGxhaW5PYmplY3QodmFsdWUpXG4gICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlXG4gICAgICAvLyBpdCB3aXRoIGl0cyBtZXJnZWQgdmFsdWUuXG4gICAgICBzdGFja0EucHVzaChzcmNWYWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIG9iamVjdFtrZXldID0gbWVyZ2VGdW5jKHJlc3VsdCwgc3JjVmFsdWUsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSByZXN1bHQgPyByZXN1bHQgIT09IHZhbHVlIDogdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aGljaCBkb2VzIG5vdCBjb2VyY2UgYGtleWAgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXggYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGluZGV4ZXMuc29ydChiYXNlQ29tcGFyZUFzY2VuZGluZyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VGbG9hdChpbmRleGVzW2xlbmd0aF0pO1xuICAgICAgICBpZiAoaW5kZXggIT0gcHJldmlvdXMgJiYgaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZ1xuICAgICAqIGFuZCByZXR1cm5pbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArIGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgb3IgYHRoaXNgIGJpbmRpbmcsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAgICogdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEZyb21Db2xsZWN0aW9uIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudFxuICAgICAqICBvZiBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUNvbGxlY3Rpb24sIGVhY2hGdW5jKSB7XG4gICAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0RnJvbUNvbGxlY3Rpb25cbiAgICAgICAgICA/IChpbml0RnJvbUNvbGxlY3Rpb24gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3AgZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9ICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiAoK2VuZCB8fCAwKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoZW5kIC0gc3RhcnQpID4+PiAwO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogb3IgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgaXNMYXJnZSA9IGlzQ29tbW9uICYmIGxlbmd0aCA+PSAyMDAsXG4gICAgICAgICAgc2VlbiA9IGlzTGFyZ2UgJiYgY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFjdGlvbnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJncyA9IFtyZXN1bHRdLFxuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uc1tpbmRleF07XG5cbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhY3Rpb24uYXJncyk7XG4gICAgICAgIHJlc3VsdCA9IGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0LCBpbnN0ZWFkXG4gICAgICogIG9mIHRoZSBsb3dlc3QsIGluZGV4IGF0IHdoaWNoIGEgdmFsdWUgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuXG4gICAgICAgICAgaWYgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmluYXJ5SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGludm9rZXMgYGl0ZXJhdGVlYCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QsIGluc3RlYWRcbiAgICAgKiAgb2YgdGhlIGxvd2VzdCwgaW5kZXggYXQgd2hpY2ggYSB2YWx1ZSBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzVW5kZWYgPSB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBmbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBpc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZDtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gaXNSZWZsZXhpdmUgfHwgcmV0SGlnaGVzdDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmKSB7XG4gICAgICAgICAgc2V0TG93ID0gaXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgdHlwZW9mIGNvbXB1dGVkICE9ICd1bmRlZmluZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBhbmQgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmZmVyKSB7XG4gICAgICByZXR1cm4gYnVmZmVyU2xpY2UuY2FsbChidWZmZXIsIDApO1xuICAgIH1cbiAgICBpZiAoIWJ1ZmZlclNsaWNlKSB7XG4gICAgICAvLyBQaGFudG9tSlMgaGFzIGBBcnJheUJ1ZmZlcmAgYW5kIGBVaW50OEFycmF5YCBidXQgbm90IGBGbG9hdDY0QXJyYXlgLlxuICAgICAgYnVmZmVyQ2xvbmUgPSAhKEFycmF5QnVmZmVyICYmIFVpbnQ4QXJyYXkpID8gY29uc3RhbnQobnVsbCkgOiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGZsb2F0TGVuZ3RoID0gRmxvYXQ2NEFycmF5ID8gZmxvb3IoYnl0ZUxlbmd0aCAvIEZMT0FUNjRfQllURVNfUEVSX0VMRU1FTlQpIDogMCxcbiAgICAgICAgICAgIG9mZnNldCA9IGZsb2F0TGVuZ3RoICogRkxPQVQ2NF9CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoZmxvYXRMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmlldyA9IG5ldyBGbG9hdDY0QXJyYXkocmVzdWx0LCAwLCBmbG9hdExlbmd0aCk7XG4gICAgICAgICAgdmlldy5zZXQobmV3IEZsb2F0NjRBcnJheShidWZmZXIsIDAsIGZsb2F0TGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVMZW5ndGggIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCwgb2Zmc2V0KTtcbiAgICAgICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycykge1xuICAgICAgdmFyIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShhcmdzTGVuZ3RoICsgbGVmdExlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gICAgICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKSB7XG4gICAgICB2YXIgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkoYXJnc0xlbmd0aCArIHJpZ2h0TGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBwYWQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3BhZCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtwYWQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYSBjb2xsZWN0aW9uLCBjcmVhdGluZyBhbiBhY2N1bXVsYXRvclxuICAgICAqIG9iamVjdCBjb21wb3NlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICogdGhyb3VnaCBhbiBpdGVyYXRlZS4gVGhlIGBzZXR0ZXJgIHNldHMgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgYWNjdW11bGF0b3JcbiAgICAgKiBvYmplY3QuIElmIGBpbml0aWFsaXplcmAgaXMgcHJvdmlkZWQgaW5pdGlhbGl6ZXMgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBhY2N1bXVsYXRvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSB0aGUgYWNjdW11bGF0b3Igb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhc3NpZ25zIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byBhIGdpdmVuXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIG9iamVjdCA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA+IDMgJiYgaXNJdGVyYXRlZUNhbGwoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSkpIHtcbiAgICAgICAgICBsZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIEp1Z2dsZSBhcmd1bWVudHMuXG4gICAgICAgIGlmIChsZW5ndGggPiAzICYmIHR5cGVvZiBhcmd1bWVudHNbbGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjdXN0b21pemVyID0gYmluZENhbGxiYWNrKGFyZ3VtZW50c1stLWxlbmd0aCAtIDFdLCBhcmd1bWVudHNbbGVuZ3RoLS1dLCA1KTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBhcmd1bWVudHNbbGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBhcmd1bWVudHNbLS1sZW5ndGhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kV3JhcHBlcihmdW5jLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyID8gQ3RvciA6IGZ1bmMpLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYFNldGAgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgY2FjaGUgb2JqZWN0IGlmIGBTZXRgIGlzIHN1cHBvcnRlZCwgZWxzZSBgbnVsbGAuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZUNhY2hlID0gIShuYXRpdmVDcmVhdGUgJiYgU2V0KSA/IGNvbnN0YW50KG51bGwpIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGNvbXBvdW5kIHdvcmRzIG91dCBvZiB0aGUgd29yZHMgaW4gYVxuICAgICAqIGdpdmVuIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFycmF5ID0gd29yZHMoZGVidXJyKHN0cmluZykpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhyZXN1bHQsIGFycmF5W2luZGV4XSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3JXcmFwcGVyKEN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGV4dHJlbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGV4dHJlbXVtIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNaW5dIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBtaW5pbXVtLCBpbnN0ZWFkIG9mIHRoZSBtYXhpbXVtLFxuICAgICAqICBleHRyZW11bSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBleHRyZW11bSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVFeHRyZW11bShhcnJheUZ1bmMsIGlzTWluKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gZ2V0Q2FsbGJhY2soKSxcbiAgICAgICAgICAgIG5vSXRlcmF0ZWUgPSBpdGVyYXRlZSA9PSBudWxsO1xuXG4gICAgICAgIGlmICghKGZ1bmMgPT09IGJhc2VDYWxsYmFjayAmJiBub0l0ZXJhdGVlKSkge1xuICAgICAgICAgIG5vSXRlcmF0ZWUgPSBmYWxzZTtcbiAgICAgICAgICBpdGVyYXRlZSA9IGZ1bmMoaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub0l0ZXJhdGVlKSB7XG4gICAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoIWlzQXJyICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpdGVyYXRlZSA9IGNoYXJBdENhbGxiYWNrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGlzQXJyID8gY29sbGVjdGlvbiA6IHRvSXRlcmFibGUoY29sbGVjdGlvbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0cmVtdW1CeShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgaXNNaW4pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcHBlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZFdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIEJJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIENVUlJZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIENVUlJZX0JPVU5EX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyeVJpZ2h0ID0gYml0bWFzayAmIENVUlJZX1JJR0hUX0ZMQUc7XG5cbiAgICAgIHZhciBDdG9yID0gIWlzQmluZEtleSAmJiBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKSxcbiAgICAgICAgICBrZXkgPSBmdW5jO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuICAgICAgICAvLyBjb252ZXJ0aW5nIGl0IHRvIGFuIGFycmF5IGJlZm9yZSBwcm92aWRpbmcgaXQgdG8gb3RoZXIgZnVuY3Rpb25zLlxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycnkgfHwgaXNDdXJyeVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgYXJnc0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgICBsZW5ndGggLT0gYXJnc0hvbGRlcnMubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgICAgdmFyIG5ld0FyZ1BvcyA9IGFyZ1BvcyA/IGFycmF5Q29weShhcmdQb3MpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBuZXdBcml0eSA9IG5hdGl2ZU1heChhcml0eSAtIGxlbmd0aCwgMCksXG4gICAgICAgICAgICAgICAgbmV3c0hvbGRlcnMgPSBpc0N1cnJ5ID8gYXJnc0hvbGRlcnMgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyBudWxsIDogYXJnc0hvbGRlcnMsXG4gICAgICAgICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gYXJncyA6IG51bGwsXG4gICAgICAgICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyBudWxsIDogYXJncztcblxuICAgICAgICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFBBUlRJQUxfRkxBRyA6IFBBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFBBUlRJQUxfUklHSFRfRkxBRyA6IFBBUlRJQUxfRkxBRyk7XG5cbiAgICAgICAgICAgIGlmICghaXNDdXJyeUJvdW5kKSB7XG4gICAgICAgICAgICAgIGJpdG1hc2sgJj0gfihCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVIeWJyaWRXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdzSG9sZGVycywgbmV3UGFydGlhbHNSaWdodCwgbmV3SG9sZGVyc1JpZ2h0LCBuZXdBcmdQb3MsIGFyeSwgbmV3QXJpdHkpO1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKGlzQmluZEtleSkge1xuICAgICAgICAgIGZ1bmMgPSB0aGlzQmluZGluZ1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIgPyAoQ3RvciB8fCBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKSkgOiBmdW5jKS5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWQgcmVxdWlyZWQgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIHRoZSBnaXZlbiBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgYGNoYXJzYCBzdHJpbmcgbWF5IGJlIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIHBhZGRpbmcgY2hhcmFjdGVyc1xuICAgICAqIGV4Y2VlZHMgdGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY3JlYXRlIHBhZGRpbmcgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cbiAgICAgIGlmIChzdHJMZW5ndGggPj0gbGVuZ3RoIHx8ICFuYXRpdmVJc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBzdHJMZW5ndGg7XG4gICAgICBjaGFycyA9IGNoYXJzID09IG51bGwgPyAnICcgOiAoY2hhcnMgKyAnJyk7XG4gICAgICByZXR1cm4gcmVwZWF0KGNoYXJzLCBjZWlsKHBhZExlbmd0aCAvIGNoYXJzLmxlbmd0aCkpLnNsaWNlKDAsIHBhZExlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIGFuZCBpbnZva2VzIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiB0aGUgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy4gU2VlIGBjcmVhdGVXcmFwcGVyYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWxXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIEJJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIC8vIEF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCB1c2UgZGlzcXVhbGlmeWluZyBvcHRpbWl6YXRpb25zIGJ5XG4gICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCBgZnVuY2AuXG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGFyZ3NMZW5ndGggKyBsZWZ0TGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIgPyBDdG9yIDogZnVuYykuYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuXG4gICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICAgICAqICAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAgMjU2IC0gYF8uYXJ5YFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBCSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihQQVJUSUFMX0ZMQUcgfCBQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgbGVuZ3RoIC09IChob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwKTtcbiAgICAgIGlmIChiaXRtYXNrICYgUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9ICFpc0JpbmRLZXkgJiYgZ2V0RGF0YShmdW5jKSxcbiAgICAgICAgICBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eV07XG5cbiAgICAgIGlmIChkYXRhICYmIGRhdGEgIT09IHRydWUpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgICAgYXJpdHkgPSBuZXdEYXRhWzldO1xuICAgICAgfVxuICAgICAgbmV3RGF0YVs5XSA9IGFyaXR5ID09IG51bGxcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IChuYXRpdmVNYXgoYXJpdHkgLSBsZW5ndGgsIDApIHx8IDApO1xuXG4gICAgICBpZiAoYml0bWFzayA9PSBCSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmRXcmFwcGVyKG5ld0RhdGFbMF0sIG5ld0RhdGFbMl0pO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBQQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoQklORF9GTEFHIHwgUEFSVElBTF9GTEFHKSkgJiYgIW5ld0RhdGFbNF0ubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWxXcmFwcGVyLmFwcGx5KG51bGwsIG5ld0RhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseShudWxsLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldHRlcihyZXN1bHQsIG5ld0RhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgYXJyYXlzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzV2hlcmVdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0FdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNXaGVyZSAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAocmVzdWx0ICYmICsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHJlc3VsdCA9IGlzV2hlcmVcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4KVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBpZiAoaXNXaGVyZSkge1xuICAgICAgICAgICAgdmFyIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltvdGhJbmRleF07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IChhcnJWYWx1ZSAmJiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChhcnJWYWx1ZSAmJiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsLlxuICAgICAgICAgIHJldHVybiArb2JqZWN0ID09ICtvdGhlcjtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuICAgICAgICAgIHJldHVybiAob2JqZWN0ICE9ICtvYmplY3QpXG4gICAgICAgICAgICA/IG90aGVyICE9ICtvdGhlclxuICAgICAgICAgICAgLy8gQnV0LCB0cmVhdCBgLTBgIHZzLiBgKzBgIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgICAgIDogKG9iamVjdCA9PSAwID8gKCgxIC8gb2JqZWN0KSA9PSAoMSAvIG90aGVyKSkgOiBvYmplY3QgPT0gK290aGVyKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncyBwcmltaXRpdmVzIGFuZCBzdHJpbmdcbiAgICAgICAgICAvLyBvYmplY3RzIGFzIGVxdWFsLiBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNXaGVyZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1doZXJlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNDdG9yLFxuICAgICAgICAgIGluZGV4ID0gLTE7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF0sXG4gICAgICAgICAgICByZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpc1doZXJlXG4gICAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSlcbiAgICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgcmVzdWx0ID0gKG9ialZhbHVlICYmIG9ialZhbHVlID09PSBvdGhWYWx1ZSkgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNDdG9yIHx8IChoYXNDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBleHRyZW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaCB2YWx1ZVxuICAgICAqIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZSBpcyByYW5rZWQuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01pbl0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIG1pbmltdW0sIGluc3RlYWQgb2YgdGhlXG4gICAgICogIG1heGltdW0sIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRyZW11bUJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBpc01pbikge1xuICAgICAgdmFyIGV4VmFsdWUgPSBpc01pbiA/IFBPU0lUSVZFX0lORklOSVRZIDogTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgY29tcHV0ZWQgPSBleFZhbHVlLFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoKGlzTWluID8gY3VycmVudCA8IGNvbXB1dGVkIDogY3VycmVudCA+IGNvbXB1dGVkKSB8fCAoY3VycmVudCA9PT0gZXhWYWx1ZSAmJiBjdXJyZW50ID09PSByZXN1bHQpKSB7XG4gICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJjYWxsYmFja1wiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uY2FsbGJhY2tgIG1ldGhvZCBpc1xuICAgICAqIGN1c3RvbWl6ZWQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUNhbGxiYWNrYCBmdW5jdGlvbi4gSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0aGUgY2hvc2VuIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guY2FsbGJhY2sgfHwgY2FsbGJhY2s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGNhbGxiYWNrID8gYmFzZUNhbGxiYWNrIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ0NvdW50ID8gcmVzdWx0KGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcImluZGV4T2ZcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmluZGV4T2ZgIG1ldGhvZCBpc1xuICAgICAqIGN1c3RvbWl6ZWQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRoZSBjaG9zZW4gZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmQgaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufG51bWJlcn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mIHx8IGluZGV4T2Y7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGluZGV4T2YgPyBiYXNlSW5kZXhPZiA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uID8gcmVzdWx0KGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2Zvcm1zXSBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMgPyB0cmFuc2Zvcm1zLmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAvLyBBZGQgYXJyYXkgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICAgICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICghKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IpKSB7XG4gICAgICAgIEN0b3IgPSBPYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBidWZmZXJDbG9uZShvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgIHZhciBidWZmZXIgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcihpc0RlZXAgPyBidWZmZXJDbG9uZShidWZmZXIpIDogYnVmZmVyLCBvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0Lmxlbmd0aCk7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcihvYmplY3Quc291cmNlLCByZUZsYWdzLmV4ZWMob2JqZWN0KSk7XG4gICAgICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IG9iamVjdC5sYXN0SW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgZWxpZ2libGUgZm9yIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIGVsaWdpYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCaW5kYWJsZShmdW5jKSB7XG4gICAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0LFxuICAgICAgICAgIHJlc3VsdCA9ICEoc3VwcG9ydC5mdW5jTmFtZXMgPyBmdW5jLm5hbWUgOiBzdXBwb3J0LmZ1bmNEZWNvbXApO1xuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICB2YXIgc291cmNlID0gZm5Ub1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICBpZiAoIXN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgcmVzdWx0ID0gIXJlRnVuY05hbWUudGVzdChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYGZ1bmNgIHJlZmVyZW5jZXMgdGhlIGB0aGlzYCBrZXl3b3JkIGFuZCBzdG9yZSB0aGUgcmVzdWx0LlxuICAgICAgICAgIHJlc3VsdCA9IHJlVGhpcy50ZXN0KHNvdXJjZSkgfHwgaXNOYXRpdmUoZnVuYyk7XG4gICAgICAgICAgYmFzZVNldERhdGEoZnVuYywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVyZXEgPSB0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVyZXEgJiYgb2JqZWN0W2luZGV4XSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIEVTIGBUb0xlbmd0aGAuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgKHZhbHVlID09PSAwID8gKCgxIC8gdmFsdWUpID4gMCkgOiAhaXNPYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgcmVxdWlyZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kIGBfLnJlYXJnYFxuICAgICAqIGF1Z21lbnQgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlIGV4ZWN1dGVkIGltcG9ydGFudCxcbiAgICAgKiBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlXG4gICAgICogY29tbW9uIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2s7XG5cbiAgICAgIHZhciBhcml0eUZsYWdzID0gQVJZX0ZMQUcgfCBSRUFSR19GTEFHLFxuICAgICAgICAgIGJpbmRGbGFncyA9IEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgY29tYm9GbGFncyA9IGFyaXR5RmxhZ3MgfCBiaW5kRmxhZ3MgfCBDVVJSWV9CT1VORF9GTEFHIHwgQ1VSUllfUklHSFRfRkxBRztcblxuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIEFSWV9GTEFHICYmICEoc3JjQml0bWFzayAmIEFSWV9GTEFHKSxcbiAgICAgICAgICBpc1JlYXJnID0gYml0bWFzayAmIFJFQVJHX0ZMQUcgJiYgIShzcmNCaXRtYXNrICYgUkVBUkdfRkxBRyksXG4gICAgICAgICAgYXJnUG9zID0gKGlzUmVhcmcgPyBkYXRhIDogc291cmNlKVs3XSxcbiAgICAgICAgICBhcnkgPSAoaXNBcnkgPyBkYXRhIDogc291cmNlKVs4XTtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gIShiaXRtYXNrID49IFJFQVJHX0ZMQUcgJiYgc3JjQml0bWFzayA+IGJpbmRGbGFncykgJiZcbiAgICAgICAgIShiaXRtYXNrID4gYmluZEZsYWdzICYmIHNyY0JpdG1hc2sgPj0gUkVBUkdfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID0gKG5ld0JpdG1hc2sgPj0gYXJpdHlGbGFncyAmJiBuZXdCaXRtYXNrIDw9IGNvbWJvRmxhZ3MpICYmXG4gICAgICAgIChiaXRtYXNrIDwgUkVBUkdfRkxBRyB8fCAoKGlzUmVhcmcgfHwgaXNBcnkpICYmIGFyZ1Bvcy5sZW5ndGggPD0gYXJ5KSk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIEJJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IChiaXRtYXNrICYgQklORF9GTEFHKSA/IDAgOiBDVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBhcnJheUNvcHkoc291cmNlWzRdKTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogYXJyYXlDb3B5KHZhbHVlKTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogYXJyYXlDb3B5KHNvdXJjZVs2XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIEFSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucGlja2AgdGhhdCBwaWNrcyBgb2JqZWN0YCBwcm9wZXJ0aWVzIHNwZWNpZmllZFxuICAgICAqIGJ5IHRoZSBgcHJvcHNgIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5QXJyYXkob2JqZWN0LCBwcm9wcykge1xuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnBpY2tgIHRoYXQgcGlja3MgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYFxuICAgICAqIHJldHVybnMgdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBiYXNlRm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBhcnJheUNvcHkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5IGZ1bmN0aW9uXG4gICAgICogdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhbXAgPSBub3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlU2V0RGF0YShrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3Igb3IgaGFzIGEgYFtbUHJvdG90eXBlXV1gXG4gICAgICogb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvcixcbiAgICAgICAgICBzdXBwb3J0ID0gbG9kYXNoLnN1cHBvcnQ7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIG5vbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgICAgaWYgKCEoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RUYWcpIHx8XG4gICAgICAgICAgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY29uc3RydWN0b3InKSAmJlxuICAgICAgICAgICAgKEN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhKEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIElFIDwgOSBpdGVyYXRlcyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgb3duIHByb3BlcnRpZXMuIElmIHRoZSBmaXJzdFxuICAgICAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAgICAgLy8gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgYmFzZUZvckluKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGgsXG4gICAgICAgICAgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0O1xuXG4gICAgICB2YXIgYWxsb3dJbmRleGVzID0gbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCAoc3VwcG9ydC5ub25FbnVtQXJncyAmJiBpc0FyZ3VtZW50cyhvYmplY3QpKSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS1saWtlIG9iamVjdCBpZiBpdCBpcyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMZW5ndGgodmFsdWUubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBvYmplY3QgaWYgaXQgaXMgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IE9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgY29sbGVjdGlvbmAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgY29udGFpbmluZyBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCgrc2l6ZSB8fCAxLCAxKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkoY2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIGBTYW1lVmFsdWVaZXJvYCBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsXG4gICAgICogZS5nLiBgPT09YCwgZXhjZXB0IHRoYXQgYE5hTmAgbWF0Y2hlcyBgTmFOYC4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMSwgMiwgM10sIFs1LCAyLCAxMF0pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpZmZlcmVuY2UoKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZSh2YWx1ZSwgYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSwgKytpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgbiA9IGxlbmd0aCAtICgrbiB8fCAwKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ3N0YXR1cyc6ICdidXN5JywgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnc3RhdHVzJzogJ2J1c3knLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ3N0YXR1cyc6ICdhd2F5JywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5tYXRjaGVzXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICdzdGF0dXMnOiAnYXdheScgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcHJlZGljYXRlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpKSB7fVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbGVuZ3RoICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikgeyByZXR1cm4gbiA8IDM7IH0pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ3N0YXR1cyc6ICdidXN5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdzdGF0dXMnOiAnYnVzeScsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ3N0YXR1cyc6ICdhd2F5JywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ubWF0Y2hlc1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3N0YXR1cyc6ICdidXN5JyB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLnByb3BlcnR5XCJcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5tYXRjaGVzXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLnByb3BlcnR5XCJcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ubWF0Y2hlc1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGhlYWRcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheS4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIHRoZSBhcnJheSBpcyByZWN1cnNpdmVseVxuICAgICAqIGZsYXR0ZW5lZCwgb3RoZXJ3aXNlIGl0IGlzIG9ubHkgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgW1s0XV1dO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGlzRGVlcGBcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc0RlZXAsIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc0RlZXAsIGd1YXJkKSkge1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlY3Vyc2l2ZWx5IGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMl0sIFszLCBbWzRdXV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF07XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIHRydWUpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgYFNhbWVWYWx1ZVplcm9gIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsXG4gICAgICogaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIHNvcnRlZFxuICAgICAqIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgIHBlcmZvcm1zIGEgZmFzdGVyIGJpbmFyeSBzZWFyY2guXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogYFNhbWVWYWx1ZVplcm9gIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucyxcbiAgICAgKiBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdCBgTmFOYCBtYXRjaGVzIGBOYU5gLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogLy8gcGVyZm9ybWluZyBhIGJpbmFyeSBzZWFyY2hcbiAgICAgKiBfLmluZGV4T2YoWzQsIDQsIDUsIDUsIDYsIDZdLCA1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IChmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUpLFxuICAgICAgICAgICAgb3RoZXIgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA9PT0gb3RoZXIgOiBvdGhlciAhPT0gb3RoZXIpID8gaW5kZXggOiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHJldHVybiBkcm9wUmlnaHQoYXJyYXksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBpbiBhbGwgcHJvdmlkZWQgYXJyYXlzIHVzaW5nIGBTYW1lVmFsdWVaZXJvYFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBgU2FtZVZhbHVlWmVyb2AgY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLFxuICAgICAqIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0IGBOYU5gIG1hdGNoZXMgYE5hTmAuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IFtdLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBjYWNoZXMucHVzaChpc0NvbW1vbiAmJiB2YWx1ZS5sZW5ndGggPj0gMTIwICYmIGNyZWF0ZUNhY2hlKGFyZ3NJbmRleCAmJiB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJyYXkgPSBhcmdzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICgoc2VlbiA/IGNhY2hlSW5kZXhPZihzZWVuLCB2YWx1ZSkgOiBpbmRleE9mKHJlc3VsdCwgdmFsdWUpKSA8IDApIHtcbiAgICAgICAgICBhcmdzSW5kZXggPSBhcmdzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLWFyZ3NJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW2FyZ3NJbmRleF07XG4gICAgICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKGFyZ3NbYXJnc0luZGV4XSwgdmFsdWUpKSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb21cbiAgICAgKiAgb3IgYHRydWVgIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgZnJvbUluZGV4YFxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBwZXJmb3JtaW5nIGEgYmluYXJ5IHNlYXJjaFxuICAgICAqIF8ubGFzdEluZGV4T2YoWzQsIDQsIDUsIDUsIDYsIDZdLCA1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCkgOiBuYXRpdmVNaW4oZnJvbUluZGV4IHx8IDAsIGxlbmd0aCAtIDEpKSArIDE7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICBpbmRleCA9IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgICAgIHJldHVybiAodmFsdWUgPT09IHZhbHVlID8gdmFsdWUgPT09IG90aGVyIDogb3RoZXIgIT09IG90aGVyKSA/IGluZGV4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleE9mTmFOKGFycmF5LCBpbmRleCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHByb3ZpZGVkIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmcgYFNhbWVWYWx1ZVplcm9gIGZvciBlcXVhbGl0eVxuICAgICAqIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlczoqKlxuICAgICAqICAtIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqICAtIGBTYW1lVmFsdWVaZXJvYCBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsXG4gICAgICogICAgZXhjZXB0IHRoYXQgYE5hTmAgbWF0Y2hlcyBgTmFOYC4gU2VlIHRoZSBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogICAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDEsIDIsIDNdO1xuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpKSA+IC0xKSB7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmRleGVzIGFuZCByZXR1cm5zXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIEluZGV4ZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZlxuICAgICAqIGluZGV4ZXMgb3IgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLFxuICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFs1LCAxMCwgMTUsIDIwXTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnB1bGxBdChhcnJheSwgWzEsIDNdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbNSwgMTVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzEwLCAyMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQXQoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlUHVsbEF0KGFycmF5IHx8IFtdLCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikgeyByZXR1cm4gbiAlIDIgPT0gMDsgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdGFpbFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoYXJyYXkpIHtcbiAgICAgIHJldHVybiBkcm9wKGFycmF5LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiBgQXJyYXkjc2xpY2VgIHRvIHN1cHBvcnQgbm9kZVxuICAgICAqIGxpc3RzIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZFxuICAgICAqIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci4gSWYgYW4gaXRlcmF0ZWVcbiAgICAgKiBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFs0LCA0LCA1LCA1LCA2LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGRpY3QgPSB7ICdkYXRhJzogeyAndGhpcnR5JzogMzAsICdmb3J0eSc6IDQwLCAnZmlmdHknOiA1MCB9IH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhbiBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0aGlydHknLCAnZmlmdHknXSwgJ2ZvcnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZGF0YVt3b3JkXTtcbiAgICAgKiB9LCBkaWN0KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUpO1xuICAgICAgcmV0dXJuIChmdW5jID09PSBiYXNlQ2FsbGJhY2sgJiYgaXRlcmF0ZWUgPT0gbnVsbClcbiAgICAgICAgPyBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUpXG4gICAgICAgIDogYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGZ1bmMoaXRlcmF0ZWUsIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wcm9wZXJ0eVwiIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDQsIDUsIDUsIDYsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUpO1xuICAgICAgcmV0dXJuIChmdW5jID09PSBiYXNlQ2FsbGJhY2sgJiYgaXRlcmF0ZWUgPT0gbnVsbClcbiAgICAgICAgPyBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUsIHRydWUpXG4gICAgICAgIDogYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGZ1bmMoaXRlcmF0ZWUsIHRoaXNBcmcsIDEpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgbiA9IGxlbmd0aCAtICgrbiB8fCAwKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ3N0YXR1cyc6ICdidXN5JywgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnc3RhdHVzJzogJ2J1c3knLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ3N0YXR1cyc6ICdhd2F5JywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5tYXRjaGVzXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICdzdGF0dXMnOiAnYXdheScgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiBwcmVkaWNhdGUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkpIHt9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBsZW5ndGggKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLnByb3BlcnR5XCJcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7IHJldHVybiBuIDwgMzsgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnc3RhdHVzJzogJ2J1c3knLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ3N0YXR1cyc6ICdidXN5JywgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnc3RhdHVzJzogJ2F3YXknLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ucHJvcGVydHlcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5tYXRjaGVzXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgeyAnc3RhdHVzJzogJ2J1c3knIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogYFNhbWVWYWx1ZVplcm9gIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBgU2FtZVZhbHVlWmVyb2AgY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLFxuICAgICAqIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0IGBOYU5gIG1hdGNoZXMgYE5hTmAuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDUsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pb24oKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIGBTYW1lVmFsdWVaZXJvYFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gUHJvdmlkaW5nIGB0cnVlYCBmb3IgYGlzU29ydGVkYCBwZXJmb3JtcyBhIGZhc3RlclxuICAgICAqIHNlYXJjaCBhbGdvcml0aG0gZm9yIHNvcnRlZCBhcnJheXMuIElmIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0XG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIGBTYW1lVmFsdWVaZXJvYCBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsXG4gICAgICogZS5nLiBgPT09YCwgZXhjZXB0IHRoYXQgYE5hTmAgbWF0Y2hlcyBgTmFOYC4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkXSBTcGVjaWZ5IHRoZSBhcnJheSBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIlxuICAgICAqICBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBgaXNTb3J0ZWRgXG4gICAgICogXy51bmlxKFsxLCAxLCAyXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhbiBpdGVyYXRlZSBmdW5jdGlvblxuICAgICAqIF8udW5pcShbMSwgMi41LCAxLjUsIDJdLCBmdW5jdGlvbihuKSB7IHJldHVybiB0aGlzLmZsb29yKG4pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8udW5pcShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgLy8gSnVnZ2xlIGFyZ3VtZW50cy5cbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nICYmIGlzU29ydGVkICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBpc1NvcnRlZCwgdGhpc0FyZykgPyBudWxsIDogaXNTb3J0ZWQ7XG4gICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGdldENhbGxiYWNrKCk7XG4gICAgICBpZiAoIShmdW5jID09PSBiYXNlQ2FsbGJhY2sgJiYgaXRlcmF0ZWUgPT0gbnVsbCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSBmdW5jKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaXNTb3J0ZWQgJiYgZ2V0SW5kZXhPZigpID09IGJhc2VJbmRleE9mKVxuICAgICAgICA/IHNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKVxuICAgICAgICA6IGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS1gXy56aXBgXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIGFycmF5TWF4KGFycmF5TWFwKGFycmF5LCBnZXRMZW5ndGgpKSkgPj4+IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yXG4gICAgICogZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogYFNhbWVWYWx1ZVplcm9gIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucyxcbiAgICAgKiBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdCBgTmFOYCBtYXRjaGVzIGBOYU5gLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlU2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqIFNlZSBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSkgZm9yXG4gICAgICogbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0pO1xuICAgICAqIC8vID0+IFszLCA1LCA0XVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDVdLCBbMiwgMywgNV0sIFszLCA0LCA1XSk7XG4gICAgICogLy8gPT4gWzEsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24geG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgID8gYmFzZURpZmZlcmVuY2UocmVzdWx0LCBhcnJheSkuY29uY2F0KGJhc2VEaWZmZXJlbmNlKGFycmF5LCByZXN1bHQpKVxuICAgICAgICAgICAgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCA/IGJhc2VVbmlxKHJlc3VsdCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWNvbmQgZWxlbWVudHNcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bnppcChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy4gUHJvdmlkZVxuICAgICAqIGVpdGhlciBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYFxuICAgICAqIG9yIHR3byBhcnJheXMsIG9uZSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMgPyBwcm9wcy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBpZiAobGVuZ3RoICYmICF2YWx1ZXMgJiYgIWlzQXJyYXkocHJvcHNbMF0pKSB7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluaW5nIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF8uY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci51c2VyICsgJyBpcyAnICsgY2hyLmFnZTsgfSlcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnNcbiAgICAgKiBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHsgYXJyYXkucG9wKCk7IH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvciwgdGhpc0FyZykge1xuICAgICAgaW50ZXJjZXB0b3IuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLmxhc3QoKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gW3ZhbHVlXTsgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvci5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGV4cGxpY2l0IG1ldGhvZCBjaGFpbmluZyBvbiB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBsb2Rhc2hgIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8odXNlcnMpLmZpcnN0KCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gd2l0aCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8odXNlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgd3JhcHBlZCBhcnJheSBzbyB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYGxvZGFzaGAgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZS5yZXZlcnNlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmV2ZXJzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgdGhlIHJlc3VsdCBvZiBjb2VyY2luZyB0aGUgdW53cmFwcGVkIHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvZXJjZWQgc3RyaW5nIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudG9TdHJpbmcoKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKCkgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluZWQgc2VxdWVuY2UgdG8gZXh0cmFjdCB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleXMsIG9yIGluZGV4ZXMsXG4gICAgICogb2YgYGNvbGxlY3Rpb25gLiBLZXlzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2Yga2V5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW118c3RyaW5nfHN0cmluZ1tdKX0gW3Byb3BzXSBUaGUgcHJvcGVydHkgbmFtZXNcbiAgICAgKiAgb3IgaW5kZXhlcyBvZiBlbGVtZW50cyB0byBwaWNrLCBzcGVjaWZpZWQgaW5kaXZpZHVhbGx5IG9yIGluIGFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwaWNrZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgWzAsIDIsIDRdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYycsICdlJ11cbiAgICAgKlxuICAgICAqIF8uYXQoWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ10sIDAsIDIpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdChjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIGlmIChpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VBdChjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYCB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5XG4gICAgICogY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZSBvZmZzZXQgZnJvbVxuICAgICAqIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIGBTYW1lVmFsdWVaZXJvYCBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsXG4gICAgICogZS5nLiBgPT09YCwgZXhjZXB0IHRoYXQgYE5hTmAgbWF0Y2hlcyBgTmFOYC4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbnRhaW5zLCBpbmNsdWRlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBtYXRjaGluZyBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygncGViYmxlcycsICdlYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCkgOiAoZnJvbUluZGV4IHx8IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbUluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAodHlwZW9mIGNvbGxlY3Rpb24gPT0gJ3N0cmluZycgfHwgIWlzQXJyYXkoY29sbGVjdGlvbikgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgID8gKGZyb21JbmRleCA8IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKGdldEluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikgeyByZXR1cm4gTWF0aC5mbG9vcihuKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7IHJldHVybiB0aGlzLmZsb29yKG4pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gKytyZXN1bHRba2V5XSA6IChyZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFsbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wcm9wZXJ0eVwiIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ubWF0Y2hlc1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdGhpc0FyZyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBzZWxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikgeyByZXR1cm4gbiAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLm1hdGNoZXNcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkZXRlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2UgPCA0MDsgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ubWF0Y2hlc1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgeyAnYWdlJzogMSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ucHJvcGVydHlcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZyk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gY29sbGVjdGlvbltpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGJhc2VGaW5kKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gJSAyID09IDE7IH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGhhcyBlcXVpdmFsZW50IHByb3BlcnR5XG4gICAgICogdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdzdGF0dXMnOiAnYnVzeScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnc3RhdHVzJzogJ2J1c3knIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kV2hlcmUodXNlcnMsIHsgJ3N0YXR1cyc6ICdidXN5JyB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQoXy5maW5kV2hlcmUodXNlcnMsIHsgJ2FnZSc6IDQwIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRXaGVyZShjb2xsZWN0aW9uLCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmaW5kKGNvbGxlY3Rpb24sIGJhc2VNYXRjaGVzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBJdGVyYXRvciBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gICAgICogYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBgbGVuZ3RoYCBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7IGNvbnNvbGUubG9nKG4pOyB9KS52YWx1ZSgpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIGxlZnQgdG8gcmlnaHQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obiwga2V5KSB7IGNvbnNvbGUubG9nKG4sIGtleSk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZS1rZXkgcGFpciBhbmQgcmV0dXJucyB0aGUgb2JqZWN0IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKVxuICAgICAgICA/IGFycmF5RWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSlcbiAgICAgICAgOiBiYXNlRWFjaChjb2xsZWN0aW9uLCBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obikgeyBjb25zb2xlLmxvZyhuKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICAgID8gYXJyYXlFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpXG4gICAgICAgIDogYmFzZUVhY2hSaWdodChjb2xsZWN0aW9uLCBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obikgeyByZXR1cm4gTWF0aC5mbG9vcihuKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obikgeyByZXR1cm4gdGhpcy5mbG9vcihuKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgZnVuY3Rpb24gaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLnByb3BlcnR5XCJcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wcm9wZXJ0eVwiIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBrZXlEYXRhID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2JqZWN0LmNvZGUpOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5RGF0YSwgZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiB0aGlzLmZyb21DaGFyQ29kZShvYmplY3QuY29kZSk7IH0sIFN0cmluZyk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgbmFtZWQgYnkgYG1ldGhvZE5hbWVgIG9uIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsXG4gICAgICogcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsXG4gICAgICogYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgbWV0aG9kTmFtZWAgaXMgYSBmdW5jdGlvblxuICAgICAqIGl0IGlzIGludm9rZWQgZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2UoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZShjb2xsZWN0aW9uLCBtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gYmFzZUludm9rZShjb2xsZWN0aW9uLCBtZXRob2ROYW1lLCBiYXNlU2xpY2UoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocm91Z2hcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiAgSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiAtSW5maW5pdHlcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICovXG4gICAgdmFyIG1heCA9IGNyZWF0ZUV4dHJlbXVtKGFycmF5TWF4KTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgZW1wdHkgb3IgZmFsc2V5XG4gICAgICogYEluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiAgSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4odXNlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ucHJvcGVydHlcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbih1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICovXG4gICAgdmFyIG1pbiA9IGNyZWF0ZUV4dHJlbXVtKGFycmF5TWluLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHdoaWxlIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLnByb3BlcnR5XCJcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbihbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gJSAyOyB9KTtcbiAgICAgKiAvLyA9PiBbWzEsIDNdLCBbMl1dXG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbihbMS4yLCAyLjMsIDMuNF0sIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIHRoaXMuZmxvb3IobikgJSAyOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbWzEsIDNdLCBbMl1dXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLm1hdGNoZXNcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSB9KSwgZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIF8ucGx1Y2soYXJyYXksICd1c2VyJyk7IH0pO1xuICAgICAqIC8vID0+IFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyksIGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBfLnBsdWNrKGFycmF5LCAndXNlcicpOyB9KTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBga2V5YCBmcm9tIGFsbCBlbGVtZW50cyBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIHZhciB1c2VySW5kZXggPSBfLmluZGV4QnkodXNlcnMsICd1c2VyJyk7XG4gICAgICogXy5wbHVjayh1c2VySW5kZXgsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiBbMzYsIDQwXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIGtleSkge1xuICAgICAgcmV0dXJuIG1hcChjb2xsZWN0aW9uLCBiYXNlUHJvcGVydHkoa2V5ICsgJycpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhyb3VnaCBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IHByb3ZpZGVkIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzdW0gPSBfLnJlZHVjZShbMSwgMiwgM10sIGZ1bmN0aW9uKHN1bSwgbikgeyByZXR1cm4gc3VtICsgbjsgfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG4sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBuICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpLCBhY2N1bXVsYXRvciwgYXJndW1lbnRzLmxlbmd0aCA8IDMsIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHsgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpOyB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KSwgYWNjdW11bGF0b3IsIGFyZ3VtZW50cy5sZW5ndGggPCAzLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2RkcyA9IF8ucmVqZWN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikgeyByZXR1cm4gbiAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ubWF0Y2hlc1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDM2IH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGggPiAwID8gY29sbGVjdGlvbltiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzaHVmZmxlKGNvbGxlY3Rpb24pO1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuIDwgMCA/IDAgOiAoK24gfHwgMCksIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXNcbiAgICAgKiBzaHVmZmxlLiBTZWUgW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCBpbmRleCk7XG4gICAgICAgIGlmIChpbmRleCAhPSByYW5kKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmFuZF0gPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGBjb2xsZWN0aW9uLmxlbmd0aGAgZm9yXG4gICAgICogYXJyYXktbGlrZSB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzTGVuZ3RoKGxlbmd0aCkgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kIGRvZXMgbm90IGl0ZXJhdGVcbiAgICAgKiBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXMgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ubWF0Y2hlc1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29tZSh1c2VycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicgfHwgdHlwZW9mIHRoaXNBcmcgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoaXMgbWV0aG9kIHBlcmZvcm1zXG4gICAgICogYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mIGVxdWFsIGVsZW1lbnRzLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5wcm9wZXJ0eVwiXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvblxuICAgICAqICBpbnZva2VkIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBhbiBvYmplY3QgaXMgcHJvdmlkZWQgaXQgaXNcbiAgICAgKiAgdXNlZCB0byBjcmVhdGUgYSBcIl8ucHJvcGVydHlcIiBvciBcIl8ubWF0Y2hlc1wiIHN0eWxlIGNhbGxiYWNrIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikgeyByZXR1cm4gTWF0aC5zaW4obik7IH0pO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7IHJldHVybiB0aGlzLnNpbihuKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnNvcnRCeSh1c2VycywgJ3VzZXInKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBpc0xlbmd0aChsZW5ndGgpID8gQXJyYXkobGVuZ3RoKSA6IFtdO1xuXG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHsgJ2NyaXRlcmlhJzogaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksICdpbmRleCc6IGluZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGNvbXBhcmVBc2NlbmRpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBzb3J0cyBieSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqIGluc3RlYWQgb2YgYW4gaXRlcmF0ZWUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHNvcnQgYnksXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5IG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMjYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0QnlBbGwodXNlcnMsIFsndXNlcicsICdhZ2UnXSksIF8udmFsdWVzKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAyNl0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnlBbGwoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAzICYmIGlzSXRlcmF0ZWVDYWxsKGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pKSB7XG4gICAgICAgIGFyZ3MgPSBbY29sbGVjdGlvbiwgYXJnc1sxXV07XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHByb3BzID0gYmFzZUZsYXR0ZW4oYXJncywgZmFsc2UsIGZhbHNlLCAxKSxcbiAgICAgICAgICByZXN1bHQgPSBpc0xlbmd0aChsZW5ndGgpID8gQXJyYXkobGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgICBjcml0ZXJpYSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgY3JpdGVyaWFbbGVuZ3RoXSA9IHZhbHVlID09IG51bGwgPyB1bmRlZmluZWQgOiB2YWx1ZVtwcm9wc1tsZW5ndGhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbKytpbmRleF0gPSB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiBpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBjb21wYXJlTXVsdGlwbGVBc2NlbmRpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCBhbmQgdGhlXG4gICAgICogc291cmNlIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3N0YXR1cyc6ICdidXN5JywgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnc3RhdHVzJzogJ2J1c3knLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAnYWdlJzogMzYgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogXy5wbHVjayhfLndoZXJlKHVzZXJzLCB7ICdwZXRzJzogWydkaW5vJ10gfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydmcmVkJ11cbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAnc3RhdHVzJzogJ2J1c3knIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7IGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7IH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gbmF0aXZlTm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0IGlzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24obikpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IG47XG4gICAgICAgICAgbiA9IGZ1bmM7XG4gICAgICAgICAgZnVuYyA9IHRlbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuID0gbmF0aXZlSXNGaW5pdGUobiA9ICtuKSA/IG4gOiAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBgbmAgYXJndW1lbnRzIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChmdW5jLCBuLCBndWFyZCkpIHtcbiAgICAgICAgbiA9IG51bGw7XG4gICAgICB9XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbmF0aXZlTWF4KCtuIHx8IDAsIDApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgQVJZX0ZMQUcsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0IGlzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoJyNhZGQnKS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gYWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24obikpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IG47XG4gICAgICAgICAgbiA9IGZ1bmM7XG4gICAgICAgICAgZnVuYyA9IHRlbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgXy5iaW5kYCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAgdGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBgbGVuZ3RoYFxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gQklORF9GTEFHO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGJhc2VTbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBiaW5kLnBsYWNlaG9sZGVyKTtcblxuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLiBNZXRob2QgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBtZXRob2QgbmFtZXMuIElmIG5vIG1ldGhvZCBuYW1lcyBhcmUgcHJvdmlkZWQgYWxsIGVudW1lcmFibGUgZnVuY3Rpb25cbiAgICAgKiBwcm9wZXJ0aWVzLCBvd24gYW5kIGluaGVyaXRlZCwgb2YgYG9iamVjdGAgYXJlIGJvdW5kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbbWV0aG9kTmFtZXNdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpOyB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3KTtcbiAgICAgKiBqUXVlcnkoJyNkb2NzJykub24oJ2NsaWNrJywgdmlldy5vbkNsaWNrKTtcbiAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gdGhlIGVsZW1lbnQgaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRBbGwob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUJpbmRBbGwob2JqZWN0LFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgICAgID8gYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpXG4gICAgICAgICAgOiBmdW5jdGlvbnMob2JqZWN0KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCBhbmQgcHJlcGVuZHNcbiAgICAgKiBhbnkgYWRkaXRpb25hbCBgXy5iaW5kS2V5YCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL21pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEtleShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGJhc2VTbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBiaW5kS2V5LnBsYWNlaG9sZGVyKTtcblxuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBhcmd1bWVudHMgb2YgYGZ1bmNgIHRoYXQgd2hlblxuICAgICAqIGNhbGxlZCBlaXRoZXIgaW52b2tlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgYXJpdHksIGd1YXJkKSkge1xuICAgICAgICBhcml0eSA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcHBlcihmdW5jLCBDVVJSWV9GTEFHLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIGFyaXR5LCBndWFyZCkpIHtcbiAgICAgICAgYXJpdHkgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXBwZXIoZnVuYywgQ1VSUllfUklHSFRfRkxBRywgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzXG4gICAgICogaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGludm9rZWQuIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGNvbWVzXG4gICAgICogd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBpbnZvY2F0aW9ucy4gUHJvdmlkZSBhbiBvcHRpb25zXG4gICAgICogb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vclxuICAgICAqIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBkZWJvdW5jZWRcbiAgICAgKiBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cDovL2RydXBhbG1vdGlvbi5jb20vYXJ0aWNsZS9kZWJvdW5jZS1hbmQtdGhyb3R0bGUtdmlzdWFsLWV4cGxhbmF0aW9uKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZVxuICAgICAqICBkZWxheWVkIGJlZm9yZSBpdCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gY2FuY2VsIGEgZGVib3VuY2VkIGNhbGxcbiAgICAgKiB2YXIgdG9kb0NoYW5nZXMgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAxMDAwKTtcbiAgICAgKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMudG9kbywgdG9kb0NoYW5nZXMpO1xuICAgICAqXG4gICAgICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLCBmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICogICBpZiAoXy5maW5kKGNoYW5nZXMsIHsgJ3VzZXInOiAndG9kbycsICd0eXBlJzogJ2RlbGV0ZSd9KSkge1xuICAgICAqICAgICB0b2RvQ2hhbmdlcy5jYW5jZWwoKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9LCBbJ2RlbGV0ZSddKTtcbiAgICAgKlxuICAgICAqIC8vIC4uLmF0IHNvbWUgcG9pbnQgYG1vZGVscy50b2RvYCBpcyBjaGFuZ2VkXG4gICAgICogbW9kZWxzLnRvZG8uY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgKlxuICAgICAqIC8vIC4uLmJlZm9yZSAxIHNlY29uZCBoYXMgcGFzc2VkIGBtb2RlbHMudG9kb2AgaXMgZGVsZXRlZFxuICAgICAqIC8vIHdoaWNoIGNhbmNlbHMgdGhlIGRlYm91bmNlZCBgdG9kb0NoYW5nZXNgIGNhbGxcbiAgICAgKiBkZWxldGUgbW9kZWxzLnRvZG87XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgbWF4VGltZW91dElkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB3YWl0IDwgMCA/IDAgOiB3YWl0O1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgbmF0aXZlTWF4KCtvcHRpb25zLm1heFdhaXQgfHwgMCwgd2FpdCk7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWxheWVkKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1heERlbGF5ZWQoKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IG1heFdhaXQ7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gbG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmVyKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJndW1lbnRzLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gbG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWxheShmdW5jLCB3YWl0KSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3VtZW50cywgMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBwcm92aWRlZFxuICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gYWRkKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coYWRkLCBzcXVhcmUpO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxvdygpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFhcnJheUV2ZXJ5KGZ1bmNzLCBpc0Z1bmN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYmFja2Zsb3csIGNvbXBvc2VcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBbZnVuY3NdIEZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGFkZCh4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoc3F1YXJlLCBhZGQpO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxvd1JpZ2h0KCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGZyb21JbmRleCA9IGZ1bmNzLmxlbmd0aCAtIDE7XG5cbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgfVxuICAgICAgaWYgKCFhcnJheUV2ZXJ5KGZ1bmNzLCBpc0Z1bmN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nIGFuZCB1c2VkIGFzIHRoZVxuICAgICAqIGNhY2hlIGtleS4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlIEVTIGBNYXBgIG1ldGhvZCBpbnRlcmZhY2VcbiAgICAgKiBvZiBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXBwZXJDYXNlID0gXy5tZW1vaXplKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy50b1VwcGVyQ2FzZSgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdXBwZXJDYXNlKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICpcbiAgICAgKiAvLyBtb2RpZnlpbmcgdGhlIHJlc3VsdCBjYWNoZVxuICAgICAqIHVwcGVyQ2FzZS5jYWNoZS5zZXQoJ2ZyZWQnLCAnQkFSTkVZJyk7XG4gICAgICogdXBwZXJDYXNlKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0JBUk5FWSdcbiAgICAgKlxuICAgICAqIC8vIHJlcGxhY2luZyBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdiYXJuZXknIH07XG4gICAgICogdmFyIGlkZW50aXR5ID0gXy5tZW1vaXplKF8uaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogaWRlbnRpdHkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBpZGVudGl0eShvdGhlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqIHZhciBpZGVudGl0eSA9IF8ubWVtb2l6ZShfLmlkZW50aXR5KTtcbiAgICAgKlxuICAgICAqIGlkZW50aXR5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogaWRlbnRpdHkob3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpIHx8IChyZXNvbHZlciAmJiAhaXNGdW5jdGlvbihyZXNvbHZlcikpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBtZW1vaXplZC5jYWNoZSxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyBtZW1vaXplLkNhY2hlO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBpbnZva2VzIGBjcmVhdGVBcHBsaWNhdGlvbmAgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZShmdW5jLCAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsYCBhcmd1bWVudHMgcHJlcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHRcbiAgICAgKiBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgICB2YXIgcGFydGlhbHMgPSBiYXNlU2xpY2UoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIHBhcnRpYWwucGxhY2Vob2xkZXIpO1xuXG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBQQVJUSUFMX0ZMQUcsIG51bGwsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbFJpZ2h0KGZ1bmMpIHtcbiAgICAgIHZhciBwYXJ0aWFscyA9IGJhc2VTbGljZShhcmd1bWVudHMsIDEpLFxuICAgICAgICAgIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgcGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyKTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgUEFSVElBTF9SSUdIVF9GTEFHLCBudWxsLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcyxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgMiwgMCwgMSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiB2YXIgbWFwID0gXy5yZWFyZyhfLm1hcCwgWzEsIDBdKTtcbiAgICAgKiBtYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIDM7IH0sIFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhcmcoZnVuYykge1xuICAgICAgdmFyIGluZGV4ZXMgPSBiYXNlRmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBSRUFSR19GTEFHLCBudWxsLCBudWxsLCBudWxsLCBpbmRleGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzLiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgaW52b2NhdGlvbnMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICogU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0XG4gICAgICogYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHA6Ly9kcnVwYWxtb3Rpb24uY29tL2FydGljbGUvZGVib3VuY2UtYW5kLXRocm90dGxlLXZpc3VhbC1leHBsYW5hdGlvbilcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gY2FuY2VsIGEgdHJhaWxpbmcgdGhyb3R0bGVkIGNhbGxcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgZGVib3VuY2VPcHRpb25zLm1heFdhaXQgPSArd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGRlYm91bmNlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgd3JhcHBlciA9IHdyYXBwZXIgPT0gbnVsbCA/IGlkZW50aXR5IDogd3JhcHBlcjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIFBBUlRJQUxfRkxBRywgbnVsbCwgW3ZhbHVlXSwgW10pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgYXJlIGNsb25lZCxcbiAgICAgKiBvdGhlcndpc2UgdGhleSBhcmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudDsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uXG4gICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gICAgICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuIFNlZSB0aGUgW0hUTUw1IHNwZWNpZmljYXRpb25dKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobSlcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKHVzZXJzKTtcbiAgICAgKiBzaGFsbG93WzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUodXNlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgYm9keSA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogYm9keSA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogYm9keS5ub2RlTmFtZVxuICAgICAqIC8vID0+IEJPRFlcbiAgICAgKiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICAvLyBKdWdnbGUgYXJndW1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiBpc0RlZXAgIT0gJ2Jvb2xlYW4nICYmIGlzRGVlcCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXNBcmcgPSBjdXN0b21pemVyO1xuICAgICAgICBjdXN0b21pemVyID0gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGlzRGVlcCwgdGhpc0FyZykgPyBudWxsIDogaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nICYmIGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAxKTtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWRcbiAgICAgKiB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjbG9uaW5nXG4gICAgICogaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnQ7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdF0pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIHN0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtLlxuICAgICAqIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmQgb2JqZWN0cyBjcmVhdGVkIGJ5XG4gICAgICogY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLiBBblxuICAgICAqIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2ggYXMgZnVuY3Rpb25zLCBET00gbm9kZXMsXG4gICAgICogTWFwcywgU2V0cywgYW5kIFdlYWtNYXBzLiBTZWUgdGhlIFtIVE1MNSBzcGVjaWZpY2F0aW9uXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcCh1c2Vycyk7XG4gICAgICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKHRydWUpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogYm9keSA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogYm9keS5ub2RlTmFtZVxuICAgICAqIC8vID0+IEJPRFlcbiAgICAgKiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyAmJiBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSk7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpOyB9KSgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gaXNPYmplY3RMaWtlKHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoaXNMZW5ndGgobGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWcpIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbFRhZykgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVUYWcpIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkuaW5kZXhPZignRWxlbWVudCcpID4gLTEpIHx8IGZhbHNlO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayBmb3IgZW52aXJvbm1lbnRzIHdpdGhvdXQgRE9NIHN1cHBvcnQuXG4gICAgaWYgKCFzdXBwb3J0LmRvbSkge1xuICAgICAgaXNFbGVtZW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSkgfHwgZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGVtcHR5LiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgZW1wdHkgdW5sZXNzIGl0IGlzIGFuXG4gICAgICogYGFyZ3VtZW50c2Agb2JqZWN0LCBhcnJheSwgc3RyaW5nLCBvciBqUXVlcnktbGlrZSBjb2xsZWN0aW9uIHdpdGggYSBsZW5ndGhcbiAgICAgKiBncmVhdGVyIHRoYW4gYDBgIG9yIGFuIG9iamVjdCB3aXRoIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmIChpc0xlbmd0aChsZW5ndGgpICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc1N0cmluZyh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gIWtleXModmFsdWUpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZFxuICAgICAqIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgb3RoZXIgWywgaW5kZXh8a2V5XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBGdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuICAgICAqIGFyZSAqKm5vdCoqIHN1cHBvcnRlZC4gUHJvdmlkZSBhIGN1c3RvbWl6ZXIgZnVuY3Rpb24gdG8gZXh0ZW5kIHN1cHBvcnRcbiAgICAgKiBmb3IgY29tcGFyaW5nIG90aGVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKGFycmF5LCBvdGhlciwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gXy5ldmVyeShbdmFsdWUsIG90aGVyXSwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCAvXmgoPzppfGVsbG8pJC8pIHx8IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nICYmIGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICghY3VzdG9taXplciAmJiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc09iamVjdExpa2UodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGVycm9yVGFnKSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIEVTIGBOdW1iZXIuaXNGaW5pdGVgLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIuaXNmaW5pdGUpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMTApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoT2JqZWN0KDEwKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRmluaXRlID0gbmF0aXZlTnVtSXNGaW5pdGUgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgLy8gQXZvaWQgYSBDaGFrcmEgSklUIGJ1ZyBpbiBjb21wYXRpYmlsaXR5IG1vZGVzIG9mIElFIDExLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9pc3N1ZXMvMTYyMSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayBmb3IgZW52aXJvbm1lbnRzIHRoYXQgcmV0dXJuIGluY29ycmVjdCBgdHlwZW9mYCBvcGVyYXRvciByZXN1bHRzLlxuICAgIGlmIChpc0Z1bmN0aW9uKC94LykgfHwgKFVpbnQ4QXJyYXkgJiYgIWlzRnVuY3Rpb24oVWludDhBcnJheSkpKSB7XG4gICAgICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gICAgICAgIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIGBPYmplY3RgLlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogKipOb3RlOioqIFNlZSB0aGUgW0VTNSBzcGVjXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdHlwZSA9PSAnZnVuY3Rpb24nIHx8ICh2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0byBkZXRlcm1pbmUgaWZcbiAgICAgKiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkXG4gICAgICogaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgb3RoZXIsIGluZGV4fGtleSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIHByb3BlcnRpZXMgb2YgYXJyYXlzLCBib29sZWFucyxcbiAgICAgKiBgRGF0ZWAgb2JqZWN0cywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmRcbiAgICAgKiBzdXBwb3J0IGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gXy5ldmVyeShbdmFsdWUsIG90aGVyXSwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCAvXmgoPzppfGVsbG8pJC8pIHx8IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgJiYgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKCFjdXN0b21pemVyICYmIGxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1swXSxcbiAgICAgICAgICAgIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgPT09IG9iamVjdFtrZXldICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBzdHJpY3RDb21wYXJlRmxhZ3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZXNbbGVuZ3RoXSA9IHNvdXJjZVtwcm9wc1tsZW5ndGhdXTtcbiAgICAgICAgc3RyaWN0Q29tcGFyZUZsYWdzW2xlbmd0aF0gPSBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgcHJvcHMsIHZhbHVlcywgc3RyaWN0Q29tcGFyZUZsYWdzLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc05hTmAgd2hpY2ggcmV0dXJucyBgdHJ1ZWBcbiAgICAgKiBmb3IgYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1lcmljIHZhbHVlcy4gU2VlIHRoZSBbRVM1IHNwZWNdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40KVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZykge1xuICAgICAgICByZXR1cm4gcmVOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUhvc3RDdG9yLnRlc3QodmFsdWUpKSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmUgY2xhc3NpZmllZFxuICAgICAqIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCc4LjQnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlclRhZykgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhc3N1bWVzIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3JcbiAgICAgKiBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgICAgIG9ialByb3RvID0gaXNOYXRpdmUodmFsdWVPZikgJiYgKG9ialByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWVPZikpICYmIGdldFByb3RvdHlwZU9mKG9ialByb3RvKTtcblxuICAgICAgcmV0dXJuIG9ialByb3RvXG4gICAgICAgID8gKHZhbHVlID09IG9ialByb3RvIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90bylcbiAgICAgICAgOiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cFRhZykgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldKSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTsgfSkoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlID8gdmFsdWUubGVuZ3RoIDogMDtcbiAgICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ29weSh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICogSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM7XG4gICAgICogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDQwIH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcgPyBvdGhlciA6IHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihiYXNlQXNzaWduKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7ICdjb25zdHJ1Y3Rvcic6IENpcmNsZSB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGJhc2VDb3B5KHByb3BlcnRpZXMsIHJlc3VsdCwga2V5cyhwcm9wZXJ0aWVzKSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIE9uY2UgYVxuICAgICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCBkZWZhdWx0cyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gYXJyYXlDb3B5KGFyZ3VtZW50cyk7XG4gICAgICBhcmdzLnB1c2goYXNzaWduRGVmYXVsdHMpO1xuICAgICAgcmV0dXJuIGFzc2lnbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBcIl8ubWF0Y2hlc1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGlzIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnByb3BlcnR5XCIgb3IgXCJfLm1hdGNoZXNcIiBzdHlsZSBjYWxsYmFjayByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5tYXRjaGVzXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiXy5wcm9wZXJ0eVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBiYXNlRmluZChvYmplY3QsIHByZWRpY2F0ZSwgYmFzZUZvck93biwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLnByb3BlcnR5XCJcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgXCJfLm1hdGNoZXNcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wcm9wZXJ0eVwiIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ubWF0Y2hlc1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJfLnByb3BlcnR5XCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGJhc2VGaW5kKG9iamVjdCwgcHJlZGljYXRlLCBiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBpbnZva2luZ1xuICAgICAqIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0b3IgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2EnLCAnYicsIGFuZCAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdHlwZW9mIHRoaXNBcmcgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYycsICdiJywgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ2EnLCAnYicsIGFuZCAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nIGBpdGVyYXRlZWBcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRvciBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG4sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSAhPSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0aGlzQXJnICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG4sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdsZW5ndGgnLCAnMScsIGFuZCAnMCcgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FsbCcsICdhbnknLCAnYmluZCcsIC4uLl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGtleWAgZXhpc3RzIGFzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgIGluc3RlYWQgb2YgYW5cbiAgICAgKiBpbmhlcml0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhhcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgJ2InKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZSBwcm9wZXJ0eVxuICAgICAqIGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcyB1bmxlc3MgYG11bHRpVmFsdWVgIGlzIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpVmFsdWVdIEFsbG93IG11bHRpcGxlIHZhbHVlcyBwZXIga2V5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ2ZyZWQnLCAnc2Vjb25kJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6ICdmaXJzdCcsICdiYXJuZXknOiAnc2Vjb25kJyB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGBtdWx0aVZhbHVlYFxuICAgICAqIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ2ZyZWQnLCAnc2Vjb25kJzogJ2Jhcm5leScsICd0aGlyZCc6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogJ3RoaXJkJywgJ2Jhcm5leSc6ICdzZWNvbmQnIH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggYG11bHRpVmFsdWVgXG4gICAgICogXy5pbnZlcnQoeyAnZmlyc3QnOiAnZnJlZCcsICdzZWNvbmQnOiAnYmFybmV5JywgJ3RoaXJkJzogJ2ZyZWQnIH0sIHRydWUpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiBbJ2ZpcnN0JywgJ3RoaXJkJ10sICdiYXJuZXknOiBbJ3NlY29uZCddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0LCBtdWx0aVZhbHVlLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKG9iamVjdCwgbXVsdGlWYWx1ZSwgZ3VhcmQpKSB7XG4gICAgICAgIG11bHRpVmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpKSkpIHtcbiAgICAgICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IChzdXBwb3J0Lm5vbkVudW1BcmdzICYmIGlzQXJndW1lbnRzKG9iamVjdCkpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT0gb2JqZWN0LFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gKGluZGV4ICsgJycpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShza2lwSW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgJiZcbiAgICAgICAgICAgICEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBcIl8ucHJvcGVydHlcIlxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIFwiXy5tYXRjaGVzXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCBpcyB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wcm9wZXJ0eVwiIG9yIFwiXy5tYXRjaGVzXCIgc3R5bGUgY2FsbGJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDN9ICwgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIDM7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcIl8ucHJvcGVydHlcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmaXZlIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZSh1c2VycywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIF8uaXNBcnJheShhKSA/IGEuY29uY2F0KGIpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdCddIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihiYXNlTWVyZ2UpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYHByZWRpY2F0ZWAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqIG9mIGBvYmplY3RgIG9taXR0aW5nIHRoZSBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlXG4gICAgICogcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gb21pdCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0KG9iamVjdCwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChiYXNlRmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICAgIHJldHVybiBwaWNrQnlBcnJheShvYmplY3QsIGJhc2VEaWZmZXJlbmNlKGtleXNJbihvYmplY3QpLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgcHJlZGljYXRlID0gYmluZENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgdGhlIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAsXG4gICAgICogZS5nLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuIFByb3BlcnR5XG4gICAgICogbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2YgcHJvcGVydHlcbiAgICAgKiBuYW1lcy4gSWYgYHByZWRpY2F0ZWAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBgb2JqZWN0YFxuICAgICAqIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwcmVkaWNhdGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCAndXNlcicpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgXy5pc1N0cmluZyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhvYmplY3QsIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgcHJlZGljYXRlID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwaWNrQnlDYWxsYmFjayhvYmplY3QsIGJpbmRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpKVxuICAgICAgICA6IHBpY2tCeUFycmF5KG9iamVjdCwgYmFzZUZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYGtleWAgb24gYG9iamVjdGAuIElmIHRoZSB2YWx1ZSBvZiBga2V5YCBpc1xuICAgICAqIGEgZnVuY3Rpb24gaXQgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgb2JqZWN0YCBhbmQgaXRzIHJlc3VsdFxuICAgICAqIGlzIHJldHVybmVkLCBlbHNlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXR1cm5lZC4gSWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHVzZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgaWYgdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICogIHJlc29sdmVzIHRvIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiBfLmNvbnN0YW50KDQwKSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAndXNlcicpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYWdlJyk7XG4gICAgICogLy8gPT4gNDBcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ3N0YXR1cycsICdidXN5Jyk7XG4gICAgICogLy8gPT4gJ2J1c3knXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdzdGF0dXMnLCBfLmNvbnN0YW50KCdidXN5JykpO1xuICAgICAqIC8vID0+ICdidXN5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duIGVudW1lcmFibGVcbiAgICAgKiBwcm9wZXJ0aWVzIHRocm91Z2ggYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb24gcG90ZW50aWFsbHkgbXV0YXRpbmdcbiAgICAgKiB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0b3IgZnVuY3Rpb25zXG4gICAgICogbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzcXVhcmVzID0gXy50cmFuc2Zvcm0oWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIG4gKj0gbjtcbiAgICAgKiAgIGlmIChuICUgMikge1xuICAgICAqICAgICByZXR1cm4gcmVzdWx0LnB1c2gobikgPCAzO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCA5LCAyNV1cbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpO1xuXG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGJhc2VDcmVhdGUodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgaXMgcmV0dXJuZWQuXG4gICAgICogSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50XG4gICAgICogbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgaXNJdGVyYXRlZUNhbGwobWluLCBtYXgsIGZsb2F0aW5nKSkge1xuICAgICAgICBtYXggPSBmbG9hdGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbm9NaW4gPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXG4gICAgICBpZiAoZmxvYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICBpZiAobm9NYXggJiYgdHlwZW9mIG1pbiA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1pbjtcbiAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgICAgbm9NYXggPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgbWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBjYW1lbCBjYXNlLlxuICAgICAqIFNlZSBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICh3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENhcGl0YWxpemVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgKHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuXG4gICAgICogU2VlIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluMSwgZGVidXJyTGV0dGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gKHRhcmdldCArICcnKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9ICh0eXBlb2YgcG9zaXRpb24gPT0gJ3VuZGVmaW5lZCcgPyBsZW5ndGggOiBuYXRpdmVNaW4ocG9zaXRpb24gPCAwID8gMCA6ICgrcG9zaXRpb24gfHwgMCksIGxlbmd0aCkpIC0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5pbmRleE9mKHRhcmdldCwgcG9zaXRpb24pID09IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIFwiJ1wiLCBhbmQgJ2AnLCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbCBjaGFyYWN0ZXJzXG4gICAgICogdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCByZXF1aXJlIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogU2VlIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEJhY2t0aWNrcyBhcmUgZXNjYXBlZCBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyIDwgOSwgdGhleSBjYW4gYnJlYWsgb3V0XG4gICAgICogb2YgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLiBTZWUgWyMxMDJdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDIpLFxuICAgICAqIFsjMTA4XShodHRwczovL2h0bWw1c2VjLm9yZy8jMTA4KSwgYW5kIFsjMTMzXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTMzKSBvZlxuICAgICAqIHRoZSBbSFRNTDUgU2VjdXJpdHkgQ2hlYXRzaGVldF0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5cyBxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLiBTZWUgW1J5YW4gR3JvdmUncyBhcnRpY2xlXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICAvLyBSZXNldCBgbGFzdEluZGV4YCBiZWNhdXNlIGluIElFIDwgOSBgU3RyaW5nI3JlcGxhY2VgIGRvZXMgbm90LlxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIlxcXCIsIFwiXlwiLCBcIiRcIiwgXCIuXCIsIFwifFwiLCBcIj9cIiwgXCIqXCIsXG4gICAgICogXCIrXCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiBhbmQgXCJ9XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFycy50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFycywgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGtlYmFiIGNhc2UgKGEuay5hLiBzcGluYWwgY2FzZSkuXG4gICAgICogU2VlIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpIGZvclxuICAgICAqIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCBpcyBzaG9ydGVyIHRoZW4gdGhlIGdpdmVuXG4gICAgICogcGFkZGluZyBsZW5ndGguIFRoZSBgY2hhcnNgIHN0cmluZyBtYXkgYmUgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgcGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgdGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChzdHJMZW5ndGggPj0gbGVuZ3RoIHx8ICFuYXRpdmVJc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBmbG9vcihtaWQpLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gY2VpbChtaWQpO1xuXG4gICAgICBjaGFycyA9IGNyZWF0ZVBhZCgnJywgcmlnaHRMZW5ndGgsIGNoYXJzKTtcbiAgICAgIHJldHVybiBjaGFycy5zbGljZSgwLCBsZWZ0TGVuZ3RoKSArIHN0cmluZyArIGNoYXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCBpcyBzaG9ydGVyIHRoZW4gdGhlIGdpdmVuIHBhZGRpbmdcbiAgICAgKiBsZW5ndGguIFRoZSBgY2hhcnNgIHN0cmluZyBtYXkgYmUgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgcGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgZXhjZWVkcyB0aGUgcGFkZGluZyBsZW5ndGguXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRMZWZ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZExlZnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgKGNyZWF0ZVBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0IGlzIHNob3J0ZXIgdGhlbiB0aGUgZ2l2ZW4gcGFkZGluZ1xuICAgICAqIGxlbmd0aC4gVGhlIGBjaGFyc2Agc3RyaW5nIG1heSBiZSB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBwYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBleGNlZWRzIHRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkUmlnaHQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgKHN0cmluZyArIGNyZWF0ZVBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYSBoZXhhZGVjaW1hbCxcbiAgICAgKiBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlIEVTNSBpbXBsZW1lbnRhdGlvbiBvZiBgcGFyc2VJbnRgLlxuICAgICAqIFNlZSB0aGUgW0VTNSBzcGVjXShodHRwczovL2VzNS5naXRodWIuaW8vI0UpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHJhZGl4LCBndWFyZCkpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHN0cmluZywgcmFkaXgpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayBmb3IgZW52aXJvbm1lbnRzIHdpdGggcHJlLUVTNSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSAhPSA4KSB7XG4gICAgICBwYXJzZUludCA9IGZ1bmN0aW9uKHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgRVMzIGZvciBgcGFyc2VJbnRgLlxuICAgICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gdHJpbSBsZWFkaW5nIDxCT00+IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTA5IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcmFkaXgsIGd1YXJkKSA6IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgICByYWRpeCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgPSB0cmltKHN0cmluZyk7XG4gICAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChzdHJpbmcsIHJhZGl4IHx8IChyZUhleFByZWZpeC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG4gPSArbjtcbiAgICAgIGlmIChuIDwgMSB8fCAhc3RyaW5nIHx8ICFuYXRpdmVJc0Zpbml0ZShuKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGZsb29yKG4gLyAyKTtcbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIHNuYWtlIGNhc2UuXG4gICAgICogU2VlIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIHN0YXJ0IGNhc2UuXG4gICAgICogU2VlIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSlcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgKHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGwgPyAwIDogbmF0aXZlTWluKHBvc2l0aW9uIDwgMCA/IDAgOiAoK3Bvc2l0aW9uIHx8IDApLCBzdHJpbmcubGVuZ3RoKTtcbiAgICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgcHJvdmlkZWQgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzIHNvdXJjZVVSTHMgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICogU2VlIHRoZSBbSFRNTDUgUm9ja3MgYXJ0aWNsZSBvbiBzb3VyY2VtYXBzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGVdIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbb3RoZXJPcHRpb25zXSBFbmFibGVzIHRoZSBsZWdhY3kgYG9wdGlvbnNgIHBhcmFtIHNpZ25hdHVyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVMgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYFxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAgIHJldHVybiBfX3A7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBvdGhlck9wdGlvbnMpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb24gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKG90aGVyT3B0aW9ucyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIG90aGVyT3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IG90aGVyT3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBiYXNlQXNzaWduKGJhc2VBc3NpZ24oe30sIG90aGVyT3B0aW9ucyB8fCBvcHRpb25zKSwgc2V0dGluZ3MsIGFzc2lnbk93bkRlZmF1bHRzKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBiYXNlQXNzaWduKGJhc2VBc3NpZ24oe30sIG9wdGlvbnMuaW1wb3J0cyksIHNldHRpbmdzLmltcG9ydHMsIGFzc2lnbk93bkRlZmF1bHRzKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgICgnc291cmNlVVJMJyBpbiBvcHRpb25zXG4gICAgICAgICAgPyBvcHRpb25zLnNvdXJjZVVSTFxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyByZXF1aXJlcyByZXR1cm5pbmcgdGhlIGBtYXRjaGBcbiAgICAgICAgLy8gc3RyaW5nIGluIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgY2hhcnMgPSAoY2hhcnMgKyAnJyk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKGNoYXJzTGVmdEluZGV4KHN0cmluZywgY2hhcnMpLCBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCBjaGFycykgKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1MZWZ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltTGVmdCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltTGVmdChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UodHJpbW1lZExlZnRJbmRleChzdHJpbmcpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShjaGFyc0xlZnRJbmRleChzdHJpbmcsIChjaGFycyArICcnKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1SaWdodCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbVJpZ2h0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1SaWdodChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIChjaGFycyArICcnKSkgKyAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQgaXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdCBvciBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywgMjQpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG4uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywgeyAnbGVuZ3RoJzogMjQsICdzZXBhcmF0b3InOiAnICcgfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywgeyAnbGVuZ3RoJzogMjQsICdzZXBhcmF0b3InOiAvLD8gKy8gfSk7XG4gICAgICogLy89PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHsgJ29taXNzaW9uJzogJyBbLi4uXScgfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuYyhzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/ICtvcHRpb25zLmxlbmd0aCB8fCAwIDogbGVuZ3RoO1xuICAgICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gK29wdGlvbnMgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAobGVuZ3RoID49IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBvbWlzc2lvbi5sZW5ndGg7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBuZXdFbmQsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpIHx8ICcnKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT0gbnVsbCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGAmIzM5O2AsIGFuZCBgJiM5NjtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbCBIVE1MXG4gICAgICogZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkpIHtcbiAgICAgICAgcGF0dGVybiA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybiB8fCByZVdvcmRzKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodFxuICAgICAqIGVycm9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9yc1xuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdHRlbXB0KGZ1bmMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGJvdW5kIHRvIGFuIG9wdGlvbmFsIGB0aGlzQXJnYC4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHlcbiAgICAgKiBuYW1lIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogSWYgYGZ1bmNgIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHNcbiAgICAgKiB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnQgb2JqZWN0IHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaXRlcmF0ZWVcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogXy5jYWxsYmFjayA9IF8ud3JhcChfLmNhbGxiYWNrLCBmdW5jdGlvbihjYWxsYmFjaywgZnVuYywgdGhpc0FyZykge1xuICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGZ1bmMpO1xuICAgICAqICAgaWYgKCFtYXRjaCkge1xuICAgICAqICAgICByZXR1cm4gY2FsbGJhY2soZnVuYywgdGhpc0FyZyk7XG4gICAgICogICB9XG4gICAgICogICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICAgIHJldHVybiBtYXRjaFsyXSA9PSAnZ3QnID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWdlX19ndDM2Jyk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgdGhpc0FyZywgZ3VhcmQpKSB7XG4gICAgICAgIHRoaXNBcmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZShmdW5jKVxuICAgICAgICA/IG1hdGNoZXMoZnVuYylcbiAgICAgICAgOiBiYXNlQ2FsbGJhY2soZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqIHZhciBnZXR0ZXIgPSBfLmNvbnN0YW50KG9iamVjdCk7XG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggcGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuIG9iamVjdFxuICAgICAqIGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50IHByb3BlcnR5XG4gICAgICogdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBtYXRjaGVzQWdlID0gXy5tYXRjaGVzKHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIG1hdGNoZXNBZ2UpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XVxuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBtYXRjaGVzQWdlKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIHRoZW4gbWV0aG9kcyBhcmUgYWRkZWQgdG9cbiAgICAgKiBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PXRoaXNdIG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIHRoZSBmdW5jdGlvbnMgYWRkZWRcbiAgICAgKiAgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNPYmogPSBpc09iamVjdChzb3VyY2UpLFxuICAgICAgICAgICAgcHJvcHMgPSBpc09iaiAmJiBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IHByb3BzICYmIHByb3BzLmxlbmd0aCAmJiBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICAgIGlmICghKG1ldGhvZE5hbWVzID8gbWV0aG9kTmFtZXMubGVuZ3RoIDogaXNPYmopKSB7XG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZE5hbWVzKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2luZGV4XSxcbiAgICAgICAgICAgIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG5cbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSAoZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgICAgICAgICAgICAocmVzdWx0Ll9fYWN0aW9uc19fID0gYXJyYXlDb3B5KHRoaXMuX19hY3Rpb25zX18pKS5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy52YWx1ZSgpXTtcbiAgICAgICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KGZ1bmMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGNvbnRleHQuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogXy5ub29wKG9iamVjdCkgPT09IHVuZGVmaW5lZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBrZXlgIG9uIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIGdldE5hbWUgPSBfLnByb3BlcnR5KCd1c2VyJyk7XG4gICAgICpcbiAgICAgKiBfLm1hcCh1c2VycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gWydmcmVkJywgYmFybmV5J11cbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy5zb3J0QnkodXNlcnMsIGdldE5hbWUpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KGtleSkge1xuICAgICAgcmV0dXJuIGJhc2VQcm9wZXJ0eShrZXkgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuc1xuICAgICAqIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBhIGdpdmVuIGtleSBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH07XG4gICAgICogXy5tYXAoWydhY3RpdmUnLCAndXNlciddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gW3RydWUsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMywgJ2InOiAxLCAnYyc6IDIgfTtcbiAgICAgKiBfLnNvcnRCeShbJ2EnLCAnYicsICdjJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYycsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBlbmRgIGFcbiAgICAgKiB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBudW1iZXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIGlmIChzdGVwICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgIGVuZCA9IHN0ZXAgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogKCtzdGVwIHx8IDApO1xuXG4gICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9ICtlbmQgfHwgMDtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBgQXJyYXkobGVuZ3RoKWAgc28gZW5naW5lcyBsaWtlIENoYWtyYSBhbmQgVjggYXZvaWQgc2xvd2VyIG1vZGVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8veW91dHUuYmUvWEFxSXBHVThaWmsjdD0xN20yNXMgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChjZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgZnVuY3Rpb24gYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGludm9jYXRpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2LCBmYWxzZSkpO1xuICAgICAqIC8vID0+IFszLCA2LCA0XVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IG1hZ2UuY2FzdFNwZWxsKG4pOyB9KTtcbiAgICAgKiAvLyA9PiBpbnZva2VzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMgd2l0aCBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgdGhpcy5jYXN0KG4pOyB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGludm9rZXMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICBuID0gK247XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgdG8gYXZvaWQgYSBKU0MgSklUIGJ1ZyBpbiBTYWZhcmkgOFxuICAgICAgLy8gd2hlcmUgYEFycmF5KDApYCBpcyB0cmVhdGVkIGFzIGBBcnJheSgxKWAuXG4gICAgICBpZiAobiA8IDEgfHwgIW5hdGl2ZUlzRmluaXRlKG4pKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSk7XG5cbiAgICAgIGl0ZXJhdGVlID0gYmluZENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpZiAoaW5kZXggPCBNQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIGJhc2VUb1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gRW5zdXJlIGBuZXcgTG9kYXNoV3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGxvZGFzaGAuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBsb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYE1hcGAgY2FjaGUuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcERlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcFNldDtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGBTZXRgIGNhY2hlLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gY2FjaGVQdXNoO1xuXG4gICAgLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbmRleEJ5ID0gaW5kZXhCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5wbHVjayA9IHBsdWNrO1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0QnlBbGwgPSBzb3J0QnlBbGw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndoZXJlID0gd2hlcmU7XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5iYWNrZmxvdyA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgICBsb2Rhc2guY29tcG9zZSA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGNhbGxiYWNrO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kV2hlcmU7XG4gICAgbG9kYXNoLmZpcnN0ID0gZmlyc3Q7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZExlZnQgPSBwYWRMZWZ0O1xuICAgIGxvZGFzaC5wYWRSaWdodCA9IHBhZFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG4gICAgbG9kYXNoLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcbiAgICBsb2Rhc2gudHJ1bmMgPSB0cnVuYztcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5hbGwgPSBldmVyeTtcbiAgICBsb2Rhc2guYW55ID0gc29tZTtcbiAgICBsb2Rhc2guY29udGFpbnMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guZGV0ZWN0ID0gZmluZDtcbiAgICBsb2Rhc2guZm9sZGwgPSByZWR1Y2U7XG4gICAgbG9kYXNoLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLmhlYWQgPSBmaXJzdDtcbiAgICBsb2Rhc2guaW5jbHVkZSA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCBmYWxzZSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIGNhcGFibGUgb2YgcmV0dXJuaW5nIHdyYXBwZWQgYW5kIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAoIXRoaXMuX19jaGFpbl9fICYmIG4gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2FtcGxlKHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGUodmFsdWUsIG4pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBpc0ZpbHRlciA9IGluZGV4ID09IExBWllfRklMVEVSX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCksXG4gICAgICAgICAgICBmaWx0ZXJlZCA9IHJlc3VsdC5maWx0ZXJlZCxcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IHJlc3VsdC5pdGVyYXRlZXMgfHwgKHJlc3VsdC5pdGVyYXRlZXMgPSBbXSk7XG5cbiAgICAgICAgcmVzdWx0LmZpbHRlcmVkID0gZmlsdGVyZWQgfHwgaXNGaWx0ZXIgfHwgKGluZGV4ID09IExBWllfV0hJTEVfRkxBRyAmJiByZXN1bHQuZGlyIDwgMCk7XG4gICAgICAgIGl0ZXJhdGVlcy5wdXNoKHsgJ2l0ZXJhdGVlJzogZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpLCAndHlwZSc6IGluZGV4IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBjb3VudE5hbWUgPSBtZXRob2ROYW1lICsgJ0NvdW50JyxcbiAgICAgICAgICB3aGlsZU5hbWUgPSBtZXRob2ROYW1lICsgJ1doaWxlJztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PSBudWxsID8gMSA6IG5hdGl2ZU1heCgrbiB8fCAwLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAocmVzdWx0LmZpbHRlcmVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0W2NvdW50TmFtZV07XG4gICAgICAgICAgcmVzdWx0W2NvdW50TmFtZV0gPSBpbmRleCA/IG5hdGl2ZU1pbih2YWx1ZSwgbikgOiAodmFsdWUgKyBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmlld3MgPSByZXN1bHQudmlld3MgfHwgKHJlc3VsdC52aWV3cyA9IFtdKTtcbiAgICAgICAgICB2aWV3cy5wdXNoKHsgJ3NpemUnOiBuLCAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0LmRpciA8IDAgPyAnUmlnaHQnIDogJycpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHRXaGlsZSddID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVt3aGlsZU5hbWVdKHByZWRpY2F0ZSwgdGhpc0FyZykucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmZpcnN0YCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnZmlyc3QnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JzogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnJlc3RgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAncmVzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5wbHVja2AgYW5kIGBfLndoZXJlYC5cbiAgICBhcnJheUVhY2goWydwbHVjaycsICd3aGVyZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIG9wZXJhdGlvbk5hbWUgPSBpbmRleCA/ICdmaWx0ZXInIDogJ21hcCcsXG4gICAgICAgICAgY3JlYXRlQ2FsbGJhY2sgPSBpbmRleCA/IGJhc2VNYXRjaGVzIDogYmFzZVByb3BlcnR5O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tvcGVyYXRpb25OYW1lXShjcmVhdGVDYWxsYmFjayhpbmRleCA/IHZhbHVlIDogKHZhbHVlICsgJycpKSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmRyb3BXaGlsZSA9IGZ1bmN0aW9uKGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgZG9uZSxcbiAgICAgICAgICBsYXN0SW5kZXgsXG4gICAgICAgICAgaXNSaWdodCA9IHRoaXMuZGlyIDwgMDtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24odmFsdWUsIGluZGV4LCBhcnJheSkge1xuICAgICAgICBkb25lID0gZG9uZSAmJiAoaXNSaWdodCA/IGluZGV4IDwgbGFzdEluZGV4IDogaW5kZXggPiBsYXN0SW5kZXgpO1xuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIGRvbmUgfHwgKGRvbmUgPSAhaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBhcnJheSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24odmFsdWUsIGluZGV4LCBhcnJheSkge1xuICAgICAgICByZXR1cm4gIWl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuICAgICAgdmFyIHJlc3VsdCA9IHN0YXJ0IDwgMCA/IHRoaXMudGFrZVJpZ2h0KC1zdGFydCkgOiB0aGlzLmRyb3Aoc3RhcnQpO1xuXG4gICAgICBpZiAodHlwZW9mIGVuZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmQgPSAoK2VuZCB8fCAwKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpmaXJzdHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCkge1xuICAgICAgICAgIHJldHVybiBvbmx5TGF6eVxuICAgICAgICAgICAgPyBmdW5jLmNhbGwodmFsdWUpXG4gICAgICAgICAgICA6IGxvZGFzaEZ1bmMuY2FsbChsb2Rhc2gsIHRoaXMudmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgb3RoZXJBcmdzID0gW3ZhbHVlXTtcbiAgICAgICAgICBwdXNoLmFwcGx5KG90aGVyQXJncywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBvdGhlckFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHdyYXBwZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgKGlzSHlicmlkIHx8IHJlc3VsdC5hY3Rpb25zKSkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbnMgPSByZXN1bHQuYWN0aW9ucyB8fCAocmVzdWx0LmFjdGlvbnMgPSBbXSk7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiBsb2Rhc2ggfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5LnByb3RvdHlwZWAgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydjb25jYXQnLCAnam9pbicsICdwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmpvaW58cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcy52YWx1ZSgpLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBsYXp5IHdyYXBwZXIuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluaW5nIGZ1bmN0aW9ucyB0byB0aGUgbG9kYXNoIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBmdW5jdGlvbiBhbGlhc2VzIHRvIHRoZSBsb2Rhc2ggd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbGxlY3QgPSBsb2Rhc2gucHJvdG90eXBlLm1hcDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmhlYWQgPSBsb2Rhc2gucHJvdG90eXBlLmZpcnN0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuc2VsZWN0ID0gbG9kYXNoLnByb3RvdHlwZS5maWx0ZXI7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50YWlsID0gbG9kYXNoLnByb3RvdHlwZS5yZXN0O1xuXG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycyBsaWtlIHIuanMgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBsb2Rhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgdG8gYXZvaWRcbiAgICAvLyBlcnJvcnMgaW4gY2FzZXMgd2hlcmUgbG9kYXNoIGlzIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgYW5kIG5vdCBpbnRlbmRlZFxuICAgIC8vIGFzIGFuIEFNRCBtb2R1bGUuIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvclxuICAgIC8vIG1vcmUgZGV0YWlscy5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdC5cbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcyBvciBSaW5nb0pTLlxuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIEV4cG9ydCBmb3IgTmFyd2hhbCBvciBSaGlubyAtcmVxdWlyZS5cbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIGEgYnJvd3NlciBvciBSaGluby5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIl19
