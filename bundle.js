(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/a/snake/index.js":[function(require,module,exports){
/*jslint node:true*/
/*global window*/
var domready = require('domready'),
    ex = require('./lib/excalibur'),
    Snake = require('./lib/snake'),
    mobile = require('./lib/mobile');

domready(function () {
    'use strict';
    var game = new ex.Engine(),
        snake = new Snake({
            ex: ex,
            game: game,
            color: {
                head: ex.Color.Red,
                body: ex.Color.Yellow,
                food: ex.Color.Green
            }
        }),
        replay = function () {
            game.rootScene.children.forEach(function (actor) {
                actor.kill();
            });
            setTimeout(function () {
                snake = new Snake({
                    ex: ex,
                    game: game,
                    color: {
                        head: ex.Color.Red,
                        body: ex.Color.Yellow,
                        food: ex.Color.Green
                    }
                });
                snake.onLose = replay;
                snake.run({x: 1});
            }, 500);
        },
        paused = false;
    game.input.keyboard.on('down', function (k) {
        k = k.key;
        if (k === 37) {
            snake.left();
        } else if (k === 38) {
            snake.up();
        } else if (k === 39) {
            snake.right();
        } else if (k === 40) {
            snake.down();
        } else if (k === 32) {
            if (paused) {
                game.start();
                paused = false;
            } else {
                game.stop();
                paused = true;
            }
        }
    });
    document.addEventListener('click', function () {
        replay();
    });
    mobile(snake);
    game.start();
    snake.onLose = replay;
    snake.run({x: 1});
});

},{"./lib/excalibur":"/home/a/snake/lib/excalibur.js","./lib/mobile":"/home/a/snake/lib/mobile.js","./lib/snake":"/home/a/snake/lib/snake.js","domready":"/home/a/snake/node_modules/domready/ready.js"}],"/home/a/snake/lib/excalibur.js":[function(require,module,exports){
/*! excalibur - v0.2.5 - 2015-02-04
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2015 ; Licensed BSD*/
if (typeof window == 'undefined') {
    window = { audioContext: function () {
    } };
}
if (typeof window != 'undefined' && !window.requestAnimationFrame) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
        window.setInterval(callback, 1000 / 60);
    };
}
if (typeof window != 'undefined' && !window.AudioContext) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError(' this is null or not defined');
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg */) {
        'use strict';
        if (this === void 0 || this === null)
            throw new TypeError();
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function')
            throw new TypeError();
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t))
                return true;
        }
        return false;
    };
}
// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {
        }, fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
var ex;
(function (ex) {
    var Effects;
    (function (Effects) {
        /**
         * Applies the "Grayscale" effect to a sprite, removing color information.
         * @class Effects.Grayscale
         * @constructor
         * @extends ISpriteEffect
         */
        var Grayscale = (function () {
            function Grayscale() {
            }
            Grayscale.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
                pixel[firstPixel + 0] = avg;
                pixel[firstPixel + 1] = avg;
                pixel[firstPixel + 2] = avg;
            };
            return Grayscale;
        })();
        Effects.Grayscale = Grayscale;
        /**
         * Applies the "Invert" effect to a sprite, inverting the pixel colors.
         * @class Effects.Invert
         * @constructor
         * @extends ISpriteEffect
         */
        var Invert = (function () {
            function Invert() {
            }
            Invert.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
                pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
                pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
            };
            return Invert;
        })();
        Effects.Invert = Invert;
        /**
         * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
         * @class Effects.Opacity
         * @extends ISpriteEffect
         * @constructor
         * @param opacity {number} The new opacity of the sprite from 0-1.0
         */
        var Opacity = (function () {
            function Opacity(opacity) {
                this.opacity = opacity;
            }
            Opacity.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 3] = Math.round(this.opacity * 255);
                }
            };
            return Opacity;
        })();
        Effects.Opacity = Opacity;
        /**
         * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
         * average of the original color and the provided color
         * @class Effects.Colorize
         * @extends ISpriteEffect
         * @constructor
         * @param color {Color} The color to apply to the sprite
         */
        var Colorize = (function () {
            function Colorize(color) {
                this.color = color;
            }
            Colorize.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
                    pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
                    pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
                }
            };
            return Colorize;
        })();
        Effects.Colorize = Colorize;
        /**
         * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
         * a given color
         * @class Effects.Fill
         * @extends ISpriteEffect
         * @constructor
         * @param color {Color} The color to apply to the sprite
         */
        var Fill = (function () {
            function Fill(color) {
                this.color = color;
            }
            Fill.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 0] = this.color.r;
                    pixel[firstPixel + 1] = this.color.g;
                    pixel[firstPixel + 2] = this.color.b;
                }
            };
            return Fill;
        })();
        Effects.Fill = Fill;
    })(Effects = ex.Effects || (ex.Effects = {}));
})(ex || (ex = {}));
/// <reference path="../SpriteEffects.ts" />
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var MovementModule = (function () {
        function MovementModule() {
        }
        MovementModule.prototype.update = function (actor, engine, delta) {
            // Update placements based on linear algebra
            actor.x += actor.dx * delta / 1000;
            actor.y += actor.dy * delta / 1000;
            actor.dx += actor.ax * delta / 1000;
            actor.dy += actor.ay * delta / 1000;
            actor.rotation += actor.rx * delta / 1000;
            actor.scale.x += actor.sx * delta / 1000;
            actor.scale.y += actor.sy * delta / 1000;
        };
        return MovementModule;
    })();
    ex.MovementModule = MovementModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var OffscreenCullingModule = (function () {
        function OffscreenCullingModule() {
        }
        OffscreenCullingModule.prototype.update = function (actor, engine, delta) {
            var eventDispatcher = actor.eventDispatcher;
            var anchor = actor.anchor;
            var globalScale = actor.getGlobalScale();
            var width = globalScale.x * actor.getWidth() / actor.scale.x;
            var height = globalScale.y * actor.getHeight() / actor.scale.y;
            var actorScreenCoords = engine.worldToScreenCoordinates(new ex.Point(actor.getGlobalX() - anchor.x * width, actor.getGlobalY() - anchor.y * height));
            var zoom = 1.0;
            if (actor.scene && actor.scene.camera) {
                zoom = actor.scene.camera.getZoom();
            }
            if (!actor.isOffScreen) {
                if (actorScreenCoords.x + width * zoom < 0 || actorScreenCoords.y + height * zoom < 0 || actorScreenCoords.x > engine.width || actorScreenCoords.y > engine.height) {
                    eventDispatcher.publish('exitviewport', new ex.ExitViewPortEvent());
                    actor.isOffScreen = true;
                }
            }
            else {
                if (actorScreenCoords.x + width * zoom > 0 && actorScreenCoords.y + height * zoom > 0 && actorScreenCoords.x < engine.width && actorScreenCoords.y < engine.height) {
                    eventDispatcher.publish('enterviewport', new ex.EnterViewPortEvent());
                    actor.isOffScreen = false;
                }
            }
        };
        return OffscreenCullingModule;
    })();
    ex.OffscreenCullingModule = OffscreenCullingModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    /**
     * Propogates pointer events to the actor
     */
    var CapturePointerModule = (function () {
        function CapturePointerModule() {
        }
        CapturePointerModule.prototype.update = function (actor, engine, delta) {
            if (!actor.enableCapturePointer)
                return;
            if (actor.isKilled())
                return;
            engine.input.pointers.propogate(actor);
        };
        return CapturePointerModule;
    })();
    ex.CapturePointerModule = CapturePointerModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var CollisionDetectionModule = (function () {
        function CollisionDetectionModule() {
        }
        CollisionDetectionModule.prototype.update = function (actor, engine, delta) {
            var eventDispatcher = actor.eventDispatcher;
            if (actor.collisionType !== 0 /* PreventCollision */) {
                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {
                    var map = engine.currentScene.tileMaps[j];
                    var intersectMap;
                    var side = 0 /* None */;
                    var max = 2;
                    var hasBounced = false;
                    while (intersectMap = map.collides(actor)) {
                        if (max-- < 0) {
                            break;
                        }
                        side = actor.getSideFromIntersect(intersectMap);
                        eventDispatcher.publish('collision', new ex.CollisionEvent(actor, null, side, intersectMap));
                        if ((actor.collisionType === 2 /* Active */ || actor.collisionType === 3 /* Elastic */)) {
                            actor.y += intersectMap.y;
                            actor.x += intersectMap.x;
                            // Naive elastic bounce
                            if (actor.collisionType === 3 /* Elastic */ && !hasBounced) {
                                hasBounced = true;
                                if (side === 3 /* Left */) {
                                    actor.dx = Math.abs(actor.dx);
                                }
                                else if (side === 4 /* Right */) {
                                    actor.dx = -Math.abs(actor.dx);
                                }
                                else if (side === 1 /* Top */) {
                                    actor.dy = Math.abs(actor.dy);
                                }
                                else if (side === 2 /* Bottom */) {
                                    actor.dy = -Math.abs(actor.dy);
                                }
                            }
                        }
                    }
                }
            }
        };
        return CollisionDetectionModule;
    })();
    ex.CollisionDetectionModule = CollisionDetectionModule;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * An enum that describes the sides of an Actor for collision
     * @class Side
     */
    (function (Side) {
        /**
        @property None {Side}
        @static
        @final
        */
        Side[Side["None"] = 0] = "None";
        /**
        @property Top {Side}
        @static
        @final
        */
        Side[Side["Top"] = 1] = "Top";
        /**
        @property Bottom {Side}
        @static
        @final
        */
        Side[Side["Bottom"] = 2] = "Bottom";
        /**
        @property Left {Side}
        @static
        @final
        */
        Side[Side["Left"] = 3] = "Left";
        /**
        @property Right {Side}
        @static
        @final
        */
        Side[Side["Right"] = 4] = "Right";
    })(ex.Side || (ex.Side = {}));
    var Side = ex.Side;
})(ex || (ex = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ex;
(function (ex) {
    /**
     * A simple 2D point on a plane
     * @class Point
     * @constructor
     * @param x {number} X coordinate of the point
     * @param y {number} Y coordinate of the point
     *
     */
    var Point = (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * X Coordinate of the point
         * @property x {number}
         */
        /**
         * Y Coordinate of the point
         * @property y {number}
         */
        /**
         * Convert this point to a vector
         * @method toVector
         * @returns Vector
         */
        Point.prototype.toVector = function () {
            return new Vector(this.x, this.y);
        };
        /**
         * Rotates the current point around another by a certain number of
         * degrees in radians
         * @method rotate
         * @returns Point
         */
        Point.prototype.rotate = function (angle, anchor) {
            if (!anchor) {
                anchor = new ex.Point(0, 0);
            }
            var sinAngle = Math.sin(angle);
            var cosAngle = Math.cos(angle);
            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
            return new Point(x, y);
        };
        /**
         * Translates the current point by a vector
         * @method add
         * @returns Point
         */
        Point.prototype.add = function (vector) {
            return new Point(this.x + vector.x, this.y + vector.y);
        };
        /**
         * Sets the x and y components at once
         * @method setTo
         * @param x {number}
         * @param y {number}
         */
        Point.prototype.setTo = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Clones a new point that is a copy of this one.
         * @method clone
         * @returns Point
         */
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };
        return Point;
    })();
    ex.Point = Point;
    /**
     * A 2D vector on a plane.
     * @class Vector
     * @extends Point
     * @constructor
     * @param x {number} X component of the Vector
     * @param y {number} Y component of the Vector
     */
    var Vector = (function (_super) {
        __extends(Vector, _super);
        function Vector(x, y) {
            _super.call(this, x, y);
            this.x = x;
            this.y = y;
        }
        /**
         * Returns a vector of unit length in the direction of the specified angle.
         * @method fromAngle
         * @static
         * @param angle {number} The angle to generate the vector
         * @returns Vector
         */
        Vector.fromAngle = function (angle) {
            return new Vector(Math.cos(angle), Math.sin(angle));
        };
        /**
         * The distance to another vector
         * @method distance
         * @param v {Vector} The other vector
         * @returns number
         */
        Vector.prototype.distance = function (v) {
            if (!v) {
                v = new Vector(0.0, 0.0);
            }
            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
        };
        /**
         * Normalizes a vector to have a magnitude of 1.
         * @method normalize
         * @return Vector
         */
        Vector.prototype.normalize = function () {
            var d = this.distance();
            if (d > 0) {
                return new Vector(this.x / d, this.y / d);
            }
            else {
                return new Vector(0, 1);
            }
        };
        /**
         * Scales a vector's by a factor of size
         * @method scale
         * @param size {number} The factor to scale the magnitude by
         * @returns Vector
         */
        Vector.prototype.scale = function (size) {
            return new Vector(this.x * size, this.y * size);
        };
        /**
         * Adds one vector to another
         * @method add
         * @param v {Vector} The vector to add
         * @returns Vector
         */
        Vector.prototype.add = function (v) {
            return new Vector(this.x + v.x, this.y + v.y);
        };
        /**
         * Subtracts a vector from the current vector
         * @method minus
         * @param v {Vector} The vector to subtract
         * @returns Vector
         */
        Vector.prototype.minus = function (v) {
            return new Vector(this.x - v.x, this.y - v.y);
        };
        /**
         * Performs a dot product with another vector
         * @method dot
         * @param v {Vector} The vector to dot
         * @returns number
         */
        Vector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        /**
         * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.
         * @method cross
         * @param v {Vector} The vector to cross
         * @returns number
         */
        Vector.prototype.cross = function (v) {
            return this.x * v.y - this.y * v.x;
        };
        /**
         * Returns the perpendicular vector to this one
         * @method perpendicular
         * @return Vector
         */
        Vector.prototype.perpendicular = function () {
            return new Vector(this.y, -this.x);
        };
        /**
         * Returns the normal vector to this one
         * @method normal
         * @return Vector
         */
        Vector.prototype.normal = function () {
            return this.perpendicular().normalize();
        };
        /**
         * Returns the angle of this vector.
         * @method toAngle
         * @returns number
         */
        Vector.prototype.toAngle = function () {
            return Math.atan2(this.y, this.x);
        };
        /**
         * Returns the point represention of this vector
         * @method toPoint
         * @returns Point
         */
        Vector.prototype.toPoint = function () {
            return new Point(this.x, this.y);
        };
        /**
         * Rotates the current vector around a point by a certain number of
         * degrees in radians
         * @method rotate
         * @returns Vector
         */
        Vector.prototype.rotate = function (angle, anchor) {
            return _super.prototype.rotate.call(this, angle, anchor).toVector();
        };
        return Vector;
    })(Point);
    ex.Vector = Vector;
    /**
     * A 2D ray that can be cast into the scene to do collision detection
     * @class Ray
     * @constructor
     * @param pos {Point} The starting position for the ray
     * @param dir {Vector} The vector indicating the direction of the ray
     */
    var Ray = (function () {
        function Ray(pos, dir) {
            this.pos = pos;
            this.dir = dir.normalize();
        }
        /**
         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
         * This number indicates the mathematical intersection time.
         * @method intersect
         * @param line {Line} The line to test
         * @returns number
         */
        Ray.prototype.intersect = function (line) {
            var numerator = line.begin.toVector().minus(this.pos.toVector());
            // Test is line and ray are parallel and non intersecting
            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
                return -1;
            }
            // Lines are parallel
            var divisor = (this.dir.cross(line.getSlope()));
            if (divisor === 0) {
                return -1;
            }
            var t = numerator.cross(line.getSlope()) / divisor;
            if (t >= 0) {
                var u = (numerator.cross(this.dir) / divisor) / line.getLength();
                if (u >= 0 && u <= 1) {
                    return t;
                }
            }
            return -1;
        };
        /**
         * Returns the point of intersection given the intersection time
         * @method getPoint
         * @returns Point
         */
        Ray.prototype.getPoint = function (time) {
            return this.pos.toVector().add(this.dir.scale(time)).toPoint();
        };
        return Ray;
    })();
    ex.Ray = Ray;
    /**
     * A 2D line segment
     * @class Line
     * @constructor
     * @param begin {Point} The starting point of the line segment
     * @param end {Point} The ending point of the line segment
     */
    var Line = (function () {
        function Line(begin, end) {
            this.begin = begin;
            this.end = end;
        }
        /**
         * Returns the slope of the line in the form of a vector
         * @method getSlope
         * @returns Vector
         */
        Line.prototype.getSlope = function () {
            var begin = this.begin.toVector();
            var end = this.end.toVector();
            var distance = begin.distance(end);
            return end.minus(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         * @method getLength
         * @returns number
         */
        Line.prototype.getLength = function () {
            var begin = this.begin.toVector();
            var end = this.end.toVector();
            var distance = begin.distance(end);
            return distance;
        };
        return Line;
    })();
    ex.Line = Line;
    var Projection = (function () {
        function Projection(min, max) {
            this.min = min;
            this.max = max;
        }
        Projection.prototype.overlaps = function (projection) {
            return this.max > projection.min && projection.max > this.min;
        };
        Projection.prototype.getOverlap = function (projection) {
            if (this.overlaps(projection)) {
                if (this.max > projection.max) {
                    return projection.max - this.min;
                }
                else {
                    return this.max - projection.min;
                }
            }
            return 0;
        };
        return Projection;
    })();
    ex.Projection = Projection;
})(ex || (ex = {}));
/// <reference path="Algebra.ts"/>
/// <reference path="Events.ts"/>
var ex;
(function (ex) {
    var Util;
    (function (Util) {
        Util.TwoPI = Math.PI * 2;
        function base64Encode(inputStr) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var outputStr = "";
            var i = 0;
            while (i < inputStr.length) {
                //all three "& 0xff" added below are there to fix a known bug 
                //with bytes returned by xhr.responseText
                var byte1 = inputStr.charCodeAt(i++) & 0xff;
                var byte2 = inputStr.charCodeAt(i++) & 0xff;
                var byte3 = inputStr.charCodeAt(i++) & 0xff;
                var enc1 = byte1 >> 2;
                var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
                var enc3, enc4;
                if (isNaN(byte2)) {
                    enc3 = enc4 = 64;
                }
                else {
                    enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
                    if (isNaN(byte3)) {
                        enc4 = 64;
                    }
                    else {
                        enc4 = byte3 & 63;
                    }
                }
                outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
            }
            return outputStr;
        }
        Util.base64Encode = base64Encode;
        function clamp(val, min, max) {
            return val <= min ? min : (val >= max ? max : val);
        }
        Util.clamp = clamp;
        function drawLine(ctx, color, startx, starty, endx, endy) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.moveTo(startx, starty);
            ctx.lineTo(endx, endy);
            ctx.closePath();
            ctx.stroke();
        }
        Util.drawLine = drawLine;
        function randomInRange(min, max) {
            return min + Math.random() * (max - min);
        }
        Util.randomInRange = randomInRange;
        function randomIntInRange(min, max) {
            return Math.round(randomInRange(min, max));
        }
        Util.randomIntInRange = randomIntInRange;
        function canonicalizeAngle(angle) {
            var tmpAngle = angle;
            if (angle > this.TwoPI) {
                while (tmpAngle > this.TwoPI) {
                    tmpAngle -= this.TwoPI;
                }
            }
            if (angle < 0) {
                while (tmpAngle < 0) {
                    tmpAngle += this.TwoPI;
                }
            }
            return tmpAngle;
        }
        Util.canonicalizeAngle = canonicalizeAngle;
        function toDegrees(radians) {
            return 180 / Math.PI * radians;
        }
        Util.toDegrees = toDegrees;
        function toRadians(degrees) {
            return degrees / 180 * Math.PI;
        }
        Util.toRadians = toRadians;
        function getPosition(el) {
            var oLeft = 0, oTop = 0;
            var calcOffsetLeft = function (parent) {
                oLeft += parent.offsetLeft;
                if (parent.offsetParent) {
                    calcOffsetLeft(parent.offsetParent);
                }
            };
            var calcOffsetTop = function (parent) {
                oTop += parent.offsetTop;
                if (parent.offsetParent) {
                    calcOffsetTop(parent.offsetParent);
                }
            };
            calcOffsetLeft(el);
            calcOffsetTop(el);
            return new ex.Point(oLeft, oTop);
        }
        Util.getPosition = getPosition;
        function getOppositeSide(side) {
            if (side === 1 /* Top */)
                return 2 /* Bottom */;
            if (side === 2 /* Bottom */)
                return 1 /* Top */;
            if (side === 3 /* Left */)
                return 4 /* Right */;
            if (side === 4 /* Right */)
                return 3 /* Left */;
            return 0 /* None */;
        }
        Util.getOppositeSide = getOppositeSide;
        /**
         * Excaliburs dynamically resizing collection
         * @class Collection
         * @constructor
         * @param [initialSize=200] {number} Initial size of the internal backing array
         */
        var Collection = (function () {
            function Collection(initialSize) {
                this.internalArray = null;
                this.endPointer = 0;
                var size = initialSize || Collection.DefaultSize;
                this.internalArray = new Array(size);
            }
            Collection.prototype.resize = function () {
                var newSize = this.internalArray.length * 2;
                var newArray = new Array(newSize);
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    newArray[i] = this.internalArray[i];
                }
                delete this.internalArray;
                this.internalArray = newArray;
            };
            /**
             * Push elements to the end of the collection
             * @method push
             * @param element {T}
             * @returns T
             */
            Collection.prototype.push = function (element) {
                if (this.endPointer === this.internalArray.length) {
                    this.resize();
                }
                return this.internalArray[this.endPointer++] = element;
            };
            /**
             * Removes elements from the end of the collection
             * @method pop
             * @returns T
             */
            Collection.prototype.pop = function () {
                this.endPointer = this.endPointer - 1 < 0 ? 0 : this.endPointer - 1;
                return this.internalArray[this.endPointer];
            };
            /**
             * Returns the count of the collection
             * @method count
             * @returns number
             */
            Collection.prototype.count = function () {
                return this.endPointer;
            };
            /**
             * Empties the collection
             * @method clear
             */
            Collection.prototype.clear = function () {
                this.endPointer = 0;
            };
            /**
             * Returns the size of the internal backing array
             * @method internalSize
             * @returns number
             */
            Collection.prototype.internalSize = function () {
                return this.internalArray.length;
            };
            /**
             * Returns an element at a specific index
             * @method elementAt
             * @param index {number} Index of element to retreive
             * @returns T
             */
            Collection.prototype.elementAt = function (index) {
                if (index >= this.count()) {
                    return;
                }
                return this.internalArray[index];
            };
            /**
             * Inserts an element at a specific index
             * @method insert
             * @param index {number} Index to insert the element
             * @returns T
             */
            Collection.prototype.insert = function (index, value) {
                if (index >= this.count()) {
                    this.resize();
                }
                return this.internalArray[index] = value;
            };
            /**
             * Removes an element at a specific index
             * @method remove
             * @param index {number} Index of element to remove
             * @returns T
             */
            Collection.prototype.remove = function (index) {
                var count = this.count();
                if (count === 0)
                    return;
                // O(n) Shift 
                var removed = this.internalArray[index];
                for (var i = index; i < count; i++) {
                    this.internalArray[i] = this.internalArray[i + 1];
                }
                this.endPointer--;
                return removed;
            };
            /**
             * Removes an element by reference
             * @method removeElement
             * @param element {T} Index of element to retreive
             */
            Collection.prototype.removeElement = function (element) {
                var index = this.internalArray.indexOf(element);
                this.remove(index);
            };
            /**
             * Returns a array representing the collection
             * @method toArray
             * @returns T[]
             */
            Collection.prototype.toArray = function () {
                return this.internalArray.slice(0, this.endPointer);
            };
            /**
             * Iterate over every element in the collection
             * @method forEach
             * @param func {(T,number)=>any} Callback to call for each element passing a reference to the element and its index, returned values are ignored
             */
            Collection.prototype.forEach = function (func) {
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    func.call(this, this.internalArray[i], i);
                }
            };
            /**
             * Mutate every element in the collection
             * @method map
             * @param func {(T,number)=>any} Callback to call for each element passing a reference to the element and its index, any values returned mutate the collection
             */
            Collection.prototype.map = function (func) {
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    this.internalArray[i] = func.call(this, this.internalArray[i], i);
                }
            };
            /**
             * Default collection size
             * @property DefaultSize {number}
             * @static
             * @final
             */
            Collection.DefaultSize = 200;
            return Collection;
        })();
        Util.Collection = Collection;
    })(Util = ex.Util || (ex.Util = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * A Sprite is one of the main drawing primitives. It is responsible for drawing
     * images or parts of images known as Textures to the screen.
     * @class Sprite
     * @constructor
     * @param image {Texture} The backing image texture to build the Sprite
     * @param sx {number} The x position of the sprite
     * @param sy {number} The y position of the sprite
     * @param swidth {number} The width of the sprite in pixels
     * @param sheight {number} The height of the sprite in pixels
     */
    var Sprite = (function () {
        function Sprite(image, sx, sy, swidth, sheight) {
            var _this = this;
            this.sx = sx;
            this.sy = sy;
            this.swidth = swidth;
            this.sheight = sheight;
            this.scaleX = 1.0;
            this.scaleY = 1.0;
            this.rotation = 0.0;
            this.transformPoint = new ex.Point(0, 0);
            this.logger = ex.Logger.getInstance();
            this.flipVertical = false;
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.effects = [];
            this.internalImage = new Image();
            this.spriteCanvas = null;
            this.spriteCtx = null;
            this.pixelData = null;
            this.pixelsLoaded = false;
            this.dirtyEffect = false;
            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {
                this.logger.error("Sprite cannot have any negative dimensions x:", sx, "y:", sy, "width:", swidth, "height:", sheight);
            }
            this.texture = image;
            this.spriteCanvas = document.createElement('canvas');
            this.spriteCanvas.width = swidth;
            this.spriteCanvas.height = sheight;
            this.spriteCtx = this.spriteCanvas.getContext('2d');
            this.texture.loaded.then(function () {
                _this.spriteCanvas.width = _this.spriteCanvas.width || _this.texture.image.naturalWidth;
                _this.spriteCanvas.height = _this.spriteCanvas.height || _this.texture.image.naturalHeight;
                _this.loadPixels();
                _this.dirtyEffect = true;
            }).error(function (e) {
                _this.logger.error("Error loading texture ", _this.texture.path, e);
            });
            this.width = swidth;
            this.height = sheight;
        }
        Sprite.prototype.loadPixels = function () {
            if (this.texture.isLoaded() && !this.pixelsLoaded) {
                var clamp = ex.Util.clamp;
                var naturalWidth = this.texture.image.naturalWidth || 0;
                var naturalHeight = this.texture.image.naturalHeight || 0;
                if (this.swidth > naturalWidth) {
                    this.logger.warn("The sprite width", this.swidth, "exceeds the width", naturalWidth, "of the backing texture", this.texture.path);
                }
                if (this.sheight > naturalHeight) {
                    this.logger.warn("The sprite height", this.sheight, "exceeds the height", naturalHeight, "of the backing texture", this.texture.path);
                }
                this.spriteCtx.drawImage(this.texture.image, clamp(this.sx, 0, naturalWidth), clamp(this.sy, 0, naturalHeight), clamp(this.swidth, 0, naturalWidth), clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
                //this.pixelData = this.spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
                this.internalImage.src = this.spriteCanvas.toDataURL("image/png");
                this.pixelsLoaded = true;
            }
        };
        /**
         * Adds a new {{#crossLink Effects.ISpriteEffect}}{{/crossLink}} to this drawing.
         * @method addEffect
         * @param effect {Effects.ISpriteEffect} Effect to add to the this drawing
         */
        Sprite.prototype.addEffect = function (effect) {
            this.effects.push(effect);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this.texture.isLoaded() || !this.pixelsLoaded) {
                this.dirtyEffect = true;
            }
            else {
                this.applyEffects();
            }
        };
        Sprite.prototype.removeEffect = function (param) {
            var indexToRemove = null;
            if (typeof param === 'number') {
                indexToRemove = param;
            }
            else {
                indexToRemove = this.effects.indexOf(param);
            }
            this.effects.splice(indexToRemove, 1);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this.texture.isLoaded() || !this.pixelsLoaded) {
                this.dirtyEffect = true;
            }
            else {
                this.applyEffects();
            }
        };
        Sprite.prototype.applyEffects = function () {
            var _this = this;
            var clamp = ex.Util.clamp;
            var naturalWidth = this.texture.image.naturalWidth || 0;
            var naturalHeight = this.texture.image.naturalHeight || 0;
            this.spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this.spriteCtx.drawImage(this.texture.image, clamp(this.sx, 0, naturalWidth), clamp(this.sy, 0, naturalHeight), clamp(this.swidth, 0, naturalWidth), clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
            this.pixelData = this.spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
            this.effects.forEach(function (effect) {
                for (var y = 0; y < _this.sheight; y++) {
                    for (var x = 0; x < _this.swidth; x++) {
                        effect.updatePixel(x, y, _this.pixelData);
                    }
                }
            });
            this.spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this.spriteCtx.putImageData(this.pixelData, 0, 0);
            this.internalImage.src = this.spriteCanvas.toDataURL("image/png");
        };
        /**
         * Clears all effects from the drawing and return it to its original state.
         * @method clearEffects
         */
        Sprite.prototype.clearEffects = function () {
            this.effects.length = 0;
            this.applyEffects();
        };
        /**
         * Sets the point about which to apply transformations to the drawing relative to the
         * top left corner of the drawing.
         * @method transformAbotPoint
         * @param point {Point} The point about which to apply transformations
         */
        Sprite.prototype.transformAboutPoint = function (point) {
            this.transformPoint = point;
        };
        /**
         * Sets the current rotation transformation for the drawing.
         * @method setRotation
         * @param radians {number} The rotation to apply to the drawing.
         */
        Sprite.prototype.setRotation = function (radians) {
            this.rotation = radians;
        };
        /**
         * Returns the current rotation for the drawing in radians.
         * @method getRotation
         * @returns number
         */
        Sprite.prototype.getRotation = function () {
            return this.rotation;
        };
        /**
         * Sets the scale trasformation in the x direction
         * @method setScale
         * @param scale {number} The magnitude to scale the drawing in the x direction
         */
        Sprite.prototype.setScaleX = function (scaleX) {
            this.scaleX = scaleX;
        };
        /**
         * Sets the scale trasformation in the x direction
         * @method setScale
         * @param scale {number} The magnitude to scale the drawing in the x direction
         */
        Sprite.prototype.setScaleY = function (scaleY) {
            this.scaleY = scaleY;
        };
        /**
         * Returns the current magnitude of the drawing's scale in the x direction
         * @method getScale
         * @returns number
         */
        Sprite.prototype.getScaleX = function () {
            return this.scaleX;
        };
        /**
         * Returns the current magnitude of the drawing's scale in the y direction
         * @method getScale
         * @returns number
         */
        Sprite.prototype.getScaleY = function () {
            return this.scaleY;
        };
        /**
         * Resets the internal state of the drawing (if any)
         * @method reset
         */
        Sprite.prototype.reset = function () {
            // do nothing
        };
        /**
         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The 2D rendering context
         * @param x {number} The x coordinate of where to draw
         * @param y {number} The y coordinate of where to draw
         */
        Sprite.prototype.draw = function (ctx, x, y) {
            if (this.dirtyEffect) {
                this.applyEffects();
                this.dirtyEffect = false;
            }
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            if (this.flipHorizontal) {
                ctx.translate(this.swidth, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, this.sheight);
                ctx.scale(1, -1);
            }
            if (this.internalImage) {
                ctx.drawImage(this.internalImage, 0, 0, this.swidth, this.sheight, -(this.transformPoint.x * this.swidth) * this.scaleX, -(this.transformPoint.y * this.sheight) * this.scaleY, this.swidth * this.scaleX, this.sheight * this.scaleY);
            }
            ctx.restore();
        };
        /**
         * Produces a copy of the current sprite
         * @method clone
         * @returns Sprite
         */
        Sprite.prototype.clone = function () {
            var result = new Sprite(this.texture, this.sx, this.sy, this.swidth, this.sheight);
            result.scaleX = this.scaleX;
            result.scaleY = this.scaleY;
            result.rotation = this.rotation;
            result.flipHorizontal = this.flipHorizontal;
            result.flipVertical = this.flipVertical;
            this.effects.forEach(function (e) {
                result.addEffect(e);
            });
            return result;
        };
        return Sprite;
    })();
    ex.Sprite = Sprite;
})(ex || (ex = {}));
/// <reference path="Sprite.ts" />
var ex;
(function (ex) {
    /**
     * SpriteSheets are a useful mechanism for slicing up image resources into
     * separate sprites or for generating in game animations. Sprites are organized
     * in row major order in the SpriteSheet.
     * @class SpriteSheet
     * @constructor
     * @param image {Texture} The backing image texture to build the SpriteSheet
     * @param columns {number} The number of columns in the image texture
     * @param rows {number} The number of rows in the image texture
     * @param spWidth {number} The width of each individual sprite in pixels
     * @param spHeight {number} The height of each individual sprite in pixels
     */
    var SpriteSheet = (function () {
        function SpriteSheet(image, columns, rows, spWidth, spHeight) {
            this.image = image;
            this.columns = columns;
            this.rows = rows;
            this.sprites = [];
            this.internalImage = image.image;
            this.sprites = new Array(columns * rows);
            // TODO: Inspect actual image dimensions with preloading
            /*if(spWidth * columns > this.internalImage.naturalWidth){
               throw new Error("SpriteSheet specified is wider than image width");
            }
   
            if(spHeight * rows > this.internalImage.naturalHeight){
               throw new Error("SpriteSheet specified is higher than image height");
            }*/
            var i = 0;
            var j = 0;
            for (i = 0; i < rows; i++) {
                for (j = 0; j < columns; j++) {
                    this.sprites[j + i * columns] = new ex.Sprite(this.image, j * spWidth, i * spHeight, spWidth, spHeight);
                }
            }
        }
        /**
         * Create an animation from the this SpriteSheet by listing out the
         * sprite indices. Sprites are organized in row major order in the SpriteSheet.
         * @method getAnimationByIndices
         * @param engine {Engine} Reference to the current game Engine
         * @param indices {number[]} An array of sprite indices to use in the animation
         * @param speed {number} The number in milliseconds to display each frame in the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationByIndices = function (engine, indices, speed) {
            var _this = this;
            var images = indices.map(function (index) {
                return _this.sprites[index];
            });
            images = images.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, images, speed);
        };
        /**
         * Create an animation from the this SpriteSheet by specifing the range of
         * images with the beginning and ending index
         * @method getAnimationBetween
         * @param engine {Engine} Reference to the current game Engine
         * @param beginIndex {number} The index to start taking frames
         * @param endIndex {number} The index to stop taking frames
         * @param speed {number} The number in milliseconds to display each frame in the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {
            var images = this.sprites.slice(beginIndex, endIndex);
            images = images.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, images, speed);
        };
        /**
         * Treat the entire SpriteSheet as one animation, organizing the frames in
         * row major order.
         * @method getAnimationForAll
         * @param engine {Engine} Reference to the current game Engine
         * @param speed {number} The number in milliseconds to display each frame the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationForAll = function (engine, speed) {
            var sprites = this.sprites.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, sprites, speed);
        };
        /**
         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized
         * in row major order in the SpriteSheet.
         * @method getSprite
         * @param index {number} The index of the sprite
         * @returns Sprite
         */
        SpriteSheet.prototype.getSprite = function (index) {
            if (index >= 0 && index < this.sprites.length) {
                return this.sprites[index];
            }
        };
        return SpriteSheet;
    })();
    ex.SpriteSheet = SpriteSheet;
    /**
     * SpriteFonts are a used in conjunction with a {{#crossLink Label}}{{/crossLink}} to specify
     * a particular bitmap as a font.
     * @class SpriteFont
     * @extends SpriteSheet
     * @constructor
     * @param image {Texture} The backing image texture to build the SpriteFont
     * @param alphabet {string} A string representing all the charaters in the image, in row major order.
     * @param caseInsensitve {boolean} Indicate whether this font takes case into account
     * @param columns {number} The number of columns of characters in the image
     * @param rows {number} The number of rows of characters in the image
     * @param spWdith {number} The width of each character in pixels
     * @param spHeight {number} The height of each character in pixels
     */
    var SpriteFont = (function (_super) {
        __extends(SpriteFont, _super);
        function SpriteFont(image, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            _super.call(this, image, columns, rows, spWidth, spHeight);
            this.image = image;
            this.alphabet = alphabet;
            this.caseInsensitive = caseInsensitive;
            this.spriteLookup = {};
            this.colorLookup = {};
            this._currentColor = ex.Color.Black;
        }
        /**
         * Returns a dictionary that maps each character in the alphabet to the appropriate Sprite.
         * @method getTextSprites
         * @returns {Object}
         */
        SpriteFont.prototype.getTextSprites = function () {
            var lookup = {};
            for (var i = 0; i < this.alphabet.length; i++) {
                var char = this.alphabet[i];
                if (this.caseInsensitive) {
                    char = char.toLowerCase();
                }
                lookup[char] = this.sprites[i].clone();
            }
            return lookup;
        };
        return SpriteFont;
    })(SpriteSheet);
    ex.SpriteFont = SpriteFont;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="SpriteSheet.ts" />
var ex;
(function (ex) {
    var TileSprite = (function () {
        function TileSprite(spriteSheetKey, spriteId) {
            this.spriteSheetKey = spriteSheetKey;
            this.spriteId = spriteId;
        }
        return TileSprite;
    })();
    ex.TileSprite = TileSprite;
    /**
     * A light-weight object that occupies a space in a collision map. Generally
     * created by a CollisionMap.
     * @class Cell
     * @constructor
     * @param x {number}
     * @param y {number}
     * @param width {number}
     * @param height {number}
     * @param index {number}
     * @param [solid=false] {boolean}
     * @param [spriteId=-1] {number}
     */
    var Cell = (function () {
        function Cell(
            /**
             * Gets or sets x coordinate of the cell in world coordinates
             * @property x {number}
             */
            x, 
            /**
             * Gets or sets y coordinate of the cell in world coordinates
             * @property y {number}
             */
            y, 
            /**
             * Gets or sets the width of the cell
             * @property width {number}
             */
            width, 
            /**
             * Gets or sets the height of the cell
             * @property height {number}
             */
            height, 
            /**
             * The index of the cell in row major order
             * @property index {number}
             */
            index, 
            /**
             * Gets or sets whether this cell is solid
             * @property solid {boolean}
             */
            solid, 
            /**
             * The index of the sprite to use from the CollisionMap SpriteSheet, if -1 is specified nothing is drawn.
             * @property number {number}
             */
            sprites) {
            if (solid === void 0) { solid = false; }
            if (sprites === void 0) { sprites = []; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.index = index;
            this.solid = solid;
            this.sprites = sprites;
            this._bounds = new ex.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
        }
        /**
         * Returns the bounding box for this cell
         * @method getBounds
         * @returns BoundingBox
         */
        Cell.prototype.getBounds = function () {
            return this._bounds;
        };
        Cell.prototype.getCenter = function () {
            return new ex.Vector(this.x + this.width / 2, this.y + this.height / 2);
        };
        Cell.prototype.pushSprite = function (tileSprite) {
            this.sprites.push(tileSprite);
        };
        Cell.prototype.removeSprite = function (tileSprite) {
            var index = -1;
            if ((index = this.sprites.indexOf(tileSprite)) > -1) {
                this.sprites.splice(index, 1);
            }
        };
        Cell.prototype.clearSprites = function () {
            this.sprites.length = 0;
        };
        return Cell;
    })();
    ex.Cell = Cell;
    /**
     * The CollisionMap object provides a lightweight way to do large complex scenes with collision
     * without the overhead of actors.
     * @class CollisionMap
     * @constructor
     * @param x {number} The x coordinate to anchor the collision map's upper left corner (should not be changed once set)
     * @param y {number} The y coordinate to anchor the collision map's upper left corner (should not be changed once set)
     * @param cellWidth {number} The individual width of each cell (in pixels) (should not be changed once set)
     * @param cellHeight {number} The individual height of each cell (in pixels) (should not be changed once set)
     * @param rows {number} The number of rows in the collision map (should not be changed once set)
     * @param cols {number} The number of cols in the collision map (should not be changed once set)
     * @param spriteSheet {SpriteSheet} The spriteSheet to use for drawing
     */
    var TileMap = (function () {
        function TileMap(x, y, cellWidth, cellHeight, rows, cols) {
            var _this = this;
            this.x = x;
            this.y = y;
            this.cellWidth = cellWidth;
            this.cellHeight = cellHeight;
            this.rows = rows;
            this.cols = cols;
            this._collidingX = -1;
            this._collidingY = -1;
            this._onScreenXStart = 0;
            this._onScreenXEnd = 9999;
            this._onScreenYStart = 0;
            this._onScreenYEnd = 9999;
            this._spriteSheets = {};
            this.logger = ex.Logger.getInstance();
            this.data = [];
            this.data = new Array(rows * cols);
            for (var i = 0; i < cols; i++) {
                for (var j = 0; j < rows; j++) {
                    (function () {
                        var cd = new Cell(i * cellWidth + x, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                        _this.data[i + j * cols] = cd;
                    })();
                }
            }
        }
        TileMap.prototype.registerSpriteSheet = function (key, spriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        };
        /**
         * Returns the intesection vector that can be used to resolve collisions with actors. If there
         * is no collision null is returned.
         * @method collides
         * @param actor {Actor}
         * @returns Vector
         */
        TileMap.prototype.collides = function (actor) {
            var points = [];
            var width = actor.x + actor.getWidth();
            var height = actor.y + actor.getHeight();
            var actorBounds = actor.getBounds();
            var overlaps = [];
            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {
                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {
                    var cell = this.getCellByPoint(x, y);
                    if (cell && cell.solid) {
                        var overlap = actorBounds.collides(cell.getBounds());
                        var dir = actor.getCenter().minus(cell.getCenter());
                        if (overlap && overlap.dot(dir) > 0) {
                            overlaps.push(overlap);
                        }
                    }
                }
            }
            if (overlaps.length === 0) {
                return null;
            }
            // Return the smallest change other than zero
            var result = overlaps.reduce(function (accum, next) {
                var x = accum.x;
                var y = accum.y;
                if (Math.abs(accum.x) < Math.abs(next.x)) {
                    x = next.x;
                }
                if (Math.abs(accum.y) < Math.abs(next.y)) {
                    y = next.y;
                }
                return new ex.Vector(x, y);
            });
            return result;
        };
        /*
        public collidesActor(actor: Actor): boolean{
           
           var points: Point[] = [];
           var width = actor.x + actor.getWidth();
           var height = actor.y + actor.getHeight();
           for(var x = actor.x; x <= width; x += Math.min(actor.getWidth()/2,this.cellWidth/2)){
              for(var y = actor.y; y <= height; y += Math.min(actor.getHeight()/2, this.cellHeight/2)){
                 points.push(new Point(x,y))
              }
           }
  
           var result = points.some((p) => {
              return this.collidesPoint(p.x, p.y);
           });
  
           return result;
  
        }*/
        /*
        public collidesPoint(x: number, y: number): boolean{
           var x = Math.floor(x/this.cellWidth);// - Math.floor(this.x/this.cellWidth);
           var y = Math.floor(y/this.cellHeight);
  
  
           var cell = this.getCell(x, y);
           if(x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell){
              if(cell.solid){
                 this._collidingX = x;
                 this._collidingY = y;
              }
              return cell.solid;
           }
  
  
  
           
           return false;
        }*/
        /**
         * Returns the cell by index (row major order)
         * @method getCellByIndex
         * @param index {number}
         * @returns Cell
         */
        TileMap.prototype.getCellByIndex = function (index) {
            return this.data[index];
        };
        /**
         * Returns the cell by it's x and y coordinates
         * @method getCell
         * @param x {number}
         * @param y {number}
         * @returns Cell
         */
        TileMap.prototype.getCell = function (x, y) {
            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
                return null;
            }
            return this.data[x + y * this.cols];
        };
        /**
         * Returns the cell by testing a point in global coordinates,
         * returns null if no cell was found.
         * @method getCellByPoint
         * @param x {number}
         * @param y {number}
         * @returns Cell
         */
        TileMap.prototype.getCellByPoint = function (x, y) {
            var x = Math.floor((x - this.x) / this.cellWidth); // - Math.floor(this.x/this.cellWidth);
            var y = Math.floor((y - this.y) / this.cellHeight);
            var cell = this.getCell(x, y);
            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
                return cell;
            }
            return null;
        };
        TileMap.prototype.update = function (engine, delta) {
            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new ex.Point(0, 0));
            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new ex.Point(engine.width, engine.height));
            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);
            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);
            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
        };
        /**
         * Draws the collision map to the screen. Called by the Scene.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         * @param delta {number} The number of milliseconds since the last draw
         */
        TileMap.prototype.draw = function (ctx, delta) {
            var _this = this;
            ctx.save();
            ctx.translate(this.x, this.y);
            for (var x = this._onScreenXStart; x < Math.min(this._onScreenXEnd, this.cols); x++) {
                for (var y = this._onScreenYStart; y < Math.min(this._onScreenYEnd, this.rows); y++) {
                    this.getCell(x, y).sprites.filter(function (s) {
                        return s.spriteId > -1;
                    }).forEach(function (ts) {
                        var ss = _this._spriteSheets[ts.spriteSheetKey];
                        if (ss) {
                            var sprite = ss.getSprite(ts.spriteId);
                            if (sprite) {
                                sprite.draw(ctx, x * _this.cellWidth, y * _this.cellHeight);
                            }
                            else {
                                _this.logger.warn("Sprite does not exist for id", ts.spriteId, "in sprite sheet", ts.spriteSheetKey, sprite, ss);
                            }
                        }
                        else {
                            _this.logger.warn("Sprite sheet", ts.spriteSheetKey, "does not exist", ss);
                        }
                    });
                }
            }
            ctx.restore();
        };
        /**
         * Draws all the collision map's debug info. Called by the Scene.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         */
        TileMap.prototype.debugDraw = function (ctx) {
            var width = this.cols * this.cellWidth;
            var height = this.rows * this.cellHeight;
            ctx.save();
            ctx.strokeStyle = ex.Color.Red.toString();
            for (var x = 0; x < this.cols + 1; x++) {
                ctx.beginPath();
                ctx.moveTo(this.x + x * this.cellWidth, this.y);
                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
                ctx.stroke();
            }
            for (var y = 0; y < this.rows + 1; y++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + y * this.cellHeight);
                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
                ctx.stroke();
            }
            var solid = ex.Color.Red.clone();
            solid.a = .3;
            this.data.filter(function (cell) {
                return cell.solid;
            }).forEach(function (cell) {
                ctx.fillStyle = solid.toString();
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            });
            if (this._collidingY > -1 && this._collidingX > -1) {
                ctx.fillStyle = ex.Color.Cyan.toString();
                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
            }
            ctx.restore();
        };
        return TileMap;
    })();
    ex.TileMap = TileMap;
})(ex || (ex = {}));
/// <reference path="../Algebra.ts" />
var ex;
(function (ex) {
    (function (CollisionStrategy) {
        CollisionStrategy[CollisionStrategy["Naive"] = 0] = "Naive";
        CollisionStrategy[CollisionStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
        CollisionStrategy[CollisionStrategy["SeparatingAxis"] = 2] = "SeparatingAxis";
    })(ex.CollisionStrategy || (ex.CollisionStrategy = {}));
    var CollisionStrategy = ex.CollisionStrategy;
    /**
     * Axis Aligned collision primitive for Excalibur.
     * @class BoundingBox
     * @constructor
     * @param left {number} x coordinate of the left edge
     * @param top {number} y coordinate of the top edge
     * @param right {number} x coordinate of the right edge
     * @param bottom {number} y coordinate of the bottom edge
     */
    var BoundingBox = (function () {
        function BoundingBox(left, top, right, bottom) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        /**
         * Returns the calculated width of the bounding box
         * @method getWidth
         * @returns number
         */
        BoundingBox.prototype.getWidth = function () {
            return this.right - this.left;
        };
        /**
         * Returns the calculated height of the bounding box
         * @method getHeight
         * @returns number
         */
        BoundingBox.prototype.getHeight = function () {
            return this.bottom - this.top;
        };
        /**
         * Returns the perimeter of the bounding box
         * @method getPerimeter
         * @returns number
         */
        BoundingBox.prototype.getPerimeter = function () {
            var wx = this.getWidth();
            var wy = this.getHeight();
            return 2 * (wx + wy);
        };
        BoundingBox.prototype.contains = function (val) {
            if (val instanceof ex.Point) {
                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);
            }
            else if (val instanceof BoundingBox) {
                if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {
                    return true;
                }
                return false;
            }
            return false;
        };
        /**
         * Combines this bounding box and another together returning a new bounding box
         * @method combine
         * @param other {BoundingBox} The bounding box to combine
         * @returns BoundingBox
         */
        BoundingBox.prototype.combine = function (other) {
            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
            return compositeBB;
        };
        /**
         * Test wether this bounding box collides with another returning,
         * the intersection vector that can be used to resovle the collision. If there
         * is no collision null is returned.
         * @method collides
         * @param collidable {ICollidable} Other collidable to test
         * @returns Vector
         */
        BoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof BoundingBox) {
                var other = collidable;
                var totalBoundingBox = this.combine(other);
                // If the total bounding box is less than the sum of the 2 bounds then there is collision
                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() && totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {
                    // collision
                    var overlapX = 0;
                    if (this.right >= other.left && this.right <= other.right) {
                        overlapX = other.left - this.right;
                    }
                    else {
                        overlapX = other.right - this.left;
                    }
                    var overlapY = 0;
                    if (this.top <= other.bottom && this.top >= other.top) {
                        overlapY = other.bottom - this.top;
                    }
                    else {
                        overlapY = other.top - this.bottom;
                    }
                    if (Math.abs(overlapX) < Math.abs(overlapY)) {
                        return new ex.Vector(overlapX, 0);
                    }
                    else {
                        return new ex.Vector(0, overlapY);
                    }
                }
                else {
                    return null;
                }
            }
            return null;
        };
        BoundingBox.prototype.debugDraw = function (ctx) {
            ctx.lineWidth = 2;
            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());
        };
        return BoundingBox;
    })();
    ex.BoundingBox = BoundingBox;
    var SATBoundingBox = (function () {
        function SATBoundingBox(points) {
            this._points = points.map(function (p) { return p.toVector(); });
        }
        SATBoundingBox.prototype.getSides = function () {
            var lines = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                lines.push(new ex.Line(this._points[i], this._points[(i + 1) % len]));
            }
            return lines;
        };
        SATBoundingBox.prototype.getAxes = function () {
            var axes = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                axes.push(this._points[i].minus(this._points[(i + 1) % len]).normal());
            }
            return axes;
        };
        SATBoundingBox.prototype.project = function (axis) {
            var scalars = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                scalars.push(this._points[i].dot(axis));
            }
            return new ex.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /**
         * Returns the calculated width of the bounding box, by generating an axis aligned box around the current
         * @method getWidth
         * @returns number
         */
        SATBoundingBox.prototype.getWidth = function () {
            var left = this._points.reduce(function (accum, p, i, arr) {
                return Math.min(accum, p.x);
            }, Infinity);
            var right = this._points.reduce(function (accum, p, i, arr) {
                return Math.max(accum, p.x);
            }, -Infinity);
            return right - left;
        };
        /**
         * Returns the calculated height of the bounding box, by generating an axis aligned box around the current
         * @method getHeight
         * @returns number
         */
        SATBoundingBox.prototype.getHeight = function () {
            var top = this._points.reduce(function (accum, p, i, arr) {
                return Math.min(accum, p.y);
            }, Infinity);
            var bottom = this._points.reduce(function (accum, p, i, arr) {
                return Math.max(accum, p.y);
            }, -Infinity);
            return top - bottom;
        };
        /**
         * Tests wether a point is contained within the bounding box, using the PIP algorithm
         * http://en.wikipedia.org/wiki/Point_in_polygon
         * @method contains
         * @param p {Point} The point to test
         * @returns boolean
         */
        SATBoundingBox.prototype.contains = function (p) {
            // Always cast to the right, as long as we cast in a consitent fixed direction we
            // will be fine
            var testRay = new ex.Ray(p, new ex.Vector(1, 0));
            var intersectCount = this.getSides().reduce(function (accum, side, i, arr) {
                if (testRay.intersect(side) >= 0) {
                    return accum + 1;
                }
                return accum;
            }, 0);
            if (intersectCount % 2 === 0) {
                return false;
            }
            return true;
        };
        SATBoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof SATBoundingBox) {
                var other = collidable;
                var axes = this.getAxes();
                axes = other.getAxes().concat(axes);
                var minOverlap = 99999;
                var minAxis = null;
                for (var i = 0; i < axes.length; i++) {
                    var proj1 = this.project(axes[i]);
                    var proj2 = other.project(axes[i]);
                    var overlap = proj1.getOverlap(proj2);
                    if (overlap === 0) {
                        return null;
                    }
                    else {
                        if (overlap <= minOverlap) {
                            minOverlap = overlap;
                            minAxis = axes[i];
                        }
                    }
                }
                if (minAxis) {
                    return minAxis.normalize().scale(minOverlap);
                }
                else {
                    return null;
                }
            }
            return null;
        };
        SATBoundingBox.prototype.debugDraw = function (ctx) {
            ctx.beginPath();
            ctx.lineWidth = 2;
            // Iterate through the supplied points and contruct a 'polygon'
            var firstPoint = this._points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this._points.forEach(function (point) {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            ctx.strokeStyle = ex.Color.Blue.toString();
            ctx.stroke();
        };
        return SATBoundingBox;
    })();
    ex.SATBoundingBox = SATBoundingBox;
})(ex || (ex = {}));
/// <reference path="Events.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur base class
     * @class Class
     * @constructor
     */
    var Class = (function () {
        function Class() {
            this.eventDispatcher = new ex.EventDispatcher(this);
        }
        /**
         * Add an event listener. You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method addEventListener
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Class.prototype.addEventListener = function (eventName, handler) {
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * Removes an event listener. If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified just that handler will be removed.
         *
         * @method removeEventListener
         * @param eventName {string} Name of the event to listen for
         * @param [handler=undefined] {event=>void} Event handler for the thrown event
         */
        Class.prototype.removeEventListener = function (eventName, handler) {
            this.eventDispatcher.unsubscribe(eventName, handler);
        };
        /**
         * Alias for "addEventListener". You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method on
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Class.prototype.on = function (eventName, handler) {
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * Alias for "removeEventListener". If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified only that handler will be removed.
         *
         * @method off
         * @param eventName {string} Name of the event to listen for
         * @param [handler=undefined] {event=>void} Event handler for the thrown event
         */
        Class.prototype.off = function (eventName, handler) {
            this.eventDispatcher.unsubscribe(eventName, handler);
        };
        /**
         * You may wish to extend native Excalibur functionality. Any method on
         * actor may be extended to support additional functionaliy. In the
         * example below we create a new type called "MyActor"
         * <br/><b>Example</b><pre>var MyActor = Actor.extend({
     constructor : function(){
        this.newprop = 'something';
        Actor.apply(this, arguments);
     },
     update : function(engine, delta){
        // Implement custom update
  
           // Call super constructor update
           Actor.prototype.update.call(this, engine, delta);
           console.log("Something cool!");
     }
  });
  var myActor = new MyActor(100, 100, 100, 100, Color.Azure);</pre>
         * @method extend
         * @static
         * @param methods {any}
         */
        Class.extend = function (methods) {
            var parent = this;
            var child;
            if (methods && methods.hasOwnProperty('constructor')) {
                child = methods.constructor;
            }
            else {
                child = function () {
                    return parent.apply(this, arguments);
                };
            }
            // Using constructor allows JS to lazily instantiate super classes
            var Super = function () {
                this.constructor = child;
            };
            Super.prototype = parent.prototype;
            child.prototype = new Super;
            if (methods) {
                for (var prop in methods) {
                    if (methods.hasOwnProperty(prop)) {
                        child.prototype[prop] = methods[prop];
                    }
                }
            }
            // Make subclasses extendable
            child.extend = Class.extend;
            return child;
        };
        return Class;
    })();
    ex.Class = Class;
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Timer = (function () {
        /**
         * The Excalibur timer hooks into the internal timer and fires callbacks, after a certain interval, optionally repeating.
         *
         * @class Timer
         * @constructor
         * @param callback {callback} The callback to be fired after the interval is complete.
         * @param [repeats=false] {boolean} Indicates whether this call back should be fired only once, or repeat after every interval as completed.
         */
        function Timer(fcn, interval, repeats) {
            this.id = 0;
            this.interval = 10;
            this.fcn = function () {
            };
            this.repeats = false;
            this.elapsedTime = 0;
            this._totalTimeAlive = 0;
            this.complete = false;
            this.scene = null;
            this.id = Timer.id++;
            this.interval = interval || this.interval;
            this.fcn = fcn || this.fcn;
            this.repeats = repeats || this.repeats;
        }
        /**
         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
         * @method update
         * @param delta {number} Number of elapsed milliseconds since the last update.
         */
        Timer.prototype.update = function (delta) {
            this._totalTimeAlive += delta;
            this.elapsedTime += delta;
            if (this.elapsedTime > this.interval) {
                this.fcn.call(this);
                if (this.repeats) {
                    this.elapsedTime = 0;
                }
                else {
                    this.complete = true;
                }
            }
        };
        Timer.prototype.getTimeRunning = function () {
            return this._totalTimeAlive;
        };
        /**
         * Cancels the timer, preventing any further executions.
         * @method cancel
         */
        Timer.prototype.cancel = function () {
            if (this.scene) {
                this.scene.cancelTimer(this);
            }
        };
        Timer.id = 0;
        return Timer;
    })();
    ex.Timer = Timer;
})(ex || (ex = {}));
/// <reference path="../Actor.ts"/>
/// <reference path="Side.ts"/>
/// <reference path="ICollisionResolver.ts"/> 
var ex;
(function (ex) {
    var NaiveCollisionResolver = (function () {
        function NaiveCollisionResolver() {
        }
        NaiveCollisionResolver.prototype.register = function (target) {
            // pass
        };
        NaiveCollisionResolver.prototype.remove = function (tartet) {
            // pass
        };
        NaiveCollisionResolver.prototype.evaluate = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== 0 /* PreventCollision */;
            });
            var actor1;
            var actor2;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor1 = potentialColliders[j];
                for (var i = j + 1; i < l; i++) {
                    actor2 = potentialColliders[i];
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor1.collides(actor2)) {
                        var side = actor1.getSideFromIntersect(minimumTranslationVector);
                        var collisionPair = new ex.CollisionPair(actor1, actor2, minimumTranslationVector, side);
                        if (!collisionPairs.some(function (cp) {
                            return cp.equals(collisionPair);
                        })) {
                            collisionPairs.push(collisionPair);
                        }
                    }
                }
            }
            collisionPairs.forEach(function (p) { return p.evaluate(); });
            return collisionPairs;
        };
        NaiveCollisionResolver.prototype.update = function (targets) {
            return 0;
        };
        NaiveCollisionResolver.prototype.debugDraw = function (ctx, delta) {
        };
        return NaiveCollisionResolver;
    })();
    ex.NaiveCollisionResolver = NaiveCollisionResolver;
})(ex || (ex = {}));
/// <reference path="BoundingBox.ts"/>
var ex;
(function (ex) {
    var TreeNode = (function () {
        function TreeNode(parent) {
            this.parent = parent;
            this.parent = parent || null;
            this.actor = null;
            this.bounds = new ex.BoundingBox();
            this.left = null;
            this.right = null;
            this.height = 0;
        }
        TreeNode.prototype.isLeaf = function () {
            return (!this.left && !this.right);
        };
        return TreeNode;
    })();
    ex.TreeNode = TreeNode;
    var DynamicTree = (function () {
        function DynamicTree() {
            this.root = null;
            this.nodes = {};
        }
        DynamicTree.prototype.insert = function (leaf) {
            // If there are no nodes in the tree, make this the root leaf
            if (this.root === null) {
                this.root = leaf;
                this.root.parent = null;
                return;
            }
            // Search the tree for a node that is not a leaf and find the best place to insert
            var leafAABB = leaf.bounds;
            var currentRoot = this.root;
            while (!currentRoot.isLeaf()) {
                var left = currentRoot.left;
                var right = currentRoot.right;
                var area = currentRoot.bounds.getPerimeter();
                var combinedAABB = currentRoot.bounds.combine(leafAABB);
                var combinedArea = combinedAABB.getPerimeter();
                // Calculate cost heuristic for creating a new parent and leaf
                var cost = 2 * combinedArea;
                // Minimum cost of pushing the leaf down the tree
                var inheritanceCost = 2 * (combinedArea - area);
                // Cost of descending
                var leftCost = 0;
                var leftCombined = leafAABB.combine(left.bounds);
                var newArea;
                var oldArea;
                if (left.isLeaf()) {
                    leftCost = leftCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = left.bounds.getPerimeter();
                    newArea = leftCombined.getPerimeter();
                    leftCost = (newArea - oldArea) + inheritanceCost;
                }
                var rightCost = 0;
                var rightCombined = leafAABB.combine(right.bounds);
                if (right.isLeaf()) {
                    rightCost = rightCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = right.bounds.getPerimeter();
                    newArea = rightCombined.getPerimeter();
                    rightCost = (newArea - oldArea) + inheritanceCost;
                }
                // cost is acceptable
                if (cost < leftCost && cost < rightCost) {
                    break;
                }
                // Descend to the depths
                if (leftCost < rightCost) {
                    currentRoot = left;
                }
                else {
                    currentRoot = right;
                }
            }
            // Create the new parent node and insert into the tree
            var oldParent = currentRoot.parent;
            var newParent = new TreeNode(oldParent);
            newParent.bounds = leafAABB.combine(currentRoot.bounds);
            newParent.height = currentRoot.height + 1;
            if (oldParent !== null) {
                // The sibling node was not the root
                if (oldParent.left === currentRoot) {
                    oldParent.left = newParent;
                }
                else {
                    oldParent.right = newParent;
                }
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling node was the root
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
                this.root = newParent;
            }
            // Walk up the tree fixing heights and AABBs
            var currentNode = leaf.parent;
            while (currentNode) {
                currentNode = this.balance(currentNode);
                if (!currentNode.left) {
                    throw new Error("Parent of current leaf cannot have a null left child" + currentNode);
                }
                if (!currentNode.right) {
                    throw new Error("Parent of current leaf cannot have a null right child" + currentNode);
                }
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode = currentNode.parent;
            }
        };
        DynamicTree.prototype.remove = function (leaf) {
            if (leaf === this.root) {
                this.root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.left === leaf) {
                sibling = parent.right;
            }
            else {
                sibling = parent.left;
            }
            if (grandParent) {
                if (grandParent.left === parent) {
                    grandParent.left = sibling;
                }
                else {
                    grandParent.right = sibling;
                }
                sibling.parent = grandParent;
                var currentNode = grandParent;
                while (currentNode) {
                    currentNode = this.balance(currentNode);
                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                    currentNode = currentNode.parent;
                }
            }
            else {
                this.root = sibling;
                sibling.parent = null;
            }
        };
        DynamicTree.prototype.registerActor = function (actor) {
            var node = new TreeNode();
            node.actor = actor;
            node.bounds = actor.getBounds();
            node.bounds.left -= 2;
            node.bounds.top -= 2;
            node.bounds.right += 2;
            node.bounds.bottom += 2;
            this.nodes[actor.id] = node;
            this.insert(node);
        };
        DynamicTree.prototype.updateActor = function (actor) {
            var node = this.nodes[actor.id];
            if (!node)
                return;
            var b = actor.getBounds();
            if (node.bounds.contains(b)) {
                return false;
            }
            this.remove(node);
            b.left -= 5;
            b.top -= 5;
            b.right += 5;
            b.bottom += 5;
            var multdx = actor.dx * 2;
            var multdy = actor.dy * 2;
            if (multdx < 0) {
                b.left += multdx;
            }
            else {
                b.right += multdx;
            }
            if (multdy < 0) {
                b.top += multdy;
            }
            else {
                b.bottom += multdy;
            }
            node.bounds = b;
            this.insert(node);
            return true;
        };
        DynamicTree.prototype.removeActor = function (actor) {
            var node = this.nodes[actor.id];
            if (!node)
                return;
            this.remove(node);
            this.nodes[actor.id] = null;
            delete this.nodes[actor.id];
        };
        DynamicTree.prototype.balance = function (node) {
            if (node === null) {
                throw new Error("Cannot balance at null node");
            }
            if (node.isLeaf() || node.height < 2) {
                return node;
            }
            var left = node.left;
            var right = node.right;
            var a = node;
            var b = left;
            var c = right;
            var d = left.left;
            var e = left.right;
            var f = right.left;
            var g = right.right;
            var balance = c.height - b.height;
            // Rotate c node up
            if (balance > 1) {
                // Swap the right node with it's parent
                c.left = a;
                c.parent = a.parent;
                a.parent = c;
                // The original node's old parent should point to the right node
                // this is mega confusing
                if (c.parent) {
                    if (c.parent.left === a) {
                        c.parent.left = c;
                    }
                    else {
                        c.parent.right = c;
                    }
                }
                else {
                    this.root = c;
                }
                // Rotate
                if (f.height > g.height) {
                    c.right = f;
                    a.right = g;
                    g.parent = a;
                    a.bounds = b.bounds.combine(g.bounds);
                    c.bounds = a.bounds.combine(f.bounds);
                    a.height = 1 + Math.max(b.height, g.height);
                    c.height = 1 + Math.max(a.height, f.height);
                }
                else {
                    c.right = g;
                    a.right = f;
                    f.parent = a;
                    a.bounds = b.bounds.combine(f.bounds);
                    c.bounds = a.bounds.combine(g.bounds);
                    a.height = 1 + Math.max(b.height, f.height);
                    c.height = 1 + Math.max(a.height, g.height);
                }
                return c;
            }
            // Rotate left node up
            if (balance < -1) {
                // swap
                b.left = a;
                b.parent = a.parent;
                a.parent = b;
                // node's old parent should point to b
                if (b.parent) {
                    if (b.parent.left === a) {
                        b.parent.left = b;
                    }
                    else {
                        if (b.parent.right !== a)
                            throw "Error rotating Dynamic Tree";
                        b.parent.right = b;
                    }
                }
                else {
                    this.root = b;
                }
                // rotate
                if (d.height > e.height) {
                    b.right = d;
                    a.left = e;
                    e.parent = a;
                    a.bounds = c.bounds.combine(e.bounds);
                    b.bounds = a.bounds.combine(d.bounds);
                    a.height = 1 + Math.max(c.height, e.height);
                    b.height = 1 + Math.max(a.height, d.height);
                }
                else {
                    b.right = e;
                    a.left = d;
                    d.parent = a;
                    a.bounds = c.bounds.combine(d.bounds);
                    b.bounds = a.bounds.combine(e.bounds);
                    a.height = 1 + Math.max(c.height, d.height);
                    b.height = 1 + Math.max(a.height, e.height);
                }
                return b;
            }
            return node;
        };
        DynamicTree.prototype.getHeight = function () {
            if (this.root === null) {
                return 0;
            }
            return this.root.height;
        };
        DynamicTree.prototype.query = function (actor, callback) {
            var bounds = actor.getBounds();
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.collides(bounds)) {
                    if (currentNode.isLeaf() && currentNode.actor !== actor) {
                        if (callback.call(actor, currentNode.actor)) {
                            return true;
                        }
                    }
                    else {
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                else {
                    return null;
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.rayCast = function (ray, max) {
            // todo implement
            return null;
        };
        DynamicTree.prototype.getNodes = function () {
            var helper = function (currentNode) {
                if (currentNode) {
                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
                }
                else {
                    return [];
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.debugDraw = function (ctx, delta) {
            // draw all the nodes in the Dynamic Tree
            var helper = function (currentNode) {
                if (currentNode) {
                    if (currentNode.isLeaf()) {
                        ctx.strokeStyle = 'green';
                    }
                    else {
                        ctx.strokeStyle = 'white';
                    }
                    currentNode.bounds.debugDraw(ctx);
                    if (currentNode.left)
                        helper(currentNode.left);
                    if (currentNode.right)
                        helper(currentNode.right);
                }
            };
            helper(this.root);
        };
        return DynamicTree;
    })();
    ex.DynamicTree = DynamicTree;
})(ex || (ex = {}));
/// <reference path="ICollisionResolver.ts"/>
/// <reference path="DynamicTree.ts"/>
var ex;
(function (ex) {
    var DynamicTreeCollisionResolver = (function () {
        function DynamicTreeCollisionResolver() {
            this._dynamicCollisionTree = new ex.DynamicTree();
        }
        DynamicTreeCollisionResolver.prototype.register = function (target) {
            this._dynamicCollisionTree.registerActor(target);
        };
        DynamicTreeCollisionResolver.prototype.remove = function (target) {
            this._dynamicCollisionTree.removeActor(target);
        };
        DynamicTreeCollisionResolver.prototype.evaluate = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== 0 /* PreventCollision */;
            });
            var actor;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor = potentialColliders[j];
                this._dynamicCollisionTree.query(actor, function (other) {
                    if (other.collisionType === 0 /* PreventCollision */ || other.isKilled())
                        return false;
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor.collides(other)) {
                        var side = actor.getSideFromIntersect(minimumTranslationVector);
                        var collisionPair = new ex.CollisionPair(actor, other, minimumTranslationVector, side);
                        if (!collisionPairs.some(function (cp) {
                            return cp.equals(collisionPair);
                        })) {
                            collisionPairs.push(collisionPair);
                        }
                        return true;
                    }
                    return false;
                });
            }
            collisionPairs.forEach(function (p) { return p.evaluate(); });
            return collisionPairs;
        };
        DynamicTreeCollisionResolver.prototype.update = function (targets) {
            var _this = this;
            var updated = 0;
            targets.forEach(function (a) {
                if (_this._dynamicCollisionTree.updateActor(a)) {
                    updated++;
                }
            });
            return updated;
        };
        DynamicTreeCollisionResolver.prototype.debugDraw = function (ctx, delta) {
            this._dynamicCollisionTree.debugDraw(ctx, delta);
        };
        return DynamicTreeCollisionResolver;
    })();
    ex.DynamicTreeCollisionResolver = DynamicTreeCollisionResolver;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Collision pairs are used internally by Excalibur to resolve collision between actors. The
     * Pair prevents collisions from being evaluated more than one time
     * @class CollisionPair
     * @constructor
     * @param left {Actor} The first actor in the collision pair
     * @param right {Actor} The second actor in the collision pair
     * @param intersect {Vector} The minimum translation vector to separate the actors from the perspective of the left actor
     * @param side {Side} The side on which the collision occured from the perspective of the left actor
     */
    var CollisionPair = (function () {
        function CollisionPair(left, right, intersect, side) {
            this.left = left;
            this.right = right;
            this.intersect = intersect;
            this.side = side;
        }
        /**
         * Determines if this collision pair and another are equivalent.
         * @method equals
         * @param collisionPair {CollisionPair}
         * @returns boolean
         */
        CollisionPair.prototype.equals = function (collisionPair) {
            return (collisionPair.left === this.left && collisionPair.right === this.right) || (collisionPair.right === this.left && collisionPair.left === this.right);
        };
        /**
         * Evaluates the collision pair, performing collision resolution and event publishing appropriate to each collision type.
         * @method evaluate
         */
        CollisionPair.prototype.evaluate = function () {
            // todo fire collision events on left and right actor
            // todo resolve collisions                  
            // Publish collision events on both participants
            this.left.eventDispatcher.publish('collision', new ex.CollisionEvent(this.left, this.right, this.side, this.intersect));
            this.right.eventDispatcher.publish('collision', new ex.CollisionEvent(this.right, this.left, ex.Util.getOppositeSide(this.side), this.intersect.scale(-1.0)));
            // If the actor is active push the actor out if its not passive
            var leftSide = this.side;
            if ((this.left.collisionType === 2 /* Active */ || this.left.collisionType === 3 /* Elastic */) && this.right.collisionType !== 1 /* Passive */) {
                this.left.y += this.intersect.y;
                this.left.x += this.intersect.x;
                // Naive elastic bounce
                if (this.left.collisionType === 3 /* Elastic */) {
                    if (leftSide === 3 /* Left */) {
                        this.left.dx = Math.abs(this.left.dx);
                    }
                    else if (leftSide === 4 /* Right */) {
                        this.left.dx = -Math.abs(this.left.dx);
                    }
                    else if (leftSide === 1 /* Top */) {
                        this.left.dy = Math.abs(this.left.dy);
                    }
                    else if (leftSide === 2 /* Bottom */) {
                        this.left.dy = -Math.abs(this.left.dy);
                    }
                }
            }
            var rightSide = ex.Util.getOppositeSide(this.side);
            var rightIntersect = this.intersect.scale(-1.0);
            if ((this.right.collisionType === 2 /* Active */ || this.right.collisionType === 3 /* Elastic */) && this.left.collisionType !== 1 /* Passive */) {
                this.right.y += rightIntersect.y;
                this.right.x += rightIntersect.x;
                // Naive elastic bounce
                if (this.right.collisionType === 3 /* Elastic */) {
                    if (rightSide === 3 /* Left */) {
                        this.right.dx = Math.abs(this.right.dx);
                    }
                    else if (rightSide === 4 /* Right */) {
                        this.right.dx = -Math.abs(this.right.dx);
                    }
                    else if (rightSide === 1 /* Top */) {
                        this.right.dy = Math.abs(this.right.dy);
                    }
                    else if (rightSide === 2 /* Bottom */) {
                        this.right.dy = -Math.abs(this.right.dy);
                    }
                }
            }
        };
        return CollisionPair;
    })();
    ex.CollisionPair = CollisionPair;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Algebra.ts" />
var ex;
(function (ex) {
    /**
    * A base implementation of a camera. This class is meant to be extended.
    * @class Camera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var BaseCamera = (function () {
        function BaseCamera() {
            this.focus = new ex.Point(0, 0);
            this.lerp = false;
            this._cameraMoving = false;
            this._currentLerpTime = 0;
            this._lerpDuration = 1 * 1000; // 5 seconds
            this._totalLerpTime = 0;
            this._lerpStart = null;
            this._lerpEnd = null;
            //camera effects
            this.isShaking = false;
            this.shakeMagnitudeX = 0;
            this.shakeMagnitudeY = 0;
            this.shakeDuration = 0;
            this.elapsedShakeTime = 0;
            this.isZooming = false;
            this.currentZoomScale = 1;
            this.maxZoomScale = 1;
            this.zoomDuration = 0;
            this.elapsedZoomTime = 0;
            this.zoomIncrement = 0.01;
        }
        BaseCamera.prototype.easeInOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime * currentTime + startValue;
            currentTime -= 2;
            return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
        };
        /**
        * Sets the {{#crossLink Actor}}{{/crossLink}} to follow with the camera
        * @method setActorToFollow
        * @param actor {Actor} The actor to follow
        */
        BaseCamera.prototype.setActorToFollow = function (actor) {
            this.follow = actor;
        };
        /**
        * Returns the focal point of the camera
        * @method getFocus
        * @returns Point
        */
        BaseCamera.prototype.getFocus = function () {
            return this.focus;
        };
        /**
        * Sets the focal point of the camera. This value can only be set if there is no actor to be followed.
        * @method setFocus
        * @param x {number} The x coordinate of the focal point
        * @param y {number} The y coordinate of the focal point
        */
        BaseCamera.prototype.setFocus = function (x, y) {
            if (!this.follow && !this.lerp) {
                this.focus.x = x;
                this.focus.y = y;
            }
            if (this.lerp) {
                this._lerpStart = this.focus.clone();
                this._lerpEnd = new ex.Point(x, y);
                this._currentLerpTime = 0;
                this._cameraMoving = true;
            }
        };
        /**
        * Sets the camera to shake at the specified magnitudes for the specified duration
        * @method shake
        * @param magnitudeX {number} the x magnitude of the shake
        * @param magnitudeY {number} the y magnitude of the shake
        * @param duration {number} the duration of the shake
        */
        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {
            this.isShaking = true;
            this.shakeMagnitudeX = magnitudeX;
            this.shakeMagnitudeY = magnitudeY;
            this.shakeDuration = duration;
        };
        /**
        * Zooms the camera in or out by the specified scale over the specified duration.
        * If no duration is specified, it will zoom by a set amount until the scale is reached.
        * @method zoom
        * @param scale {number} the scale of the zoom
        * @param [duration] {number} the duration of the zoom
        */
        BaseCamera.prototype.zoom = function (scale, duration) {
            this.isZooming = true;
            this.maxZoomScale = scale;
            this.zoomDuration = duration | 0;
            if (duration) {
                this.zoomIncrement = Math.abs(this.maxZoomScale - this.currentZoomScale) / duration * 1000;
            }
            if (this.maxZoomScale < 1) {
                if (duration) {
                    this.zoomIncrement = -1 * this.zoomIncrement;
                }
                else {
                    this.isZooming = false;
                    this.setCurrentZoomScale(this.maxZoomScale);
                }
            }
            else {
                if (!duration) {
                    this.isZooming = false;
                    this.setCurrentZoomScale(this.maxZoomScale);
                }
            }
            // console.log("zoom increment: " + this.zoomIncrement);
        };
        /**
        * gets the current zoom scale
        * @method getZoom
        * @returns {Number} the current zoom scale
        */
        BaseCamera.prototype.getZoom = function () {
            return this.currentZoomScale;
        };
        BaseCamera.prototype.setCurrentZoomScale = function (zoomScale) {
            this.currentZoomScale = zoomScale;
        };
        /**
        * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
        * @method update
        * @param delta {number} The number of milliseconds since the last update
        */
        BaseCamera.prototype.update = function (ctx, delta) {
            var focus = this.getFocus();
            var xShake = 0;
            var yShake = 0;
            var canvasWidth = ctx.canvas.width;
            var canvasHeight = ctx.canvas.height;
            var newCanvasWidth = canvasWidth * this.getZoom();
            var newCanvasHeight = canvasHeight * this.getZoom();
            if (this.lerp) {
                if (this._currentLerpTime < this._lerpDuration && this._cameraMoving) {
                    if (this._lerpEnd.x < this._lerpStart.x) {
                        this.focus.x = this._lerpStart.x - (this.easeInOutCubic(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                    }
                    else {
                        this.focus.x = this.easeInOutCubic(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                    }
                    if (this._lerpEnd.y < this._lerpStart.y) {
                        this.focus.y = this._lerpStart.y - (this.easeInOutCubic(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                    }
                    else {
                        this.focus.y = this.easeInOutCubic(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                    }
                    this._currentLerpTime += delta;
                }
                else {
                    this._lerpStart = null;
                    this._lerpEnd = null;
                    this._currentLerpTime = 0;
                    this._cameraMoving = false;
                }
            }
            if (this.isDoneShaking()) {
                this.isShaking = false;
                this.elapsedShakeTime = 0;
                this.shakeMagnitudeX = 0;
                this.shakeMagnitudeY = 0;
                this.shakeDuration = 0;
            }
            else {
                this.elapsedShakeTime += delta;
                xShake = (Math.random() * this.shakeMagnitudeX | 0) + 1;
                yShake = (Math.random() * this.shakeMagnitudeY | 0) + 1;
            }
            ctx.translate(-focus.x + xShake + (newCanvasWidth / 2), -focus.y + yShake + (newCanvasHeight / 2));
            if (this.isDoneZooming()) {
                this.isZooming = false;
                this.elapsedZoomTime = 0;
                this.zoomDuration = 0;
                this.setCurrentZoomScale(this.maxZoomScale);
            }
            else {
                this.elapsedZoomTime += delta;
                this.setCurrentZoomScale(this.getZoom() + this.zoomIncrement * delta / 1000);
            }
            ctx.scale(this.getZoom(), this.getZoom());
        };
        BaseCamera.prototype.debugDraw = function (ctx) {
            var focus = this.getFocus();
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        BaseCamera.prototype.isDoneShaking = function () {
            return !(this.isShaking) || (this.elapsedShakeTime >= this.shakeDuration);
        };
        BaseCamera.prototype.isDoneZooming = function () {
            if (this.zoomDuration != 0) {
                return (this.elapsedZoomTime >= this.zoomDuration);
            }
            else {
                if (this.maxZoomScale < 1) {
                    return (this.currentZoomScale <= this.maxZoomScale);
                }
                else {
                    return (this.currentZoomScale >= this.maxZoomScale);
                }
            }
        };
        return BaseCamera;
    })();
    ex.BaseCamera = BaseCamera;
    /**
    * An extension of BaseCamera that is locked vertically; it will only move side to side.
    * @class SideCamera
    * @extends BaseCamera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var SideCamera = (function (_super) {
        __extends(SideCamera, _super);
        function SideCamera() {
            _super.apply(this, arguments);
        }
        SideCamera.prototype.getFocus = function () {
            if (this.follow) {
                return new ex.Point(this.follow.x + this.follow.getWidth() / 2, this.focus.y);
            }
            else {
                return this.focus;
            }
        };
        return SideCamera;
    })(BaseCamera);
    ex.SideCamera = SideCamera;
    /**
    * An extension of BaseCamera that is locked to an actor or focal point; the actor will appear in the center of the screen.
    * @class TopCamera
    * @extends BaseCamera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var TopCamera = (function (_super) {
        __extends(TopCamera, _super);
        function TopCamera() {
            _super.apply(this, arguments);
        }
        TopCamera.prototype.getFocus = function () {
            if (this.follow) {
                return new ex.Point(this.follow.x + this.follow.getWidth() / 2, this.follow.y + this.follow.getHeight() / 2);
            }
            else {
                return this.focus;
            }
        };
        return TopCamera;
    })(BaseCamera);
    ex.TopCamera = TopCamera;
})(ex || (ex = {}));
/// <reference path="Class.ts" />
/// <reference path="Timer.ts" />
/// <reference path="Collision/NaiveCollisionResolver.ts"/>
/// <reference path="Collision/DynamicTreeCollisionResolver.ts"/>
/// <reference path="CollisionPair.ts" />
/// <reference path="Camera.ts" />
var ex;
(function (ex) {
    /**
     * Actors are composed together into groupings called Scenes in
     * Excalibur. The metaphor models the same idea behind real world
     * actors in a scene. Only actors in scenes will be updated and drawn.
     * @class Scene
     * @constructor
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(engine) {
            _super.call(this);
            /**
             * The actors in the current scene
             * @property children {Actor[]}
             */
            this.children = [];
            this.tileMaps = [];
            this.uiActors = [];
            this._collisionResolver = new ex.DynamicTreeCollisionResolver();
            this._killQueue = [];
            this._timers = [];
            this._cancelQueue = [];
            this._isInitialized = false;
            this.camera = new ex.BaseCamera();
            if (engine) {
                this.camera.setFocus(engine.width / 2, engine.height / 2);
            }
        }
        /**
         * This is called when the scene is made active and started. It is meant to be overriden,
         * this is where you should setup any DOM UI or event handlers needed for the scene.
         * @method onActivate
         */
        Scene.prototype.onActivate = function () {
            // will be overridden
        };
        /**
         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,
         * this is where you should cleanup any DOM UI or event handlers needed for the scene.
         * @method onDeactivate
         */
        Scene.prototype.onDeactivate = function () {
            // will be overridden
        };
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         * @method onInitialize
         * @param engine {Engine}
         */
        Scene.prototype.onInitialize = function (engine) {
            // will be overridden
        };
        /**
         * Publish an event to all actors in the scene
         * @method publish
         * @param eventType {string} The name of the event to publish
         * @param event {GameEvent} The event object to send
         */
        Scene.prototype.publish = function (eventType, event) {
            this.children.forEach(function (actor) {
                actor.triggerEvent(eventType, event);
            });
        };
        /**
         * Updates all the actors and timers in the Scene. Called by the Engine.
         * @method update
         * @param engine {Engine} Reference to the current Engine
         * @param delta {number} The number of milliseconds since the last update
         */
        Scene.prototype.update = function (engine, delta) {
            if (!this._isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.publish('initialize', new ex.InitializeEvent(engine));
                this._isInitialized = true;
            }
            this.uiActors.forEach(function (ui) {
                ui.update(engine, delta);
            });
            this.tileMaps.forEach(function (cm) {
                cm.update(engine, delta);
            });
            var len = 0;
            for (var i = 0, len = this.children.length; i < len; i++) {
                this.children[i].update(engine, delta);
            }
            // Run collision resolution strategy
            if (this._collisionResolver) {
                this._collisionResolver.update(this.children);
                this._collisionResolver.evaluate(this.children);
            }
            // Remove actors from scene graph after being killed
            var actorIndex = 0;
            for (var i = 0, len = this._killQueue.length; i < len; i++) {
                actorIndex = this.children.indexOf(this._killQueue[i]);
                if (actorIndex > -1) {
                    this.children.splice(actorIndex, 1);
                }
            }
            this._killQueue.length = 0;
            // Remove timers in the cancel queue before updating them
            var timerIndex = 0;
            for (var i = 0, len = this._cancelQueue.length; i < len; i++) {
                this.removeTimer(this._cancelQueue[i]);
            }
            this._cancelQueue.length = 0;
            // Cycle through timers updating timers
            var that = this;
            this._timers = this._timers.filter(function (timer) {
                timer.update(delta);
                return !timer.complete;
            });
        };
        /**
         * Draws all the actors in the Scene. Called by the Engine.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         * @param delta {number} The number of milliseconds since the last draw
         */
        Scene.prototype.draw = function (ctx, delta) {
            ctx.save();
            if (this.camera) {
                this.camera.update(ctx, delta);
            }
            this.tileMaps.forEach(function (cm) {
                cm.draw(ctx, delta);
            });
            var len = 0;
            var start = 0;
            var end = 0;
            var actor;
            for (var i = 0, len = this.children.length; i < len; i++) {
                actor = this.children[i];
                // only draw actors that are visible
                if (actor.visible) {
                    this.children[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                ctx.strokeStyle = 'yellow';
                this.debugDraw(ctx);
            }
            ctx.restore();
            this.uiActors.forEach(function (ui) {
                if (ui.visible) {
                    ui.draw(ctx, delta);
                }
            });
            if (this.engine && this.engine.isDebug) {
                this.uiActors.forEach(function (ui) {
                    ui.debugDraw(ctx);
                });
            }
        };
        /**
         * Draws all the actors' debug information in the Scene. Called by the Engine.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         */
        Scene.prototype.debugDraw = function (ctx) {
            this.tileMaps.forEach(function (map) {
                map.debugDraw(ctx);
            });
            this.children.forEach(function (actor) {
                actor.debugDraw(ctx);
            });
            // todo possibly enable this with excalibur flags features?
            //this._collisionResolver.debugDraw(ctx, 20);
            //this.camera.debugDraw(ctx);
        };
        Scene.prototype.add = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.addUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.addChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.addTileMap(entity);
            }
        };
        Scene.prototype.remove = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.removeUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this._collisionResolver.remove(entity);
                this.removeChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.removeTileMap(entity);
            }
        };
        /**
         * Adds an actor to act as a piece of UI, meaning it is always positioned
         * in screen coordinates. UI actors do not participate in collisions
         * @method addUIActor
         * @param actor {Actor}
         */
        Scene.prototype.addUIActor = function (actor) {
            this.uiActors.push(actor);
        };
        /**
         * Removes an actor as a piec of UI
         * @method removeUIActor
         * @param actor {Actor}
         */
        Scene.prototype.removeUIActor = function (actor) {
            var index = this.uiActors.indexOf(actor);
            if (index > -1) {
                this.uiActors.splice(index, 1);
            }
        };
        /**
         * Adds an actor to the Scene, once this is done the actor will be drawn and updated.
         * @method addChild
         * @param actor {Actor}
         */
        Scene.prototype.addChild = function (actor) {
            this._collisionResolver.register(actor);
            actor.scene = this;
            this.children.push(actor);
            actor.parent = this.actor;
        };
        /**
         * Adds a TileMap to the Scene, once this is done the TileMap will be drawn and updated.
         * @method addTileMap
         * @param tileMap {TileMap}
         */
        Scene.prototype.addTileMap = function (tileMap) {
            this.tileMaps.push(tileMap);
        };
        /**
         * Removes a TileMap from the Scene, it willno longer be drawn or updated.
         * @method removeTileMap
         * @param tileMap {TileMap}
         */
        Scene.prototype.removeTileMap = function (tileMap) {
            var index = this.tileMaps.indexOf(tileMap);
            if (index > -1) {
                this.tileMaps.splice(index, 1);
            }
        };
        /**
         * Removes an actor from the Scene, it will no longer be drawn or updated.
         * @method removeChild
         * @param actor {Actor} The actor to remove
         */
        Scene.prototype.removeChild = function (actor) {
            this._collisionResolver.remove(actor);
            this._killQueue.push(actor);
            actor.parent = null;
        };
        /**
         * Adds a timer to the Scene
         * @method addTimer
         * @param timer {Timer} The timer to add
         * @returns Timer
         */
        Scene.prototype.addTimer = function (timer) {
            this._timers.push(timer);
            timer.scene = this;
            return timer;
        };
        /**
         * Removes a timer to the Scene, can be dangerous
         * @method removeTimer
         * @private
         * @param timer {Timer} The timer to remove
         * @returns Timer
         */
        Scene.prototype.removeTimer = function (timer) {
            var i = this._timers.indexOf(timer);
            if (i !== -1) {
                this._timers.splice(i, 1);
            }
            return timer;
        };
        /**
         * Cancels a timer, removing it from the scene nicely
         * @method cancelTimer
         * @param timer {Timer} The timer to cancel
         * @returns Timer
         */
        Scene.prototype.cancelTimer = function (timer) {
            this._cancelQueue.push(timer);
            return timer;
        };
        /**
         * Tests whether a timer is active in the scene
         * @method isTimerActive
         * @param timer {Timer}
         * @returns boolean
         */
        Scene.prototype.isTimerActive = function (timer) {
            return (this._timers.indexOf(timer) > -1);
        };
        return Scene;
    })(ex.Class);
    ex.Scene = Scene;
})(ex || (ex = {}));
/// <reference path="Algebra.ts" />
/// <reference path="Engine.ts" />
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    var Internal;
    (function (Internal) {
        var Actions;
        (function (Actions) {
            var EaseTo = (function () {
                function EaseTo(actor, x, y, duration, easingFcn) {
                    this.actor = actor;
                    this.easingFcn = easingFcn;
                    this._currentLerpTime = 0;
                    this._lerpDuration = 1 * 1000; // 5 seconds
                    this._lerpStart = new ex.Point(0, 0);
                    this._lerpEnd = new ex.Point(0, 0);
                    this._initialized = false;
                    this._stopped = false;
                    this._distance = 0;
                    this._lerpDuration = duration;
                    this._lerpEnd = new ex.Point(x, y);
                }
                EaseTo.prototype._initialize = function () {
                    this._lerpStart = new ex.Point(this.actor.x, this.actor.y);
                    this._currentLerpTime = 0;
                    this._distance = this._lerpStart.toVector().distance(this._lerpEnd.toVector());
                };
                EaseTo.prototype.update = function (delta) {
                    if (!this._initialized) {
                        this._initialize();
                        this._initialized = true;
                    }
                    var newX = this.actor.x;
                    var newY = this.actor.y;
                    if (this._currentLerpTime < this._lerpDuration) {
                        if (this._lerpEnd.x < this._lerpStart.x) {
                            newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                        }
                        else {
                            newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                        }
                        if (this._lerpEnd.y < this._lerpStart.y) {
                            newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                        }
                        else {
                            newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                        }
                        this.actor.x = newX;
                        this.actor.y = newY;
                        this._currentLerpTime += delta;
                    }
                    else {
                        this.actor.x = this._lerpEnd.x;
                        this.actor.y = this._lerpEnd.y;
                    }
                };
                EaseTo.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this._lerpStart.toVector()) >= this._distance;
                };
                EaseTo.prototype.reset = function () {
                    this._initialized = false;
                };
                EaseTo.prototype.stop = function () {
                    this._stopped = true;
                };
                return EaseTo;
            })();
            Actions.EaseTo = EaseTo;
            var MoveTo = (function () {
                function MoveTo(actor, destx, desty, speed) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = new ex.Vector(destx, desty);
                    this.speed = speed;
                }
                MoveTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = new ex.Vector(this.actor.x, this.actor.y);
                        this.distance = this.start.distance(this.end);
                        this.dir = this.end.minus(this.start).normalize();
                    }
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                MoveTo.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this.start) >= this.distance;
                };
                MoveTo.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                MoveTo.prototype.reset = function () {
                    this._started = false;
                };
                return MoveTo;
            })();
            Actions.MoveTo = MoveTo;
            var MoveBy = (function () {
                function MoveBy(actor, destx, desty, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = new ex.Vector(destx, desty);
                    if (time <= 0) {
                        ex.Logger.getInstance().error("Attempted to moveBy time less than or equal to zero : " + time);
                        throw new Error("Cannot move in time <= 0");
                    }
                    this.time = time;
                }
                MoveBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = new ex.Vector(this.actor.x, this.actor.y);
                        this.distance = this.start.distance(this.end);
                        this.dir = this.end.minus(this.start).normalize();
                        this.speed = this.distance / (this.time / 1000);
                    }
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                MoveBy.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this.start) >= this.distance;
                };
                MoveBy.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                MoveBy.prototype.reset = function () {
                    this._started = false;
                };
                return MoveBy;
            })();
            Actions.MoveBy = MoveBy;
            var Follow = (function () {
                function Follow(actor, actorToFollow, followDistance) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.actorToFollow = actorToFollow;
                    this.current = new ex.Vector(this.actor.x, this.actor.y);
                    this.end = new ex.Vector(actorToFollow.x, actorToFollow.y);
                    this.maximumDistance = (followDistance != undefined) ? followDistance : this.current.distance(this.end);
                    this.speed = 0;
                }
                Follow.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.distanceBetween = this.current.distance(this.end);
                        this.dir = this.end.minus(this.current).normalize();
                    }
                    var actorToFollowSpeed = Math.sqrt(Math.pow(this.actorToFollow.dx, 2) + Math.pow(this.actorToFollow.dy, 2));
                    if (actorToFollowSpeed != 0) {
                        this.speed = actorToFollowSpeed;
                    }
                    this.current.x = this.actor.x;
                    this.current.y = this.actor.y;
                    this.end.x = this.actorToFollow.x;
                    this.end.y = this.actorToFollow.y;
                    this.distanceBetween = this.current.distance(this.end);
                    this.dir = this.end.minus(this.current).normalize();
                    if (this.distanceBetween >= this.maximumDistance) {
                        var m = this.dir.scale(this.speed);
                        this.actor.dx = m.x;
                        this.actor.dy = m.y;
                    }
                    else {
                        this.actor.dx = 0;
                        this.actor.dy = 0;
                    }
                    if (this.isComplete(this.actor)) {
                        // TODO this should never occur
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                Follow.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                Follow.prototype.isComplete = function (actor) {
                    // the actor following should never stop unless specified to do so
                    return this._stopped;
                };
                Follow.prototype.reset = function () {
                    this._started = false;
                };
                return Follow;
            })();
            Actions.Follow = Follow;
            var Meet = (function () {
                function Meet(actor, actorToMeet, speed) {
                    this._started = false;
                    this._stopped = false;
                    this._speedWasSpecified = false;
                    this.actor = actor;
                    this.actorToMeet = actorToMeet;
                    this.current = new ex.Vector(this.actor.x, this.actor.y);
                    this.end = new ex.Vector(actorToMeet.x, actorToMeet.y);
                    this.speed = speed || 0;
                    if (speed != undefined) {
                        this._speedWasSpecified = true;
                    }
                }
                Meet.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.distanceBetween = this.current.distance(this.end);
                        this.dir = this.end.minus(this.current).normalize();
                    }
                    var actorToMeetSpeed = Math.sqrt(Math.pow(this.actorToMeet.dx, 2) + Math.pow(this.actorToMeet.dy, 2));
                    if ((actorToMeetSpeed != 0) && (!this._speedWasSpecified)) {
                        this.speed = actorToMeetSpeed;
                    }
                    this.current.x = this.actor.x;
                    this.current.y = this.actor.y;
                    this.end.x = this.actorToMeet.x;
                    this.end.y = this.actorToMeet.y;
                    this.distanceBetween = this.current.distance(this.end);
                    this.dir = this.end.minus(this.current).normalize();
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    if (this.isComplete(this.actor)) {
                        // console.log("meeting is complete")
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                Meet.prototype.isComplete = function (actor) {
                    return this._stopped || (this.distanceBetween <= 1);
                };
                Meet.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                Meet.prototype.reset = function () {
                    this._started = false;
                };
                return Meet;
            })();
            Actions.Meet = Meet;
            var RotateTo = (function () {
                function RotateTo(actor, angleRadians, speed) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = angleRadians;
                    this.speed = speed;
                }
                RotateTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = this.actor.rotation;
                        this.distance = Math.abs(this.end - this.start);
                    }
                    this.actor.rx = this.speed;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.rotation = this.end;
                        this.actor.rx = 0;
                    }
                };
                RotateTo.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.rotation - this.start) >= this.distance);
                };
                RotateTo.prototype.stop = function () {
                    this.actor.rx = 0;
                    this._stopped = true;
                };
                RotateTo.prototype.reset = function () {
                    this._started = false;
                };
                return RotateTo;
            })();
            Actions.RotateTo = RotateTo;
            var RotateBy = (function () {
                function RotateBy(actor, angleRadians, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = angleRadians;
                    this.time = time;
                    this.speed = (this.end - this.actor.rotation) / time * 1000;
                }
                RotateBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = this.actor.rotation;
                        this.distance = Math.abs(this.end - this.start);
                    }
                    this.actor.rx = this.speed;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.rotation = this.end;
                        this.actor.rx = 0;
                    }
                };
                RotateBy.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.rotation - this.start) >= this.distance);
                };
                RotateBy.prototype.stop = function () {
                    this.actor.rx = 0;
                    this._stopped = true;
                };
                RotateBy.prototype.reset = function () {
                    this._started = false;
                };
                return RotateBy;
            })();
            Actions.RotateBy = RotateBy;
            var ScaleTo = (function () {
                function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endX = scaleX;
                    this.endY = scaleY;
                    this.speedX = speedX;
                    this.speedY = speedY;
                }
                ScaleTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.startX = this.actor.scale.x;
                        this.startY = this.actor.scale.y;
                        this.distanceX = Math.abs(this.endX - this.startX);
                        this.distanceY = Math.abs(this.endY - this.startY);
                    }
                    if (!(Math.abs(this.actor.scale.x - this.startX) >= this.distanceX)) {
                        var directionX = this.endY < this.startY ? -1 : 1;
                        this.actor.sx = this.speedX * directionX;
                    }
                    else {
                        this.actor.sx = 0;
                    }
                    if (!(Math.abs(this.actor.scale.y - this.startY) >= this.distanceY)) {
                        var directionY = this.endY < this.startY ? -1 : 1;
                        this.actor.sy = this.speedY * directionY;
                    }
                    else {
                        this.actor.sy = 0;
                    }
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.scale.x = this.endX;
                        this.actor.scale.y = this.endY;
                        this.actor.sx = 0;
                        this.actor.sy = 0;
                    }
                };
                ScaleTo.prototype.isComplete = function (actor) {
                    return this._stopped || ((Math.abs(this.actor.scale.y - this.startX) >= this.distanceX) && (Math.abs(this.actor.scale.y - this.startY) >= this.distanceY));
                };
                ScaleTo.prototype.stop = function () {
                    this.actor.sx = 0;
                    this.actor.sy = 0;
                    this._stopped = true;
                };
                ScaleTo.prototype.reset = function () {
                    this._started = false;
                };
                return ScaleTo;
            })();
            Actions.ScaleTo = ScaleTo;
            var ScaleBy = (function () {
                function ScaleBy(actor, scaleX, scaleY, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endX = scaleX;
                    this.endY = scaleY;
                    this.time = time;
                    this.speedX = (this.endX - this.actor.scale.x) / time * 1000;
                    this.speedY = (this.endY - this.actor.scale.y) / time * 1000;
                }
                ScaleBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.startX = this.actor.scale.x;
                        this.startY = this.actor.scale.y;
                        this.distanceX = Math.abs(this.endX - this.startX);
                        this.distanceY = Math.abs(this.endY - this.startY);
                    }
                    var directionX = this.endX < this.startX ? -1 : 1;
                    var directionY = this.endY < this.startY ? -1 : 1;
                    this.actor.sx = this.speedX * directionX;
                    this.actor.sy = this.speedY * directionY;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.scale.x = this.endX;
                        this.actor.scale.y = this.endY;
                        this.actor.sx = 0;
                        this.actor.sy = 0;
                    }
                };
                ScaleBy.prototype.isComplete = function (actor) {
                    return this._stopped || ((Math.abs(this.actor.scale.x - this.startX) >= this.distanceX) && (Math.abs(this.actor.scale.y - this.startY) >= this.distanceY));
                };
                ScaleBy.prototype.stop = function () {
                    this.actor.sx = 0;
                    this.actor.sy = 0;
                    this._stopped = true;
                };
                ScaleBy.prototype.reset = function () {
                    this._started = false;
                };
                return ScaleBy;
            })();
            Actions.ScaleBy = ScaleBy;
            var Delay = (function () {
                function Delay(actor, delay) {
                    this.elapsedTime = 0;
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.delay = delay;
                }
                Delay.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    this.elapsedTime += delta;
                };
                Delay.prototype.isComplete = function (actor) {
                    return this._stopped || (this.elapsedTime >= this.delay);
                };
                Delay.prototype.stop = function () {
                    this._stopped = true;
                };
                Delay.prototype.reset = function () {
                    this.elapsedTime = 0;
                    this._started = false;
                };
                return Delay;
            })();
            Actions.Delay = Delay;
            var Blink = (function () {
                function Blink(actor, timeVisible, timeNotVisible, numBlinks) {
                    if (numBlinks === void 0) { numBlinks = 1; }
                    this.timeVisible = 0;
                    this.timeNotVisible = 0;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                    this._stopped = false;
                    this._started = false;
                    this.actor = actor;
                    this.timeVisible = timeVisible;
                    this.timeNotVisible = timeNotVisible;
                    this.duration = (timeVisible + timeNotVisible) * numBlinks;
                }
                Blink.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    this.elapsedTime += delta;
                    this.totalTime += delta;
                    if (this.actor.visible && this.elapsedTime >= this.timeVisible) {
                        this.actor.visible = false;
                        this.elapsedTime = 0;
                    }
                    if (!this.actor.visible && this.elapsedTime >= this.timeNotVisible) {
                        this.actor.visible = true;
                        this.elapsedTime = 0;
                    }
                    if (this.isComplete(this.actor)) {
                        this.actor.visible = true;
                    }
                };
                Blink.prototype.isComplete = function (actor) {
                    return this._stopped || (this.totalTime >= this.duration);
                };
                Blink.prototype.stop = function () {
                    this.actor.visible = true;
                    this._stopped = true;
                };
                Blink.prototype.reset = function () {
                    this._started = false;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                };
                return Blink;
            })();
            Actions.Blink = Blink;
            var Fade = (function () {
                function Fade(actor, endOpacity, speed) {
                    this.multiplyer = 1;
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endOpacity = endOpacity;
                    this.speed = speed;
                    if (endOpacity < actor.opacity) {
                        this.multiplyer = -1;
                    }
                }
                Fade.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    if (this.speed > 0) {
                        this.actor.opacity += this.multiplyer * (Math.abs(this.actor.opacity - this.endOpacity) * delta) / this.speed;
                    }
                    this.speed -= delta;
                    ex.Logger.getInstance().debug("actor opacity: " + this.actor.opacity);
                    if (this.isComplete(this.actor)) {
                        this.actor.opacity = this.endOpacity;
                    }
                };
                Fade.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.opacity - this.endOpacity) < 0.05);
                };
                Fade.prototype.stop = function () {
                    this._stopped = true;
                };
                Fade.prototype.reset = function () {
                    this._started = false;
                };
                return Fade;
            })();
            Actions.Fade = Fade;
            var Die = (function () {
                function Die(actor) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                }
                Die.prototype.update = function (delta) {
                    this.actor.actionQueue.clearActions();
                    this.actor.kill();
                    this._stopped = true;
                };
                Die.prototype.isComplete = function () {
                    return this._stopped;
                };
                Die.prototype.stop = function () {
                };
                Die.prototype.reset = function () {
                };
                return Die;
            })();
            Actions.Die = Die;
            var CallMethod = (function () {
                function CallMethod(actor, method) {
                    this._method = null;
                    this._actor = null;
                    this._hasBeenCalled = false;
                    this._actor = actor;
                    this._method = method;
                }
                CallMethod.prototype.update = function (delta) {
                    this._method.call(this._actor);
                    this._hasBeenCalled = true;
                };
                CallMethod.prototype.isComplete = function (actor) {
                    return this._hasBeenCalled;
                };
                CallMethod.prototype.reset = function () {
                    this._hasBeenCalled = false;
                };
                CallMethod.prototype.stop = function () {
                    this._hasBeenCalled = true;
                };
                return CallMethod;
            })();
            Actions.CallMethod = CallMethod;
            var Repeat = (function () {
                function Repeat(actor, repeat, actions) {
                    var _this = this;
                    this._stopped = false;
                    this.actor = actor;
                    this.actionQueue = new ActionQueue(actor);
                    this.repeat = repeat;
                    this.originalRepeat = repeat;
                    actions.forEach(function (action) {
                        action.reset();
                        _this.actionQueue.add(action);
                    });
                }
                Repeat.prototype.update = function (delta) {
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    if (!this.actionQueue.hasNext()) {
                        this.actionQueue.reset();
                        this.repeat--;
                    }
                    this.actionQueue.update(delta);
                };
                Repeat.prototype.isComplete = function () {
                    return this._stopped || (this.repeat <= 0);
                };
                Repeat.prototype.stop = function () {
                    this._stopped = true;
                };
                Repeat.prototype.reset = function () {
                    this.repeat = this.originalRepeat;
                };
                return Repeat;
            })();
            Actions.Repeat = Repeat;
            var RepeatForever = (function () {
                function RepeatForever(actor, actions) {
                    var _this = this;
                    this._stopped = false;
                    this.actor = actor;
                    this.actionQueue = new ActionQueue(actor);
                    actions.forEach(function (action) {
                        action.reset();
                        _this.actionQueue.add(action);
                    });
                }
                RepeatForever.prototype.update = function (delta) {
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    if (this._stopped) {
                        return;
                    }
                    if (!this.actionQueue.hasNext()) {
                        this.actionQueue.reset();
                    }
                    this.actionQueue.update(delta);
                };
                RepeatForever.prototype.isComplete = function () {
                    return this._stopped;
                };
                RepeatForever.prototype.stop = function () {
                    this._stopped = true;
                    this.actionQueue.clearActions();
                };
                RepeatForever.prototype.reset = function () {
                };
                return RepeatForever;
            })();
            Actions.RepeatForever = RepeatForever;
            var ActionQueue = (function () {
                function ActionQueue(actor) {
                    this._actions = [];
                    this._completedActions = [];
                    this.actor = actor;
                }
                ActionQueue.prototype.add = function (action) {
                    this._actions.push(action);
                };
                ActionQueue.prototype.remove = function (action) {
                    var index = this._actions.indexOf(action);
                    this._actions.splice(index, 1);
                };
                ActionQueue.prototype.clearActions = function () {
                    this._actions.length = 0;
                    this._completedActions.length = 0;
                    this._currentAction.stop();
                };
                ActionQueue.prototype.getActions = function () {
                    return this._actions.concat(this._completedActions);
                };
                ActionQueue.prototype.hasNext = function () {
                    return this._actions.length > 0;
                };
                ActionQueue.prototype.reset = function () {
                    this._actions = this.getActions();
                    this._actions.forEach(function (action) {
                        action.reset();
                    });
                    this._completedActions = [];
                };
                ActionQueue.prototype.update = function (delta) {
                    if (this._actions.length > 0) {
                        this._currentAction = this._actions[0];
                        this._currentAction.update(delta);
                        if (this._currentAction.isComplete(this.actor)) {
                            //Logger.getInstance().log("Action complete!", Log.DEBUG);
                            this._completedActions.push(this._actions.shift());
                        }
                    }
                };
                return ActionQueue;
            })();
            Actions.ActionQueue = ActionQueue;
        })(Actions = Internal.Actions || (Internal.Actions = {}));
    })(Internal = ex.Internal || (ex.Internal = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var EasingFunctions = (function () {
        function EasingFunctions() {
        }
        /*
       easeInQuad: function (t) { return t * t },
       // decelerating to zero velocity
       easeOutQuad: function (t) { return t * (2 - t) },
       // acceleration until halfway, then deceleration
       easeInOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
       // accelerating from zero velocity
       easeInCubic: function (t) { return t * t * t },
       // decelerating to zero velocity
       easeOutCubic: function (t) { return (--t) * t * t + 1 },
       // acceleration until halfway, then deceleration
       easeInOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
       // accelerating from zero velocity
       easeInQuart: function (t) { return t * t * t * t },
       // decelerating to zero velocity
       easeOutQuart: function (t) { return 1 - (--t) * t * t * t },
       // acceleration until halfway, then deceleration
       easeInOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
       // accelerating from zero velocity
       easeInQuint: function (t) { return t * t * t * t * t },
       // decelerating to zero velocity
       easeOutQuint: function (t) { return 1 + (--t) * t * t * t * t },
       // acceleration until halfway, then deceleration
       easeInOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t }
        */
        EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            return endValue * currentTime / duration + startValue;
        };
        EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {
            //endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * currentTime * currentTime + startValue;
        };
        EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {
            //endValue = (endValue - startValue);
            currentTime /= duration;
            return -endValue * currentTime * (currentTime - 2) + startValue;
        };
        EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime + startValue;
            currentTime--;
            return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
        };
        EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * currentTime * currentTime * currentTime + startValue;
        };
        EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
        };
        EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime * currentTime + startValue;
            currentTime -= 2;
            return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
        };
        return EasingFunctions;
    })();
    ex.EasingFunctions = EasingFunctions;
})(ex || (ex = {}));
/// <reference path="Interfaces/IDrawable.ts" />
/// <reference path="Modules/MovementModule.ts" />
/// <reference path="Modules/OffscreenCullingModule.ts" />
/// <reference path="Modules/CapturePointerModule.ts" />
/// <reference path="Modules/CollisionDetectionModule.ts" />
/// <reference path="Collision/Side.ts" />
/// <reference path="Algebra.ts" />
/// <reference path="Util.ts" />
/// <reference path="TileMap.ts" />
/// <reference path="Collision/BoundingBox.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Action.ts" />
/// <reference path="EasingFunctions.ts"/>
var ex;
(function (ex) {
    /**
     * An enum that describes the types of collisions actors can participate in
     * @class CollisionType
     */
    (function (CollisionType) {
        /**
         * Actors with the PreventCollision setting do not participate in any
         * collisions and do not raise collision events.
         * @property PreventCollision {CollisionType}
         * @static
         */
        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";
        /**
         * Actors with the Passive setting only raise collision events, but are not
         * influenced or moved by other actors and do not influence or move other actors.
         * @property Passive {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Passive"] = 1] = "Passive";
        /**
         * Actors with the Active setting raise collision events and participate
         * in collisions with other actors and will be push or moved by actors sharing
         * the Active or Fixed setting.
         * @property Active {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Active"] = 2] = "Active";
        /**
         * Actors with the Elastic setting will behave the same as Active, except that they will
         * "bounce" in the opposite direction given their velocity dx/dy. This is a naive implementation meant for
         * prototyping, for a more robust elastic collision listen to the "collision" event and perform your custom logic.
         * @property Elastic {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Elastic"] = 3] = "Elastic";
        /**
         * Actors with the Fixed setting raise collision events and participate in
         * collisions with other actors. Actors with the Fixed setting will not be
         * pushed or moved by other actors sharing the Fixed or Actors. Think of Fixed
         * actors as "immovable/onstoppable" objects. If two Fixed actors meet they will
         * not be pushed or moved by each other, they will not interact except to throw
         * collision events.
         * @property Fixed {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Fixed"] = 4] = "Fixed";
    })(ex.CollisionType || (ex.CollisionType = {}));
    var CollisionType = ex.CollisionType;
    /**
     * The most important primitive in Excalibur is an "Actor." Anything that
     * can move on the screen, collide with another Actor, respond to events,
     * or interact with the current scene, must be an actor. An Actor <b>must</b>
     * be part of a {{#crossLink "Scene"}}{{/crossLink}} for it to be drawn to the screen.
     * @class Actor
     * @extends Class
     * @constructor
     * @param [x=0.0] {number} The starting x coordinate of the actor
     * @param [y=0.0] {number} The starting y coordinate of the actor
     * @param [width=0.0] {number} The starting width of the actor
     * @param [height=0.0] {number} The starting height of the actor
     * @param [color=undefined] {Color} The starting color of the actor
     */
    var Actor = (function (_super) {
        __extends(Actor, _super);
        function Actor(x, y, width, height, color) {
            _super.call(this);
            /**
             * The unique identifier for the actor
             */
            this.id = Actor.maxId++;
            /**
             * The x coordinate of the actor (left edge)
             * @property x {number}
             */
            this.x = 0;
            /**
             * The y coordinate of the actor (top edge)
             * @property y {number}
             */
            this.y = 0;
            this.height = 0;
            this.width = 0;
            /**
             * The rotation of the actor in radians
             * @property rotation {number}
             */
            this.rotation = 0; // radians
            /**
             * The rotational velocity of the actor in radians/second
             * @property rx {number}
             */
            this.rx = 0; //radions/sec
            /**
             * The scale vector of the actor
             * @property scale
             */
            this.scale = new ex.Vector(1, 1);
            /**
             * The x scalar velocity of the actor in scale/second
             * @property sx {number}
             */
            this.sx = 0; //scale/sec
            /**
             * The y scalar velocity of the actor in scale/second
             * @property sy {number}
             */
            this.sy = 0; //scale/sec
            /**
             * The x velocity of the actor in pixels/second
             * @property dx {number}
             */
            this.dx = 0; // pixels/sec
            /**
             * The x velocity of the actor in pixels/second
             * @property dx {number}
             */
            this.dy = 0;
            /**
             * The x acceleration of the actor in pixels/second^2
             * @property ax {number}
             */
            this.ax = 0; // pixels/sec/sec
            /**
             * The y acceleration of the actor in pixels/second^2
             * @property ay {number}
             */
            this.ay = 0;
            /**
             * Indicates wether the actor is physically in the viewport
             * @property isOffScreen {boolean}
             */
            this.isOffScreen = false;
            /**
             * The visibility of an actor
             * @property visible {boolean}
             */
            this.visible = true;
            /**
             * The opacity of an actor
             * @property opacity {number}
             */
            this.opacity = 1;
            this.previousOpacity = 1;
            /**
             * Convenience reference to the global logger
             * @property logger {Logger}
             */
            this.logger = ex.Logger.getInstance();
            /**
            * The scene that the actor is in
            * @property scene {Scene}
            */
            this.scene = null; //formerly "parent"
            /**
            * The parent of this actor
            * @property parent {Actor}
            */
            this.parent = null;
            /**
             * Gets or sets the current collision type of this actor. By
             * default all actors participate in Active collisions.
             * @property collisionType {CollisionType}
             */
            this.collisionType = 0 /* PreventCollision */;
            this.collisionGroups = [];
            this._collisionHandlers = {};
            this._isInitialized = false;
            this.frames = {};
            /**
             * Access to the current drawing on for the actor, this can be an {{#crossLink "Animation"}}{{/crossLink}},
             * {{#crossLink "Sprite"}}{{/crossLink}}, or {{#crossLink "Polygon"}}{{/crossLink}}.
             * Set drawings with the {{#crossLink "Actor/setDrawing:method"}}{{/crossLink}}.
             * @property currentDrawing {IDrawable}
             */
            this.currentDrawing = null;
            this.centerDrawingX = false;
            this.centerDrawingY = false;
            /**
             * Modify the current actor update pipeline.
             *
             *
             */
            this.pipeline = [];
            /**
             * Whether or not to enable the CapturePointer trait that propogates pointer events to this actor
             * @property [enableCapturePointer=false] {boolean}
             */
            this.enableCapturePointer = false;
            /**
             * Configuration for CapturePointer trait
             * @property capturePointer {ICapturePointerConfig}
             */
            this.capturePointer = {
                captureMoveEvents: false
            };
            this._isKilled = false;
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
            if (color) {
                this.color = color.clone();
                // set default opacity of an actor to the color
                this.opacity = color.a;
            }
            // Build default pipeline
            this.pipeline.push(new ex.MovementModule());
            //this.pipeline.push(new ex.CollisionDetectionModule());
            this.pipeline.push(new ex.OffscreenCullingModule());
            this.pipeline.push(new ex.CapturePointerModule());
            this.actionQueue = new ex.Internal.Actions.ActionQueue(this);
            this.sceneNode = new ex.Scene();
            this.sceneNode.actor = this;
            this.anchor = new ex.Point(.5, .5);
        }
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         * @method onInitialize
         * @param engine {Engine}
         */
        Actor.prototype.onInitialize = function (engine) {
        };
        Actor.prototype._checkForPointerOptIn = function (eventName) {
            if (eventName && (eventName.toLowerCase() === 'pointerdown' || eventName.toLowerCase() === 'pointerdown' || eventName.toLowerCase() === 'pointermove')) {
                this.enableCapturePointer = true;
                if (eventName.toLowerCase() === 'pointermove') {
                    this.capturePointer.captureMoveEvents = true;
                }
            }
        };
        /**
        * Add an event listener. You can listen for a variety of
        * events off of the engine; see the events section below for a complete list.
        * @method addEventListener
        * @param eventName {string} Name of the event to listen for
        * @param handler {event=>void} Event handler for the thrown event
        */
        Actor.prototype.addEventListener = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            _super.prototype.addEventListener.call(this, eventName, handler);
        };
        /**
         * Alias for "addEventListener". You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method on
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Actor.prototype.on = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * If the current actors is a member of the scene. This will remove
         * it from the scene graph. It will no longer be drawn or updated.
         * @method kill
         */
        Actor.prototype.kill = function () {
            if (this.scene) {
                this.scene.removeChild(this);
                this._isKilled = true;
            }
            else {
                this.logger.warn("Cannot kill actor, it was never added to the Scene");
            }
        };
        /**
         * Indicates wether the actor has been killed.
         * @method isKilled
         * @returns boolean
         */
        Actor.prototype.isKilled = function () {
            return this._isKilled;
        };
        /**
         * Adds a child actor to this actor. All movement of the child actor will be
         * relative to the parent actor. Meaning if the parent moves the child will
         * move with
         * @method addChild
         * @param actor {Actor} The child actor to add
         */
        Actor.prototype.addChild = function (actor) {
            actor.collisionType = 0 /* PreventCollision */;
            this.sceneNode.addChild(actor);
        };
        /**
         * Removes a child actor from this actor.
         * @method removeChild
         * @param actor {Actor} The child actor to remove
         */
        Actor.prototype.removeChild = function (actor) {
            this.sceneNode.removeChild(actor);
        };
        /**
         * Sets the current drawing of the actor to the drawing correspoding to
         * the key.
         * @method setDrawing
         * @param key {string} The key of the drawing
         */
        Actor.prototype.setDrawing = function (key) {
            if (this.currentDrawing != this.frames[key]) {
                this.frames[key].reset();
            }
            this.currentDrawing = this.frames[key];
        };
        Actor.prototype.addDrawing = function (args) {
            if (arguments.length === 2) {
                this.frames[arguments[0]] = arguments[1];
                if (!this.currentDrawing) {
                    this.currentDrawing = arguments[1];
                }
            }
            else {
                if (arguments[0] instanceof ex.Sprite) {
                    this.addDrawing("default", arguments[0]);
                }
                if (arguments[0] instanceof ex.Texture) {
                    this.addDrawing("default", arguments[0].asSprite());
                }
            }
        };
        /**
         * Artificially trigger an event on an actor, useful when creating custom events.
         * @method triggerEvent
         * @param eventName {string} The name of the event to trigger
         * @param [event=undefined] {GameEvent} The event object to pass to the callback
         */
        Actor.prototype.triggerEvent = function (eventName, event) {
            this.eventDispatcher.publish(eventName, event);
        };
        /**
         * Adds an actor to a collision group. Actors with no named collision group are
         * considered to be in every collision group.
         *
         * Once in a collision group(s) actors will only collide with other actors in
         * that group.
         *
         * @method addCollisionGroup
         * @param name {string} The name of the collision group
         */
        Actor.prototype.addCollisionGroup = function (name) {
            this.collisionGroups.push(name);
        };
        /**
         * Remove an actor from a collision group.
         * @method removeCollisionGroup
         * @param name {string} The name of the collision group
         */
        Actor.prototype.removeCollisionGroup = function (name) {
            var index = this.collisionGroups.indexOf(name);
            if (index !== -1) {
                this.collisionGroups.splice(index, 1);
            }
        };
        /**
         * Get the center point of an actor
         * @method getCenter
         * @returns Vector
         */
        Actor.prototype.getCenter = function () {
            var anchor = this._getCalculatedAnchor();
            return new ex.Vector(this.x + this.getWidth() / 2, this.y + this.getHeight() / 2);
        };
        /**
         * Gets the calculated width of an actor
         * @method getWidth
         * @returns number
         */
        Actor.prototype.getWidth = function () {
            return this.width * this.scale.x;
        };
        /**
         * Sets the width of an actor, factoring in the current scale
         * @method setWidth
         */
        Actor.prototype.setWidth = function (width) {
            this.width = width / this.scale.x;
        };
        /**
         * Gets the calculated height of an actor
         * @method getHeight
         * @returns number
         */
        Actor.prototype.getHeight = function () {
            return this.height * this.scale.y;
        };
        /**
         * Sets the height of an actor, factoring in the current scale
         * @method setHeight
         */
        Actor.prototype.setHeight = function (height) {
            this.height = height / this.scale.y;
        };
        /**
         * Centers the actor's drawing around the center of the actor's bounding box
         * @method setCenterDrawing
         * @param center {boolean} Indicates to center the drawing around the actor
         */
        Actor.prototype.setCenterDrawing = function (center) {
            this.centerDrawingY = center;
            this.centerDrawingX = center;
        };
        /**
         * Gets the left edge of the actor
         * @method getLeft
         * @returns number
         */
        Actor.prototype.getLeft = function () {
            return this.x;
        };
        /**
         * Gets the right edge of the actor
         * @method getRight
         * @returns number
         */
        Actor.prototype.getRight = function () {
            return this.x + this.getWidth();
        };
        /**
         * Gets the top edge of the actor
         * @method getTop
         * @returns number
         */
        Actor.prototype.getTop = function () {
            return this.y;
        };
        /**
         * Gets the bottom edge of the actor
         * @method getBottom
         * @returns number
         */
        Actor.prototype.getBottom = function () {
            return this.y + this.getHeight();
        };
        /**
        * Gets the x value of the Actor in global coordinates
        * @method getGlobalX
        * @returns number
        */
        Actor.prototype.getGlobalX = function () {
            if (!this.parent)
                return this.x;
            return this.x * this.parent.scale.y + this.parent.getGlobalX();
        };
        /**
        * Gets the y value of the Actor in global coordinates
        * @method getGlobalY
        * @returns number
        */
        Actor.prototype.getGlobalY = function () {
            if (!this.parent)
                return this.y;
            return this.y * this.parent.scale.y + this.parent.getGlobalY();
        };
        /**
         * Gets the global scale of the Actor
         * @method getGlobalScale
         * @returns Point
         */
        Actor.prototype.getGlobalScale = function () {
            if (!this.parent)
                return new ex.Point(this.scale.x, this.scale.y);
            var parentScale = this.parent.getGlobalScale();
            return new ex.Point(this.scale.x * parentScale.x, this.scale.y * parentScale.y);
        };
        /**
         * Returns the actor's bounding box calculated for this instant.
         * @method getBounds
         * @returns BoundingBox
         */
        Actor.prototype.getBounds = function () {
            var anchor = this._getCalculatedAnchor();
            return new ex.BoundingBox(this.getGlobalX() - anchor.x, this.getGlobalY() - anchor.y, this.getGlobalX() + this.getWidth() - anchor.x, this.getGlobalY() + this.getHeight() - anchor.y);
        };
        /**
         * Tests whether the x/y specified are contained in the actor
         * @method contains
         * @param x {number} X coordinate to test (in world coordinates)
         * @param y {number} Y coordinate to test (in world coordinates)
         */
        Actor.prototype.contains = function (x, y) {
            return this.getBounds().contains(new ex.Point(x, y));
        };
        /**
         * Returns the side of the collision based on the intersection
         * @method getSideFromIntersect
         * @param intersect {Vector} The displacement vector returned by a collision
         * @returns Side
        */
        Actor.prototype.getSideFromIntersect = function (intersect) {
            if (intersect) {
                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {
                    if (intersect.x < 0) {
                        return 4 /* Right */;
                    }
                    return 3 /* Left */;
                }
                else {
                    if (intersect.y < 0) {
                        return 2 /* Bottom */;
                    }
                    return 1 /* Top */;
                }
            }
            return 0 /* None */;
        };
        /**
         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.
         * @method collides
         * @param actor {Actor} The other actor to test
         * @returns Side
         */
        Actor.prototype.collidesWithSide = function (actor) {
            var separationVector = this.collides(actor);
            if (!separationVector) {
                return 0 /* None */;
            }
            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {
                if (this.x < actor.x) {
                    return 4 /* Right */;
                }
                else {
                    return 3 /* Left */;
                }
            }
            else {
                if (this.y < actor.y) {
                    return 2 /* Bottom */;
                }
                else {
                    return 1 /* Top */;
                }
            }
            return 0 /* None */;
        };
        /**
         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns
         * null when there is no collision;
         * @method collides
         * @param actor {Actor} The other actor to test
         * @returns Vector
         */
        Actor.prototype.collides = function (actor) {
            var bounds = this.getBounds();
            var otherBounds = actor.getBounds();
            var intersect = bounds.collides(otherBounds);
            return intersect;
        };
        /**
         * Register a handler to fire when this actor collides with another in a specified group
         * @method onCollidesWith
         * @param group {string} The group name to listen for
         * @param func {callback} The callback to fire on collision with another actor from the group. The callback is passed the other actor.
         */
        Actor.prototype.onCollidesWith = function (group, func) {
            if (!this._collisionHandlers[group]) {
                this._collisionHandlers[group] = [];
            }
            this._collisionHandlers[group].push(func);
        };
        Actor.prototype.getCollisionHandlers = function () {
            return this._collisionHandlers;
        };
        /**
         * Removes all collision handlers for this group on this actor
         * @method removeCollidesWith
         * @param group {string} Group to remove all handlers for on this actor.
         */
        Actor.prototype.removeCollidesWith = function (group) {
            this._collisionHandlers[group] = [];
        };
        /**
         * Returns true if the two actors are less than or equal to the distance specified from each other
         * @method within
         * @param actor {Actor} Actor to test
         * @param distance {number} Distance in pixels to test
         * @returns boolean
         */
        Actor.prototype.within = function (actor, distance) {
            return Math.sqrt(Math.pow(this.x - actor.x, 2) + Math.pow(this.y - actor.y, 2)) <= distance;
        };
        /**
         * Clears all queued actions from the Actor
         * @method clearActions
         */
        Actor.prototype.clearActions = function () {
            this.actionQueue.clearActions();
        };
        Actor.prototype.easeTo = function (x, y, duration, easingFcn) {
            if (easingFcn === void 0) { easingFcn = ex.EasingFunctions.Linear; }
            this.actionQueue.add(new ex.Internal.Actions.EaseTo(this, x, y, duration, easingFcn));
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position at the
         * speed specified (in pixels per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @method moveTo
         * @param x {number} The x location to move the actor to
         * @param y {number} The y location to move the actor to
         * @param speed {number} The speed in pixels per second to move
         * @returns Actor
         */
        Actor.prototype.moveTo = function (x, y, speed) {
            this.actionQueue.add(new ex.Internal.Actions.MoveTo(this, x, y, speed));
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position by a
         * certain time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @method moveBy
         * @param x {number} The x location to move the actor to
         * @param y {number} The y location to move the actor to
         * @param time {number} The time it should take the actor to move to the new location in milliseconds
         * @returns Actor
         */
        Actor.prototype.moveBy = function (x, y, time) {
            this.actionQueue.add(new ex.Internal.Actions.MoveBy(this, x, y, time));
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle at the speed
         * specified (in radians per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @method rotateTo
         * @param angleRadians {number} The angle to rotate to in radians
         * @param speed {number} The angular velocity of the rotation specified in radians per second
         * @returns Actor
         */
        Actor.prototype.rotateTo = function (angleRadians, speed) {
            this.actionQueue.add(new ex.Internal.Actions.RotateTo(this, angleRadians, speed));
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle by a certain
         * time (in milliseconds) and return back the actor. This method is part
         * of the actor 'Action' fluent API allowing action chaining.
         * @method rotateBy
         * @param angleRadians {number} The angle to rotate to in radians
         * @param time {number} The time it should take the actor to complete the rotation in milliseconds
         * @returns Actor
         */
        Actor.prototype.rotateBy = function (angleRadians, time) {
            this.actionQueue.add(new ex.Internal.Actions.RotateBy(this, angleRadians, time));
            return this;
        };
        /**
         * This method will scale an actor to the specified size at the speed
         * specified (in magnitude increase per second) and return back the
         * actor. This method is part of the actor 'Action' fluent API allowing
         * action chaining.
         * @method scaleTo
         * @param size {number} The scaling factor to apply
         * @param speed {number} The speed of scaling specified in magnitude increase per second
         * @returns Actor
         */
        Actor.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {
            this.actionQueue.add(new ex.Internal.Actions.ScaleTo(this, sizeX, sizeY, speedX, speedY));
            return this;
        };
        /**
         * This method will scale an actor to the specified size by a certain time
         * (in milliseconds) and return back the actor. This method is part of the
         * actor 'Action' fluent API allowing action chaining.
         * @method scaleBy
         * @param size {number} The scaling factor to apply
         * @param time {number} The time it should take to complete the scaling in milliseconds
         * @returns Actor
         */
        Actor.prototype.scaleBy = function (sizeX, sizeY, time) {
            this.actionQueue.add(new ex.Internal.Actions.ScaleBy(this, sizeX, sizeY, time));
            return this;
        };
        /**
         * This method will cause an actor to blink (become visible and not
         * visible). Optionally, you may specify the number of blinks. Specify the amount of time
         * the actor should be visible per blink, and the amount of time not visible.
         * This method is part of the actor 'Action' fluent API allowing action chaining.
         * @method blink
         * @param timeVisible {number} The amount of time to stay visible per blink in milliseconds
         * @param timeNotVisible {number} The amount of time to stay not visible per blink in milliseconds
         * @param [numBlinks] {number} The number of times to blink
         * @returns Actor
         */
        Actor.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            this.actionQueue.add(new ex.Internal.Actions.Blink(this, timeVisible, timeNotVisible, numBlinks));
            return this;
        };
        /**
         * This method will cause an actor's opacity to change from its current value
         * to the provided value by a specified time (in milliseconds). This method is
         * part of the actor 'Action' fluent API allowing action chaining.
         * @method fade
         * @param opacity {number} The ending opacity
         * @param time {number} The time it should take to fade the actor (in milliseconds)
         * @returns Actor
         */
        Actor.prototype.fade = function (opacity, time) {
            this.actionQueue.add(new ex.Internal.Actions.Fade(this, opacity, time));
            return this;
        };
        /**
         * This method will delay the next action from executing for a certain
         * amount of time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @method delay
         * @param time {number} The amount of time to delay the next action in the queue from executing in milliseconds
         * @returns Actor
         */
        Actor.prototype.delay = function (time) {
            this.actionQueue.add(new ex.Internal.Actions.Delay(this, time));
            return this;
        };
        /**
         * This method will add an action to the queue that will remove the actor from the
         * scene once it has completed its previous actions. Any actions on the
         * action queue after this action will not be executed.
         * @method die
         * @returns Actor
         */
        Actor.prototype.die = function () {
            this.actionQueue.add(new ex.Internal.Actions.Die(this));
            return this;
        };
        /**
         * This method allows you to call an arbitrary method as the next action in the
         * action queue. This is useful if you want to execute code in after a specific
         * action, i.e An actor arrives at a destinatino after traversing a path
         * @method callMethod
         * @returns Actor
         */
        Actor.prototype.callMethod = function (method) {
            this.actionQueue.add(new ex.Internal.Actions.CallMethod(this, method));
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions a certain number of times. If the number of repeats
         * is not specified it will repeat forever. This method is part of
         * the actor 'Action' fluent API allowing action chaining
         * @method repeat
         * @param [times=undefined] {number} The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions will repeat forever
         * @returns Actor
         */
        Actor.prototype.repeat = function (times) {
            if (!times) {
                this.repeatForever();
                return this;
            }
            this.actionQueue.add(new ex.Internal.Actions.Repeat(this, times, this.actionQueue.getActions()));
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions forever. This method is part of the actor 'Action'
         * fluent API allowing action chaining.
         * @method repeatForever
         * @returns Actor
         */
        Actor.prototype.repeatForever = function () {
            this.actionQueue.add(new ex.Internal.Actions.RepeatForever(this, this.actionQueue.getActions()));
            return this;
        };
        /**
         * This method will cause the actor to follow another at a specified distance
         * @method follow
         * @param actor {Actor} The actor to follow
         * @param [followDistance=currentDistance] {number} The distance to maintain when following, if not specified the actor will follow at the current distance.
         * @returns Actor
         */
        Actor.prototype.follow = function (actor, followDistance) {
            if (followDistance == undefined) {
                this.actionQueue.add(new ex.Internal.Actions.Follow(this, actor));
            }
            else {
                this.actionQueue.add(new ex.Internal.Actions.Follow(this, actor, followDistance));
            }
            return this;
        };
        /**
         * This method will cause the actor to move towards another until they
         * collide "meet" at a specified speed.
         * @method meet
         * @param actor {Actor} The actor to meet
         * @param [speed=0] {number} The speed in pixels per second to move, if not specified it will match the speed of the other actor
         * @returns Actor
         */
        Actor.prototype.meet = function (actor, speed) {
            if (speed == undefined) {
                this.actionQueue.add(new ex.Internal.Actions.Meet(this, actor));
            }
            else {
                this.actionQueue.add(new ex.Internal.Actions.Meet(this, actor, speed));
            }
            return this;
        };
        /**
         * Returns a promise that resolves when the current action queue up to now
         * is finished.
         * @method asPromise
         * @returns Promise
         */
        Actor.prototype.asPromise = function () {
            var complete = new ex.Promise();
            this.callMethod(function () {
                complete.resolve();
            });
            return complete;
        };
        Actor.prototype._getCalculatedAnchor = function () {
            return new ex.Point(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);
        };
        /**
         * Called by the Engine, updates the state of the actor
         * @method update
         * @param engine {Engine} The reference to the current game engine
         * @param delta {number} The time elapsed since the last update in milliseconds
         */
        Actor.prototype.update = function (engine, delta) {
            if (!this._isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.publish('initialize', new ex.InitializeEvent(engine));
                this._isInitialized = true;
            }
            var eventDispatcher = this.eventDispatcher;
            // Update action queue
            this.actionQueue.update(delta);
            for (var i = 0; i < this.pipeline.length; i++) {
                this.pipeline[i].update(this, engine, delta);
            }
            eventDispatcher.publish(ex.EventType[5 /* Update */], new ex.UpdateEvent(delta));
        };
        /**
         * Called by the Engine, draws the actor to the screen
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The rendering context
         * @param delta {number} The time since the last draw in milliseconds
         */
        Actor.prototype.draw = function (ctx, delta) {
            if (this.isOffScreen) {
                return;
            }
            var anchorPoint = this._getCalculatedAnchor();
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale.x, this.scale.y);
            // calculate changing opacity
            if (this.previousOpacity != this.opacity) {
                for (var drawing in this.frames) {
                    this.frames[drawing].addEffect(new ex.Effects.Opacity(this.opacity));
                }
                this.previousOpacity = this.opacity;
            }
            if (this.currentDrawing) {
                var xDiff = 0;
                var yDiff = 0;
                if (this.centerDrawingX) {
                    xDiff = (this.currentDrawing.width * this.currentDrawing.getScaleX() - this.getWidth()) / 2;
                }
                if (this.centerDrawingY) {
                    yDiff = (this.currentDrawing.height * this.currentDrawing.getScaleY() - this.getHeight()) / 2;
                }
                this.currentDrawing.draw(ctx, -xDiff - anchorPoint.x, -yDiff - anchorPoint.y);
            }
            else {
                if (this.color) {
                    ctx.fillStyle = this.color.toString();
                    ctx.fillRect(-anchorPoint.x, -anchorPoint.y, this.width, this.height);
                }
            }
            this.sceneNode.draw(ctx, delta);
            ctx.restore();
        };
        /**
         * Called by the Engine, draws the actors debugging to the screen
         * @method debugDraw
         * @param ctx {CanvasRenderingContext2D} The rendering context
         */
        Actor.prototype.debugDraw = function (ctx) {
            var bb = this.getBounds();
            bb.debugDraw(ctx);
            ctx.fillStyle = ex.Color.Yellow.toString();
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        /**
         * Indicates the next id to be set
         */
        Actor.maxId = 0;
        return Actor;
    })(ex.Class);
    ex.Actor = Actor;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Logging level that Excalibur will tag
     * @class LogLevel
     */
    (function (LogLevel) {
        /**
         @property Debug {LogLevel}
         @static
         @final
         */
        /**
        @property Info {LogLevel}
        @static
        @final
        */
        /**
        @property Warn {LogLevel}
        @static
        @final
        */
        /**
        @property Error {LogLevel}
        @static
        @final
        */
        /**
        @property Fatal {LogLevel}
        @static
        @final
        */
        LogLevel[LogLevel["Debug"] = 0] = "Debug";
        LogLevel[LogLevel["Info"] = 1] = "Info";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
    })(ex.LogLevel || (ex.LogLevel = {}));
    var LogLevel = ex.LogLevel;
    /**
     * Static singleton that represents the logging facility for Excalibur.
     * Excalibur comes built-in with a ConsoleAppender and ScreenAppender.
     * Derive from IAppender to create your own logging appenders.
     * @class Logger
     * @static
     */
    var Logger = (function () {
        function Logger() {
            this.appenders = [];
            /**
             * Gets or sets the default logging level. Excalibur will only log
             * messages if equal to or above this level.
             * @property defaultLevel {LogLevel}
             */
            this.defaultLevel = 1 /* Info */;
            if (Logger._instance) {
                throw new Error("Logger is a singleton");
            }
            Logger._instance = this;
            // Default console appender
            Logger._instance.addAppender(new ConsoleAppender());
            return Logger._instance;
        }
        /**
         * Gets the current static instance of Logger
         * @method getInstance
         * @static
         * @returns Logger
         */
        Logger.getInstance = function () {
            if (Logger._instance == null) {
                Logger._instance = new Logger();
            }
            return Logger._instance;
        };
        /**
         * Adds a new IAppender to the list of appenders to write to
         * @method addAppender
         * @param appender {IAppender} Appender to add
         */
        Logger.prototype.addAppender = function (appender) {
            this.appenders.push(appender);
        };
        /**
         * Clears all appenders from the logger
         * @method clearAppenders
         */
        Logger.prototype.clearAppenders = function () {
            this.appenders.length = 0;
        };
        /**
         * Logs a message at a given LogLevel
         * @method _log
         * @private
         * @param level {LogLevel}The LogLevel`to log the message at
         * @param args An array of arguments to write to an appender
         */
        Logger.prototype._log = function (level, args) {
            var _this = this;
            if (level == null) {
                level = this.defaultLevel;
            }
            this.appenders.forEach(function (appender) {
                if (level >= _this.defaultLevel) {
                    appender.log(level, args);
                }
            });
        };
        /**
         * Writes a log message at the LogLevel.Debug level
         * @method debug
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(0 /* Debug */, args);
        };
        /**
         * Writes a log message at the LogLevel.Info level
         * @method info
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(1 /* Info */, args);
        };
        /**
         * Writes a log message at the LogLevel.Warn level
         * @method warn
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(2 /* Warn */, args);
        };
        /**
         * Writes a log message at the LogLevel.Error level
         * @method error
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(3 /* Error */, args);
        };
        /**
         * Writes a log message at the LogLevel.Fatal level
         * @method fatal
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.fatal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(4 /* Fatal */, args);
        };
        Logger._instance = null;
        return Logger;
    })();
    ex.Logger = Logger;
    /**
     * Console appender for browsers (i.e. console.log)
     * @class ConsoleAppender
     * @constructor
     * @extends IAppender
     */
    var ConsoleAppender = (function () {
        function ConsoleAppender() {
        }
        ConsoleAppender.prototype.log = function (level, args) {
            // Check for console support
            if (!console && !console.log && console.warn && console.error) {
                // todo maybe do something better than nothing
                return;
            }
            // Create a new console args array
            var consoleArgs = [];
            consoleArgs.unshift.apply(consoleArgs, args);
            consoleArgs.unshift("[" + LogLevel[level] + "] : ");
            if (level < 2 /* Warn */) {
                // Call .log for Debug/Info
                if (console.log.apply) {
                    // this is required on some older browsers that don't support apply on console.log :(
                    console.log.apply(console, consoleArgs);
                }
                else {
                    console.log(consoleArgs.join(' '));
                }
            }
            else if (level < 3 /* Error */) {
                // Call .warn for Warn
                if (console.warn.apply) {
                    console.warn.apply(console, consoleArgs);
                }
                else {
                    console.warn(consoleArgs.join(' '));
                }
            }
            else {
                // Call .error for Error/Fatal
                if (console.error.apply) {
                    console.error.apply(console, consoleArgs);
                }
                else {
                    console.error(consoleArgs.join(' '));
                }
            }
        };
        return ConsoleAppender;
    })();
    ex.ConsoleAppender = ConsoleAppender;
    /**
     * On-screen (canvas) appender
     * @todo Clean this up
     * @class ScreenAppender
     * @extends IAppender
     * @constructor
     * @param width {number} Width of the screen appender in pixels
     * @param height {number} Height of the screen appender in pixels
     */
    var ScreenAppender = (function () {
        function ScreenAppender(width, height) {
            this._messages = [];
            this.canvas = document.createElement('canvas');
            this.canvas.width = width || window.innerWidth;
            this.canvas.height = height || window.innerHeight;
            this.canvas.style.position = 'absolute';
            this.ctx = this.canvas.getContext('2d');
            document.body.appendChild(this.canvas);
        }
        ScreenAppender.prototype.log = function (level, args) {
            var message = args.join(",");
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this._messages.unshift("[" + LogLevel[level] + "] : " + message);
            var pos = 10;
            var opacity = 1.0;
            for (var i = 0; i < this._messages.length; i++) {
                this.ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
                this.ctx.fillText(this._messages[i], 200, pos);
                pos += 10;
                opacity = opacity > 0 ? opacity - .05 : 0;
            }
        };
        return ScreenAppender;
    })();
    ex.ScreenAppender = ScreenAppender;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Actor.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    /**
     * An enum representing all of the built in event types for Excalibur
     * @class EventType
     */
    (function (EventType) {
        /**
        @property UserEvent {EventType}
        @static
        @final
        */
        /**
        @property Blur {EventType}
        @static
        @final
        */
        /**
        @property Focus {EventType}
        @static
        @final
        */
        /**
        @property Update {EventType}
        @static
        @final
        */
        /**
        @property EnterViewPort {EventType}
        @static
        @final
        */
        /**
        @property ExitViewPort {EventType}
        @static
        @final
        */
        /**
        @property Activate {EventType}
        @static
        @final
        */
        /**
        @property Deactivate {EventType}
        @static
        @final
        */
        /**
        @property Initialize {EventType}
        @static
        @final
        */
        EventType[EventType["Collision"] = 0] = "Collision";
        EventType[EventType["EnterViewPort"] = 1] = "EnterViewPort";
        EventType[EventType["ExitViewPort"] = 2] = "ExitViewPort";
        EventType[EventType["Blur"] = 3] = "Blur";
        EventType[EventType["Focus"] = 4] = "Focus";
        EventType[EventType["Update"] = 5] = "Update";
        EventType[EventType["Activate"] = 6] = "Activate";
        EventType[EventType["Deactivate"] = 7] = "Deactivate";
        EventType[EventType["Initialize"] = 8] = "Initialize";
    })(ex.EventType || (ex.EventType = {}));
    var EventType = ex.EventType;
    /**
     * Base event type in Excalibur that all other event types derive from.
     *
     * @class GameEvent
     * @constructor
     * @param target {any} Events can have target game object, like the Engine, or an Actor.
     */
    var GameEvent = (function () {
        function GameEvent() {
        }
        return GameEvent;
    })();
    ex.GameEvent = GameEvent;
    /**
     * Event received by the Engine when the browser window is visible
     *
     * @class VisibleEvent
     * @extends GameEvent
     * @constructor
     */
    var VisibleEvent = (function (_super) {
        __extends(VisibleEvent, _super);
        function VisibleEvent() {
            _super.call(this);
        }
        return VisibleEvent;
    })(GameEvent);
    ex.VisibleEvent = VisibleEvent;
    /**
     * Event received by the Engine when the browser window is hidden
     *
     * @class HiddenEvent
     * @extends GameEvent
     * @constructor
     */
    var HiddenEvent = (function (_super) {
        __extends(HiddenEvent, _super);
        function HiddenEvent() {
            _super.call(this);
        }
        return HiddenEvent;
    })(GameEvent);
    ex.HiddenEvent = HiddenEvent;
    /**
     * Event thrown on an actor when a collision has occured
     *
     * @class CollisionEvent
     * @extends GameEvent
     * @constructor
     * @param actor {Actor} The actor the event was thrown on
     * @param other {Actor} The actor that was collided with
     * @param side {Side} The side that was collided with
     */
    var CollisionEvent = (function (_super) {
        __extends(CollisionEvent, _super);
        function CollisionEvent(actor, other, side, intersection) {
            _super.call(this);
            this.actor = actor;
            this.other = other;
            this.side = side;
            this.intersection = intersection;
        }
        return CollisionEvent;
    })(GameEvent);
    ex.CollisionEvent = CollisionEvent;
    /**
     * Event thrown on a game object on Excalibur update
     *
     * @class UpdateEvent
     * @extends GameEvent
     * @constructor
     * @param delta {number} The number of milliseconds since the last update
     */
    var UpdateEvent = (function (_super) {
        __extends(UpdateEvent, _super);
        function UpdateEvent(delta) {
            _super.call(this);
            this.delta = delta;
        }
        return UpdateEvent;
    })(GameEvent);
    ex.UpdateEvent = UpdateEvent;
    /**
     * Event thrown on an Actor only once before the first update call
     *
     * @class InitializeEvent
     * @extends GameEvent
     * @constructor
     * @param engine {Engine} The reference to the current engine
     */
    var InitializeEvent = (function (_super) {
        __extends(InitializeEvent, _super);
        function InitializeEvent(engine) {
            _super.call(this);
            this.engine = engine;
        }
        return InitializeEvent;
    })(GameEvent);
    ex.InitializeEvent = InitializeEvent;
    /**
     * Event thrown on a Scene on activation
     *
     * @class ActivateEvent
     * @extends GameEvent
     * @constructor
     * @param oldScene {Scene} The reference to the old scene
     */
    var ActivateEvent = (function (_super) {
        __extends(ActivateEvent, _super);
        function ActivateEvent(oldScene) {
            _super.call(this);
            this.oldScene = oldScene;
        }
        return ActivateEvent;
    })(GameEvent);
    ex.ActivateEvent = ActivateEvent;
    /**
     * Event thrown on a Scene on deactivation
     *
     * @class DeactivateEvent
     * @extends GameEvent
     * @constructor
     * @param newScene {Scene} The reference to the new scene
     */
    var DeactivateEvent = (function (_super) {
        __extends(DeactivateEvent, _super);
        function DeactivateEvent(newScene) {
            _super.call(this);
            this.newScene = newScene;
        }
        return DeactivateEvent;
    })(GameEvent);
    ex.DeactivateEvent = DeactivateEvent;
    /**
     * Event thrown on an Actor when it completely leaves the screen.
     * @class ExitViewPortEvent
     * @constructor
     */
    var ExitViewPortEvent = (function (_super) {
        __extends(ExitViewPortEvent, _super);
        function ExitViewPortEvent() {
            _super.call(this);
        }
        return ExitViewPortEvent;
    })(GameEvent);
    ex.ExitViewPortEvent = ExitViewPortEvent;
    /**
     * Event thrown on an Actor when it completely leaves the screen.
     * @class EnterViewPortEvent
     * @constructor
     */
    var EnterViewPortEvent = (function (_super) {
        __extends(EnterViewPortEvent, _super);
        function EnterViewPortEvent() {
            _super.call(this);
        }
        return EnterViewPortEvent;
    })(GameEvent);
    ex.EnterViewPortEvent = EnterViewPortEvent;
    /**
     * Enum representing the different mouse buttons
     * @class MouseButton
     */
    (function (MouseButton) {
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Left"] = 0] = "Left";
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Middle"] = 1] = "Middle";
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Right"] = 2] = "Right";
    })(ex.MouseButton || (ex.MouseButton = {}));
    var MouseButton = ex.MouseButton;
})(ex || (ex = {}));
/// <reference path="Events.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur's internal event dispatcher implementation. Callbacks are fired immediately after an event is published
     * @class EventDispatcher
     * @constructor
     * @param target {any} The object that will be the recipient of events from this event dispatcher
     */
    var EventDispatcher = (function () {
        function EventDispatcher(target) {
            this._handlers = {};
            this.log = ex.Logger.getInstance();
            this.target = target;
        }
        /**
         * Publish an event for target
         * @method publish
         * @param eventName {string} The name of the event to publish
         * @param [event=undefined] {GameEvent} Optionally pass an event data object to the handler
         */
        EventDispatcher.prototype.publish = function (eventName, event) {
            if (!eventName) {
                // key not mapped
                return;
            }
            eventName = eventName.toLowerCase();
            var target = this.target;
            if (!event) {
                event = new ex.GameEvent();
            }
            event.target = target;
            if (this._handlers[eventName]) {
                this._handlers[eventName].forEach(function (callback) {
                    callback.call(target, event);
                });
            }
        };
        /**
         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
         * @method subscribe
         * @param eventName {string} The name of the event to subscribe to
         * @param handler {GameEvent=>void} The handler callback to fire on this event
         */
        EventDispatcher.prototype.subscribe = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            if (!this._handlers[eventName]) {
                this._handlers[eventName] = [];
            }
            this._handlers[eventName].push(handler);
        };
        /**
         * Unsubscribe a event handler(s) from an event. If a specific handler
         * is specified for an event, only that handler will be unsubscribed.
         * Otherwise all handlers will be unsubscribed for that event.
         * @method unsubscribe
         * @param eventName {string} The name of the event to unsubscribe
         * @param [handler=undefined] Optionally the specific handler to unsubscribe
         *
         */
        EventDispatcher.prototype.unsubscribe = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            var eventHandlers = this._handlers[eventName];
            if (eventHandlers) {
                // if no explicit handler is give with the event name clear all handlers
                if (!handler) {
                    this._handlers[eventName].length = 0;
                }
                else {
                    var index = eventHandlers.indexOf(handler);
                    if (index < 0)
                        return;
                    this._handlers[eventName].splice(index, 1);
                }
            }
        };
        return EventDispatcher;
    })();
    ex.EventDispatcher = EventDispatcher;
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Color = (function () {
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @class Color
         * @constructor
         * @param r {number} The red component of color (0-255)
         * @param g {number} The green component of color (0-255)
         * @param b {number} The blue component of color (0-255)
         * @param [a=1] {number} The alpha component of color (0-1.0)
         */
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            this.a = (a != null ? a : 1);
        }
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @method fromRGB
         * @static
         * @param r {number} The red component of color (0-255)
         * @param g {number} The green component of color (0-255)
         * @param b {number} The blue component of color (0-255)
         * @param [a=1] {number} The alpha component of color (0-1.0)
         */
        Color.fromRGB = function (r, g, b, a) {
            return new Color(r, g, b, a);
        };
        /**
         * Creates a new inscance of Color from a hex string
         *
         * @method fromHex
         * @static
         * @param hex {string} CSS color string of the form #ffffff, the alpha component is optional
         */
        Color.fromHex = function (hex) {
            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
            var match = null;
            if (match = hex.match(hexRegEx)) {
                var r = parseInt(match[1], 16);
                var g = parseInt(match[2], 16);
                var b = parseInt(match[3], 16);
                var a = 1;
                if (match[4]) {
                    a = parseInt(match[4], 16) / 255;
                }
                return new Color(r, g, b, a);
            }
            else {
                throw new Error("Invalid hex string: " + hex);
            }
        };
        /**
         * Returns a CSS string representation of a color.
         * @method toString
         * @returns string
         */
        Color.prototype.toString = function () {
            var result = String(this.r.toFixed(0)) + ", " + String(this.g.toFixed(0)) + ", " + String(this.b.toFixed(0));
            if (this.a !== undefined || this.a !== null) {
                return "rgba(" + result + ", " + String(this.a) + ")";
            }
            return "rgb(" + result + ")";
        };
        /**
         * Returns a CSS string representation of a color.
         * @method fillStyle
         * @returns string
         */
        Color.prototype.fillStyle = function () {
            return this.toString();
        };
        /**
         * Returns a clone of the current color.
         * @method clone
         * @returns Color
         */
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        /**
         * Color constant
         * @property Black {ex.Color}
         * @static
         * @final
         */
        Color.Black = Color.fromHex('#000000');
        /**
         * Color constant
         * @property White {ex.Color}
         * @static
         * @final
         */
        Color.White = Color.fromHex('#FFFFFF');
        /**
         * Color constant
         * @property Gray {ex.Color}
         * @static
         * @final
         */
        Color.Gray = Color.fromHex('#808080');
        /**
         * Color constant
         * @property LightGray {ex.Color}
         * @static
         * @final
         */
        Color.LightGray = Color.fromHex('#D3D3D3');
        /**
         * Color constant
         * @property DarkGray {ex.Color}
         * @static
         * @final
         */
        Color.DarkGray = Color.fromHex('#A9A9A9');
        /**
         * Color constant
         * @property Yellow {ex.Color}
         * @static
         * @final
         */
        Color.Yellow = Color.fromHex('#FFFF00');
        /**
         * Color constant
         * @property Orange {ex.Color}
         * @static
         * @final
         */
        Color.Orange = Color.fromHex('#FFA500');
        /**
         * Color constant
         * @property Red {ex.Color}
         * @static
         * @final
         */
        Color.Red = Color.fromHex('#FF0000');
        /**
         * Color constant
         * @property Vermillion {ex.Color}
         * @static
         * @final
         */
        Color.Vermillion = Color.fromHex('#FF5B31');
        /**
         * Color constant
         * @property Rose {ex.Color}
         * @static
         * @final
         */
        Color.Rose = Color.fromHex('#FF007F');
        /**
         * Color constant
         * @property Magenta {ex.Color}
         * @static
         * @final
         */
        Color.Magenta = Color.fromHex('#FF00FF');
        /**
         * Color constant
         * @property Violet {ex.Color}
         * @static
         * @final
         */
        Color.Violet = Color.fromHex('#7F00FF');
        /**
         * Color constant
         * @property Blue {ex.Color}
         * @static
         * @final
         */
        Color.Blue = Color.fromHex('#0000FF');
        /**
         * Color constant
         * @property Azure {ex.Color}
         * @static
         * @final
         */
        Color.Azure = Color.fromHex('#007FFF');
        /**
         * Color constant
         * @property Cyan {ex.Color}
         * @static
         * @final
         */
        Color.Cyan = Color.fromHex('#00FFFF');
        /**
         * Color constant
         * @property Viridian {ex.Color}
         * @static
         * @final
         */
        Color.Viridian = Color.fromHex('#59978F');
        /**
         * Color constant
         * @property Green {ex.Color}
         * @static
         * @final
         */
        Color.Green = Color.fromHex('#00FF00');
        /**
         * Color constant
         * @property Chartreuse {ex.Color}
         * @static
         * @final
         */
        Color.Chartreuse = Color.fromHex('#7FFF00');
        /**
         * Color constant
         * @property Transparent {ex.Color}
         * @static
         * @final
         */
        Color.Transparent = Color.fromHex('#FFFFFF00');
        return Color;
    })();
    ex.Color = Color;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * Helper Actor primitive for drawing UI's, optimized for UI drawing. Does
     * not participate in collisions.
     * @class UIActor
     * @extends Actor
     * @constructor
     * @param [x=0.0] {number} The starting x coordinate of the actor
     * @param [y=0.0] {number} The starting y coordinate of the actor
     * @param [width=0.0] {number} The starting width of the actor
     * @param [height=0.0] {number} The starting height of the actor
     */
    var UIActor = (function (_super) {
        __extends(UIActor, _super);
        function UIActor(x, y, width, height) {
            _super.call(this, x, y, width, height);
            this.pipeline = [];
            this.pipeline.push(new ex.MovementModule());
            this.pipeline.push(new ex.CapturePointerModule());
            this.anchor.setTo(0, 0);
            this.collisionType = 0 /* PreventCollision */;
            this.enableCapturePointer = true;
        }
        UIActor.prototype.onInitialize = function (engine) {
            this._engine = engine;
        };
        UIActor.prototype.contains = function (x, y, useWorld) {
            if (useWorld === void 0) { useWorld = true; }
            if (useWorld)
                return _super.prototype.contains.call(this, x, y);
            var coords = this._engine.worldToScreenCoordinates(new ex.Point(x, y));
            return _super.prototype.contains.call(this, coords.x, coords.y);
        };
        return UIActor;
    })(ex.Actor);
    ex.UIActor = UIActor;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
/// <reference path="Engine.ts" />
var ex;
(function (ex) {
    /**
     * Triggers a method of firing arbitrary code on collision. These are useful
     * as 'buttons', 'switches', or to trigger effects in a game. By defualt triggers
     * are invisible, and can only be seen with debug mode enabled on the Engine.
     * @class Trigger
     * @constructor
     * @param [x=0] {number} The x position of the trigger
     * @param [y=0] {number} The y position of the trigger
     * @param [width=0] {number} The width of the trigger
     * @param [height=0] {number} The height of the trigger
     * @param [action=null] {()=>void} Callback to fire when trigger is activated
     * @param [repeats=1] {number} The number of times that this trigger should fire, by default it is 1, if -1 is supplied it will fire indefinitely
     */
    var Trigger = (function (_super) {
        __extends(Trigger, _super);
        function Trigger(x, y, width, height, action, repeats) {
            _super.call(this, x, y, width, height);
            this.action = function () {
            };
            this.repeats = 1;
            this.target = null;
            this.repeats = repeats || this.repeats;
            this.action = action || this.action;
            this.collisionType = 0 /* PreventCollision */;
            this.eventDispatcher = new ex.EventDispatcher(this);
            this.actionQueue = new ex.Internal.Actions.ActionQueue(this);
        }
        Trigger.prototype.update = function (engine, delta) {
            // Update action queue
            this.actionQueue.update(delta);
            // Update placements based on linear algebra
            this.x += this.dx * delta / 1000;
            this.y += this.dy * delta / 1000;
            this.rotation += this.rx * delta / 1000;
            this.scale.x += this.sx * delta / 1000;
            this.scale.y += this.sy * delta / 1000;
            // check for trigger collisions
            if (this.target) {
                if (this.collides(this.target)) {
                    this.dispatchAction();
                }
            }
            else {
                for (var i = 0; i < engine.currentScene.children.length; i++) {
                    var other = engine.currentScene.children[i];
                    if (other !== this && other.collisionType !== 0 /* PreventCollision */ && this.collides(other)) {
                        this.dispatchAction();
                    }
                }
            }
            // remove trigger if its done, -1 repeat forever
            if (this.repeats === 0) {
                this.kill();
            }
        };
        Trigger.prototype.dispatchAction = function () {
            this.action.call(this);
            this.repeats--;
        };
        Trigger.prototype.draw = function (ctx, delta) {
            // does not draw
            return;
        };
        Trigger.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            // Meant to draw debug information about actors
            ctx.save();
            ctx.translate(this.x, this.y);
            var bb = this.getBounds();
            bb.left = bb.left - this.getGlobalX();
            bb.right = bb.right - this.getGlobalX();
            bb.top = bb.top - this.getGlobalY();
            bb.bottom = bb.bottom - this.getGlobalY();
            // Currently collision primitives cannot rotate 
            // ctx.rotate(this.rotation);
            ctx.fillStyle = ex.Color.Violet.toString();
            ctx.strokeStyle = ex.Color.Violet.toString();
            ctx.fillText('Trigger', 10, 10);
            bb.debugDraw(ctx);
            ctx.restore();
        };
        return Trigger;
    })(ex.Actor);
    ex.Trigger = Trigger;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Algebra.ts" />
/// <reference path="Util.ts" />
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * An enum that represents the types of emitter nozzles
     * @class EmitterType
     */
    (function (EmitterType) {
        /**
         * Constant for the circular emitter type
         * @property Circle {EmitterType}
         */
        EmitterType[EmitterType["Circle"] = 0] = "Circle";
        /**
         * Constant for the rectangular emitter type
         * @property Rectangle {EmitterType}
         */
        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
    })(ex.EmitterType || (ex.EmitterType = {}));
    var EmitterType = ex.EmitterType;
    var Particle = (function () {
        function Particle(emitter, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            this.position = new ex.Vector(0, 0);
            this.velocity = new ex.Vector(0, 0);
            this.acceleration = new ex.Vector(0, 0);
            this.particleRotationalVelocity = 0;
            this.currentRotation = 0;
            this.focus = null;
            this.focusAccel = 0;
            this.opacity = 1;
            this.beginColor = ex.Color.White.clone();
            this.endColor = ex.Color.White.clone();
            // Life is counted in ms
            this.life = 300;
            this.fadeFlag = false;
            // Color transitions
            this.rRate = 1;
            this.gRate = 1;
            this.bRate = 1;
            this.aRate = 0;
            this.currentColor = ex.Color.White.clone();
            this.emitter = null;
            this.particleSize = 5;
            this.particleSprite = null;
            this.sizeRate = 0;
            this.elapsedMultiplier = 0;
            this.emitter = emitter;
            this.life = life || this.life;
            this.opacity = opacity || this.opacity;
            this.endColor = endColor || this.endColor.clone();
            this.beginColor = beginColor || this.beginColor.clone();
            this.currentColor = this.beginColor.clone();
            this.position = position || this.position;
            this.velocity = velocity || this.velocity;
            this.acceleration = acceleration || this.acceleration;
            this.rRate = (this.endColor.r - this.beginColor.r) / this.life;
            this.gRate = (this.endColor.g - this.beginColor.g) / this.life;
            this.bRate = (this.endColor.b - this.beginColor.b) / this.life;
            this.aRate = this.opacity / this.life;
            this.startSize = startSize || 0;
            this.endSize = endSize || 0;
            if ((this.endSize > 0) && (this.startSize > 0)) {
                this.sizeRate = (this.endSize - this.startSize) / this.life;
                this.particleSize = this.startSize;
            }
        }
        Particle.prototype.kill = function () {
            this.emitter.removeParticle(this);
        };
        Particle.prototype.update = function (delta) {
            this.life = this.life - delta;
            this.elapsedMultiplier = this.elapsedMultiplier + delta;
            if (this.life < 0) {
                this.kill();
            }
            if (this.fadeFlag) {
                this.opacity = ex.Util.clamp(this.aRate * this.life, 0.0001, 1);
            }
            if ((this.startSize > 0) && (this.endSize > 0)) {
                this.particleSize = ex.Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
            }
            this.currentColor.r = ex.Util.clamp(this.currentColor.r + this.rRate * delta, 0, 255);
            this.currentColor.g = ex.Util.clamp(this.currentColor.g + this.gRate * delta, 0, 255);
            this.currentColor.b = ex.Util.clamp(this.currentColor.b + this.bRate * delta, 0, 255);
            this.currentColor.a = ex.Util.clamp(this.opacity, 0.0001, 1);
            if (this.focus) {
                var accel = this.focus.minus(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);
                this.velocity = this.velocity.add(accel);
            }
            else {
                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
            }
            this.position = this.position.add(this.velocity.scale(delta / 1000));
            if (this.particleRotationalVelocity) {
                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);
            }
        };
        Particle.prototype.draw = function (ctx) {
            if (this.particleSprite) {
                this.particleSprite.setRotation(this.currentRotation);
                this.particleSprite.setScaleX(this.particleSize);
                this.particleSprite.setScaleY(this.particleSize);
                this.particleSprite.draw(ctx, this.position.x, this.position.y);
                return;
            }
            this.currentColor.a = ex.Util.clamp(this.opacity, 0.0001, 1);
            ctx.fillStyle = this.currentColor.toString();
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };
        return Particle;
    })();
    ex.Particle = Particle;
    /**
     * Using a particle emitter is a great way to create interesting effects
     * in your game, like smoke, fire, water, explosions, etc. Particle Emitters
     * extend Actor allowing you to use all of the features that come with Actor
     * @class ParticleEmitter
     * @constructor
     * @param [x=0] {number} The x position of the emitter
     * @param [y=0] {number} The y position of the emitter
     * @param [width=0] {number} The width of the emitter
     * @param [height=0] {number} The height of the emitter
     */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        function ParticleEmitter(x, y, width, height) {
            _super.call(this, x, y, width, height, ex.Color.White);
            this._particlesToEmit = 0;
            this.numParticles = 0;
            /**
             * Gets or sets the isEmitting flag
             * @property isEmitting {boolean}
             */
            this.isEmitting = true;
            /**
             * Gets or sets the backing particle collection
             * @property particles {Util.Collection&lt;Particle&gt;}
             */
            this.particles = null;
            /**
             * Gets or sets the backing deadParticle collection
             * @property particles {Util.Collection&lt;Particle&gt;}
             */
            this.deadParticles = null;
            /**
             * Gets or sets the minimum partical velocity
             * @property [minVel=0] {number}
             */
            this.minVel = 0;
            /**
             * Gets or sets the maximum partical velocity
             * @property [maxVel=0] {number}
             */
            this.maxVel = 0;
            /**
             * Gets or sets the acceleration vector for all particles
             * @property [acceleration=new Vector(0,0)] {Vector}
             */
            this.acceleration = new ex.Vector(0, 0);
            /**
             * Gets or sets the minimum angle in radians
             * @property [minAngle=0] {number}
             */
            this.minAngle = 0;
            /**
             * Gets or sets the maximum angle in radians
             * @property [maxAngle=0] {number}
             */
            this.maxAngle = 0;
            /**
             * Gets or sets the emission rate for particles (particles/sec)
             * @property [emitRate=1] {number}
             */
            this.emitRate = 1; //particles/sec
            /**
             * Gets or sets the life of each particle in milliseconds
             * @property [particleLife=2000] {number}
             */
            this.particleLife = 2000;
            /**
             * Gets or sets the opacity of each particle from 0 to 1.0
             * @property [opacity=1.0] {number}
             */
            this.opacity = 1;
            /**
             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
             * @property [fade=false] {boolean}
             */
            this.fadeFlag = false;
            /**
             * Gets or sets the optional focus where all particles should accelerate towards
             * @property [focus=null] {Vector}
             */
            this.focus = null;
            /**
             * Gets or sets the acceleration for focusing particles if a focus has been specified
             * @property [focusAccel=1] {number}
             */
            this.focusAccel = 1;
            /*
             * Gets or sets the optional starting size for the particles
             * @property [startSize=null] {number}
             */
            this.startSize = null;
            /*
             * Gets or sets the optional ending size for the particles
             * @property [endSize=null] {number}
             */
            this.endSize = null;
            /**
             * Gets or sets the minimum size of all particles
             * @property [minSize=5] {number}
             */
            this.minSize = 5;
            /**
             * Gets or sets the maximum size of all particles
             * @property [maxSize=5] {number}
             */
            this.maxSize = 5;
            /**
             * Gets or sets the beginning color of all particles
             * @property [beginColor=Color.White] {Color}
             */
            this.beginColor = ex.Color.White;
            /**
             * Gets or sets the ending color of all particles
             * @property [endColor=Color.White] {Color}
             */
            this.endColor = ex.Color.White;
            /**
             * Gets or sets the sprite that a particle should use
             * @property [particleSprite=null] {Sprite}
             */
            this.particleSprite = null;
            /**
             * Gets or sets the emitter type for the particle emitter
             * @property [emitterType=EmitterType.Rectangle] {EmitterType}
             */
            this.emitterType = 1 /* Rectangle */;
            /**
             * Gets or sets the emitter radius, only takes effect when the emitterType is Circle
             * @property [radius=0] {number}
             */
            this.radius = 0;
            /**
             * Gets or sets the particle rotational speed velocity
             * @property [particleRotationalVelocity=0] {number}
             */
            this.particleRotationalVelocity = 0;
            /**
             * Indicates whether particles should start with a random rotation
             * @property [randomRotation=false] {boolean}
             */
            this.randomRotation = false;
            this.collisionType = 0 /* PreventCollision */;
            this.particles = new ex.Util.Collection();
            this.deadParticles = new ex.Util.Collection();
        }
        ParticleEmitter.prototype.removeParticle = function (particle) {
            this.deadParticles.push(particle);
        };
        /**
         * Causes the emitter to emit particles
         * @method emit
         * @param particleCount {number} Number of particles to emit right now
         */
        ParticleEmitter.prototype.emit = function (particleCount) {
            for (var i = 0; i < particleCount; i++) {
                this.particles.push(this.createParticle());
            }
        };
        ParticleEmitter.prototype.clearParticles = function () {
            this.particles.clear();
        };
        // Creates a new particle given the contraints of the emitter
        ParticleEmitter.prototype.createParticle = function () {
            // todo implement emitter contraints;
            var ranX = 0;
            var ranY = 0;
            var angle = ex.Util.randomInRange(this.minAngle, this.maxAngle);
            var vel = ex.Util.randomInRange(this.minVel, this.maxVel);
            var size = this.startSize || ex.Util.randomInRange(this.minSize, this.maxSize);
            var dx = vel * Math.cos(angle);
            var dy = vel * Math.sin(angle);
            if (this.emitterType === 1 /* Rectangle */) {
                ranX = ex.Util.randomInRange(this.x, this.x + this.getWidth());
                ranY = ex.Util.randomInRange(this.y, this.y + this.getHeight());
            }
            else if (this.emitterType === 0 /* Circle */) {
                var radius = ex.Util.randomInRange(0, this.radius);
                ranX = radius * Math.cos(angle) + this.x;
                ranY = radius * Math.sin(angle) + this.y;
            }
            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new ex.Vector(ranX, ranY), new ex.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
            p.fadeFlag = this.fadeFlag;
            p.particleSize = size;
            if (this.particleSprite) {
                p.particleSprite = this.particleSprite;
            }
            p.particleRotationalVelocity = this.particleRotationalVelocity;
            if (this.randomRotation) {
                p.currentRotation = ex.Util.randomInRange(0, Math.PI * 2);
            }
            if (this.focus) {
                p.focus = this.focus.add(new ex.Vector(this.x, this.y));
                p.focusAccel = this.focusAccel;
            }
            return p;
        };
        ParticleEmitter.prototype.update = function (engine, delta) {
            var _this = this;
            _super.prototype.update.call(this, engine, delta);
            if (this.isEmitting) {
                this._particlesToEmit += this.emitRate * (delta / 1000);
                var numParticles = Math.ceil(this.emitRate * delta / 1000);
                if (this._particlesToEmit > 1.0) {
                    this.emit(Math.floor(this._particlesToEmit));
                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
                }
            }
            this.particles.forEach(function (particle, index) {
                particle.update(delta);
            });
            this.deadParticles.forEach(function (particle, index) {
                _this.particles.removeElement(particle);
            });
            this.deadParticles.clear();
        };
        ParticleEmitter.prototype.draw = function (ctx, delta) {
            this.particles.forEach(function (particle, index) {
                // todo is there a more efficient to draw 
                // possibly use a webgl offscreen canvas and shaders to do particles?
                particle.draw(ctx);
            });
        };
        ParticleEmitter.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            ctx.fillStyle = ex.Color.Black.toString();
            ctx.fillText("Particles: " + this.particles.count(), this.x, this.y + 20);
            if (this.focus) {
                ctx.fillRect(this.focus.x + this.x, this.focus.y + this.y, 3, 3);
                ex.Util.drawLine(ctx, "yellow", this.focus.x + this.x, this.focus.y + this.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);
                ctx.fillText("Focus", this.focus.x + this.x, this.focus.y + this.y);
            }
        };
        return ParticleEmitter;
    })(ex.Actor);
    ex.ParticleEmitter = ParticleEmitter;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Animations allow you to display a series of images one after another,
     * creating the illusion of change. Generally these images will come from a sprite sheet source.
     * @class Animation
     * @extends IDrawable
     * @constructor
     * @param engine {Engine} Reference to the current game engine
     * @param images {Sprite[]} An array of sprites to create the frames for the animation
     * @param speed {number} The number in milliseconds to display each frame in the animation
     * @param [loop=false] {boolean} Indicates whether the animation should loop after it is completed
     */
    var Animation = (function () {
        function Animation(engine, images, speed, loop) {
            this.currIndex = 0;
            this.oldTime = Date.now();
            this.rotation = 0.0;
            this.scaleX = 1.0;
            this.scaleY = 1.0;
            /**
             * Indicates whether the animation should loop after it is completed
             * @property [loop=false] {boolean}
             */
            this.loop = false;
            this.freezeFrame = -1;
            this.flipVertical = false;
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.sprites = images;
            this.speed = speed;
            this.engine = engine;
            if (loop != null) {
                this.loop = loop;
            }
            this.height = images[0] ? images[0].height : 0;
            this.width = images[0] ? images[0].width : 0;
        }
        Animation.prototype.addEffect = function (effect) {
            for (var i in this.sprites) {
                this.sprites[i].addEffect(effect);
            }
        };
        Animation.prototype.removeEffect = function (param) {
            for (var i in this.sprites) {
                this.sprites[i].removeEffect(param);
            }
        };
        Animation.prototype.clearEffects = function () {
            for (var i in this.sprites) {
                this.sprites[i].clearEffects();
            }
        };
        Animation.prototype.transformAboutPoint = function (point) {
            for (var i in this.sprites) {
                this.sprites[i].transformAboutPoint(point);
            }
        };
        Animation.prototype.setRotation = function (radians) {
            this.rotation = radians;
            for (var i in this.sprites) {
                this.sprites[i].setRotation(radians);
            }
        };
        Animation.prototype.getRotation = function () {
            return this.rotation;
        };
        Animation.prototype.setScaleX = function (scaleX) {
            this.scaleX = scaleX;
            for (var i in this.sprites) {
                this.sprites[i].setScaleX(scaleX);
            }
        };
        Animation.prototype.setScaleY = function (scaleY) {
            this.scaleY = scaleY;
            for (var i in this.sprites) {
                this.sprites[i].setScaleY(scaleY);
            }
        };
        Animation.prototype.getScaleX = function () {
            return this.scaleX;
        };
        Animation.prototype.getScaleY = function () {
            return this.scaleY;
        };
        /**
         * Resets the animation to first frame.
         * @method reset
         */
        Animation.prototype.reset = function () {
            this.currIndex = 0;
        };
        /**
         * Indicates whether the animation is complete, animations that loop are never complete.
         * @method isDone
         * @returns boolean
         */
        Animation.prototype.isDone = function () {
            return (!this.loop && this.currIndex >= this.sprites.length);
        };
        /**
         * Not meant to be called by game developers. Ticks the animation forward internally an
         * calculates whether to change to teh frame.
         * @method tick
         */
        Animation.prototype.tick = function () {
            var time = Date.now();
            if ((time - this.oldTime) > this.speed) {
                this.currIndex = (this.loop ? (this.currIndex + 1) % this.sprites.length : this.currIndex + 1);
                this.oldTime = time;
            }
        };
        /**
         * Skips ahead a specified number of frames in the animation
         * @method skip
         * @param frames {number} Frames to skip ahead
         */
        Animation.prototype.skip = function (frames) {
            this.currIndex = (this.currIndex + frames) % this.sprites.length;
        };
        Animation.prototype.draw = function (ctx, x, y) {
            this.tick();
            if (this.currIndex < this.sprites.length) {
                var currSprite = this.sprites[this.currIndex];
                if (this.flipVertical) {
                    currSprite.flipVertical = this.flipVertical;
                }
                if (this.flipHorizontal) {
                    currSprite.flipHorizontal = this.flipHorizontal;
                }
                currSprite.draw(ctx, x, y);
            }
            if (this.freezeFrame !== -1 && this.currIndex >= this.sprites.length) {
                var currSprite = this.sprites[ex.Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];
                currSprite.draw(ctx, x, y);
            }
        };
        /**
         * Plays an animation at an arbitrary location in the game.
         * @method play
         * @param x {number} The x position in the game to play
         * @param y {number} The y position in the game to play
         */
        Animation.prototype.play = function (x, y) {
            this.reset();
            this.engine.playAnimation(this, x, y);
        };
        return Animation;
    })();
    ex.Animation = Animation;
})(ex || (ex = {}));
/// <reference path="MonkeyPatch.ts" />
/// <reference path="Util.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    var Internal;
    (function (Internal) {
        var FallbackAudio = (function () {
            function FallbackAudio(path, volume) {
                this.log = ex.Logger.getInstance();
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                if (window.AudioContext) {
                    this.log.debug("Using new Web Audio Api for " + path);
                    this.soundImpl = new WebAudio(path, volume);
                }
                else {
                    this.log.debug("Falling back to Audio Element for " + path);
                    this.soundImpl = new AudioTag(path, volume);
                }
            }
            FallbackAudio.prototype.setVolume = function (volume) {
                this.soundImpl.setVolume(volume);
            };
            FallbackAudio.prototype.setLoop = function (loop) {
                this.soundImpl.setLoop(loop);
            };
            FallbackAudio.prototype.load = function () {
                this.soundImpl.onload = this.onload;
                this.soundImpl.onprogress = this.onprogress;
                this.soundImpl.onerror = this.onerror;
                this.soundImpl.load();
            };
            FallbackAudio.prototype.isPlaying = function () {
                return this.soundImpl.isPlaying();
            };
            FallbackAudio.prototype.play = function () {
                return this.soundImpl.play();
            };
            FallbackAudio.prototype.pause = function () {
                this.soundImpl.pause();
            };
            FallbackAudio.prototype.stop = function () {
                this.soundImpl.stop();
            };
            return FallbackAudio;
        })();
        Internal.FallbackAudio = FallbackAudio;
        var AudioTag = (function () {
            function AudioTag(path, volume) {
                var _this = this;
                this.path = path;
                this.audioElements = new Array(5);
                this._loadedAudio = null;
                this.isLoaded = false;
                this.index = 0;
                this.log = ex.Logger.getInstance();
                this._isPlaying = false;
                this._currentOffset = 0;
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                for (var i = 0; i < this.audioElements.length; i++) {
                    (function (i) {
                        _this.audioElements[i] = new Audio();
                    })(i);
                }
                if (volume) {
                    this.setVolume(ex.Util.clamp(volume, 0, 1.0));
                }
                else {
                    this.setVolume(1.0);
                }
            }
            AudioTag.prototype.isPlaying = function () {
                return this._isPlaying;
            };
            AudioTag.prototype.audioLoaded = function () {
                this.isLoaded = true;
            };
            AudioTag.prototype.setVolume = function (volume) {
                this.audioElements.forEach(function (a) {
                    a.volume = volume;
                });
            };
            AudioTag.prototype.setLoop = function (loop) {
                this.audioElements.forEach(function (a) {
                    a.loop = loop;
                });
            };
            AudioTag.prototype.getLoop = function () {
                this.audioElements.some(function (a) { return a.loop; });
            };
            AudioTag.prototype.load = function () {
                var _this = this;
                var request = new XMLHttpRequest();
                request.open("GET", this.path, true);
                request.responseType = 'blob';
                request.onprogress = this.onprogress;
                request.onerror = this.onerror;
                request.onload = function (e) {
                    if (request.status !== 200) {
                        _this.log.error("Failed to load audio resource ", _this.path, " server responded with error code", request.status);
                        _this.onerror(request.response);
                        _this.isLoaded = false;
                        return;
                    }
                    _this._loadedAudio = URL.createObjectURL(request.response);
                    _this.audioElements.forEach(function (a) {
                        a.src = _this._loadedAudio;
                    });
                    _this.onload(e);
                };
                request.send();
            };
            AudioTag.prototype.play = function () {
                var _this = this;
                this.audioElements[this.index].load();
                //this.audioElements[this.index].currentTime = this._currentOffset;
                this.audioElements[this.index].play();
                this._currentOffset = 0;
                var done = new ex.Promise();
                this._isPlaying = true;
                if (!this.getLoop()) {
                    this.audioElements[this.index].addEventListener('ended', function () {
                        _this._isPlaying = false;
                        done.resolve(true);
                    });
                }
                this.index = (this.index + 1) % this.audioElements.length;
                return done;
            };
            AudioTag.prototype.pause = function () {
                this.index = (this.index - 1 + this.audioElements.length) % this.audioElements.length;
                this._currentOffset = this.audioElements[this.index].currentTime;
                this.audioElements.forEach(function (a) {
                    a.pause();
                });
                this._isPlaying = false;
            };
            AudioTag.prototype.stop = function () {
                this.audioElements.forEach(function (a) {
                    a.pause();
                    //a.currentTime = 0;
                });
                this._isPlaying = false;
            };
            return AudioTag;
        })();
        Internal.AudioTag = AudioTag;
        if (window.AudioContext) {
            var audioContext = new window.AudioContext();
        }
        var WebAudio = (function () {
            function WebAudio(soundPath, volume) {
                this.context = audioContext;
                this.volume = this.context.createGain();
                this.buffer = null;
                this.sound = null;
                this.path = "";
                this.isLoaded = false;
                this.loop = false;
                this._isPlaying = false;
                this._isPaused = false;
                this._currentOffset = 0;
                this.logger = ex.Logger.getInstance();
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                this.path = soundPath;
                if (volume) {
                    this.volume.gain.value = ex.Util.clamp(volume, 0, 1.0);
                }
                else {
                    this.volume.gain.value = 1.0; // max volume
                }
            }
            WebAudio.prototype.setVolume = function (volume) {
                this.volume.gain.value = volume;
            };
            WebAudio.prototype.load = function () {
                var _this = this;
                var request = new XMLHttpRequest();
                request.open('GET', this.path);
                request.responseType = 'arraybuffer';
                request.onprogress = this.onprogress;
                request.onerror = this.onerror;
                request.onload = function () {
                    if (request.status !== 200) {
                        _this.logger.error("Failed to load audio resource ", _this.path, " server responded with error code", request.status);
                        _this.onerror(request.response);
                        _this.isLoaded = false;
                        return;
                    }
                    _this.context.decodeAudioData(request.response, function (buffer) {
                        _this.buffer = buffer;
                        _this.isLoaded = true;
                        _this.onload(_this);
                    }, function (e) {
                        _this.logger.error("Unable to decode " + _this.path + " this browser may not fully support this format, or the file may be corrupt, " + "if this is an mp3 try removing id3 tags and album art from the file.");
                        _this.isLoaded = false;
                        _this.onload(_this);
                    });
                };
                try {
                    request.send();
                }
                catch (e) {
                    console.error("Error loading sound! If this is a cross origin error, you must host your sound with your html and javascript.");
                }
            };
            WebAudio.prototype.setLoop = function (loop) {
                this.loop = loop;
            };
            WebAudio.prototype.isPlaying = function () {
                return this._isPlaying;
            };
            WebAudio.prototype.play = function () {
                var _this = this;
                if (this.isLoaded) {
                    this.sound = this.context.createBufferSource();
                    this.sound.buffer = this.buffer;
                    this.sound.loop = this.loop;
                    this.sound.connect(this.volume);
                    this.volume.connect(this.context.destination);
                    this.sound.start(0, this._currentOffset % this.buffer.duration);
                    this._currentOffset = 0;
                    var done;
                    if (!this._isPaused || !this._playPromise) {
                        done = new ex.Promise();
                    }
                    else {
                        done = this._playPromise;
                    }
                    this._isPaused = false;
                    this._isPlaying = true;
                    if (!this.loop) {
                        this.sound.onended = (function () {
                            _this._isPlaying = false;
                            if (!_this._isPaused) {
                                done.resolve(true);
                            }
                        }).bind(this);
                    }
                    this._playPromise = done;
                    return done;
                }
                else {
                    return ex.Promise.wrap(true);
                }
            };
            WebAudio.prototype.pause = function () {
                if (this._isPlaying) {
                    try {
                        window.clearTimeout(this._playingTimer);
                        this.sound.stop(0);
                        this._currentOffset = this.context.currentTime;
                        this._isPlaying = false;
                        this._isPaused = true;
                    }
                    catch (e) {
                        this.logger.warn("The sound clip", this.path, "has already been paused!");
                    }
                }
            };
            WebAudio.prototype.stop = function () {
                if (this.sound) {
                    try {
                        window.clearTimeout(this._playingTimer);
                        this._currentOffset = 0;
                        this.sound.stop(0);
                        this._isPlaying = false;
                        this._isPaused = false;
                    }
                    catch (e) {
                        this.logger.warn("The sound clip", this.path, "has already been stopped!");
                    }
                }
            };
            return WebAudio;
        })();
        Internal.WebAudio = WebAudio;
    })(Internal = ex.Internal || (ex.Internal = {}));
})(ex || (ex = {}));
/// <reference path="Log.ts" />
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
var ex;
(function (ex) {
    /**
     * Valid states for a promise to be in
     * @class PromiseState
     */
    (function (PromiseState) {
        /**
        @property Resolved {PromiseState}
        */
        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
        /**
        @property Rejected {PromiseState}
        */
        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
        /**
        @property Pending {PromiseState}
        */
        PromiseState[PromiseState["Pending"] = 2] = "Pending";
    })(ex.PromiseState || (ex.PromiseState = {}));
    var PromiseState = ex.PromiseState;
    /**
     * Promises/A+ spec implementation of promises
     * @class Promise
     * @constructor
     */
    var Promise = (function () {
        function Promise() {
            this._state = 2 /* Pending */;
            this.successCallbacks = [];
            this.rejectCallback = function () {
            };
            this.logger = ex.Logger.getInstance();
        }
        /**
         * Wrap a value in a resolved promise
         * @method wrap<T>
         * @param [value=undefined] {T} An optional value to wrap in a resolved promise
         * @returns Promise&lt;T&gt;
         */
        Promise.wrap = function (value) {
            var promise = (new Promise()).resolve(value);
            return promise;
        };
        /**
         * Returns a new promise that resolves when all the promises passed to it resolve, or rejects
         * when at least 1 promise rejects.
         * @param promises {Promise[]}
         * @returns Promise
         */
        Promise.join = function () {
            var promises = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                promises[_i - 0] = arguments[_i];
            }
            var joinedPromise = new Promise();
            if (!promises) {
                return joinedPromise.resolve();
            }
            var total = promises.length;
            var successes = 0;
            var rejects = 0;
            var errors = [];
            promises.forEach(function (p) {
                p.then(function () {
                    successes += 1;
                    if (successes === total) {
                        joinedPromise.resolve();
                    }
                    else if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }, function () {
                    rejects += 1;
                    if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }).error(function (e) {
                    errors.push(e);
                    if ((errors.length + successes + rejects) === total) {
                        joinedPromise.reject(errors);
                    }
                });
            });
            return joinedPromise;
        };
        /**
         * Chain success and reject callbacks after the promise is resovled
         * @method then
         * @param successCallback {T=>any} Call on resolution of promise
         * @param rejectCallback {any=>any} Call on rejection of promise
         * @returns Promise&lt;T&gt;
         */
        Promise.prototype.then = function (successCallback, rejectCallback) {
            if (successCallback) {
                this.successCallbacks.push(successCallback);
                // If the promise is already resovled call immediately
                if (this.state() === 0 /* Resolved */) {
                    try {
                        successCallback.call(this, this.value);
                    }
                    catch (e) {
                        this.handleError(e);
                    }
                }
            }
            if (rejectCallback) {
                this.rejectCallback = rejectCallback;
                // If the promise is already rejected call immediately
                if (this.state() === 1 /* Rejected */) {
                    try {
                        rejectCallback.call(this, this.value);
                    }
                    catch (e) {
                        this.handleError(e);
                    }
                }
            }
            return this;
        };
        /**
         * Add an error callback to the promise
         * @method error
         * @param errorCallback {any=>any} Call if there was an error in a callback
         * @returns Promise&lt;T&gt;
         */
        Promise.prototype.error = function (errorCallback) {
            if (errorCallback) {
                this.errorCallback = errorCallback;
            }
            return this;
        };
        /**
         * Resolve the promise and pass an option value to the success callbacks
         * @method resolve
         * @param [value=undefined] {T} Value to pass to the success callbacks
         */
        Promise.prototype.resolve = function (value) {
            var _this = this;
            if (this._state === 2 /* Pending */) {
                this.value = value;
                try {
                    this._state = 0 /* Resolved */;
                    this.successCallbacks.forEach(function (cb) {
                        cb.call(_this, _this.value);
                    });
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            else {
                throw new Error('Cannot resolve a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Reject the promise and pass an option value to the reject callbacks
         * @method reject
         * @param [value=undefined] {T} Value to pass to the reject callbacks
         */
        Promise.prototype.reject = function (value) {
            if (this._state === 2 /* Pending */) {
                this.value = value;
                try {
                    this._state = 1 /* Rejected */;
                    this.rejectCallback.call(this, this.value);
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            else {
                throw new Error('Cannot reject a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Inpect the current state of a promise
         * @method state
         * @returns PromiseState
         */
        Promise.prototype.state = function () {
            return this._state;
        };
        Promise.prototype.handleError = function (e) {
            if (this.errorCallback) {
                this.errorCallback.call(this, e);
            }
            else {
                throw e;
            }
        };
        return Promise;
    })();
    ex.Promise = Promise;
})(ex || (ex = {}));
/// <reference path="Interfaces/ILoadable.ts" />
var ex;
(function (ex) {
    /**
     * The Resource type allows games built in Excalibur to load generic resources.
     * For any type of remote resource it is recome
     * @class Resource
     * @extend ILoadable
     * @constructor
     * @param path {string} Path to the remote resource
     */
    var Resource = (function () {
        function Resource(path, responseType, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            this.path = path;
            this.responseType = responseType;
            this.bustCache = bustCache;
            this.data = null;
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
        }
        /**
         * Returns true if the Resource is completely loaded and is ready
         * to be drawn.
         * @method isLoaded
         * @returns boolean
         */
        Resource.prototype.isLoaded = function () {
            return !!this.data;
        };
        Resource.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        Resource.prototype.cacheBust = function (uri) {
            var query = /\?\w*=\w*/;
            if (query.test(uri)) {
                uri += ("&__=" + Date.now());
            }
            else {
                uri += ("?__=" + Date.now());
            }
            return uri;
        };
        Resource.prototype._start = function (e) {
            this.logger.debug("Started loading resource " + this.path);
        };
        /**
         * Begin loading the resource and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;any&gt;
         */
        Resource.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var request = new XMLHttpRequest();
            request.open("GET", this.bustCache ? this.cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = function (e) {
                _this._start(e);
            };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function (e) {
                if (request.status !== 200) {
                    _this.logger.error("Failed to load resource ", _this.path, " server responded with error code", request.status);
                    _this.onerror(request.response);
                    complete.resolve(request.response);
                    return;
                }
                _this.data = _this.processDownload(request.response);
                _this.oncomplete();
                _this.logger.debug("Completed loading resource", _this.path);
                complete.resolve(_this.data);
            };
            request.send();
            return complete;
        };
        /**
         * Returns the loaded data once the resource is loaded
         * @method GetData
         * @returns any
         */
        Resource.prototype.getData = function () {
            return this.data;
        };
        /**
         * This method is meant to be overriden to handle any additional
         * processing. Such as decoding downloaded audio bits.
         * @method ProcessDownload
         */
        Resource.prototype.processDownload = function (data) {
            // Handle any additional loading after the xhr has completed.
            return URL.createObjectURL(data);
        };
        return Resource;
    })();
    ex.Resource = Resource;
})(ex || (ex = {}));
/// <reference path="Sound.ts" />
/// <reference path="Util.ts" />
/// <reference path="Promises.ts" />
/// <reference path="Resource.ts" />
/// <reference path="Interfaces/ILoadable.ts" />
var ex;
(function (ex) {
    /**
     * The Texture object allows games built in Excalibur to load image resources.
     * It is generally recommended to preload images using the "Texture" object.
     * @class Texture
     * @extend Resource
     * @constructor
     * @param path {string} Path to the image resource
     * @param [bustCache=true] {boolean} Optionally load texture with cache busting
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture(path, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            _super.call(this, path, 'blob', bustCache);
            this.path = path;
            this.bustCache = bustCache;
            this.loaded = new ex.Promise();
            this._isLoaded = false;
            this._sprite = null;
            this._sprite = new ex.Sprite(this, 0, 0, 0, 0);
        }
        /**
         * Returns true if the Texture is completely loaded and is ready
         * to be drawn.
         * @method isLoaded
         * @returns boolean
         */
        Texture.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the texture and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;HTMLImageElement&gt;
         */
        Texture.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var loaded = _super.prototype.load.call(this);
            loaded.then(function () {
                _this.image = new Image();
                _this.image.addEventListener("load", function () {
                    _this._isLoaded = true;
                    _this.width = _this._sprite.swidth = _this._sprite.width = _this.image.naturalWidth;
                    _this.height = _this._sprite.sheight = _this._sprite.height = _this.image.naturalHeight;
                    _this.loaded.resolve(_this.image);
                    complete.resolve(_this.image);
                });
                _this.image.src = _super.prototype.getData.call(_this);
            }, function () {
                complete.reject("Error loading texture.");
            });
            return complete;
        };
        Texture.prototype.asSprite = function () {
            return this._sprite;
        };
        return Texture;
    })(ex.Resource);
    ex.Texture = Texture;
    /**
     * The Sound object allows games built in Excalibur to load audio
     * components, from soundtracks to sound effects. It is generally
     * recommended to load sound resources when using Excalibur
     * @class Sound
     * @extend Resource
     * @constructor
     * @param ...paths {string[]} A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    var Sound = (function () {
        function Sound() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i - 0] = arguments[_i];
            }
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            this.onload = function () {
            };
            this._isLoaded = false;
            this._selectedFile = "";
            this._wasPlayingOnHidden = false;
            /* Chrome : MP3, WAV, Ogg
             * Firefox : WAV, Ogg,
             * IE : MP3, WAV coming soon
             * Safari MP3, WAV, Ogg
             */
            this._selectedFile = "";
            for (var i = 0; i < paths.length; i++) {
                if (Sound.canPlayFile(paths[i])) {
                    this._selectedFile = paths[i];
                    break;
                }
            }
            if (!this._selectedFile) {
                this.logger.warn("This browser does not support any of the files specified");
                this._selectedFile = paths[0]; // select the first specified
            }
            this.sound = new ex.Internal.FallbackAudio(this._selectedFile, 1.0);
        }
        Sound.canPlayFile = function (file) {
            try {
                var a = new Audio();
                var filetype = /.*\.([A-Za-z0-9]+)$/;
                var type = file.match(filetype)[1];
                if (a.canPlayType('audio/' + type)) {
                    return true;
                }
                {
                    return false;
                }
            }
            catch (e) {
                ex.Logger.getInstance().warn("Cannot determine audio support, assuming no support for the Audio Tag", e);
                return false;
            }
        };
        Sound.prototype.wireEngine = function (engine) {
            var _this = this;
            if (engine) {
                this._engine = engine;
                this._engine.on('hidden', function () {
                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {
                        _this._wasPlayingOnHidden = true;
                        _this.pause();
                    }
                });
                this._engine.on('visible', function () {
                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {
                        _this.play();
                        _this._wasPlayingOnHidden = false;
                    }
                });
            }
        };
        /**
         * Sets the volume of the sound clip
         * @method setVolume
         * @param volume {number} A volume value between 0-1.0
         */
        Sound.prototype.setVolume = function (volume) {
            if (this.sound)
                this.sound.setVolume(volume);
        };
        /**
         * Indicates whether the clip should loop when complete
         * @method setLoop
         * @param loop {boolean} Set the looping flag
         */
        Sound.prototype.setLoop = function (loop) {
            if (this.sound)
                this.sound.setLoop(loop);
        };
        Sound.prototype.isPlaying = function () {
            if (this.sound)
                return this.sound.isPlaying();
        };
        /**
         * Play the sound, returns a promise that resolves when the sound is done playing
         * @method play
         * @return ex.Promise
         */
        Sound.prototype.play = function () {
            if (this.sound)
                return this.sound.play();
        };
        /**
         * Stop the sound, and do not rewind
         * @method pause
         */
        Sound.prototype.pause = function () {
            if (this.sound)
                this.sound.pause();
        };
        /**
         * Stop the sound and rewind
         * @method stop
         */
        Sound.prototype.stop = function () {
            if (this.sound)
                this.sound.stop();
        };
        /**
         * Returns true if the sound is loaded
         * @method isLoaded
         */
        Sound.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the sound and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;Sound&gt;
         */
        Sound.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            this.logger.debug("Started loading sound", this._selectedFile);
            this.sound.onprogress = this.onprogress;
            this.sound.onload = function () {
                _this.oncomplete();
                _this._isLoaded = true;
                _this.logger.debug("Completed loading sound", _this._selectedFile);
                complete.resolve(_this.sound);
            };
            this.sound.onerror = function (e) {
                _this.onerror(e);
                complete.resolve(e);
            };
            this.sound.load();
            return complete;
        };
        return Sound;
    })();
    ex.Sound = Sound;
    /**
     * The loader provides a mechanism to preload multiple resources at
     * one time. The loader must be passed to the engine in order to
     * trigger the loading progress bar
     * @class Loader
     * @extend ILoadable
     * @constructor
     * @param [loadables=undefined] {ILoadable[]} Optionally provide the list of resources you want to load at constructor time
     */
    var Loader = (function () {
        function Loader(loadables) {
            this.resourceList = [];
            this.index = 0;
            this.resourceCount = 0;
            this.numLoaded = 0;
            this.progressCounts = {};
            this.totalCounts = {};
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            if (loadables) {
                this.addResources(loadables);
            }
        }
        Loader.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Add a resource to the loader to load
         * @method addResource
         * @param loadable {ILoadable} Resource to add
         */
        Loader.prototype.addResource = function (loadable) {
            var key = this.index++;
            this.resourceList.push(loadable);
            this.progressCounts[key] = 0;
            this.totalCounts[key] = 1;
            this.resourceCount++;
        };
        /**
         * Add a list of resources to the loader to load
         * @method addResources
         * @param loadables {ILoadable[]} The list of resources to load
         */
        Loader.prototype.addResources = function (loadables) {
            var _this = this;
            loadables.forEach(function (l) {
                _this.addResource(l);
            });
        };
        Loader.prototype.sumCounts = function (obj) {
            var sum = 0;
            var prev = 0;
            for (var i in obj) {
                sum += obj[i] | 0;
            }
            return sum;
        };
        /**
         * Returns true if the loader has completely loaded all resources
         * @method isLoaded
         */
        Loader.prototype.isLoaded = function () {
            return this.numLoaded === this.resourceCount;
        };
        /**
         * Begin loading all of the supplied resources, returning a promise that resolves when loading of all is complete
         * @method load
         * @returns Promsie&lt;any&gt;
         */
        Loader.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var me = this;
            if (this.resourceList.length === 0) {
                me.oncomplete.call(me);
                return complete;
            }
            var progressArray = new Array(this.resourceList.length);
            var progressChunks = this.resourceList.length;
            this.resourceList.forEach(function (r, i) {
                if (_this._engine) {
                    r.wireEngine(_this._engine);
                }
                r.onprogress = function (e) {
                    var total = e.total;
                    var loaded = e.loaded;
                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };
                    var progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: (accum.loaded + next.loaded), total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                r.oncomplete = r.onerror = function () {
                    me.numLoaded++;
                    if (me.numLoaded === me.resourceCount) {
                        me.onprogress.call(me, { loaded: 100, total: 100 });
                        me.oncomplete.call(me);
                        complete.resolve();
                    }
                };
            });
            function loadNext(list, index) {
                if (!list[index])
                    return;
                list[index].load().then(function () {
                    loadNext(list, index + 1);
                });
            }
            loadNext(this.resourceList, 0);
            return complete;
        };
        return Loader;
    })();
    ex.Loader = Loader;
})(ex || (ex = {}));
/// <reference path="Promises.ts" />
/// <reference path="Loader.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur's built in templating class, it is a loadable that will load
     * and html fragment from a url. Excalibur templating is very basic only
     * allowing bindings of the type data-text="this.obj.someprop",
     * data-style="color:this.obj.color.toString()". Bindings allow all valid
     * javascript expressions.
     * @class Template
     * @extends ILoadable
     * @constructor
     * @param path {string} Location of the html template
     */
    var Template = (function () {
        function Template(path) {
            this.path = path;
            this._isLoaded = false;
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            this._innerElement = document.createElement('div');
            this._innerElement.className = "excalibur-template";
        }
        Template.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Returns the full html template string once loaded.
         * @method getTemplateString
         * @returns string
         */
        Template.prototype.getTemplateString = function () {
            if (!this._isLoaded)
                return "";
            return this._htmlString;
        };
        Template.prototype._compile = function () {
            this._innerElement.innerHTML = this._htmlString;
            this._styleElements = this._innerElement.querySelectorAll('[data-style]');
            this._textElements = this._innerElement.querySelectorAll('[data-text]');
        };
        Template.prototype._evaluateExpresion = function (expression, ctx) {
            var func = new Function("return " + expression + ";");
            var val = func.call(ctx);
            return val;
        };
        /**
         * Applies any ctx object you wish and evaluates the template.
         * Overload this method to include your favorite template library.
         * You may return either an HTML string or a Dom node.
         * @method apply
         * @param ctx {any} Any object you wish to apply to the template
         * @returns any
         */
        Template.prototype.apply = function (ctx) {
            var _this = this;
            for (var j = 0; j < this._styleElements.length; j++) {
                (function () {
                    // poor man's json parse for things that aren't exactly json :(
                    // Extract style expressions
                    var styles = {};
                    _this._styleElements[j].dataset["style"].split(";").forEach(function (s) {
                        if (s) {
                            var vals = s.split(":");
                            styles[vals[0].trim()] = vals[1].trim();
                        }
                    });
                    for (var style in styles) {
                        (function () {
                            var expression = styles[style];
                            _this._styleElements[j].style[style] = _this._evaluateExpresion(expression, ctx);
                        })();
                    }
                })();
            }
            for (var i = 0; i < this._textElements.length; i++) {
                (function () {
                    // Evaluate text expressions
                    var expression = _this._textElements[i].dataset["text"];
                    _this._textElements[i].innerText = _this._evaluateExpresion(expression, ctx);
                })();
            }
            // If the template HTML has a root element return that, otherwise use constructed root
            if (this._innerElement.children.length === 1) {
                this._innerElement = this._innerElement.firstChild;
            }
            return this._innerElement;
        };
        /**
         * Begins loading the template. Returns a promise that resolves with the template string when loaded.
         * @method load
         * @returns {Promise}
         */
        Template.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var request = new XMLHttpRequest();
            request.open("GET", this.path, true);
            request.responseType = "text";
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function (e) {
                if (request.status !== 200) {
                    _this.logger.error("Failed to load html template resource ", _this.path, " server responded with error code", request.status);
                    _this.onerror(request.response);
                    _this._isLoaded = false;
                    complete.resolve("error");
                    return;
                }
                _this._htmlString = request.response;
                _this.oncomplete();
                _this.logger.debug("Completed loading template", _this.path);
                _this._compile();
                _this._isLoaded = true;
                complete.resolve(_this._htmlString);
            };
            if (request.overrideMimeType) {
                request.overrideMimeType('text/plain; charset=x-user-defined');
            }
            request.send();
            return complete;
        };
        /**
         * Indicates whether the template has been loaded
         * @method isLoaded
         * @returns {boolean}
         */
        Template.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        return Template;
    })();
    ex.Template = Template;
    /**
     * Excalibur's binding library that allows you to bind an html
     * template to the dom given a certain context. Excalibur bindings are only updated
     * when the update() method is called
     * @class Binding
     * @constructor
     * @param parentElementId {string} The id of the element in the dom to attach the template binding
     * @param template {Template} The template you wish to bind
     * @param ctx {any} The context of the binding, which can be any object
     */
    var Binding = (function () {
        function Binding(parentElementId, template, ctx) {
            this.parent = document.getElementById(parentElementId);
            this.template = template;
            this._ctx = ctx;
            this.update();
        }
        /**
         * Listen to any arbitrary object's events to update this binding
         * @method listen
         * @param obj {any} Any object that supports addEventListener
         * @param events {string[]} A list of events to listen for
         * @param [hander=defaultHandler] {callback} A optional handler to fire on any event
         */
        Binding.prototype.listen = function (obj, events, handler) {
            var _this = this;
            // todo
            if (!handler) {
                handler = function () {
                    _this.update();
                };
            }
            if (obj.addEventListener) {
                events.forEach(function (e) {
                    obj.addEventListener(e, handler);
                });
            }
        };
        /**
         * Update this template binding with the latest values from the ctx reference passed to the constructor
         * @method update
         */
        Binding.prototype.update = function () {
            var html = this._applyTemplate(this.template, this._ctx);
            if (html instanceof String) {
                this.parent.innerHTML = html;
            }
            if (html instanceof Node) {
                if (this.parent.lastChild !== html) {
                    this.parent.appendChild(html);
                }
            }
        };
        Binding.prototype._applyTemplate = function (template, ctx) {
            if (template.isLoaded()) {
                return template.apply(ctx);
            }
        };
        return Binding;
    })();
    ex.Binding = Binding;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * Enum representing the different horizontal text alignments
     * @class TextAlign
     */
    (function (TextAlign) {
        /**
         * The text is left-aligned.
         * @property Left
         * @static
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * The text is right-aligned.
         * @property Right
         * @static
         */
        TextAlign[TextAlign["Right"] = 1] = "Right";
        /**
         * The text is centered.
         * @property Center
         * @static
         */
        TextAlign[TextAlign["Center"] = 2] = "Center";
        /**
         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).
         * @property Start
         * @static
         */
        TextAlign[TextAlign["Start"] = 3] = "Start";
        /**
         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).
         * @property End
         * @static
         */
        TextAlign[TextAlign["End"] = 4] = "End";
    })(ex.TextAlign || (ex.TextAlign = {}));
    var TextAlign = ex.TextAlign;
    /**
     * Enum representing the different baseline text alignments
     * @class BaseAlign
     */
    (function (BaseAlign) {
        /**
         * The text baseline is the top of the em square.
         * @property Top
         * @static
         */
        BaseAlign[BaseAlign["Top"] = 0] = "Top";
        /**
         * The text baseline is the hanging baseline.  Currently unsupported; this will act like alphabetic.
         * @property Hanging
         * @static
         */
        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
        /**
         * The text baseline is the middle of the em square.
         * @property Middle
         * @static
         */
        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
        /**
         * The text baseline is the normal alphabetic baseline.
         * @property Alphabetic
         * @static
         */
        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
        /**
         * The text baseline is the ideographic baseline; this is the bottom of
         * the body of the characters, if the main body of characters protrudes
         * beneath the alphabetic baseline.  Currently unsupported; this will
         * act like alphabetic.
         * @property Ideographic
         * @static
         */
        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
        /**
         * The text baseline is the bottom of the bounding box.  This differs
         * from the ideographic baseline in that the ideographic baseline
         * doesn't consider descenders.
         * @property Bottom
         * @static
         */
        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
    })(ex.BaseAlign || (ex.BaseAlign = {}));
    var BaseAlign = ex.BaseAlign;
    /**
     * Labels are the way to draw small amounts of text to the screen in Excalibur. They are
     * actors and inherit all of the benifits and capabilities.
     * @class Label
     * @extends Actor
     * @constructor
     * @param [text=empty] {string} The text of the label
     * @param [x=0] {number} The x position of the label
     * @param [y=0] {number} The y position of the label
     * @param [font=sans-serif] {string} Use any valid css font string for the label's font. Default is "10px sans-serif".
     * @param [spriteFont=undefined] {SpriteFont} Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precendence over a css font.
     *
     */
    var Label = (function (_super) {
        __extends(Label, _super);
        function Label(text, x, y, font, spriteFont) {
            _super.call(this, x, y);
            /**
             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
             * @property [letterSpacing=0] {number}
             */
            this.letterSpacing = 0; //px
            this.caseInsensitive = true;
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = ex.Color.Black.clone();
            this._shadowColorDirty = false;
            this._textSprites = {};
            this._shadowSprites = {};
            this._color = ex.Color.Black.clone();
            this.text = text || "";
            this.color = ex.Color.Black.clone();
            this.spriteFont = spriteFont;
            this.collisionType = 0 /* PreventCollision */;
            this.font = font || "10px sans-serif"; // coallesce to default canvas font
            if (spriteFont) {
                this._textSprites = spriteFont.getTextSprites();
            }
        }
        /**
         * Returns the width of the text in the label (in pixels);
         * @method getTextWidth {number}
         * @param ctx {CanvasRenderingContext2D} Rending context to measure the string with
         */
        Label.prototype.getTextWidth = function (ctx) {
            var oldFont = ctx.font;
            ctx.font = this.font;
            var width = ctx.measureText(this.text).width;
            ctx.font = oldFont;
            return width;
        };
        // TypeScript doesn't support string enums :(
        Label.prototype._lookupTextAlign = function (textAlign) {
            switch (textAlign) {
                case 0 /* Left */:
                    return "left";
                    break;
                case 1 /* Right */:
                    return "right";
                    break;
                case 2 /* Center */:
                    return "center";
                    break;
                case 4 /* End */:
                    return "end";
                    break;
                case 3 /* Start */:
                    return "start";
                    break;
                default:
                    return "start";
                    break;
            }
        };
        Label.prototype._lookupBaseAlign = function (baseAlign) {
            switch (baseAlign) {
                case 3 /* Alphabetic */:
                    return "alphabetic";
                    break;
                case 5 /* Bottom */:
                    return "bottom";
                    break;
                case 1 /* Hanging */:
                    return "hangin";
                    break;
                case 4 /* Ideographic */:
                    return "ideographic";
                    break;
                case 2 /* Middle */:
                    return "middle";
                    break;
                case 0 /* Top */:
                    return "top";
                    break;
                default:
                    return "alphabetic";
                    break;
            }
        };
        /**
         * Sets the text shadow for sprite fonts
         * @method setTextShadow
         * @param offsetX {number} The x offset in pixels to place the shadow
         * @param offsetY {number} The y offset in pixles to place the shadow
         * @param shadowColor {Color} The color of the text shadow
         */
        Label.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this._textShadowOn = true;
            this._shadowOffsetX = offsetX;
            this._shadowOffsetY = offsetY;
            this._shadowColor = shadowColor.clone();
            this._shadowColorDirty = true;
            for (var character in this._textSprites) {
                this._shadowSprites[character] = this._textSprites[character].clone();
            }
        };
        /**
         * Clears the current text shadow
         * @method clearTextShadow
         */
        Label.prototype.clearTextShadow = function () {
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = ex.Color.Black.clone();
        };
        Label.prototype.update = function (engine, delta) {
            _super.prototype.update.call(this, engine, delta);
            if (this.spriteFont && this._color !== this.color) {
                for (var character in this._textSprites) {
                    this._textSprites[character].clearEffects();
                    this._textSprites[character].addEffect(new ex.Effects.Fill(this.color.clone()));
                    this._color = this.color;
                }
            }
            if (this.spriteFont && this._textShadowOn && this._shadowColorDirty && this._shadowColor) {
                for (var character in this._shadowSprites) {
                    this._shadowSprites[character].clearEffects();
                    this._shadowSprites[character].addEffect(new ex.Effects.Fill(this._shadowColor.clone()));
                }
                this._shadowColorDirty = false;
            }
        };
        Label.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            if (this._textShadowOn) {
                ctx.save();
                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
                this._fontDraw(ctx, delta, this._shadowSprites);
                ctx.restore();
            }
            this._fontDraw(ctx, delta, this._textSprites);
            _super.prototype.draw.call(this, ctx, delta);
            ctx.restore();
        };
        Label.prototype._fontDraw = function (ctx, delta, sprites) {
            if (this.spriteFont) {
                var currX = 0;
                for (var i = 0; i < this.text.length; i++) {
                    var character = this.text[i];
                    if (this.caseInsensitive) {
                        character = character.toLowerCase();
                    }
                    try {
                        var charSprite = sprites[character];
                        if (this.previousOpacity !== this.opacity) {
                            charSprite.clearEffects();
                            charSprite.addEffect(new ex.Effects.Opacity(this.opacity));
                        }
                        charSprite.draw(ctx, currX, 0);
                        currX += (charSprite.swidth + this.letterSpacing);
                    }
                    catch (e) {
                        ex.Logger.getInstance().error("SpriteFont Error drawing char " + character);
                    }
                }
                if (this.previousOpacity !== this.opacity) {
                    this.previousOpacity = this.opacity;
                }
            }
            else {
                var oldAlign = ctx.textAlign;
                var oldTextBaseline = ctx.textBaseline;
                ctx.textAlign = this._lookupTextAlign(this.textAlign);
                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
                if (this.color) {
                    this.color.a = this.opacity;
                }
                ctx.fillStyle = this.color.toString();
                ctx.font = this.font;
                if (this.maxWidth) {
                    ctx.fillText(this.text, 0, 0, this.maxWidth);
                }
                else {
                    ctx.fillText(this.text, 0, 0);
                }
                ctx.textAlign = oldAlign;
                ctx.textBaseline = oldTextBaseline;
            }
        };
        Label.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
        };
        return Label;
    })(ex.Actor);
    ex.Label = Label;
})(ex || (ex = {}));
/// <reference path="../Events.ts"/>
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        (function (PointerType) {
            PointerType[PointerType["Touch"] = 0] = "Touch";
            PointerType[PointerType["Mouse"] = 1] = "Mouse";
            PointerType[PointerType["Pen"] = 2] = "Pen";
            PointerType[PointerType["Unknown"] = 3] = "Unknown";
        })(Input.PointerType || (Input.PointerType = {}));
        var PointerType = Input.PointerType;
        (function (PointerButton) {
            PointerButton[PointerButton["Left"] = 0] = "Left";
            PointerButton[PointerButton["Middle"] = 1] = "Middle";
            PointerButton[PointerButton["Right"] = 2] = "Right";
            PointerButton[PointerButton["Unknown"] = 3] = "Unknown";
        })(Input.PointerButton || (Input.PointerButton = {}));
        var PointerButton = Input.PointerButton;
        var PointerEvent = (function (_super) {
            __extends(PointerEvent, _super);
            function PointerEvent(x, y, index, pointerType, button, ev) {
                _super.call(this);
                this.x = x;
                this.y = y;
                this.index = index;
                this.pointerType = pointerType;
                this.button = button;
                this.ev = ev;
            }
            return PointerEvent;
        })(ex.GameEvent);
        Input.PointerEvent = PointerEvent;
        ;
        /**
         * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to W3C Pointer Events.
         * There is always at least one pointer available (primary).
         *
         * @class Pointers
         * @extends Class
         * @constructor
         */
        var Pointers = (function (_super) {
            __extends(Pointers, _super);
            function Pointers(engine) {
                _super.call(this);
                this._pointerDown = [];
                this._pointerUp = [];
                this._pointerMove = [];
                this._pointerCancel = [];
                this._pointers = [];
                this._activePointers = [];
                this._engine = engine;
                this._pointers.push(new Pointer());
                this._activePointers = [-1];
                this.primary = this._pointers[0];
            }
            /**
             * Initializes pointer event listeners
             */
            Pointers.prototype.init = function () {
                // Touch Events
                document.addEventListener('touchstart', this._handleTouchEvent("down", this._pointerDown));
                document.addEventListener('touchend', this._handleTouchEvent("up", this._pointerUp));
                document.addEventListener('touchmove', this._handleTouchEvent("move", this._pointerMove));
                document.addEventListener('touchcancel', this._handleTouchEvent("cancel", this._pointerCancel));
                // W3C Pointer Events
                // Current: IE11, IE10
                if (window.PointerEvent) {
                    // IE11
                    this._engine.canvas.style.touchAction = "none";
                    document.addEventListener('pointerdown', this._handlePointerEvent("down", this._pointerDown));
                    document.addEventListener('pointerup', this._handlePointerEvent("up", this._pointerUp));
                    document.addEventListener('pointermove', this._handlePointerEvent("move", this._pointerMove));
                    document.addEventListener('pointercancel', this._handlePointerEvent("cancel", this._pointerMove));
                }
                else if (window.MSPointerEvent) {
                    // IE10
                    this._engine.canvas.style.msTouchAction = "none";
                    document.addEventListener('MSPointerDown', this._handlePointerEvent("down", this._pointerDown));
                    document.addEventListener('MSPointerUp', this._handlePointerEvent("up", this._pointerUp));
                    document.addEventListener('MSPointerMove', this._handlePointerEvent("move", this._pointerMove));
                    document.addEventListener('MSPointerCancel', this._handlePointerEvent("cancel", this._pointerMove));
                }
                else {
                    // Mouse Events
                    document.addEventListener('mousedown', this._handleMouseEvent("down", this._pointerDown));
                    document.addEventListener('mouseup', this._handleMouseEvent("up", this._pointerUp));
                    document.addEventListener('mousemove', this._handleMouseEvent("move", this._pointerMove));
                }
            };
            Pointers.prototype.update = function (delta) {
                this._pointerUp.length = 0;
                this._pointerDown.length = 0;
                this._pointerMove.length = 0;
                this._pointerCancel.length = 0;
            };
            /**
             * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
             * @param index {number} The pointer index to retrieve
             */
            Pointers.prototype.at = function (index) {
                if (index >= this._pointers.length) {
                    for (var i = this._pointers.length - 1, max = index; i < max; i++) {
                        this._pointers.push(new Pointer());
                        this._activePointers.push(-1);
                    }
                }
                return this._pointers[index];
            };
            /**
             * Get number of pointers being watched
             */
            Pointers.prototype.count = function () {
                return this._pointers.length;
            };
            /**
             * Propogates events to actor if necessary
             */
            Pointers.prototype.propogate = function (actor) {
                var isUIActor = actor instanceof ex.UIActor;
                this._pointerUp.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointerup", e);
                    }
                });
                this._pointerDown.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointerdown", e);
                    }
                });
                if (actor.capturePointer.captureMoveEvents) {
                    this._pointerMove.forEach(function (e) {
                        if (actor.contains(e.x, e.y, !isUIActor)) {
                            actor.eventDispatcher.publish("pointermove", e);
                        }
                    });
                }
                this._pointerCancel.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointercancel", e);
                    }
                });
            };
            Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    var x = e.pageX - ex.Util.getPosition(_this._engine.canvas).x;
                    var y = e.pageY - ex.Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, 0, 1 /* Mouse */, e.button, e);
                    eventArr.push(pe);
                    _this.at(0).eventDispatcher.publish(eventName, pe);
                };
            };
            Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                        var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                        if (index === -1)
                            continue;
                        var x = e.changedTouches[i].pageX - ex.Util.getPosition(_this._engine.canvas).x;
                        var y = e.changedTouches[i].pageY - ex.Util.getPosition(_this._engine.canvas).y;
                        var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                        var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, index, 0 /* Touch */, 3 /* Unknown */, e);
                        eventArr.push(pe);
                        _this.at(index).eventDispatcher.publish(eventName, pe);
                        // only with multi-pointer
                        if (_this._pointers.length > 1) {
                            if (eventName === "up") {
                                // remove pointer ID from pool when pointer is lifted
                                _this._activePointers[index] = -1;
                            }
                            else if (eventName === "down") {
                                // set pointer ID to given index
                                _this._activePointers[index] = e.changedTouches[i].identifier;
                            }
                        }
                    }
                };
            };
            Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    // get the index for this pointer ID if multi-pointer is asked for
                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;
                    if (index === -1)
                        return;
                    var x = e.pageX - ex.Util.getPosition(_this._engine.canvas).x;
                    var y = e.pageY - ex.Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, index, _this._stringToPointerType(e.pointerType), e.button, e);
                    eventArr.push(pe);
                    _this.at(index).eventDispatcher.publish(eventName, pe);
                    // only with multi-pointer
                    if (_this._pointers.length > 1) {
                        if (eventName === "up") {
                            // remove pointer ID from pool when pointer is lifted
                            _this._activePointers[index] = -1;
                        }
                        else if (eventName === "down") {
                            // set pointer ID to given index
                            _this._activePointers[index] = e.pointerId;
                        }
                    }
                };
            };
            /**
             * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
             * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
             * @private
             */
            Pointers.prototype._getPointerIndex = function (pointerId) {
                var idx;
                if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
                    return idx;
                }
                for (var i = 0; i < this._activePointers.length; i++) {
                    if (this._activePointers[i] === -1)
                        return i;
                }
                // ignore pointer because game isn't watching
                return -1;
            };
            Pointers.prototype._stringToPointerType = function (s) {
                switch (s) {
                    case "touch":
                        return 0 /* Touch */;
                    case "mouse":
                        return 1 /* Mouse */;
                    case "pen":
                        return 2 /* Pen */;
                    default:
                        return 3 /* Unknown */;
                }
            };
            return Pointers;
        })(ex.Class);
        Input.Pointers = Pointers;
        /**
         * Captures and dispatches PointerEvents
         * @class Pointer
         * @constructor
         * @extends Class
         */
        var Pointer = (function (_super) {
            __extends(Pointer, _super);
            function Pointer() {
                _super.apply(this, arguments);
            }
            return Pointer;
        })(ex.Class);
        Input.Pointer = Pointer;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        /**
        * Enum representing input key codes
        * @class Keys
        *
        */
        (function (Keys) {
            /**
            @property Num1 {Keys}
            */
            /**
            @property Num2 {Keys}
            */
            /**
            @property Num3 {Keys}
            */
            /**
            @property Num4 {Keys}
            */
            /**
            @property Num5 {Keys}
            */
            /**
            @property Num6 {Keys}
            */
            /**
            @property Num7 {Keys}
            */
            /**
            @property Num8 {Keys}
            */
            /**
            @property Num9 {Keys}
            */
            /**
            @property Num0 {Keys}
            */
            Keys[Keys["Num1"] = 97] = "Num1";
            Keys[Keys["Num2"] = 98] = "Num2";
            Keys[Keys["Num3"] = 99] = "Num3";
            Keys[Keys["Num4"] = 100] = "Num4";
            Keys[Keys["Num5"] = 101] = "Num5";
            Keys[Keys["Num6"] = 102] = "Num6";
            Keys[Keys["Num7"] = 103] = "Num7";
            Keys[Keys["Num8"] = 104] = "Num8";
            Keys[Keys["Num9"] = 105] = "Num9";
            Keys[Keys["Num0"] = 96] = "Num0";
            /**
            @property Numlock {Keys}
            */
            Keys[Keys["Numlock"] = 144] = "Numlock";
            /**
            @property Semicolon {Keys}
            */
            Keys[Keys["Semicolon"] = 186] = "Semicolon";
            /**
            @property A {Keys}
            */
            /**
            @property B {Keys}
            */
            /**
            @property C {Keys}
            */
            /**
            @property D {Keys}
            */
            /**
            @property E {Keys}
            */
            /**
            @property F {Keys}
            */
            /**
            @property G {Keys}
            */
            /**
            @property H {Keys}
            */
            /**
            @property I {Keys}
            */
            /**
            @property J {Keys}
            */
            /**
            @property K {Keys}
            */
            /**
            @property L {Keys}
            */
            /**
            @property M {Keys}
            */
            /**
            @property N {Keys}
            */
            /**
            @property O {Keys}
            */
            /**
            @property P {Keys}
            */
            /**
            @property Q {Keys}
            */
            /**
            @property R {Keys}
            */
            /**
            @property S {Keys}
            */
            /**
            @property T {Keys}
            */
            /**
            @property U {Keys}
            */
            /**
            @property V {Keys}
            */
            /**
            @property W {Keys}
            */
            /**
            @property X {Keys}
            */
            /**
            @property Y {Keys}
            */
            /**
            @property Z {Keys}
            */
            Keys[Keys["A"] = 65] = "A";
            Keys[Keys["B"] = 66] = "B";
            Keys[Keys["C"] = 67] = "C";
            Keys[Keys["D"] = 68] = "D";
            Keys[Keys["E"] = 69] = "E";
            Keys[Keys["F"] = 70] = "F";
            Keys[Keys["G"] = 71] = "G";
            Keys[Keys["H"] = 72] = "H";
            Keys[Keys["I"] = 73] = "I";
            Keys[Keys["J"] = 74] = "J";
            Keys[Keys["K"] = 75] = "K";
            Keys[Keys["L"] = 76] = "L";
            Keys[Keys["M"] = 77] = "M";
            Keys[Keys["N"] = 78] = "N";
            Keys[Keys["O"] = 79] = "O";
            Keys[Keys["P"] = 80] = "P";
            Keys[Keys["Q"] = 81] = "Q";
            Keys[Keys["R"] = 82] = "R";
            Keys[Keys["S"] = 83] = "S";
            Keys[Keys["T"] = 84] = "T";
            Keys[Keys["U"] = 85] = "U";
            Keys[Keys["V"] = 86] = "V";
            Keys[Keys["W"] = 87] = "W";
            Keys[Keys["X"] = 88] = "X";
            Keys[Keys["Y"] = 89] = "Y";
            Keys[Keys["Z"] = 90] = "Z";
            /**
            @property Shift {Keys}
            */
            /**
            @property Alt {Keys}
            */
            /**
            @property Up {Keys}
            */
            /**
            @property Down {Keys}
            */
            /**
            @property Left {Keys}
            */
            /**
            @property Right {Keys}
            */
            /**
            @property Space {Keys}
            */
            /**
            @property Esc {Keys}
            */
            Keys[Keys["Shift"] = 16] = "Shift";
            Keys[Keys["Alt"] = 18] = "Alt";
            Keys[Keys["Up"] = 38] = "Up";
            Keys[Keys["Down"] = 40] = "Down";
            Keys[Keys["Left"] = 37] = "Left";
            Keys[Keys["Right"] = 39] = "Right";
            Keys[Keys["Space"] = 32] = "Space";
            Keys[Keys["Esc"] = 27] = "Esc";
        })(Input.Keys || (Input.Keys = {}));
        var Keys = Input.Keys;
        ;
        /**
         * Event thrown on a game object for a key event
         *
         * @class KeyEvent
         * @extends GameEvent
         * @constructor
         * @param key {InputKey} The key responsible for throwing the event
         */
        var KeyEvent = (function (_super) {
            __extends(KeyEvent, _super);
            function KeyEvent(key) {
                _super.call(this);
                this.key = key;
            }
            return KeyEvent;
        })(ex.GameEvent);
        Input.KeyEvent = KeyEvent;
        /**
         * Manages Keyboard input events that you can query or listen for events on
         *
         * @class Keyboard
         * @extends Class
         * @constructor
         *
         */
        var Keyboard = (function (_super) {
            __extends(Keyboard, _super);
            function Keyboard(engine) {
                _super.call(this);
                this._keys = [];
                this._keysUp = [];
                this._keysDown = [];
                this._engine = engine;
            }
            /**
             * Initialize Keyboard event listeners
             */
            Keyboard.prototype.init = function () {
                var _this = this;
                window.addEventListener('blur', function (ev) {
                    _this._keys.length = 0; // empties array efficiently
                });
                // key up is on window because canvas cannot have focus
                window.addEventListener('keyup', function (ev) {
                    var key = _this._keys.indexOf(ev.keyCode);
                    _this._keys.splice(key, 1);
                    _this._keysUp.push(ev.keyCode);
                    var keyEvent = new KeyEvent(ev.keyCode);
                    _this.eventDispatcher.publish("up", keyEvent);
                });
                // key down is on window because canvas cannot have focus
                window.addEventListener('keydown', function (ev) {
                    if (_this._keys.indexOf(ev.keyCode) === -1) {
                        _this._keys.push(ev.keyCode);
                        _this._keysDown.push(ev.keyCode);
                        var keyEvent = new KeyEvent(ev.keyCode);
                        _this.eventDispatcher.publish("down", keyEvent);
                    }
                });
            };
            Keyboard.prototype.update = function (delta) {
                // Reset keysDown and keysUp after update is complete
                this._keysDown.length = 0;
                this._keysUp.length = 0;
            };
            /**
             * Gets list of keys being pressed down
             */
            Keyboard.prototype.getKeys = function () {
                return this._keys;
            };
            /**
             *  Tests if a certain key is down.
             * @method isKeyDown
             * @param key {Keys} Test wether a key is down
             * @returns boolean
             */
            Keyboard.prototype.isKeyDown = function (key) {
                return this._keysDown.indexOf(key) > -1;
            };
            /**
             *  Tests if a certain key is pressed.
             * @method isKeyPressed
             * @param key {Keys} Test wether a key is pressed
             * @returns boolean
             */
            Keyboard.prototype.isKeyPressed = function (key) {
                return this._keys.indexOf(key) > -1;
            };
            /**
             *  Tests if a certain key is up.
             * @method isKeyUp
             * @param key {Keys} Test wether a key is up
             * @returns boolean
             */
            Keyboard.prototype.isKeyUp = function (key) {
                return this._keysUp.indexOf(key) > -1;
            };
            return Keyboard;
        })(ex.Class);
        Input.Keyboard = Keyboard;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        /**
         * Manages Gamepad API input. You can query the gamepads that are connected
         * or listen to events ("button" and "axis").
         * @class Gamepads
         * @extends Class
         * @param pads {Gamepad[]} The connected gamepads.
         * @param supported {boolean} Whether or not the Gamepad API is present
         */
        var Gamepads = (function (_super) {
            __extends(Gamepads, _super);
            function Gamepads(engine) {
                _super.call(this);
                /**
                 * Whether or not to poll for Gamepad input (default: false)
                 * @property enabled {boolean}
                 */
                this.enabled = false;
                /**
                 * Whether or not Gamepad API is supported
                 * @property supported {boolean}
                 */
                this.supported = !!navigator.getGamepads;
                this._gamePadTimeStamps = [0, 0, 0, 0];
                this._oldPads = [];
                this._pads = [];
                this._initSuccess = false;
                this._navigator = navigator;
                this._engine = engine;
            }
            Gamepads.prototype.init = function () {
                if (!this.supported)
                    return;
                if (this._initSuccess)
                    return;
                // In Chrome, this will return 4 undefined items until a button is pressed
                // In FF, this will not return any items until a button is pressed
                this._oldPads = this._clonePads(this._navigator.getGamepads());
                if (this._oldPads.length && this._oldPads[0]) {
                    this._initSuccess = true;
                }
            };
            /**
             * Updates Gamepad state and publishes Gamepad events
             */
            Gamepads.prototype.update = function (delta) {
                if (!this.enabled || !this.supported)
                    return;
                this.init();
                var gamepads = this._navigator.getGamepads();
                for (var i = 0; i < gamepads.length; i++) {
                    if (!gamepads[i]) {
                        // Reset connection status
                        this.at(i).connected = false;
                        continue;
                    }
                    else {
                        // Set connection status
                        this.at(i).connected = true;
                    }
                    ;
                    // Only supported in Chrome
                    if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                        continue;
                    }
                    this._gamePadTimeStamps[i] = gamepads[i].timestamp;
                    // Buttons
                    var b, a, value, buttonIndex, axesIndex;
                    for (b in Buttons) {
                        if (typeof Buttons[b] !== "number")
                            continue;
                        buttonIndex = Buttons[b];
                        value = gamepads[i].buttons[buttonIndex].value;
                        if (value !== this._oldPads[i].getButton(buttonIndex)) {
                            if (gamepads[i].buttons[buttonIndex].pressed) {
                                this.at(i).updateButton(buttonIndex, value);
                                this.at(i).eventDispatcher.publish("button", new GamepadButtonEvent(buttonIndex, value));
                            }
                            else {
                                this.at(i).updateButton(buttonIndex, 0);
                            }
                        }
                    }
                    for (a in Axes) {
                        if (typeof Axes[a] !== "number")
                            continue;
                        axesIndex = Axes[a];
                        value = gamepads[i].axes[axesIndex];
                        if (value !== this._oldPads[i].getAxes(axesIndex)) {
                            this.at(i).updateAxes(axesIndex, value);
                            this.at(i).eventDispatcher.publish("axis", new GamepadAxisEvent(axesIndex, value));
                        }
                    }
                    this._oldPads[i] = this._clonePad(gamepads[i]);
                }
            };
            /**
             * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
             */
            Gamepads.prototype.at = function (index) {
                if (index >= this._pads.length) {
                    for (var i = this._pads.length - 1, max = index; i < max; i++) {
                        this._pads.push(new Gamepad());
                        this._oldPads.push(new Gamepad());
                    }
                }
                return this._pads[index];
            };
            /**
             * Gets the number of connected gamepads
             */
            Gamepads.prototype.count = function () {
                return this._pads.filter(function (p) { return p.connected; }).length;
            };
            Gamepads.prototype._clonePads = function (pads) {
                var arr = [];
                for (var i = 0, len = pads.length; i < len; i++) {
                    arr.push(this._clonePad(pads[i]));
                }
                return arr;
            };
            /**
             * Fastest way to clone a known object is to do it yourself
             */
            Gamepads.prototype._clonePad = function (pad) {
                var i, len;
                var clonedPad = new Gamepad();
                if (!pad)
                    return clonedPad;
                for (i = 0, len = pad.buttons.length; i < len; i++) {
                    clonedPad.updateButton(i, pad.buttons[i].value);
                }
                for (i = 0, len = pad.axes.length; i < len; i++) {
                    clonedPad.updateAxes(i, pad.axes[i]);
                }
                return clonedPad;
            };
            /**
             * The minimum value an axis has to move before considering it a change
             * @property MinAxisMoveThreshold {number}
             * @static
             */
            Gamepads.MinAxisMoveThreshold = 0.05;
            return Gamepads;
        })(ex.Class);
        Input.Gamepads = Gamepads;
        /**
         * Individual state for a Gamepad
         * @class Gamepad
         * @extends Class
         */
        var Gamepad = (function (_super) {
            __extends(Gamepad, _super);
            function Gamepad() {
                _super.call(this);
                this.connected = false;
                this._buttons = new Array(16);
                this._axes = new Array(4);
                var i;
                for (i = 0; i < this._buttons.length; i++) {
                    this._buttons[i] = 0;
                }
                for (i = 0; i < this._axes.length; i++) {
                    this._axes[i] = 0;
                }
            }
            /**
             * Whether or not the given button is pressed
             * @param button {Buttons}
             * @param [threshold=1] {number} The threshold over which the button is considered to be pressed
             */
            Gamepad.prototype.isButtonPressed = function (button, threshold) {
                if (threshold === void 0) { threshold = 1; }
                return this._buttons[button] >= threshold;
            };
            /**
             * Gets the given button value
             * @param button {Buttons}
             */
            Gamepad.prototype.getButton = function (button) {
                return this._buttons[button];
            };
            /**
             * Gets the given axis value
             * @param axes {Axes}
             */
            Gamepad.prototype.getAxes = function (axes) {
                var value = this._axes[axes];
                if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
                    return 0;
                }
                else {
                    return value;
                }
            };
            Gamepad.prototype.updateButton = function (buttonIndex, value) {
                this._buttons[buttonIndex] = value;
            };
            Gamepad.prototype.updateAxes = function (axesIndex, value) {
                this._axes[axesIndex] = value;
            };
            return Gamepad;
        })(ex.Class);
        Input.Gamepad = Gamepad;
        /**
         * Gamepad Buttons enumeration
         * @class Buttons
         */
        (function (Buttons) {
            /**
             * Face 1 button (e.g. A)
             * @property Face1 {Buttons}
             * @static
             */
            /**
             * Face 2 button (e.g. B)
             * @property Face2 {Buttons}
             * @static
             */
            /**
             * Face 3 button (e.g. X)
             * @property Face3 {Buttons}
             * @static
             */
            /**
             * Face 4 button (e.g. Y)
             * @property Face4 {Buttons}
             * @static
             */
            Buttons[Buttons["Face1"] = 0] = "Face1";
            Buttons[Buttons["Face2"] = 1] = "Face2";
            Buttons[Buttons["Face3"] = 2] = "Face3";
            Buttons[Buttons["Face4"] = 3] = "Face4";
            /**
             * Left bumper button
             * @property LeftBumper {Buttons}
             * @static
             */
            /**
             * Right bumper button
             * @property RightBumper {Buttons}
             * @static
             */
            Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
            Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
            /**
             * Left trigger button
             * @property LeftTrigger {Buttons}
             * @static
             */
            /**
             * Right trigger button
             * @property RightTrigger {Buttons}
             * @static
             */
            Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
            Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
            /**
             * Select button
             * @property Select {Buttons}
             * @static
             */
            /**
             * Start button
             * @property Start {Buttons}
             * @static
             */
            Buttons[Buttons["Select"] = 8] = "Select";
            Buttons[Buttons["Start"] = 9] = "Start";
            /**
             * Left analog stick press (e.g. L3)
             * @property LeftStick {Buttons}
             * @static
             */
            /**
             * Right analog stick press (e.g. R3)
             * @property Start {Buttons}
             * @static
             */
            Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
            Buttons[Buttons["RightStick"] = 11] = "RightStick";
            /**
             * D-pad up
             * @property DpadUp {Buttons}
             * @static
             */
            /**
             * D-pad down
             * @property DpadDown {Buttons}
             * @static
             */
            /**
             * D-pad left
             * @property DpadLeft {Buttons}
             * @static
             */
            /**
             * D-pad right
             * @property DpadRight {Buttons}
             * @static
             */
            Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
            Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
            Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
            Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
        })(Input.Buttons || (Input.Buttons = {}));
        var Buttons = Input.Buttons;
        /**
         * Gamepad Axes enumeration
         * @class Axes
         */
        (function (Axes) {
            /**
             * Left analogue stick X direction
             * @property LeftStickX {Axes}
             * @static
             */
            /**
             * Left analogue stick Y direction
             * @property LeftStickY {Axes}
             * @static
             */
            /**
             * Right analogue stick X direction
             * @property RightStickX {Axes}
             * @static
             */
            /**
             * Right analogue stick Y direction
             * @property RightStickY {Axes}
             * @static
             */
            Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
            Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
            Axes[Axes["RightStickX"] = 2] = "RightStickX";
            Axes[Axes["RightStickY"] = 3] = "RightStickY";
        })(Input.Axes || (Input.Axes = {}));
        var Axes = Input.Axes;
        var GamepadButtonEvent = (function (_super) {
            __extends(GamepadButtonEvent, _super);
            function GamepadButtonEvent(button, value) {
                _super.call(this);
                this.button = button;
                this.value = value;
            }
            return GamepadButtonEvent;
        })(ex.GameEvent);
        Input.GamepadButtonEvent = GamepadButtonEvent;
        var GamepadAxisEvent = (function (_super) {
            __extends(GamepadAxisEvent, _super);
            function GamepadAxisEvent(axis, value) {
                _super.call(this);
                this.axis = axis;
                this.value = value;
            }
            return GamepadAxisEvent;
        })(ex.GameEvent);
        Input.GamepadAxisEvent = GamepadAxisEvent;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
/// <reference path="MonkeyPatch.ts" />
/// <reference path="Events.ts" />
/// <reference path="EventDispatcher.ts" />
/// <reference path="Class.ts" />
/// <reference path="Color.ts" />
/// <reference path="Log.ts" />
/// <reference path="Collision/Side.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Actor.ts" />
/// <reference path="UIActor.ts" />
/// <reference path="Trigger.ts" />
/// <reference path="Particles.ts" />
/// <reference path="Animation.ts" />
/// <reference path="Camera.ts" />
/// <reference path="Sound.ts" />
/// <reference path="Loader.ts" />
/// <reference path="Promises.ts" />
/// <reference path="Util.ts" />
/// <reference path="Binding.ts" />
/// <reference path="TileMap.ts" />
/// <reference path="Label.ts" />
/// <reference path="PostProcessing/IPostProcessor.ts"/>
/// <reference path="Input/IEngineInput.ts"/>
/// <reference path="Input/Pointer.ts"/>
/// <reference path="Input/Keyboard.ts"/>
/// <reference path="Input/Gamepad.ts"/>
var ex;
(function (ex) {
    /**
     * Enum representing the different display modes available to Excalibur
     * @class DisplayMode
     */
    (function (DisplayMode) {
        /**
         * Show the game as full screen
         * @property FullScreen {DisplayMode}
         */
        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";
        /**
         * Scale the game to the parent DOM container
         * @property Container {DisplayMode}
         */
        DisplayMode[DisplayMode["Container"] = 1] = "Container";
        /**
         * Show the game as a fixed size
         * @Property Fixed {DisplayMode}
         */
        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";
    })(ex.DisplayMode || (ex.DisplayMode = {}));
    var DisplayMode = ex.DisplayMode;
    // internal
    var AnimationNode = (function () {
        function AnimationNode(animation, x, y) {
            this.animation = animation;
            this.x = x;
            this.y = y;
        }
        return AnimationNode;
    })();
    /**
     * The 'Engine' is the main driver for a game. It is responsible for
     * starting/stopping the game, maintaining state, transmitting events,
     * loading resources, and managing the scene.
     *
     * @class Engine
     * @constructor
     * @param [width] {number} The width in pixels of the Excalibur game viewport
     * @param [height] {number} The height in pixels of the Excalibur game viewport
     * @param [canvasElementId] {string} If this is not specified, then a new canvas will be created and inserted into the body.
     * @param [displayMode] {DisplayMode} If this is not specified, then it will fall back to fixed if a height and width are specified, else the display mode will be FullScreen.
     */
    var Engine = (function (_super) {
        __extends(Engine, _super);
        function Engine(width, height, canvasElementId, displayMode) {
            _super.call(this);
            /**
             * Sets or gets the collision strategy for Excalibur
             * @property collisionStrategy {CollisionStrategy}
             */
            this.collisionStrategy = 1 /* DynamicAABBTree */;
            this.hasStarted = false;
            this.fps = 0;
            this.postProcessors = [];
            this.sceneHash = {};
            this.animations = [];
            /**
             * Indicates whether the engine is set to fullscreen or not
             * @property isFullscreen {boolean}
             */
            this.isFullscreen = false;
            /**
             * Indicates the current DisplayMode of the engine.
             * @property [displayMode=FullScreen] {DisplayMode}
             */
            this.displayMode = 0 /* FullScreen */;
            /**
             * Indicates whether audio should be paused when the game is no longer visible.
             * @property [pauseAudioWhenHidden=true] {boolean}
             */
            this.pauseAudioWhenHidden = true;
            /**
             * Indicates whether the engine should draw with debug information
             * @property [isDebug=false] {boolean}
             */
            this.isDebug = false;
            this.debugColor = new ex.Color(255, 255, 255);
            /**
             * Sets the background color for the engine.
             * @property [backgroundColor=new Color(0, 0, 100)] {Color}
             */
            this.backgroundColor = new ex.Color(0, 0, 100);
            this.isSmoothingEnabled = true;
            this.isLoading = false;
            this.progress = 0;
            this.total = 1;
            this.logger = ex.Logger.getInstance();
            this.logger.info("Powered by Excalibur.js visit", "http://excaliburjs.com", "for more information.");
            this.logger.debug("Building engine...");
            this.canvasElementId = canvasElementId;
            if (canvasElementId) {
                this.logger.debug("Using Canvas element specified: " + canvasElementId);
                this.canvas = document.getElementById(canvasElementId);
            }
            else {
                this.logger.debug("Using generated canvas element");
                this.canvas = document.createElement('canvas');
            }
            if (width && height) {
                if (displayMode == undefined) {
                    this.displayMode = 2 /* Fixed */;
                }
                this.logger.debug("Engine viewport is size " + width + " x " + height);
                this.width = width;
                this.canvas.width = width;
                this.height = height;
                this.canvas.height = height;
            }
            else if (!displayMode) {
                this.logger.debug("Engine viewport is fullscreen");
                this.displayMode = 0 /* FullScreen */;
            }
            this.loader = new ex.Loader();
            this.initialize();
            this.rootScene = this.currentScene = new ex.Scene(this);
            this.addScene('root', this.rootScene);
        }
        /**
         * Plays a sprite animation on the screen at the specified x and y
         * (in game coordinates, not screen pixels). These animations play
         * independent of actors, and will be cleaned up internally as soon
         * as they are complete. Note animations that loop will never be
         * cleaned up.
         * @method playAnimation
         * @param animation {Animation} Animation to play
         * @param x {number} x game coordinate to play the animation
         * @param y {number} y game coordinate to play the animation
         */
        Engine.prototype.playAnimation = function (animation, x, y) {
            this.animations.push(new AnimationNode(animation, x, y));
        };
        /**
         * Adds an actor to the current scene of the game. This is synonymous
         * to calling engine.currentScene.addChild(actor : Actor).
         *
         * Actors can only be drawn if they are a member of a scene, and only
         * the 'currentScene' may be drawn or updated.
         * @method addChild
         * @param actor {Actor} The actor to add to the current scene
         */
        Engine.prototype.addChild = function (actor) {
            this.currentScene.addChild(actor);
        };
        /**
         * Removes an actor from the currentScene of the game. This is synonymous
         * to calling engine.currentScene.removeChild(actor : Actor).
         * Actors that are removed from a scene will no longer be drawn or updated.
         *
         * @method removeChild
         * @param actor {Actor} The actor to remove from the current scene.
         */
        Engine.prototype.removeChild = function (actor) {
            this.currentScene.removeChild(actor);
        };
        /**
         * Adds a TileMap to the Scene, once this is done the TileMap will be drawn and updated.
         * @method addTileMap
         * @param tileMap {TileMap}
         */
        Engine.prototype.addTileMap = function (tileMap) {
            this.currentScene.addTileMap(tileMap);
        };
        /**
         * Removes a TileMap from the Scene, it willno longer be drawn or updated.
         * @method removeTileMap
         * @param tileMap {TileMap}
         */
        Engine.prototype.removeTileMap = function (tileMap) {
            this.currentScene.removeTileMap(tileMap);
        };
        /**
         * Adds an excalibur timer to the current scene.
         * @param timer {Timer} The timer to add to the current scene.
         * @method addTimer
         */
        Engine.prototype.addTimer = function (timer) {
            return this.currentScene.addTimer(timer);
        };
        /**
         * Removes an excalibur timer from the current scene.
         * @method removeTimer
         * @param timer {Timer} The timer to remove to the current scene.
         */
        Engine.prototype.removeTimer = function (timer) {
            return this.currentScene.removeTimer(timer);
        };
        /**
         * Adds a scene to the engine, think of scenes in excalibur as you
         * would scenes in a play.
         * @method addScene
         * @param name {string} The name of the scene, must be unique
         * @param scene {Scene} The scene to add to the engine
         */
        Engine.prototype.addScene = function (name, scene) {
            if (this.sceneHash[name]) {
                this.logger.warn("Scene", name, "already exists overwriting");
            }
            this.sceneHash[name] = scene;
            scene.engine = this;
        };
        Engine.prototype.removeScene = function (entity) {
            if (entity instanceof ex.Scene) {
                for (var key in this.sceneHash) {
                    if (this.sceneHash.hasOwnProperty(key)) {
                        if (this.sceneHash[key] === entity) {
                            delete this.sceneHash[key];
                        }
                    }
                }
            }
            if (typeof entity === "string") {
                // remove scene
                delete this.sceneHash[entity];
            }
        };
        Engine.prototype.add = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.currentScene.addUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.addChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.addTileMap(entity);
            }
            if (arguments.length === 2) {
                this.addScene(arguments[0], arguments[1]);
            }
        };
        Engine.prototype.remove = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.currentScene.removeUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.removeChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.removeTileMap(entity);
            }
            if (entity instanceof ex.Scene) {
                this.removeScene(entity);
            }
            if (typeof entity === "string") {
                this.removeScene(entity);
            }
        };
        /**
         * Changes the currently updating and drawing scene to a different,
         * named scene.
         * @method goToScene
         * @param name {string} The name of the scene to trasition to.
         */
        Engine.prototype.goToScene = function (name) {
            if (this.sceneHash[name]) {
                this.currentScene.onDeactivate.call(this.currentScene);
                var oldScene = this.currentScene;
                this.currentScene = this.sceneHash[name];
                oldScene.eventDispatcher.publish('deactivate', new ex.DeactivateEvent(this.currentScene));
                this.currentScene.onActivate.call(this.currentScene);
                this.currentScene.eventDispatcher.publish('activate', new ex.ActivateEvent(oldScene));
            }
            else {
                this.logger.error("Scene", name, "does not exist!");
            }
        };
        /**
         * Returns the width of the engines drawing surface in pixels.
         * @method getWidth
         * @returns number The width of the drawing surface in pixels.
         */
        Engine.prototype.getWidth = function () {
            if (this.currentScene && this.currentScene.camera) {
                return this.width / this.currentScene.camera.getZoom();
            }
            return this.width;
        };
        /**
         * Returns the height of the engines drawing surface in pixels.
         * @method getHeight
         * @returns number The height of the drawing surface in pixels.
         */
        Engine.prototype.getHeight = function () {
            if (this.currentScene && this.currentScene.camera) {
                return this.height / this.currentScene.camera.getZoom();
            }
            return this.height;
        };
        /**
         * Transforms the current x, y from screen coordinates to world coordinates
         * @method screenToWorldCoordinates
         * @param point {Point} screen coordinate to convert
         */
        Engine.prototype.screenToWorldCoordinates = function (point) {
            // todo set these back this.canvas.clientWidth
            var newX = point.x;
            var newY = point.y;
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                newX = focus.x + (point.x - (this.getWidth() / 2));
                newY = focus.y + (point.y - (this.getHeight() / 2));
            }
            newX = Math.floor((newX / this.canvas.clientWidth) * this.getWidth());
            newY = Math.floor((newY / this.canvas.clientHeight) * this.getHeight());
            return new ex.Point(newX, newY);
        };
        /**
         * Transforms a world coordinate, to a screen coordinate
         * @method worldToScreenCoordinates
         * @param point {Point} world coordinate to convert
         *
         */
        Engine.prototype.worldToScreenCoordinates = function (point) {
            // todo set these back this.canvas.clientWidth
            // this isn't correct on zoom
            var screenX = point.x;
            var screenY = point.y;
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                screenX = (point.x - focus.x) + (this.getWidth() / 2); //(this.getWidth() / this.canvas.clientWidth);
                screenY = (point.y - focus.y) + (this.getHeight() / 2); // (this.getHeight() / this.canvas.clientHeight);
            }
            screenX = Math.floor((screenX / this.getWidth()) * this.canvas.clientWidth);
            screenY = Math.floor((screenY / this.getHeight()) * this.canvas.clientHeight);
            return new ex.Point(screenX, screenY);
        };
        /**
         * Sets the internal canvas height based on the selected display mode.
         * @method setHeightByDisplayMode
         * @private
         */
        Engine.prototype.setHeightByDisplayMode = function (parent) {
            if (this.displayMode === 1 /* Container */) {
                this.width = this.canvas.width = parent.clientWidth;
                this.height = this.canvas.height = parent.clientHeight;
            }
            if (this.displayMode === 0 /* FullScreen */) {
                document.body.style.margin = '0px';
                document.body.style.overflow = 'hidden';
                this.width = this.canvas.width = parent.innerWidth;
                this.height = this.canvas.height = parent.innerHeight;
            }
        };
        /**
         * Initializes the internal canvas, rendering context, displaymode, and native event listeners
         * @method initialize
         * @private
         */
        Engine.prototype.initialize = function () {
            var _this = this;
            if (this.displayMode === 0 /* FullScreen */ || this.displayMode === 1 /* Container */) {
                var parent = (this.displayMode === 1 /* Container */ ? (this.canvas.parentElement || document.body) : window);
                this.setHeightByDisplayMode(parent);
                window.addEventListener('resize', function (ev) {
                    _this.logger.debug("View port resized");
                    _this.setHeightByDisplayMode(parent);
                    _this.logger.info("parent.clientHeight " + parent.clientHeight);
                    _this.setAntialiasing(_this.isSmoothingEnabled);
                });
            }
            // initialize inputs
            this.input = {
                keyboard: new ex.Input.Keyboard(this),
                pointers: new ex.Input.Pointers(this),
                gamepads: new ex.Input.Gamepads(this)
            };
            this.input.keyboard.init();
            this.input.pointers.init();
            this.input.gamepads.init();
            // Issue #385 make use of the visibility api
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
            document.addEventListener("visibilitychange", function () {
                if (document.hidden || document.msHidden) {
                    _this.eventDispatcher.publish('hidden', new ex.HiddenEvent());
                    _this.logger.debug("Window hidden");
                }
                else {
                    _this.eventDispatcher.publish('visible', new ex.VisibleEvent());
                    _this.logger.debug("Window visible");
                }
            });
            /*
            // DEPRECATED in favor of visibility api
            window.addEventListener('blur', () => {
               this.eventDispatcher.publish(EventType[EventType.Blur], new BlurEvent());
            });
   
            window.addEventListener('focus', () => {
               this.eventDispatcher.publish(EventType[EventType.Focus], new FocusEvent());
            });*/
            this.ctx = this.canvas.getContext('2d');
            if (!this.canvasElementId) {
                document.body.appendChild(this.canvas);
            }
        };
        /**
         * If supported by the browser, this will set the antialiasing flag on the
         * canvas. Set this to false if you want a 'jagged' pixel art look to your
         * image resources.
         * @method setAntialiasing
         * @param isSmooth {boolean} Set smoothing to true or false
         */
        Engine.prototype.setAntialiasing = function (isSmooth) {
            this.isSmoothingEnabled = isSmooth;
            this.ctx.imageSmoothingEnabled = isSmooth;
            this.ctx.webkitImageSmoothingEnabled = isSmooth;
            this.ctx.mozImageSmoothingEnabled = isSmooth;
            this.ctx.msImageSmoothingEnabled = isSmooth;
        };
        /**
         *  Return the current smoothing status of the canvas
         * @method getAntialiasing
         * @returns boolean
         */
        Engine.prototype.getAntialiasing = function () {
            return this.ctx.imageSmoothingEnabled || this.ctx.webkitImageSmoothingEnabled || this.ctx.mozImageSmoothingEnabled || this.ctx.msImageSmoothingEnabled;
        };
        /**
         * Updates the entire state of the game
         * @method update
         * @private
         * @param delta {number} Number of milliseconds elapsed since the last update.
         */
        Engine.prototype.update = function (delta) {
            if (this.isLoading) {
                // suspend updates untill loading is finished
                return;
            }
            // process engine level events
            this.currentScene.update(this, delta);
            // update animations
            this.animations = this.animations.filter(function (a) {
                return !a.animation.isDone();
            });
            // Update input listeners
            this.input.keyboard.update(delta);
            this.input.pointers.update(delta);
            this.input.gamepads.update(delta);
            // Publish update event
            this.eventDispatcher.publish(ex.EventType[5 /* Update */], new ex.UpdateEvent(delta));
        };
        /**
         * Draws the entire game
         * @method draw
         * @private
         * @param draw {number} Number of milliseconds elapsed since the last draw.
         */
        Engine.prototype.draw = function (delta) {
            var ctx = this.ctx;
            if (this.isLoading) {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, this.width, this.height);
                this.drawLoadingBar(ctx, this.progress, this.total);
                // Drawing nothing else while loading
                return;
            }
            ctx.clearRect(0, 0, this.width, this.height);
            ctx.fillStyle = this.backgroundColor.toString();
            ctx.fillRect(0, 0, this.width, this.height);
            this.currentScene.draw(this.ctx, delta);
            // todo needs to be a better way of doing this
            this.animations.forEach(function (a) {
                a.animation.draw(ctx, a.x, a.y);
            });
            this.fps = 1.0 / (delta / 1000);
            // Draw debug information
            if (this.isDebug) {
                this.ctx.font = "Consolas";
                this.ctx.fillStyle = this.debugColor.toString();
                var keys = this.input.keyboard.getKeys();
                for (var j = 0; j < keys.length; j++) {
                    this.ctx.fillText(keys[j].toString() + " : " + (ex.Input.Keys[keys[j]] ? ex.Input.Keys[keys[j]] : "Not Mapped"), 100, 10 * j + 10);
                }
                this.ctx.fillText("FPS:" + this.fps.toFixed(2).toString(), 10, 10);
            }
            for (var i = 0; i < this.postProcessors.length; i++) {
                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.width, this.height), this.ctx);
            }
            //ctx.drawImage(currentImage, 0, 0, this.width, this.height);
        };
        /**
         * Starts the internal game loop for Excalibur after loading
         * any provided assets.
         * @method start
         * @param [loader=undefined] {ILoadable} Optional resources to load before
         * starting the mainloop. Some loadable such as a Loader collection, Sound, or Texture.
         * @returns Promise
         */
        Engine.prototype.start = function (loader) {
            var loadingComplete;
            if (loader) {
                loader.wireEngine(this);
                loadingComplete = this.load(loader);
            }
            else {
                loadingComplete = ex.Promise.wrap();
            }
            if (!this.hasStarted) {
                this.hasStarted = true;
                this.logger.debug("Starting game...");
                // Mainloop
                var lastTime = Date.now();
                var game = this;
                (function mainloop() {
                    if (!game.hasStarted) {
                        return;
                    }
                    window.requestAnimationFrame(mainloop);
                    // Get the time to calculate time-elapsed
                    var now = Date.now();
                    var elapsed = Math.floor(now - lastTime) || 1;
                    // Resolves issue #138 if the game has been paused, or blurred for 
                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability 
                    // and provides more expected behavior when the engine comes back
                    // into focus
                    if (elapsed > 200) {
                        elapsed = 1;
                    }
                    game.update(elapsed);
                    game.draw(elapsed);
                    lastTime = now;
                })();
                this.logger.debug("Game started");
            }
            else {
            }
            return loadingComplete;
        };
        /**
         * Stops Excalibur's mainloop, useful for pausing the game.
         * @method stop
         */
        Engine.prototype.stop = function () {
            if (this.hasStarted) {
                this.hasStarted = false;
                this.logger.debug("Game stopped");
            }
        };
        /**
         * Takes a screen shot of the current viewport and returns it as an
         * HTML Image Element.
         * @method screenshot
         * @returns HTMLImageElement
         */
        Engine.prototype.screenshot = function () {
            var result = new Image();
            var raw = this.canvas.toDataURL("image/png");
            result.src = raw;
            return result;
        };
        /**
         * Draws the Excalibur loading bar
         * @method drawLoadingBar
         * @private
         * @param ctx {CanvasRenderingContext2D} The canvas rendering context
         * @param loaded {number} Number of bytes loaded
         * @param total {number} Total number of bytes to load
         */
        Engine.prototype.drawLoadingBar = function (ctx, loaded, total) {
            if (this.loadingDraw) {
                this.loadingDraw(ctx, loaded, total);
                return;
            }
            var y = this.canvas.height / 2;
            var width = this.canvas.width / 3;
            var x = width;
            // loading image
            var image = new Image();
            // 64 bit string encoding of the excalibur logo
            image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAEsCAYAAAA7Ldc6AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjenhJ3MAAA6Y0lEQVR4Xu3dUagkWZ3ncUEEQYSiRXBdmi2KdRUZxgJZhmV9qOdmkWJYlmYYhkKWcWcfpEDQFx9K2O4Fm6UaVhoahi4GF2wWh1pnYawHoXzxpVu6Gimatqni0kpTiGLhgy++3Pn9Mk6kkXlPZp4TGSfiROT3A39aq25EnMi6GfH/ZcSJ/BAAAAAAAAAAAAAAYAw/+9nPLqluqO6rroc/BgAAAIDhhNBxV3Ue6mn4KwAAAAA4nkLGddUdh40QOrp1J/wYAAAAAPSjYHHV4UIVCx3duhoWAQAAAIB0DhOq26qzEC4O1VlYFAAAAAAOU4i4rLrpMBFCxYV66623zt99993z999///ydd97p/t3tsBoAAAAAiFNwaEPHgxAkotWGjt/85jer+vWvf739M9x+BQAAAOAihYX2sbndJ1hdKF/hODs7W4WNNni09fjx4+7PPgirBgAAAICGgsLB0PHzn/98Z+joln+us9zNsAkAAAAAp0zhYN9jc1flMOErGk+ePImGje3yz22t43LYHAAAAIBTo0Bw8LG5b7/99vl7772XHDq6xe1XAAAAwIlTEDj42Nw2dHzwwQfRYJFaXk9nvTfCEAAAAAAsmZr/rMfmxsJEbjm8bG3jUhgOAAAAgKVRw9/rsblDla+gdLZzNwwLAAAAwFKo0T/6sblDFbdfAQAAAAvlBl81yGNzh6hf/epX3W17gju3XwEAAABzpqZ+8MfmDlW+raszjjthyAAAAADmRM180cfmDlWe0N4Z0/UwfAAAAAC1UwM/2mNzhyhPaO+M7WnYDQAAAAC1UwPvuR3dhn5dQz82d6ji9isAAABghtS8R8NHjaGjLU9w3xrv1bA7AAAAAGqlxn0jfPhqx1hPsDqmPMbOuM/C7gAAAAColRr3C+GjhrkdKeXvF+mM/XbYJQAAAAA1UtM+2/DB7VcAAADAjKhhn234cPn7RjrjfxB2CwAAAEBt1LDPOny4/KWHnX24GXYNAAAAQE3UrM8+fPhLD7v7oLocdg8AAABALdSozz58uB49etQNH9x+BQAAANRGjfpG+PAtTHMMHy5/E3tnX26EXQQAAABQAzfpnYZ9FT5q/46PXeXQ1N0X1aWwmwAAAACmpgZ9MeHD9d5773XDx92wmwAAAACmpgZ9UeHDxe1XAAAAQIXcnHca9UWEj/fff78bPp6quP0KAAAAmJoa88WFD9e7777bDSB3wu4CAAAAmIoa80WGD5cfG9zZt+thlwEAAABMQU35YsPH9u1XYZcBAAAATEFN+WLDh+udd97pBpDbYbcBAAAAjE0N+aLDh/elu3+qq2HXAQAAAIxJzfiiw4fr7OysGz7Owq4DAAAAGJOa8cWHDxe3XwEAAAATUyN+EuHjyZMn3fDhuhxeAgAAAABjUBN+EuHD9fjx4274eBBeAgAAAABjUBN+MuHD5f3r7O/N8DIAAAAAKE0N+EmFD26/AgAAACai5vukwofr0aNH3fBxP7wUAAAAAEpS831y4cP19ttvdwPIjfByAAAAACjFjXenCT+Z8PHBBx90w4frUnhJAAAAAJSgpvskw4frvffe64aPu+ElAQAAAFCCmu6TDR8ubr8CAAAARuKGu9N8n1z4eP/997vh42l4WQAAAAAMTQ33SYcP17vvvtsNIHfCSwMAAABgSGq2Tz58uN56661uALkeXh4AAAAAQ1GjTfhQPX78uBs+uP0KAAAAGJoabcKH6uzsrBs+XLfDSwQAAABgCGqyCR+qSPh4oOK7PwAAAIChqMEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qAgfAAAAQGFqsAkfKsIHAAAAUJgabMKHivABAAAAFKYGm/ChInwAAAAAhanBvt1puAkffyrCBwAAADAkNdh3Og034eNPRfgAAAAAhqQGm/ChInwAAAAAhanBJnyoCB8AAABAYWqwCR8qwgcAAABQmBpswoeK8AEAAAAUpgab8KEifAAAAACFqcEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qAgfAAAAQGFqsAkfKsIHAAAAUJgabMKHivABAAAAFKYGm/ChInwAAAAAhanBJnyoCB8AAABAYWqwCR8qwgcAAABQmBpswoeK8AEAAAAUpgab8KEifAAAAACFqcEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qB49etQNHi7CBwAAADAkNdiED9W7777bDR4uwgcAAAAwJDXYhA8V4QMAAAAoTA024UNF+AAAAAAKU4NN+FARPgAAAIDC1GATPlSEDwAAAKAwNdiEDxXhAwAAAChMDTbhQ0X4AAAAAApTg034UBE+AAAAgMLUYBM+VIQPAAAAoDA12IQPFeEDAAAAKEwNNuFDRfgAAAAAClODTfhQET4AAACAwtRgEz5UhA8AAACgMDXYhA8V4QMAAAAoTA024UNF+AAAAAAKU4NN+FARPgAAAIDC1GATPlSEDwAAAKAwNdiEDxXhAwAAAChMDTbhQ0X4AAAAAApTg034UBE+AAAAgMLUYBM+VIQPAAAAoDA12IQPFeEDAAAAKEwNNuFDRfgAMHfn5+ffUCULixWh1b/QbCXJm2GxIrT+e81mktwLiwEASlCDTfhQET4ALIGa5yoCiFb9pWYLWV4Iiw9O6yaAAEAN1GBvhI+HDx8SPpoaLXz4RNec7xbhG2G3AEzE78Pm7ZgmLDY4rfrNZgvZroRVDErrJYAAwNTUYG+EDzfhseZ86TX1lQ+f6Jrz3SIQQICJ+X3YvB3ThMUGpdVeadbey1fDagal9RJAAGBKarAJH6oabrvyia453y0CAQSYmN+HzdsxTVhsUFptn9uvWq+E1QxK6yWAAMBU1GATPlQ1hA/zia453y0CAQSYmN+HzdsxTVhsUFrtMQGkSPPv9TarT0IAAYChqMEmfKhqCR/mE11zvlsEAggwMb8Pm7djmrDYoLRaroAAAAgfbdUUPswnuuZ8twgEEGBifh82b8c0YbFBabXMAQGAU6cGm/Chqi18mE90zfluEQggwMT8PmzejmnCYoPTqh81W8jGU7AAYO7UYBM+VDWGD/OJrjnfLQIBBJiY34fN2zFNWGxwWvVzzRayFDuGaN0EEAAYgxpswoeq1vBhPtE157tFIIAAE/P7sHk7pgmLFaHVv9JsJQnfhA4Ac6cGm/Chqjl8mE90zfluEQggwMT8PmzejmnCYsVoEynjcVD5RFikCK2fAAIAJanBJnyoag8f5hNdc75bBAIIMDG/D5u3Y5qwWFHajCelv6Dqfju654g4eHwp/FhR2g4BBABKUYNN+FDNIXyYT3TN+S5NWAwAonSYqC6A1EC7SgABgBLUYBM+VHMJH+YTXXO+SxMWA4AoHSYIIBHaVQIIAAxNDTbhQzWn8GE+0TXnuzRhMQCI0mGCABKhXSWAAMCQ1GATPlRzCx/mE11zvksTFgOAKB0mCCAR2lUCCAAMRQ024UM1x/BhPtE157s0YTEAiNJhggASoV0lgADAENRgEz5Ucw0f5hNdc75LExYDgCgdJgggEdpVAggAHEsNNuFDNefwYT7RNee7NGExAIjSYYIAEqFdJYAAwDHUYBM+VHMPH+YTXXO+SxMWA4AoHSYIIBHaVQIIAPSlBpvwoVpC+DCf6JrzXZqwGABE6TBBAInQrhJAAKAPNdiED9VSwof5RNec79KExQAgSocJAkiEdpUAAgC51GATPlRLCh/mE11zvksTFgOAKB0mCCAR2lUCCADkUINN+FBFwsd91WzDh/lE15zv0oTFACBKhwkCSIR2lQACAKnUYBM+VJHwcSe8RLPmE11zvksTFgOAKB0mCCAR2lUCCIDy/unvPnRZdS2hbiXUHdX9Tt0ImynKTXa36SZ8LCt8mE90zfkuTVgMAKJ0mCCARGhXCSAALlJT7zCw3ejvqvOJ61YYdjFusrtNN+FjeeHDfKJrzndpwmIAEKXDBAEkQruac6wlgACnwk39VpNfc90Nwy7CTXa36SZ8LDN8mE90zfkuTVgMAKJ0mCCARGhXc461BBDgVKipHzSA/OhrHz7/6bc+drAevvTM+S9e/uTeevzdT62qs/77YdiDc5PdbboJH8sNH+YTXXO+SxMWAwajX6svqZ5XuXH176PrkWoX/137c17Gy34hrK56Gqv396th7O1+vKna5Xeq2exvGGOysNjiaVf975dqkACi9XxB5d+XF7zOULvM5ncM86LfpSsqH/NeV8WOde0x7hWVf+5KWPQ0qKlfB5AHL146/+33Lu+sP/7ws+fn//z5UesPP/jMamxthWEPyk12t+kmfCw7fFh40ycLiwG96dfITVHbfA/N66zmBKZxfEL1nMon1n0how+ftL3e58LmqqDxEEAitKs5v++9A4iWdcD178W+EJ/K66judwzzoN8b/y72Oc6f1hVANfXrAOKrDrEQMHW14wt1OQx9EG6yu0034WP54cP8Rm/e72nCYrOnXfEnMm7gcj0fVjEpjcONbe74Jzuoa9t+vf0p7BBNUSo3/P4k9xNhGKPw9sJ2/WnfWPy6uvEfdV9jwjiShcWK0Opzjm9F3x9ef7OZJNlj0TL+nSv5/vK6He5r+B2b9XlLQ8p6j8iXwqKD07oH/73Uz/lDpqx/oy0EkNrKt2y1Y1RdD0M/mpvsbtNN+DiN8GF+ozfv9zRhsUXQ7vhkmutRWHxSGoeb+RwOK6NfFdA2/QnYmI14jPf9G2FIxWgbDln+tLhPsB2Ktz1pSNb2CSARXn+zmSTJY9HPlg4e22r4HZv1eUtDWmwA0c/0Oa9uO7kA4idgnbs83yIWAKYu3xrWjlE1yJOw3GR3m27Cx+mED/MbvXm/pwmLLYZ2KWv/g+LN7D7avj9dyvXVsPgotD03431e22LC0AanVfe9zaAkj2eST6q1XQJIhNffbCZJSqM39XvMVxgnmSei7Wbtd1isGhrSIgOI/t4fwAzh5ALI+vG6nucRCwBT1y9f/fRqfKGOnojuJrvbdBM+Tit8mN/ozfs9TVhsMbRLfZp5fwI42W0I2nbWv5mMdjDXtnz7Ue7VmVGEIQ5Gq2yveNTKv6ejN4jaJgEkwutvNpPkUKPneUVTXmlrTXI1RNuc9XlLQ1pcANHfDXksJIDUVr9//cpqfKGehqH34ia723QTPk4vfJjf6M37PU1YbFG0W7knA3slLD4qbde3W+RwgzDKrVfajsPcmLeCZAnDHIRW1+d3ZgqjhxBtjwAS4fU3m0myr9HLPQaMYdSrwtrerM9bGtKiAoj+fOgPYgggNZYf79uOU3U1DD+Lm+xu0034OM3wYX6jN+/3NGGxxdGu9XlC0diNXZ+J56PceqXt1NgUbQhDPZpW5Vuu5mS0EGraFgEkwutvNpNkrEZvSKN9KKNtzfq8pSEtJoDoz4aY87GNAFJjvfHtj6/GGOpmGH4SNdiXVPc7DTfh4091cuHD/EZv3u9pwmKLo13r01SOepDU9nJvbRplfNpOzU3RWhju0bSquQUQezMMvzhtiwAS4fU3m0kSa/Rym9YpvBCGW5S2M+vzloa0iACi/9/nFuYUo55bJ6dmfhYBpO8XEqrBdvh40Gm4CR9/qpMMH+Y3evN+TxMWWyTtXp+5C6M8H1/byT3Qj/Kpt7Yxi/BhYchH06rmGEBslNtkvJ1mc2nCYkVo9TnHt2oDiP5/9VcYO4rPCdE2Zn3e0pCWEkCG/m6jFgGkxtr+QkLVpbALO6nBJnyEInxs8hu9eb+nCYstknbPtzjlzmEY5bG82k7Wv5MUv/VK2xgyfDgw+XG9PjG7wY+ecPXnDmL+e1/29/aT/73CKo6mVR0bQDzmdl89mdjru/BQA/9Z+Dvvq38+9/a7mDFCKQEkwutvNpNkPRb97z6fMvt3zB+oOLj4d+jCv7v/LPxd+14a4verVfT2VK1/1uctDWn2AUT/u8StVy0CSK31469/ZDXOUDfCLkSpwSZ8hCJ8XOQ3evN+TxMWWyztohvCXEWbfa0/d0zFD97axlDhw+s56iqSlncj5ZPh3jASfvxoWlWfAOIA4WawdwDQsu0XHOaG5K7i9+lrGwSQCK+/2UyS1Vj035wPRRwg/Nof8zvmY80Q39vjMRd7UqDWPevzloY06wCi/+bMR/Tvk4/PF/ZBf9Z+yOLjWvcDJQJIrfXwpWdW4wx1N+zCBWqwCR+hCB9xfqM37/c0YbFF027mnoB9IC5ysvV6VTkNp8dS9FNurT/35BnjdQz+mmmdPplFf6fDjxxNq0oNIP5384l30P30+lTHBMCqfj/CYkVo9TnHtxoDSMqxaBU8VhsZiNbnqy5Z54aIYvNBtO5Zn7c0pLkHkJTx+xiVfazRMg7Bo8wlqkanoV/d5hRr/GuprcfxuqK3YanJvtttugkfhI9teqPfUyULiy2adjPn051WkQOm1pt7oqrtasw2N1RFG2DTNi4EkfBXR9OqDgUQ3xc9xn3wfecFFD25a/0EkAivv9lMEv9synvN76eSVxqOvc2myK1YWu+sz1sa0twDyL4Pxfx3o3//0Kx1G/pY019bpdyGpUb7Vrfx/vWvfx1t0JdchI/9dKC4tzpkJAqLLZ52tU9zN2hj7fU1q01WuoHqE8xaXm6KLyzzv+NqzOGPjqZV7QogPvGOuo/aXm4jY78Lixeh9RNAIrz+ZjNJHGIPXfkc6xHbvhrS931f5DX1epvVpwmLVUNDmm0AUe0Lxv77YoF4sTrNfLThr622bsOKPg1LzbZvwXraNt+PHj2KNulLLcLHYeGAkSwsdhK0u1mvjQx6svX6mtUmcYNQ+taa3Nej5bFN9omYtu3gNNi/jdYVCyBuKCY58Wq7ff5dSjY0BJAIr7/ZzCDGDrrHhJDBf9e0zqzXMixWDQ1pzgFk122Br4dVIlenmY82/LVV5GlYl8OubFDTvb4K8tZbb53MVRDCRxodNO41x440YbGToN31FYjck+4gJwqtJ/dWp1pvvfInucVvuRqT9qcbQCa/3cDbX40kT7FH8nrdzSbShMWK0Opzjm9zCSCjX0k0bbfP75kN/rp6nc2q04TFqqEhzTWA7Loq5+M8Vz766jbzsYa/xvrptz62HrPqdtiVDWq8T+4qCOEjnQ4a91aHj/kq+t0GXn+zmWRHP5ZX68ideF66cep761XxqzJT0D61AaTo/fc5NI7cSenFfme0bgJIhNffbOYok4SPlrbfd07I0LenZr2WYbFqaEhzDSAxizzOj6rTyEeb/Rrrl69+ej1m1VPVrsnoG3NBnjx5Em3cl1CEjzw6cNxbHULmq/iXq2kbuV+2dFSToOVzTk7FD/5af+7J0jyuRU5E1H45gIxy/30qjSf7ClVYdHBaNQEkwutvNtNb8Ucop9A4+uzHoA8+0PqyxhAWq4aGtKQAMsqX8S5ap5GPNvu11tZk9Jthdy5QI37WNuXvvPNOtHmfexE+8ungca85hszWGAEk99YDN9+9PhnXcrkTz0vfetX36gcnpZHpNc/9dyr1hCICSITX32ymF18RreVqW59bUwd98IHWl/VahsWqoSEtJYAUfc+cjE4TH230a61fvPzJ9bhVZ2F3LlAzfr3bnP/qV7+KNvFzLcJHPz6ANMeR2SoeQMzbaTaXrNe4tFzOv0fxg7+2kbvfdlrPcK+EXvfc27CKNDVaLwEkwutvNtNLsQa0D42nz3FhsA8ltK6s1zIsVg0NaSkBhFuvjqXG/VKniY82+rXWH3/42fMffe3D67Grdn4zupry+22D/vbbby9mQjrhoz8dQO41x5HZGiuA5M7LsKyDs34+5zYafwJZ/OCvbeTuczWf1J4ave659+cXee94vc3q04TFitDqc45vtQaQ6j5l1ph8PMw12AcTWlfWaxkWq4aGtIQAUsUtgbOnpv1a28B7Ynes0a+5Mq6CXFatJ6S/99570YZ+TkX4OI4OIn0PPrUYJYCYtrXr+x92SX4soX42N+AUn4OgbfR58tWkk2RPmV773N9PAsimWgNIVVc/WhpX7hW3ox/Q0dK6sl7LsFg1NKQlBBC+bHAIatpnHUAiV0FuhV27QA36xoT0Od+KRfg4ng4ifQ8+tRgtgJi2V+Q2F/1czglplE9EtZ1dz3vfZbAGA/n0+ud+Kl3Ft/eHxYrQ6nOObzUGkOqufrQ0tj6P5R3kqq3Wk/VahsWqoSHNPYC8GRbHsdSwzzqAuLaugux8IpapUX/QNu1z/W4QwscwdCDpc/CpydgBJHdS9sEDtX4mZ1LnWLde9bnFgqsfEwv/DqmKNLdaLwEkwutvNpOl6veUxpd7i+Yg80C0nqzXMixWDQ1p7gGkqqcAzpqa9dkHkMhVkOj3gpia9auq9a1Yc3sqFuFjODqQ9Dn41GTUAGLaZu6tSXubCP19zpWGUQ782s7zzeaScfWjAvp3yAnHBJBNNQaQqudTaXy5V4QHOV5rPVmvZVisGhrS3AMIt18NRc367AOI6/F3P7Xah05dDbt4gZr2m90mfi5fUEj4GJYOJPea48lsjR5ATNvNCQ07J2brz3Pu2x/tdgxtK7ex4MlXFdC/Q877mQCyqbYAMtr7vS+NMfeDikH2yetpVpcmLFYNDWnOAYQPm4akRn0RAcT1k29+dLUfoe6HXYxS836328zXPh+E8DE8HUxyDz61mSqA5D4LPzpO/XnqLQyj3HrV0rZyb63gE7EK6N8h5/1MANlUWwCZ5NiWQ2PM/d6iQZpXrSfrtQyLVUNDmnMASX64ChKoUV9MAPnt9y6v9qNT+76c8JJqYz7IBx98EG3+py7CRxk6mNxrjilpwmIQvRw5jz11gNi4CqL/n3MSGu2eW21rkqYC6fSa+8qZbwX075CvVvl9nBOIjQCyqbYAUqzpHFIYa7Kw2FG0mlmftzSkOQeQ6oPxrKhJX0wAcT148dJqX0J5QvrlsKsXqJHfmA/y85//vKpJ6R6L56i04wtF+BiIDiZZB5+wGAK9JDmv3/q56frfOVdQijZG27S93DkuPA++AL2uQ4SMfQggm2oLILP4Ph2NM3e/jr6Sq3VkbTMsVg0Nac4BZBbBeDbUoN9oG/Y3vv3xaFM/p4pMSD90K9bGt6TXEkI8Bo+lOzYV4WNAOphkHXzCYgj0kuQ+inJ18tV/U+eQjHrrlWl7uSdHnn7Vk1670iFjHwLIpqoCSFisehpq7uO6j25gtY5Zv5Ya0pwDyKjno8VTg36rbdb9ONtYUz+3evLas6v96dTO7wYxNfY3uo3+w4cPo6FgrCJ8jEMHk3vNMSVNWAwdellyTiZuMnMmno/+uENtM7ehYP7HAX6NVL5l7wWV33NjhYx9CCCbagogs/meBY119GZa65j1eUtDmm0ACYthKG7O20Z9KQHE9fClZ1b71KlrYZej3OB3G37Pu4iFg9JF+BiPjif3msNKmrAYtuilebN5hZKkNp+TNCHaLr8TR9LL4u9R8ROCHOZqCBsxBJBNNQWQomMZksZKAMmkIRFA0FBjvsgA4luxtp6KtfcLCs2NfrfxHzuEED7GpeMJB58B6KXJuaqRapIrC2HbqZiA3qHXw7dT5V5BmgoBZBMBpAeNNbeZPnoSs9Yx6/OWhjTXADKb38vZUFO+yADi+v3rV7bngzwIu72TG/5uAHAIGWNOCOFjfD6gNMeVNGExROjl8e01Q5nsSSNh+6k4IYleB1/tyH108dQIIJsIID1orASQTBoSAQQNNeWLDSCuX7766dW+depgU+/GvxsEHAxKhhDCxzR8QGmOK2nCYojQy+PbboZoQie7/1vb9j7kOOkTkvbfV77mFjxaBJBNBJAeNFYCSCYNiQCChhryRQcQV2Q+yN5J6eYA0A0EpUII4WM6PqA0x5U0YTHsoJco9xG2MZNN6ta2c28lO8lvQNd+O6gNecVrCgSQTQSQHjRWAkgmDYkAgoab8bYxX2oAcfkRw+1+hroRXoKdHAS6wWDoLyskfEzLB5TmuJImLIY99DIdMwdgsluvTNvPDSCTjncK2meHj5yHDpTg961/z9zI+PYv/7t5XDnvZwLIJgJIDxorASSThkQAQUON+DqA+IsI/W3if/jBZ6JN/JwrMindlRJCbnUDgkPI2dlZNFDkFOFjej6gNMeVNGEx7KGXKfc2pq5Jv3xM2yeA7KH99eN0x3iqlbfh96Yf27wRMsJQovT3Oe9nAsgmAkgPGisBJJOGRABBQ0343a2mfF0OJL59yd+r4QY+1tjPqbwPP/76R7b3MyWEbHxPiOuYJ2QRPurgA0pzXEkTFsMeepn8fQ99TXpLk7ZPANlB++pgOXT48JWUNmT49r2jGg0tn/N+JoBsIoD0oLGO3kxrHbM+b2lIBBA01IDf32rId5avILSBJNbgz6EiT8ZypYSQq6qnncCwChG5t2QRPurhA0pzXEkTFsMOeolyvxk9ptjJ5hBvuxlCslMKIEPcduV1uPko8m+s9ea8nwkgmwggPWisBJBMGhIBBA0131dV11W+FeuOKjmQeF6FnzI1t6sjR4SQS6oHneCwuiXr8ePH0bCxXYSPuviA0hxX0oTFsINeoiGaVD9VaZJbsbTd3AByEick7ecxE8797+mG40pYXTHaRs77mQCyiQDSg8aaO+eNAEIAwSFqyB1Mbqhuqx6ozvfVgxcvzerKSN8QYgoNt7dCxPnDhw/Pnzx5Eg0eLsJHfXxAaY4racJiiNDLk3tS2WeSW7G0XQLIFu1j36tavl3r+bCaUWh7Oe9nAsgmAkgPHmsz5GRHB3GtY9bnLQ2JAII8as4vqXylxFdJzlTnsfIcCz9Naw5XRXaEkKRQoPBwTXXWCROrevTo0SpsED7q5wNKc1xJExbDFr00uY17imInnV20zdwJ9KcQQLLeI4E/FR79Kpa2mTNWAsgmAkgPGmvW9+CExY6i1cz6vKUhEUBwHDXqvkLiqyPRMOLG3ldFan+i1o6nY/k2tEthV3dSiPAtWRuP6nW9/fbb5++//z7ho3I+oDTHlTRhMXToZXHTXuLL6Ca5FavZdLqw2CJp9/pc/XglLD46bTvn/UwA2UQA6SGMN9XvwmJH0Xpmfd7SkAggGI6a9WsqXxk5j1XtQWRHCPFtZ1fDLu6lQBG9GuLbsggf9fIBpTmupAmLoUMvi59ilMonnpywMvqtWNpm7pOeJn10cEnat5x/W5v0BO3tN8NIQgDZRADJpHFOcsum1pM1JyssVg0NiQCC4alh921aN1XRqyK1BxGPb2vMT1Wp80J8NcTfGbLxpKytInxUxAeU5riSJiyGQC9JzjefvxmW8Xc65Bj1VixtL+t3Qka/VWws2rfcMFZ8ovk+2n7OeAkgmwggmTTO3EeOD/KBitZTze9YHxoSAQRluXFXXZi87luzap4j8vi7n9oYbyh/V8rBW7JMIeOyg0YndBA+KuUDSnNcSRMWg+jlyP1eiC+ERb1sztOyRr0VS9vK/dR/kY/i1X7lfro72a1XrTCOVASQTTUFkEdhsappnLnHiq+GRY+i9cw9gOQ+VY8Agn7UuPv2rAtXRDxZvdanZvnb4COT070P18JuHaTA4e8NuU/4qJcPKM1xJU1YDKKXI+fxkxuf/On/5za3o92KpW3lfjq3yJOS9iv3dXguLDoJbf9KM4xkBJBNNQWQWRxrNczcuW/rD2GOofXkvjerukqr8WT9LggBBMdR8+4rIheCiL9LpMarIR6Tvwl+e7wqz3VJuhpiDiLhf6IyPqA0x5U0YbGTp5ci59YDXyW5cAVDf5b76eEoJ1Fvp9lclsXNA9E+Zb03ZNLXQNuf5H78bVovASTC6282k2yQZr0Uj68ZZrqw6NG0qrkHkNxbOwkgGIaad3/hoedWnLflqw21Xg3xLVmRqyHJc0NQLx9QmuNKmrDYSdPL4E+ac04g0e+C0J/nrme0W7GazWUZ9fsuxqB9yvl0d/JbZjSG3KaMALKptgAyyO1KpWh8ubcRDfb6al25v+vV3CaqseReqTQCCIaj5v2y6sI3rtd6NcQT53dcDfEcl+TbslAXH1Ca40qasNhJ08uQM39j7wFbfz/JJM5DtJ2s3wtZ3Ikp7FeqyfffY2iGkqzImLVeAkiE199sJtnrYdEqaXy5t18NFqi0rtnNz2ppLLkPITECCNL8q+f+x+XwPw9S8+4vNty4GuK5If6CwFgQmLp2XA1xOUwRRGbGB5TmuJImLHay9BLkfvJ28KlI+pmcQGPFbyfQNnKDkVV9y0gO7cusvpBR288drxFANtUWQKzKWxs1rj63aQ52fNC6cre/egJhDTSWnLmDLQIIDlP4uKU6D/9Nmiehxt2P7r1wNeSXr346GgKmLl+hiTyuty2CyIz4gNIcV9KExU6Sdj/3nueky/76udyTafFbsbT+PrcJVPMp47G0L1XMp0il7fcJjASQTTUGkCpvbdS4cpvoQW9R1Pr6BO7Jw5zH0AwlGwEE+ylwXA/ho62nqpvhrw9S4+7vD3ETvy43+rEQUEP5Ks2O27JcDiLXw66hUj6gNMeVNGGxk6Nd94mj2KNz9bO5E9KL34qlbeRembFFXAXRfswtgOTeDmMEkE01BpDqHserMfX5cGLwORhaZ+5E7snDnMaQewW9RQDBbgoaV0Pg6AaQth6okp4Epab9qmrjSVlu8mv9zhCXH9m7J4h4XzzpPvm2NIzHB5TmuJImLHZytOtFn9uun3fAqebJKKb197lXeREnKO3HbAKItt3n38kIIJtqDCBW1VUQjafPfgz+BZ1aZ+44Jp1To+33Oca3CCCIU7i4FELGKnD86//0P1fV/v9O3VYdvC1Lzbpvydr4AsOffPOjVYcQ14Eg4vJVET+KOPkRvijLB5TmuJImLHZStNu5zWivE52Wy72NpuitWF63qs8Js+qn96TQPuTebjfJJ9Xarv+N+lz9MALIploDiN+DVcwF0TieW40oT6nfs9wPhWzwIJRK2+579cMIIIhTqLjbCRnnX/zK98//w3/7f+efe/7VbvhoK+dqiL9vw437qjz5u9bJ6d3yE7N869iOyeptOYz4ljOujEzIB5TmuJImLHYytMu5Tbh/tvdJTsvm3vZU9FYsrb/vSXP2t2KF/cgxenOjbfZpwloEkE21BhCb/IlYGkPfDySKNM9ab58wNMnjeLVd37bW57VrEUBwkcJEO+l8VX/216+d/8f//v/X5TDyb67/r24AaetWWMVeoUl3w76quYQQl6/YeCK9r9509yFSvk3LYctXR/jSwhH5gNIcV9KExU6Gdjl3suVRn/5r+dyrLVby5NS36fAysw4hzW5kGbW50fb6/K50EUA21RxAbNJbsbT9Pk9vKvaaat0+NuU66gOivrTNPvPpuggg2KQQsTHp/N/9l1c2wke3Pv9Xf98NH23dV6XckuXG3I36quYUQtryVZGHLz2zesRwd1/2lK+Q3FZ5/sg1FcGkAB9QmuNKmrDYSdDu5n7CNsijHrWe3E+1S9+K1fcqiMc12S0Px9LYs94b4uZmlFtltB3fInbMJ6pGANlUewCx58LqRqXt5j4ko1WscTatv09jP+rVJG2v72vXRQDBnyg4bEw691UO33YVCx9t/fv/+n/Pn/3yd7ZDyJnqYHOtBnz2IaQthxF/n8iB+SLRCi8HBuIDSnNcSRMWWzztap9L5oN84q/19LnqUOxWLK3b4+k7z8D7MemVEG9flf36eBlVrjGeTjZE+DACyKY5BBD/uxdt6rdpe30b6OLNqrbR5/HTNsrVJG2n7/i2EUDQUGC4MOn8L/72H6OhY7scUnylpF02lIPMjbD6ndSAXwghtU9MTylPXv/Fy59cBZID80YIIAPzAaU5rqQJiy2edjXrdZFBG0+tr7Zvyz3mdh83TZPcPqLtts1w9olTy/S5x9yK7avWPVT4MALIpjkEkNZYDfQxn94X/+BB2/AHRX0VfQ21/r5XjmMIIGgoLFyYdB4LG/vKc0W66wh18DtD1IRvhJA5PB0rt3yF5Mlrz65CyRvf/vh6X1X3w8uAgfiA0hxX0oTFFk27mfuplRvCwW+90Tqz/m2k9K1Yx0x4Nt9DPtYtSg5w3as2fQJIn3vMW4M3N16nal/48N/lhBMCyKY5BRDz+7HI+0nrdWN/zHhHmw+lbfWZm9Iq8T71cePQmHI/RCCA4PCk85zyLVmRx/XeCZvaSY34hRASa+SXUL460tlXAsjAfEBpjiuL0vsgqWX7fMJc5L5srddjyVX6qVjHTqb0a+sGtURg84l/O3i0ev1OaLljPgEepAnTelKbQb+uOe9nAsimmgKIf4dTjkP+ucGaaK3L7yH/++UeA7sGmQuXSts79mEMg30wovX4qmns+NPlv896jwgB5NQpHCRPOk8t37oVeUpWSgjZeDpWzd+YfkwRQMryAaU5rizKMQEkt8Eu3bT0uepQ8mTVZ27MLm7ujw5vXkdY175x9fp30nLHNje9G0Qt522nBqBV06f/5ryfi/zuar0EkAivv9lMEv9szuu4+j1T9WqktZzf18cGD/PyUzxl6tjzmMft/e81di3n1z51DH5fE0CQTqEge9J5ank9PUPIxveE+JG3sSZ+zkUAKcsHlOa4sih9m83ck4IVPdlq/f5EMrcpcDNS7FYnrXvIeQjmdfn30K+/w4RP0BfG7z8Lf+ef8c/m/O72PnF62WYVR/E+Oky4UbnQTOjP2n3z3/vnDn2Kum11v73+O8prso/Wm/U+CosVodVP/nq0vP5mM0lWY9F/+1xx9Hb8b+DfpwvzMPRn3d81f8Bx7FXNrqme0tXnavEufj3aY9G+18+36vrqSc6xcHWFWv/Neo8IAeRUKQz0nnSeWjsmp6eEED+u9rytuT4Za1cRQMryAaU5rixK9kFSy/iEkmuU+5y1HTcKuUrfijV0CCmt94lTyw7Z3JSw/u4Z/e+c93ORZkLrJYBEeP3NZpKsxqL/DnnFsbSik7oP0faPnaNWmoPN6oMV/ZcAgjQKAkdPOk+t3BCipvySyl/kd+7y92wsaVI6AaQsH1Ca48qiZB0k9fP+RCv3E+dHYfFRaHt9/p2KnbRM659TCDnqxKnlcxuGsbwShrii/5/ze1KkmdB6CSARXn+zmSTrseh/+5P42k0aPloax5BXc4bk4+T6aor+NwEEhykADDbpPLV6hJCrnSZ99eSoWDM/xyKAlOUDSnNcWZSsg6R+vqp5FjHanj8JzVX0VizT+h1CcsPbFI4+cWodxzxtp4QL++Q/a/4qSZFmQuslgER4/c1mkmyMRf+/z1XQsVQRPkxj8YdJNX4osnG+0P8ngGA/Nf6DTzpPrUgI2fuIXjXnG5PS/UV/sYZ+bkUAKcsHlOa4sijJB0n9bJ9PFzc+dR6LttvnU/gxvhjPJ/3af4+OPnFqHd7PWj5h9esdmyeT8+9QpJnQegkgEV5/s5kkF8aiP6sthLjRryZ8tDSm2q7MXniN9GcEEOymhr/YpPOU2jExfe+XFapBv9s26/5CP3+fRqypn1M5SLX7pDo4JwZ5fEBpjiuLknSQ1M/1+bTMP1/0qsIu3q6qz9WGUa7WaDuelFnjp482yIlT66khhOwMwPq7nPdzkWZC6yWARHj9zWaSRMeiP68lhPg9UPyLBvvy2FRTX5n1sTD6GunPCSCIU6NffNJ5SkVCiAPR1TDMC9Sgez7I07Zh9zeLx5r6OZW/jLDdH9WtsKsYiA8ozXFlUZIOkvq5PrfUrCf8TkHb73PFpvitWC1tx7eK1fY75fEM+rQyrW+KCa9uaPb+/unvc157Asim6gOI6e+mbq5H+5LBY2icU16ZdUDbeczR3xFAEKcmf7RJ54fKwWfrywrPVJfCUC9Qk36907CvvlE81tjPpQggZfmA0hxXFuXgQVI/k/tt51bFwdfjaIaTpfitWF3anp8qNvXvlrdf8sTtMDhWI+h9ORiiws+lKvL7rPUSQCK8/mYzSfaORX/v5nrsEOzHQxd97HgJGrOvGo11ZdbbORjQ/DOrn05HADkFau5Hn3R+qPyN6d0xqfbOhVCjvr4Va+5PxSKAlOUDSnNcWZRDJ+++j7as4pYDjaPPhHQb5VasLm3Tn9Ye+pLAITkQuDEbrVHSttxMlAoifn8m/7uFn09FANk0mwDS0s/5WJD6ZZV9+H07y+DRpfE7sPn3stRxKOt10s8RQLBJjf1kk84P1Z//zT90A4hrZzOuRv2yan0rlpv4WHM/hyKAAMugk5evGPgkPXSz7tsdHDomDYjavvcv94vJYtpmptp77FEX/a44iAwVhNvfv+ommA9B+9Ueh4YIIz72+Gr6JPMCsRBq6CeddJ5SkSdj7ZsPcqvTuM92QjoBBFgenbDdMLkRcNPkpv2eat/kbjdW/hmXl/FJf/QrOqk8tjBGNzr79q3dL/+cf57QgaPod8jvLd925FC+73fPDXj3PeVlTur3z/ur8vuufa1cu3RfKx+7CB04nhr5KiadHyoHome//J1uADk0H2T9BYUPXrwUbfBrLwIIAAAAFkdNfDWTzg9VZD7I7bAbF6hh35iQPserIAQQAAAALIoa+OomnR+qz//V33cDiGvfrVj32wZ+jldBHr70DAEEAAAAy6DGvdpJ54dq6/tBHoRdukBN+7VOAz+7qyD+LpPO+K+F3QIAAADmRU179ZPO91XkVqybYdcuUOM+26sgBBAAAADMnpr1C5PO3dDHGv2aK/It6dEJ6WrcZzsXhAACAACA2VOjvjHp/OqN/xNt8GstX6m58pcvd8OHywHkctjFC9S8r5+INafvBSGAAAAAYNbUpG9MOveE7liTX2v5Ss3Wo3hdvpqzM3yYmvcbbSPvb0ePNfs1FgEEAAAAs6UmfWPS+b/9z/872uTXWv42dN8u1t0H1R3Vzu8Caal5v6Rafzv6k9eejTb8tRUBBAAAALOkJn3Wk84/9/yr28HDtXPieYwa+DttM//Gtz8ebfhrKwIIAAAAZkeN+mwnne+Z77Hzuz92UQN/tdPMn//xh5+NNv01FQEEAAAAs6NmfZaTzvfM9zh4y9UuauLXk9F/+eqno01/TfWjr324G0D2znMBAAAAJqdmfZaTznfN9wi71Zua+NttQz+H27DasbrCLgAAAAB1UsM+y0nn/kb27rhD3Qi7dRQ18rO6Das71rALAAAAQH3UsM9u0rnHt/Xlgq5e8z32UTO/vg2r9qdhteN0heEDAAAAdVHDPrtJ5x5f5Jaro+Z77KJmfn0b1oMXL0Ub/1qqHacrDB8AAACoi5r2WU0693yP7nhDHT3fYxc189fbpr72LyVsx+kKwwcAAADqocZ9VpPOS8732Kfb2P/hB5+JNv81VHecYegAAABAHdS4z2bS+Y75HmeqQed77KKG/n7b2Nf8ON52jK4wdAAAAGB6btxVs5h0vmO+x33V4PM9dlFDf6tt7B++9Ey0+Z+6/ISudoyuMHQAAABgWm7cVbOYdL5jvsftsCujUUO/ngfibxuPBYCp67ffu9wNIPfD0AEAAIBpqYGvftK5r8ZE5nv4ik3x+R4xaugvd5r7aACYugggAAAAqI4a+Judhr7KSed/8bf/OOl8j13U1D9tG/zfv34lGgKmLAIIAAAAqqIG/lqnoa9y0vkXv/L9yed77OKmvm3wa/xCQgIIAAAAqqEG/rKq6knnf/bXr20HD9fo8z12UVO/8YWEbvgP1ePvfur8Fy9/8mB5Xsmh+sk3P9oNGIeKAAIAAIBpqImvetJ5bfM9dlFTv34S1gyKAAIAAIBpqJG/02nsq5p0Xut8jxg19de2mvxay3NVqrlyBAAAgBOiRr7aSec1z/eIUVPfDSBu8j0n5FDdUfnKyaHyY369/r0VhgIAAADUR418tZPOd8z3uBWGDgAAAGBO1MxXOel8z3yP62HoAAAAAOZEzXyVk853zPfwOKub7wEAAAAgkRr66iadewyR+R7+RvYq53sAAAAASKCGvrpJ5x5Dd0yhmO8BAAAAzJma+qomnXu+h8fQHZOK+R4AAADA3Kmpr2rSueecMN8DAAAAWCA19RuTzl3+jo1YMBijmO8BAAAALJga+41J5y4HAM+9GPsqCPM9AAAAgIVTg++5Hw4h61uw2nr2y98Z5SlYe+Z78O3dAAAAwBKp2fetWH4K1plqIwz4y/9KXQ3ZM9/jchgaAAAAgKVS4+8gcku1cUXEIWHoLyTcMd/DV2OY7wEAAACcEoUAPxnrfggFqxryW9E/9/yr3dDR1s2weQAAAACnSKHAV0PWIeHYEOJbua785cvd0OFivgcAAAAwV//0dx+6prquutWpmyr/efbcCoWDGyEkHBVCvIwntrfrCcV8DwAAAGBOHCpCwLivOk+op6o7quRvFVdIuKraCCE5E9P//G/+gfkeAAAAwJwpQDh4OEjEQkZqnaluhFXupbDgELIOEJ6YHgsb28V8DwAAAGDGFBguqW6HAHGhfvz1j5z/9FsfO3/40jPnv3j5k6t68OKl1Z/Ffj6Ug8jBeRgKDr4dax0k/OWBsdDhYr4HAAAAMHMKCVdVD0JoWNdPvvnR88ff/dT5H37wmfPzf/783nry2rOrQPKjr314Yx2hbodN7aQAcbsTKKLzQZjvAQAAAMycwoHDh+dvrAODr3b89nuXo0HjUP3xh59dXR3pri+U55LsnJuhEOHvCll/YaGvcnTDx675HmFxAAAAALVTILgQPhweYsEit3zVxFdQuutW+SrLvhByrRswvviV76/Cx475HklzTAAAAABUQEFgI3z41qm+Vz32lW/LarcRau9VCwULP8VqFTJ8FcST0tv/H8rzPa6GHwcAAABQO4UATzhfz/lw+Pj961eiAWKIioSQnU+rUrjwt6Vvh462PN+DR+wCAAAAc6IAsPG0qxJXPrbrjW9/vBtAXDsnjitkrK+CdIr5HgAAAMDcuPHvBoGh5nwcKk9O9+T2zrbvhyFdoLCxMRdExXwPAAAAYI7U+K+/ZNCTxGNhoVT5Sku77VA7v7tDocNPxGK+BwAAADBXavg3rn6McevVdm19ceHO26oUPK6rmO8BAAAAzJUa/ptt8z/21Y+2IldBCBkAAADAEqnZXz/5yt9wHgsIY9TWXBDmdwAAAABL1Gn6V18UGAsHY9TDl57pBpDbYXgAAAAAlkKN/rW26fcViFgwGKuevPZsN4DsfBoWAAAAgJlSo3+jbfo9ETwWDMYqX31px+IKQwQAAACwFGr0b7UN/1jf/bGv2rG4whABAAAALIUafQIIAAAAgHGo0SeAAAAAABiHGv11APFTqGKhYMxqx+IKQwQAAACwFGr010/BmnoS+taXEZ6FIQIAAABYCjX6V9um/0df+3A0GIxVv3z1090AwmN4AQAAgCVSs/+0bfx///qVaDgYo9749se7AeRWGB4AAACAJVGzf7dt/KeaB/LHH352dQWmHYfqahgeAAAAgCVRs7/+MkKHAIeBWEgoWVu3XzH/AwAAAFgyNf3r27DGfhyvA8+Pv/6RbgDh9isAAABgydz0twHAV0H+8IPPRMNCiXLgabetchC6FIYFAAAAYInc9KvOQggY7ZG8nvTebjMUVz8AAACAU6Dm/3o3DDx48VI0NAxVvsqyNfH8QRgKAAAAgFOgEHCnEwiKhRCHj59886Pd8OFbr3jyFQAAAHBqFAQedILBKoQM+WQs33a1deXDdSNsHgAAAMApURjwfJCNEOKrFb/93uVooMiprQnnbRE+AAAAgFOmUOAQcr8TElblqyG535buqyf+no+tR+22RfgAAAAA0FBAWD+et1u+IuKrGb4qErs9yyHFocOBJXK7lctP3GLOBwAAAIBNDgqqC1dDepYnmzvU8F0fAAAAAHZTaLimuquKBYtDRfAAAAAAkM8hQnVD5Uf2bkxW75QDh6+aOHRcC4sCAAAAAAAAAAAAAAAAAAAAAAAg1Yc+9C+CyYFQsnpjxgAAAABJRU5ErkJggg==';
            var imageHeight = width * 3 / 8;
            var oldAntialias = this.getAntialiasing();
            this.setAntialiasing(true);
            ctx.drawImage(image, 0, 0, 800, 300, x, y - imageHeight - 20, width, imageHeight);
            // loading box
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, 20);
            var progress = width * (loaded / total);
            ctx.fillStyle = 'white';
            var margin = 5;
            var width = progress - margin * 2;
            var height = 20 - margin * 2;
            ctx.fillRect(x + margin, y + margin, width > 0 ? width : 0, height);
            this.setAntialiasing(oldAntialias);
        };
        /**
         * Sets the loading screen draw function if you want to customize the draw
         * @method setLoadingDrawFunction
         * @param fcn {ctx: CanvasRenderingContext2D, loaded: number, total: number) => void}
         * Callback to draw the loading screen which is passed a rendering context, the number of bytes loaded, and the total number of bytes to load.
         */
        Engine.prototype.setLoadingDrawFunction = function (fcn) {
            this.loadingDraw = fcn;
        };
        /**
         * Another option available to you to load resources into the game.
         * Immediately after calling this the game will pause and the loading screen
         * will appear.
         * @method load
         * @param loader {ILoadable} Some loadable such as a Loader collection, Sound, or Texture.
         */
        Engine.prototype.load = function (loader) {
            var _this = this;
            var complete = new ex.Promise();
            this.isLoading = true;
            loader.onprogress = function (e) {
                _this.progress = e.loaded;
                _this.total = e.total;
                _this.logger.debug('Loading ' + (100 * _this.progress / _this.total).toFixed(0));
            };
            loader.oncomplete = function () {
                setTimeout(function () {
                    _this.isLoading = false;
                    complete.resolve();
                }, 500);
            };
            loader.load();
            return complete;
        };
        return Engine;
    })(ex.Class);
    ex.Engine = Engine;
    ;
})(ex || (ex = {}));
//# sourceMappingURL=excalibur-0.2.5.js.map
;
// Concatenated onto excalibur after build
// Exports the excalibur module so it can be used with browserify
// https://github.com/excaliburjs/Excalibur/issues/312
if (typeof module !== 'undefined') {module.exports = ex;}
},{}],"/home/a/snake/lib/food.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
var _ = require('underscore');

module.exports = function (opts) {
    'use strict';
    var
        parts = opts.parts,
        ex = opts.ex,
        game = opts.game,
        color = opts.color,
        w = game.width,
        h = game.height,
        size = opts.size,
        findX = function () {
            var x = size * _.random(2, Math.floor(w / size) - 2);
            return _.pluck(parts, 'x').indexOf(x) === -1 ? x : findX();
        },
        findY = function () {
            var y = size * _.random(2, Math.floor(h / size) - 2);
            return _.pluck(parts, 'y').indexOf(y) === -1 ? y : findY();
        },
        actor = new ex.Actor(findX(), findY(), size, size, color);
    this.eat = function () {
        actor.kill();
    };
    this.actor = actor;
    game.add(actor);
};

},{"underscore":"/home/a/snake/node_modules/underscore/underscore.js"}],"/home/a/snake/lib/mobile.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
/*global window*/
module.exports = function (snake) {
    'use strict';
    var handleOrientation = function (event) {
        var y = event.beta,
            x = event.gamma,
            maxX = 30,
            maxY = 20;
        if (y > maxY) {
            snake.down();
        } else if (y < -maxY) {
            snake.up();
        } else if (x > maxX) {
            snake.right();
        } else if (x < -maxX) {
            snake.left();
        }
    };
    window.addEventListener('deviceorientation', handleOrientation);
};

},{}],"/home/a/snake/lib/snake.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
var Food = require('./food'),
    _ = require('underscore');

module.exports = function (opts) {
    'use strict';
    var
        self = this,
        v = {},
        running = false,
        speed = 150,
        game = opts.game,
        size = Math.floor(Math.min(game.width, game.height) / 22),
        ex = opts.ex,
        color = opts.color,
        part = function (x, y, color) {
            var actor = new ex.Actor(x, y, size, size, color);
            game.add(actor);
            return actor;
        },
        startPlaceRandX = _.random(2, Math.floor(game.width / size) - 2),
        startPlaceRandY = _.random(2, Math.floor(game.height / size) - 2),
        parts = [
            part((startPlaceRandX + 1) * size, startPlaceRandY * size, color.body),
            part(startPlaceRandX * size, startPlaceRandY * size, color.body)
        ],
        food = new Food({
            ex: ex,
            game: game,
            color: color.food,
            parts: parts,
            size: size
        }),
        cutTail = function () {
            var last = parts.pop(),
                prelast = parts[parts.length - 1];
            last.moveTo(
                prelast.x,
                prelast.y,
                2 * speed
            );
            return last;
        },
        addNeck = function (time) {
            var firstPart = parts[0],
                x = firstPart.x,
                y =  firstPart.y,
                newPart = part(x, y, color.body);
            parts.unshift(newPart);
            newPart.moveTo(
                x + v.x * size,
                y + v.y * size,
                speed
            );
            newPart.on('exitviewport', function () {
                self.onLose();
            });
            return newPart;
        },
        hiTail = function (actor) {
            var i;
            for (i = 2; i < parts.length - 2; i += 1) {
                if (parts[i] && actor.within(parts[i], size / 2)) {
                    return true;
                }
            }
        },
        step = function () {
            addNeck().callMethod(function () {
                if (this.within(food.actor, size / 2)) {
                    speed += 50;
                    food.eat();
                    food = new Food({
                        ex: ex,
                        game: game,
                        color: color.food,
                        parts: parts,
                        size: size
                    });
                    step();
                } else if (hiTail(this)) {
                    self.onLose();
                } else {
                    cutTail().callMethod(function () {
                        this.kill();
                        document.title = 'Score: ' + (parts.length - 2);
                        step();
                    });
                }
            });
        };
    this.right = function () {
        v.x = 1;
        v.y = 0;
    };
    this.left = function () {
        v.x = -1;
        v.y = 0;
    };
    this.up = function () {
        v.x = 0;
        v.y = -1;
    };
    this.down = function () {
        v.x = 0;
        v.y = 1;
    };
    this.run = function (obj) {
        v.x = obj.x || 0;
        v.y = obj.y || 0;
        step();
    };
};

},{"./food":"/home/a/snake/lib/food.js","underscore":"/home/a/snake/node_modules/underscore/underscore.js"}],"/home/a/snake/node_modules/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/home/a/snake/node_modules/underscore/underscore.js":[function(require,module,exports){
//     Underscore.js 1.7.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.7.0';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var createCallback = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  _.iteratee = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return createCallback(value, context, argCount);
    if (_.isObject(value)) return _.matches(value);
    return _.property(value);
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    if (obj == null) return obj;
    iteratee = createCallback(iteratee, context);
    var i, length = obj.length;
    if (length === +length) {
      for (i = 0; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    if (obj == null) return [];
    iteratee = _.iteratee(iteratee, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length),
        currentKey;
    for (var index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index = 0, currentKey;
    if (arguments.length < 3) {
      if (!length) throw new TypeError(reduceError);
      memo = obj[keys ? keys[index++] : index++];
    }
    for (; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== + obj.length && _.keys(obj),
        index = (keys || obj).length,
        currentKey;
    if (arguments.length < 3) {
      if (!index) throw new TypeError(reduceError);
      memo = obj[keys ? keys[--index] : --index];
    }
    while (index--) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    predicate = _.iteratee(predicate, context);
    _.some(obj, function(value, index, list) {
      if (predicate(value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    predicate = _.iteratee(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(_.iteratee(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    if (obj == null) return true;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    if (obj == null) return false;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (obj.length !== +obj.length) obj = _.values(obj);
    return _.indexOf(obj, target) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = obj && obj.length === +obj.length ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = _.iteratee(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = _.iteratee(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = _.iteratee(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    for (var i = 0, length = input.length; i < length; i++) {
      var value = input[i];
      if (!_.isArray(value) && !_.isArguments(value)) {
        if (!strict) output.push(value);
      } else if (shallow) {
        push.apply(output, value);
      } else {
        flatten(value, shallow, strict, output);
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = _.iteratee(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i];
      if (isSorted) {
        if (!i || seen !== value) result.push(value);
        seen = value;
      } else if (iteratee) {
        var computed = iteratee(value, i, array);
        if (_.indexOf(seen, computed) < 0) {
          seen.push(computed);
          result.push(value);
        }
      } else if (_.indexOf(result, value) < 0) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true, []));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(slice.call(arguments, 1), true, true, []);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function(array) {
    if (array == null) return [];
    var length = _.max(arguments, 'length').length;
    var results = Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var idx = array.length;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var Ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    args = slice.call(arguments, 2);
    bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      Ctor.prototype = func.prototype;
      var self = new Ctor;
      Ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (_.isObject(result)) return result;
      return self;
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = hasher ? hasher.apply(this, arguments) : key;
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last > 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed before being called N times.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      } else {
        func = null;
      }
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    if (!_.isObject(obj)) return obj;
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (hasOwnProperty.call(source, prop)) {
            obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj, iteratee, context) {
    var result = {}, key;
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      iteratee = createCallback(iteratee, context);
      for (key in obj) {
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
    } else {
      var keys = concat.apply([], slice.call(arguments, 1));
      obj = new Object(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (key in obj) result[key] = obj[key];
      }
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    if (!_.isObject(obj)) return obj;
    for (var i = 1, length = arguments.length; i < length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (
      aCtor !== bCtor &&
      // Handle Object.create(x) cases
      'constructor' in a && 'constructor' in b &&
      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
        _.isFunction(bCtor) && bCtor instanceof bCtor)
    ) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size, result;
    // Recursively compare objects and arrays.
    if (className === '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size === b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      size = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      result = _.keys(b).length === size;
      if (result) {
        while (size--) {
          // Deep compare each member
          key = keys[size];
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
  if (typeof /./ !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    var pairs = _.pairs(attrs), length = pairs.length;
    return function(obj) {
      if (obj == null) return !length;
      obj = new Object(obj);
      for (var i = 0; i < length; i++) {
        var pair = pairs[i], key = pair[0];
        if (pair[1] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = createCallback(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? object[property]() : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}]},{},["/home/a/snake/index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiaW5kZXguanMiLCJsaWIvZXhjYWxpYnVyLmpzIiwibGliL2Zvb2QuanMiLCJsaWIvbW9iaWxlLmpzIiwibGliL3NuYWtlLmpzIiwibm9kZV9tb2R1bGVzL2RvbXJlYWR5L3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzl1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKmpzbGludCBub2RlOnRydWUqL1xuLypnbG9iYWwgd2luZG93Ki9cbnZhciBkb21yZWFkeSA9IHJlcXVpcmUoJ2RvbXJlYWR5JyksXG4gICAgZXggPSByZXF1aXJlKCcuL2xpYi9leGNhbGlidXInKSxcbiAgICBTbmFrZSA9IHJlcXVpcmUoJy4vbGliL3NuYWtlJyksXG4gICAgbW9iaWxlID0gcmVxdWlyZSgnLi9saWIvbW9iaWxlJyk7XG5cbmRvbXJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGdhbWUgPSBuZXcgZXguRW5naW5lKCksXG4gICAgICAgIHNuYWtlID0gbmV3IFNuYWtlKHtcbiAgICAgICAgICAgIGV4OiBleCxcbiAgICAgICAgICAgIGdhbWU6IGdhbWUsXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGhlYWQ6IGV4LkNvbG9yLlJlZCxcbiAgICAgICAgICAgICAgICBib2R5OiBleC5Db2xvci5ZZWxsb3csXG4gICAgICAgICAgICAgICAgZm9vZDogZXguQ29sb3IuR3JlZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHJlcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdhbWUucm9vdFNjZW5lLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYWN0b3Iua2lsbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzbmFrZSA9IG5ldyBTbmFrZSh7XG4gICAgICAgICAgICAgICAgICAgIGV4OiBleCxcbiAgICAgICAgICAgICAgICAgICAgZ2FtZTogZ2FtZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQ6IGV4LkNvbG9yLlJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGV4LkNvbG9yLlllbGxvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvb2Q6IGV4LkNvbG9yLkdyZWVuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzbmFrZS5vbkxvc2UgPSByZXBsYXk7XG4gICAgICAgICAgICAgICAgc25ha2UucnVuKHt4OiAxfSk7XG4gICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9LFxuICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBnYW1lLmlucHV0LmtleWJvYXJkLm9uKCdkb3duJywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgayA9IGsua2V5O1xuICAgICAgICBpZiAoayA9PT0gMzcpIHtcbiAgICAgICAgICAgIHNuYWtlLmxlZnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSAzOCkge1xuICAgICAgICAgICAgc25ha2UudXAoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSAzOSkge1xuICAgICAgICAgICAgc25ha2UucmlnaHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrID09PSA0MCkge1xuICAgICAgICAgICAgc25ha2UuZG93bigpO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IDMyKSB7XG4gICAgICAgICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgZ2FtZS5zdGFydCgpO1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnYW1lLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcGxheSgpO1xuICAgIH0pO1xuICAgIG1vYmlsZShzbmFrZSk7XG4gICAgZ2FtZS5zdGFydCgpO1xuICAgIHNuYWtlLm9uTG9zZSA9IHJlcGxheTtcbiAgICBzbmFrZS5ydW4oe3g6IDF9KTtcbn0pO1xuIiwiLyohIGV4Y2FsaWJ1ciAtIHYwLjIuNSAtIDIwMTUtMDItMDRcbiogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1clxuKiBDb3B5cmlnaHQgKGMpIDIwMTUgOyBMaWNlbnNlZCBCU0QqL1xuaWYgKHR5cGVvZiB3aW5kb3cgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cgPSB7IGF1ZGlvQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIH0gfTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgd2luZG93LnNldEludGVydmFsKGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgIH07XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiAhd2luZG93LkF1ZGlvQ29udGV4dCkge1xuICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHwgd2luZG93Lm1vekF1ZGlvQ29udGV4dCB8fCB3aW5kb3cubXNBdWRpb0NvbnRleHQgfHwgd2luZG93Lm9BdWRpb0NvbnRleHQ7XG59XG4vLyBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2hcbi8vIFByb2R1Y3Rpb24gc3RlcHMgb2YgRUNNQS0yNjIsIEVkaXRpb24gNSwgMTUuNC40LjE4XG4vLyBSZWZlcmVuY2U6IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNC40LjE4XG5pZiAoIUFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIFQsIGs7XG4gICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyB0aGlzIGlzIG51bGwgb3Igbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAxLiBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QgcGFzc2luZyB0aGUgfHRoaXN8IHZhbHVlIGFzIHRoZSBhcmd1bWVudC5cbiAgICAgICAgdmFyIE8gPSBPYmplY3QodGhpcyk7XG4gICAgICAgIC8vIDIuIExldCBsZW5WYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIHRoZSBhcmd1bWVudCBcImxlbmd0aFwiLlxuICAgICAgICAvLyAzLiBMZXQgbGVuIGJlIFRvVWludDMyKGxlblZhbHVlKS5cbiAgICAgICAgdmFyIGxlbiA9IE8ubGVuZ3RoID4+PiAwO1xuICAgICAgICAvLyA0LiBJZiBJc0NhbGxhYmxlKGNhbGxiYWNrKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAvLyBTZWU6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuMTFcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNhbGxiYWNrICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDUuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBUID0gdGhpc0FyZztcbiAgICAgICAgfVxuICAgICAgICAvLyA2LiBMZXQgayBiZSAwXG4gICAgICAgIGsgPSAwO1xuICAgICAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgICAgICAgdmFyIGtWYWx1ZTtcbiAgICAgICAgICAgIC8vIGEuIExldCBQayBiZSBUb1N0cmluZyhrKS5cbiAgICAgICAgICAgIC8vICAgVGhpcyBpcyBpbXBsaWNpdCBmb3IgTEhTIG9wZXJhbmRzIG9mIHRoZSBpbiBvcGVyYXRvclxuICAgICAgICAgICAgLy8gYi4gTGV0IGtQcmVzZW50IGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgSGFzUHJvcGVydHkgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgICAgICAgIC8vICAgVGhpcyBzdGVwIGNhbiBiZSBjb21iaW5lZCB3aXRoIGNcbiAgICAgICAgICAgIC8vIGMuIElmIGtQcmVzZW50IGlzIHRydWUsIHRoZW5cbiAgICAgICAgICAgIGlmIChrIGluIE8pIHtcbiAgICAgICAgICAgICAgICAvLyBpLiBMZXQga1ZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAgICAgICAgICAga1ZhbHVlID0gT1trXTtcbiAgICAgICAgICAgICAgICAvLyBpaS4gQ2FsbCB0aGUgQ2FsbCBpbnRlcm5hbCBtZXRob2Qgb2YgY2FsbGJhY2sgd2l0aCBUIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50IGxpc3QgY29udGFpbmluZyBrVmFsdWUsIGssIGFuZCBPLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoVCwga1ZhbHVlLCBrLCBPKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGQuIEluY3JlYXNlIGsgYnkgMS5cbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICAvLyA4LiByZXR1cm4gdW5kZWZpbmVkXG4gICAgfTtcbn1cbi8vIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVxuaWYgKCFBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIEFycmF5LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGZ1biAvKiwgdGhpc0FyZyAqLykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuLy8gUG9seWZpbGwgZnJvbSAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCNQb2x5ZmlsbFxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmVG9CaW5kID0gdGhpcywgZk5PUCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgfSwgZkJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXMgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuICAgICAgICByZXR1cm4gZkJvdW5kO1xuICAgIH07XG59XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIEVmZmVjdHM7XG4gICAgKGZ1bmN0aW9uIChFZmZlY3RzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBcIkdyYXlzY2FsZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgcmVtb3ZpbmcgY29sb3IgaW5mb3JtYXRpb24uXG4gICAgICAgICAqIEBjbGFzcyBFZmZlY3RzLkdyYXlzY2FsZVxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQGV4dGVuZHMgSVNwcml0ZUVmZmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEdyYXlzY2FsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBHcmF5c2NhbGUoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBHcmF5c2NhbGUucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGF2ZyA9IChwaXhlbFtmaXJzdFBpeGVsICsgMF0gKyBwaXhlbFtmaXJzdFBpeGVsICsgMV0gKyBwaXhlbFtmaXJzdFBpeGVsICsgMl0pIC8gMztcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBhdmc7XG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gYXZnO1xuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IGF2ZztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gR3JheXNjYWxlO1xuICAgICAgICB9KSgpO1xuICAgICAgICBFZmZlY3RzLkdyYXlzY2FsZSA9IEdyYXlzY2FsZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFwiSW52ZXJ0XCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBpbnZlcnRpbmcgdGhlIHBpeGVsIGNvbG9ycy5cbiAgICAgICAgICogQGNsYXNzIEVmZmVjdHMuSW52ZXJ0XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBJU3ByaXRlRWZmZWN0XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgSW52ZXJ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEludmVydCgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEludmVydC5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMF07XG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDFdO1xuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gSW52ZXJ0O1xuICAgICAgICB9KSgpO1xuICAgICAgICBFZmZlY3RzLkludmVydCA9IEludmVydDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFwiT3BhY2l0eVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgc2V0dGluZyB0aGUgYWxwaGEgb2YgYWxsIHBpeGVscyB0byBhIGdpdmVuIHZhbHVlLlxuICAgICAgICAgKiBAY2xhc3MgRWZmZWN0cy5PcGFjaXR5XG4gICAgICAgICAqIEBleHRlbmRzIElTcHJpdGVFZmZlY3RcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBvcGFjaXR5IHtudW1iZXJ9IFRoZSBuZXcgb3BhY2l0eSBvZiB0aGUgc3ByaXRlIGZyb20gMC0xLjBcbiAgICAgICAgICovXG4gICAgICAgIHZhciBPcGFjaXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIE9wYWNpdHkob3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPcGFjaXR5LnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChwaXhlbFtmaXJzdFBpeGVsICsgM10gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gTWF0aC5yb3VuZCh0aGlzLm9wYWNpdHkgKiAyNTUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gT3BhY2l0eTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgRWZmZWN0cy5PcGFjaXR5ID0gT3BhY2l0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFwiQ29sb3JpemVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgdGhlIHBpeGVscyB0byBhblxuICAgICAgICAgKiBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBjb2xvciBhbmQgdGhlIHByb3ZpZGVkIGNvbG9yXG4gICAgICAgICAqIEBjbGFzcyBFZmZlY3RzLkNvbG9yaXplXG4gICAgICAgICAqIEBleHRlbmRzIElTcHJpdGVFZmZlY3RcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciB7Q29sb3J9IFRoZSBjb2xvciB0byBhcHBseSB0byB0aGUgc3ByaXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgQ29sb3JpemUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQ29sb3JpemUoY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDb2xvcml6ZS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMF0gKyB0aGlzLmNvbG9yLnIpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSArIHRoaXMuY29sb3IuZykgLyAyO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDJdICsgdGhpcy5jb2xvci5iKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBDb2xvcml6ZTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgRWZmZWN0cy5Db2xvcml6ZSA9IENvbG9yaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgXCJGaWxsXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIG5vbi10cmFuc3BhcmVudCBwaXhlbHMgdG8gbWF0Y2hcbiAgICAgICAgICogYSBnaXZlbiBjb2xvclxuICAgICAgICAgKiBAY2xhc3MgRWZmZWN0cy5GaWxsXG4gICAgICAgICAqIEBleHRlbmRzIElTcHJpdGVFZmZlY3RcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBjb2xvciB7Q29sb3J9IFRoZSBjb2xvciB0byBhcHBseSB0byB0aGUgc3ByaXRlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgRmlsbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBGaWxsKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRmlsbC5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IHRoaXMuY29sb3IucjtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gdGhpcy5jb2xvci5nO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSB0aGlzLmNvbG9yLmI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBGaWxsO1xuICAgICAgICB9KSgpO1xuICAgICAgICBFZmZlY3RzLkZpbGwgPSBGaWxsO1xuICAgIH0pKEVmZmVjdHMgPSBleC5FZmZlY3RzIHx8IChleC5FZmZlY3RzID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vU3ByaXRlRWZmZWN0cy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vSW50ZXJmYWNlcy9JUGlwZWxpbmVNb2R1bGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBNb3ZlbWVudE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1vdmVtZW50TW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIE1vdmVtZW50TW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwbGFjZW1lbnRzIGJhc2VkIG9uIGxpbmVhciBhbGdlYnJhXG4gICAgICAgICAgICBhY3Rvci54ICs9IGFjdG9yLmR4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgYWN0b3IueSArPSBhY3Rvci5keSAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIGFjdG9yLmR4ICs9IGFjdG9yLmF4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgYWN0b3IuZHkgKz0gYWN0b3IuYXkgKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICBhY3Rvci5yb3RhdGlvbiArPSBhY3Rvci5yeCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIGFjdG9yLnNjYWxlLnggKz0gYWN0b3Iuc3ggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICBhY3Rvci5zY2FsZS55ICs9IGFjdG9yLnN5ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTW92ZW1lbnRNb2R1bGU7XG4gICAgfSkoKTtcbiAgICBleC5Nb3ZlbWVudE1vZHVsZSA9IE1vdmVtZW50TW9kdWxlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9JbnRlcmZhY2VzL0lQaXBlbGluZU1vZHVsZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIE9mZnNjcmVlbkN1bGxpbmdNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPZmZzY3JlZW5DdWxsaW5nTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIE9mZnNjcmVlbkN1bGxpbmdNb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50RGlzcGF0Y2hlciA9IGFjdG9yLmV2ZW50RGlzcGF0Y2hlcjtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhY3Rvci5hbmNob3I7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsU2NhbGUgPSBhY3Rvci5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZ2xvYmFsU2NhbGUueCAqIGFjdG9yLmdldFdpZHRoKCkgLyBhY3Rvci5zY2FsZS54O1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGdsb2JhbFNjYWxlLnkgKiBhY3Rvci5nZXRIZWlnaHQoKSAvIGFjdG9yLnNjYWxlLnk7XG4gICAgICAgICAgICB2YXIgYWN0b3JTY3JlZW5Db29yZHMgPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKG5ldyBleC5Qb2ludChhY3Rvci5nZXRHbG9iYWxYKCkgLSBhbmNob3IueCAqIHdpZHRoLCBhY3Rvci5nZXRHbG9iYWxZKCkgLSBhbmNob3IueSAqIGhlaWdodCkpO1xuICAgICAgICAgICAgdmFyIHpvb20gPSAxLjA7XG4gICAgICAgICAgICBpZiAoYWN0b3Iuc2NlbmUgJiYgYWN0b3Iuc2NlbmUuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgem9vbSA9IGFjdG9yLnNjZW5lLmNhbWVyYS5nZXRab29tKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFjdG9yLmlzT2ZmU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yU2NyZWVuQ29vcmRzLnggKyB3aWR0aCAqIHpvb20gPCAwIHx8IGFjdG9yU2NyZWVuQ29vcmRzLnkgKyBoZWlnaHQgKiB6b29tIDwgMCB8fCBhY3RvclNjcmVlbkNvb3Jkcy54ID4gZW5naW5lLndpZHRoIHx8IGFjdG9yU2NyZWVuQ29vcmRzLnkgPiBlbmdpbmUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdleGl0dmlld3BvcnQnLCBuZXcgZXguRXhpdFZpZXdQb3J0RXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmlzT2ZmU2NyZWVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3JTY3JlZW5Db29yZHMueCArIHdpZHRoICogem9vbSA+IDAgJiYgYWN0b3JTY3JlZW5Db29yZHMueSArIGhlaWdodCAqIHpvb20gPiAwICYmIGFjdG9yU2NyZWVuQ29vcmRzLnggPCBlbmdpbmUud2lkdGggJiYgYWN0b3JTY3JlZW5Db29yZHMueSA8IGVuZ2luZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2VudGVydmlld3BvcnQnLCBuZXcgZXguRW50ZXJWaWV3UG9ydEV2ZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rvci5pc09mZlNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE9mZnNjcmVlbkN1bGxpbmdNb2R1bGU7XG4gICAgfSkoKTtcbiAgICBleC5PZmZzY3JlZW5DdWxsaW5nTW9kdWxlID0gT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vSW50ZXJmYWNlcy9JUGlwZWxpbmVNb2R1bGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIFByb3BvZ2F0ZXMgcG9pbnRlciBldmVudHMgdG8gdGhlIGFjdG9yXG4gICAgICovXG4gICAgdmFyIENhcHR1cmVQb2ludGVyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2FwdHVyZVBvaW50ZXJNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ2FwdHVyZVBvaW50ZXJNb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgaWYgKCFhY3Rvci5lbmFibGVDYXB0dXJlUG9pbnRlcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoYWN0b3IuaXNLaWxsZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBlbmdpbmUuaW5wdXQucG9pbnRlcnMucHJvcG9nYXRlKGFjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENhcHR1cmVQb2ludGVyTW9kdWxlO1xuICAgIH0pKCk7XG4gICAgZXguQ2FwdHVyZVBvaW50ZXJNb2R1bGUgPSBDYXB0dXJlUG9pbnRlck1vZHVsZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vSW50ZXJmYWNlcy9JUGlwZWxpbmVNb2R1bGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBDb2xsaXNpb25EZXRlY3Rpb25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb2xsaXNpb25EZXRlY3Rpb25Nb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYWN0b3IsIGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBldmVudERpc3BhdGNoZXIgPSBhY3Rvci5ldmVudERpc3BhdGNoZXI7XG4gICAgICAgICAgICBpZiAoYWN0b3IuY29sbGlzaW9uVHlwZSAhPT0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbmdpbmUuY3VycmVudFNjZW5lLnRpbGVNYXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBlbmdpbmUuY3VycmVudFNjZW5lLnRpbGVNYXBzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0TWFwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNCb3VuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbnRlcnNlY3RNYXAgPSBtYXAuY29sbGlkZXMoYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4LS0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gYWN0b3IuZ2V0U2lkZUZyb21JbnRlcnNlY3QoaW50ZXJzZWN0TWFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdjb2xsaXNpb24nLCBuZXcgZXguQ29sbGlzaW9uRXZlbnQoYWN0b3IsIG51bGwsIHNpZGUsIGludGVyc2VjdE1hcCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChhY3Rvci5jb2xsaXNpb25UeXBlID09PSAyIC8qIEFjdGl2ZSAqLyB8fCBhY3Rvci5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IueSArPSBpbnRlcnNlY3RNYXAueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci54ICs9IGludGVyc2VjdE1hcC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5haXZlIGVsYXN0aWMgYm91bmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbGxpc2lvblR5cGUgPT09IDMgLyogRWxhc3RpYyAqLyAmJiAhaGFzQm91bmNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNCb3VuY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPT09IDMgLyogTGVmdCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZHggPSBNYXRoLmFicyhhY3Rvci5keCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA9PT0gNCAvKiBSaWdodCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZHggPSAtTWF0aC5hYnMoYWN0b3IuZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPT09IDEgLyogVG9wICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5keSA9IE1hdGguYWJzKGFjdG9yLmR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWRlID09PSAyIC8qIEJvdHRvbSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZHkgPSAtTWF0aC5hYnMoYWN0b3IuZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlO1xuICAgIH0pKCk7XG4gICAgZXguQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlID0gQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSBzaWRlcyBvZiBhbiBBY3RvciBmb3IgY29sbGlzaW9uXG4gICAgICogQGNsYXNzIFNpZGVcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKFNpZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBOb25lIHtTaWRlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBTaWRlW1NpZGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBUb3Age1NpZGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIFNpZGVbU2lkZVtcIlRvcFwiXSA9IDFdID0gXCJUb3BcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBCb3R0b20ge1NpZGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIFNpZGVbU2lkZVtcIkJvdHRvbVwiXSA9IDJdID0gXCJCb3R0b21cIjtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBMZWZ0IHtTaWRlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBTaWRlW1NpZGVbXCJMZWZ0XCJdID0gM10gPSBcIkxlZnRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBSaWdodCB7U2lkZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgU2lkZVtTaWRlW1wiUmlnaHRcIl0gPSA0XSA9IFwiUmlnaHRcIjtcbiAgICB9KShleC5TaWRlIHx8IChleC5TaWRlID0ge30pKTtcbiAgICB2YXIgU2lkZSA9IGV4LlNpZGU7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIF9fZXh0ZW5kcyA9IHRoaXMuX19leHRlbmRzIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gICAgZC5wcm90b3R5cGUgPSBuZXcgX18oKTtcbn07XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgMkQgcG9pbnQgb24gYSBwbGFuZVxuICAgICAqIEBjbGFzcyBQb2ludFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgUG9pbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogWCBDb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAgICAgKiBAcHJvcGVydHkgeCB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFkgQ29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgICAgICogQHByb3BlcnR5IHkge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHRoaXMgcG9pbnQgdG8gYSB2ZWN0b3JcbiAgICAgICAgICogQG1ldGhvZCB0b1ZlY3RvclxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFBvaW50LnByb3RvdHlwZS50b1ZlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJvdGF0ZXMgdGhlIGN1cnJlbnQgcG9pbnQgYXJvdW5kIGFub3RoZXIgYnkgYSBjZXJ0YWluIG51bWJlciBvZlxuICAgICAgICAgKiBkZWdyZWVzIGluIHJhZGlhbnNcbiAgICAgICAgICogQG1ldGhvZCByb3RhdGVcbiAgICAgICAgICogQHJldHVybnMgUG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIFBvaW50LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUsIGFuY2hvcikge1xuICAgICAgICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXcgZXguUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICB2YXIgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICB2YXIgeCA9IGNvc0FuZ2xlICogKHRoaXMueCAtIGFuY2hvci54KSAtIHNpbkFuZ2xlICogKHRoaXMueSAtIGFuY2hvci55KSArIGFuY2hvci54O1xuICAgICAgICAgICAgdmFyIHkgPSBzaW5BbmdsZSAqICh0aGlzLnggLSBhbmNob3IueCkgKyBjb3NBbmdsZSAqICh0aGlzLnkgLSBhbmNob3IueSkgKyBhbmNob3IueTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2xhdGVzIHRoZSBjdXJyZW50IHBvaW50IGJ5IGEgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgYWRkXG4gICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB2ZWN0b3IueCwgdGhpcy55ICsgdmVjdG9yLnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgeCBhbmQgeSBjb21wb25lbnRzIGF0IG9uY2VcbiAgICAgICAgICogQG1ldGhvZCBzZXRUb1xuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfVxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgUG9pbnQucHJvdG90eXBlLnNldFRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvbmVzIGEgbmV3IHBvaW50IHRoYXQgaXMgYSBjb3B5IG9mIHRoaXMgb25lLlxuICAgICAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBQb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBvaW50O1xuICAgIH0pKCk7XG4gICAgZXguUG9pbnQgPSBQb2ludDtcbiAgICAvKipcbiAgICAgKiBBIDJEIHZlY3RvciBvbiBhIHBsYW5lLlxuICAgICAqIEBjbGFzcyBWZWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBQb2ludFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFggY29tcG9uZW50IG9mIHRoZSBWZWN0b3JcbiAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBZIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXG4gICAgICovXG4gICAgdmFyIFZlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhWZWN0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFZlY3Rvcih4LCB5KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgdmVjdG9yIG9mIHVuaXQgbGVuZ3RoIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNwZWNpZmllZCBhbmdsZS5cbiAgICAgICAgICogQG1ldGhvZCBmcm9tQW5nbGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gYW5nbGUge251bWJlcn0gVGhlIGFuZ2xlIHRvIGdlbmVyYXRlIHRoZSB2ZWN0b3JcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IuZnJvbUFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLmNvcyhhbmdsZSksIE1hdGguc2luKGFuZ2xlKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlzdGFuY2UgdG8gYW5vdGhlciB2ZWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBkaXN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgb3RoZXIgdmVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICB2ID0gbmV3IFZlY3RvcigwLjAsIDAuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIHYueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSB2LnksIDIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vcm1hbGl6ZXMgYSB2ZWN0b3IgdG8gaGF2ZSBhIG1hZ25pdHVkZSBvZiAxLlxuICAgICAgICAgKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICAgICAgICAgKiBAcmV0dXJuIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGlzdGFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAvIGQsIHRoaXMueSAvIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsZXMgYSB2ZWN0b3IncyBieSBhIGZhY3RvciBvZiBzaXplXG4gICAgICAgICAqIEBtZXRob2Qgc2NhbGVcbiAgICAgICAgICogQHBhcmFtIHNpemUge251bWJlcn0gVGhlIGZhY3RvciB0byBzY2FsZSB0aGUgbWFnbml0dWRlIGJ5XG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggKiBzaXplLCB0aGlzLnkgKiBzaXplKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgb25lIHZlY3RvciB0byBhbm90aGVyXG4gICAgICAgICAqIEBtZXRob2QgYWRkXG4gICAgICAgICAqIEBwYXJhbSB2IHtWZWN0b3J9IFRoZSB2ZWN0b3IgdG8gYWRkXG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICsgdi54LCB0aGlzLnkgKyB2LnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gdGhlIGN1cnJlbnQgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgbWludXNcbiAgICAgICAgICogQHBhcmFtIHYge1ZlY3Rvcn0gVGhlIHZlY3RvciB0byBzdWJ0cmFjdFxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubWludXMgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54IC0gdi54LCB0aGlzLnkgLSB2LnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSBkb3QgcHJvZHVjdCB3aXRoIGFub3RoZXIgdmVjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZG90XG4gICAgICAgICAqIEBwYXJhbSB2IHtWZWN0b3J9IFRoZSB2ZWN0b3IgdG8gZG90XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgMkQgY3Jvc3MgcHJvZHVjdCB3aXRoIGFub3RoZXIgdmVjdG9yLiAyRCBjcm9zcyBwcm9kdWN0cyByZXR1cm4gYSBzY2FsYXIgdmFsdWUgbm90IGEgdmVjdG9yLlxuICAgICAgICAgKiBAbWV0aG9kIGNyb3NzXG4gICAgICAgICAqIEBwYXJhbSB2IHtWZWN0b3J9IFRoZSB2ZWN0b3IgdG8gY3Jvc3NcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwZXJwZW5kaWN1bGFyIHZlY3RvciB0byB0aGlzIG9uZVxuICAgICAgICAgKiBAbWV0aG9kIHBlcnBlbmRpY3VsYXJcbiAgICAgICAgICogQHJldHVybiBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUucGVycGVuZGljdWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueSwgLXRoaXMueCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBub3JtYWwgdmVjdG9yIHRvIHRoaXMgb25lXG4gICAgICAgICAqIEBtZXRob2Qgbm9ybWFsXG4gICAgICAgICAqIEByZXR1cm4gVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm5vcm1hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcnBlbmRpY3VsYXIoKS5ub3JtYWxpemUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIG9mIHRoaXMgdmVjdG9yLlxuICAgICAgICAgKiBAbWV0aG9kIHRvQW5nbGVcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnRvQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCByZXByZXNlbnRpb24gb2YgdGhpcyB2ZWN0b3JcbiAgICAgICAgICogQG1ldGhvZCB0b1BvaW50XG4gICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnRvUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJvdGF0ZXMgdGhlIGN1cnJlbnQgdmVjdG9yIGFyb3VuZCBhIHBvaW50IGJ5IGEgY2VydGFpbiBudW1iZXIgb2ZcbiAgICAgICAgICogZGVncmVlcyBpbiByYWRpYW5zXG4gICAgICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUsIGFuY2hvcikge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucm90YXRlLmNhbGwodGhpcywgYW5nbGUsIGFuY2hvcikudG9WZWN0b3IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZlY3RvcjtcbiAgICB9KShQb2ludCk7XG4gICAgZXguVmVjdG9yID0gVmVjdG9yO1xuICAgIC8qKlxuICAgICAqIEEgMkQgcmF5IHRoYXQgY2FuIGJlIGNhc3QgaW50byB0aGUgc2NlbmUgdG8gZG8gY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAqIEBjbGFzcyBSYXlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcG9zIHtQb2ludH0gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgcmF5XG4gICAgICogQHBhcmFtIGRpciB7VmVjdG9yfSBUaGUgdmVjdG9yIGluZGljYXRpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcmF5XG4gICAgICovXG4gICAgdmFyIFJheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJheShwb3MsIGRpcikge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICB0aGlzLmRpciA9IGRpci5ub3JtYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgYSB3aGV0aGVyIHRoaXMgcmF5IGludGVyc2VjdHMgd2l0aCBhIGxpbmUgc2VnbWVudC4gUmV0dXJucyBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBvbiBzdWNjZXNzLlxuICAgICAgICAgKiBUaGlzIG51bWJlciBpbmRpY2F0ZXMgdGhlIG1hdGhlbWF0aWNhbCBpbnRlcnNlY3Rpb24gdGltZS5cbiAgICAgICAgICogQG1ldGhvZCBpbnRlcnNlY3RcbiAgICAgICAgICogQHBhcmFtIGxpbmUge0xpbmV9IFRoZSBsaW5lIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gbGluZS5iZWdpbi50b1ZlY3RvcigpLm1pbnVzKHRoaXMucG9zLnRvVmVjdG9yKCkpO1xuICAgICAgICAgICAgLy8gVGVzdCBpcyBsaW5lIGFuZCByYXkgYXJlIHBhcmFsbGVsIGFuZCBub24gaW50ZXJzZWN0aW5nXG4gICAgICAgICAgICBpZiAodGhpcy5kaXIuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSA9PT0gMCAmJiBudW1lcmF0b3IuY3Jvc3ModGhpcy5kaXIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHBhcmFsbGVsXG4gICAgICAgICAgICB2YXIgZGl2aXNvciA9ICh0aGlzLmRpci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpKTtcbiAgICAgICAgICAgIGlmIChkaXZpc29yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSBudW1lcmF0b3IuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSAvIGRpdmlzb3I7XG4gICAgICAgICAgICBpZiAodCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSAobnVtZXJhdG9yLmNyb3NzKHRoaXMuZGlyKSAvIGRpdmlzb3IpIC8gbGluZS5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICBpZiAodSA+PSAwICYmIHUgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gZ2l2ZW4gdGhlIGludGVyc2VjdGlvbiB0aW1lXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UG9pbnRcbiAgICAgICAgICogQHJldHVybnMgUG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIFJheS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zLnRvVmVjdG9yKCkuYWRkKHRoaXMuZGlyLnNjYWxlKHRpbWUpKS50b1BvaW50KCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSYXk7XG4gICAgfSkoKTtcbiAgICBleC5SYXkgPSBSYXk7XG4gICAgLyoqXG4gICAgICogQSAyRCBsaW5lIHNlZ21lbnRcbiAgICAgKiBAY2xhc3MgTGluZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBiZWdpbiB7UG9pbnR9IFRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50XG4gICAgICogQHBhcmFtIGVuZCB7UG9pbnR9IFRoZSBlbmRpbmcgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICAqL1xuICAgIHZhciBMaW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTGluZShiZWdpbiwgZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luID0gYmVnaW47XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2xvcGUgb2YgdGhlIGxpbmUgaW4gdGhlIGZvcm0gb2YgYSB2ZWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRTbG9wZVxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIExpbmUucHJvdG90eXBlLmdldFNsb3BlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJlZ2luID0gdGhpcy5iZWdpbi50b1ZlY3RvcigpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kLnRvVmVjdG9yKCk7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiZWdpbi5kaXN0YW5jZShlbmQpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZC5taW51cyhiZWdpbikuc2NhbGUoMSAvIGRpc3RhbmNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSBzZWdtZW50IGluIHBpeGVsc1xuICAgICAgICAgKiBAbWV0aG9kIGdldExlbmd0aFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIExpbmUucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHRoaXMuYmVnaW4udG9WZWN0b3IoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZC50b1ZlY3RvcigpO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIExpbmU7XG4gICAgfSkoKTtcbiAgICBleC5MaW5lID0gTGluZTtcbiAgICB2YXIgUHJvamVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFByb2plY3Rpb24obWluLCBtYXgpIHtcbiAgICAgICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgUHJvamVjdGlvbi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4ID4gcHJvamVjdGlvbi5taW4gJiYgcHJvamVjdGlvbi5tYXggPiB0aGlzLm1pbjtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0T3ZlcmxhcCA9IGZ1bmN0aW9uIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdmVybGFwcyhwcm9qZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heCA+IHByb2plY3Rpb24ubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0aW9uLm1heCAtIHRoaXMubWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4IC0gcHJvamVjdGlvbi5taW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9qZWN0aW9uO1xuICAgIH0pKCk7XG4gICAgZXguUHJvamVjdGlvbiA9IFByb2plY3Rpb247XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFsZ2VicmEudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRXZlbnRzLnRzXCIvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBVdGlsO1xuICAgIChmdW5jdGlvbiAoVXRpbCkge1xuICAgICAgICBVdGlsLlR3b1BJID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIGZ1bmN0aW9uIGJhc2U2NEVuY29kZShpbnB1dFN0cikge1xuICAgICAgICAgICAgdmFyIGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgICAgICAgIHZhciBvdXRwdXRTdHIgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBpbnB1dFN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvL2FsbCB0aHJlZSBcIiYgMHhmZlwiIGFkZGVkIGJlbG93IGFyZSB0aGVyZSB0byBmaXggYSBrbm93biBidWcgXG4gICAgICAgICAgICAgICAgLy93aXRoIGJ5dGVzIHJldHVybmVkIGJ5IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xuICAgICAgICAgICAgICAgIHZhciBieXRlMiA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcbiAgICAgICAgICAgICAgICB2YXIgZW5jMSA9IGJ5dGUxID4+IDI7XG4gICAgICAgICAgICAgICAgdmFyIGVuYzIgPSAoKGJ5dGUxICYgMykgPDwgNCkgfCAoYnl0ZTIgPj4gNCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuYzMsIGVuYzQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGJ5dGUyKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jMyA9ICgoYnl0ZTIgJiAxNSkgPDwgMikgfCAoYnl0ZTMgPj4gNik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihieXRlMykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYzQgPSA2NDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYzQgPSBieXRlMyAmIDYzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dFN0ciArPSBiNjQuY2hhckF0KGVuYzEpICsgYjY0LmNoYXJBdChlbmMyKSArIGI2NC5jaGFyQXQoZW5jMykgKyBiNjQuY2hhckF0KGVuYzQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dFN0cjtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLmJhc2U2NEVuY29kZSA9IGJhc2U2NEVuY29kZTtcbiAgICAgICAgZnVuY3Rpb24gY2xhbXAodmFsLCBtaW4sIG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA8PSBtaW4gPyBtaW4gOiAodmFsID49IG1heCA/IG1heCA6IHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5jbGFtcCA9IGNsYW1wO1xuICAgICAgICBmdW5jdGlvbiBkcmF3TGluZShjdHgsIGNvbG9yLCBzdGFydHgsIHN0YXJ0eSwgZW5keCwgZW5keSkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHN0YXJ0eCwgc3RhcnR5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oZW5keCwgZW5keSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5kcmF3TGluZSA9IGRyYXdMaW5lO1xuICAgICAgICBmdW5jdGlvbiByYW5kb21JblJhbmdlKG1pbiwgbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwucmFuZG9tSW5SYW5nZSA9IHJhbmRvbUluUmFuZ2U7XG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobWluLCBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHJhbmRvbUluUmFuZ2UobWluLCBtYXgpKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLnJhbmRvbUludEluUmFuZ2UgPSByYW5kb21JbnRJblJhbmdlO1xuICAgICAgICBmdW5jdGlvbiBjYW5vbmljYWxpemVBbmdsZShhbmdsZSkge1xuICAgICAgICAgICAgdmFyIHRtcEFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPiB0aGlzLlR3b1BJKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRtcEFuZ2xlID4gdGhpcy5Ud29QSSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBBbmdsZSAtPSB0aGlzLlR3b1BJO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodG1wQW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcEFuZ2xlICs9IHRoaXMuVHdvUEk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRtcEFuZ2xlO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwuY2Fub25pY2FsaXplQW5nbGUgPSBjYW5vbmljYWxpemVBbmdsZTtcbiAgICAgICAgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAxODAgLyBNYXRoLlBJICogcmFkaWFucztcbiAgICAgICAgfVxuICAgICAgICBVdGlsLnRvRGVncmVlcyA9IHRvRGVncmVlcztcbiAgICAgICAgZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWdyZWVzIC8gMTgwICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLnRvUmFkaWFucyA9IHRvUmFkaWFucztcbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBvTGVmdCA9IDAsIG9Ub3AgPSAwO1xuICAgICAgICAgICAgdmFyIGNhbGNPZmZzZXRMZWZ0ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIG9MZWZ0ICs9IHBhcmVudC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNPZmZzZXRMZWZ0KHBhcmVudC5vZmZzZXRQYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY2FsY09mZnNldFRvcCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBvVG9wICs9IHBhcmVudC5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY09mZnNldFRvcChwYXJlbnQub2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FsY09mZnNldExlZnQoZWwpO1xuICAgICAgICAgICAgY2FsY09mZnNldFRvcChlbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KG9MZWZ0LCBvVG9wKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLmdldFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgICAgIGZ1bmN0aW9uIGdldE9wcG9zaXRlU2lkZShzaWRlKSB7XG4gICAgICAgICAgICBpZiAoc2lkZSA9PT0gMSAvKiBUb3AgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQm90dG9tICovO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT09IDIgLyogQm90dG9tICovKVxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFRvcCAqLztcbiAgICAgICAgICAgIGlmIChzaWRlID09PSAzIC8qIExlZnQgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIDQgLyogUmlnaHQgKi87XG4gICAgICAgICAgICBpZiAoc2lkZSA9PT0gNCAvKiBSaWdodCAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBMZWZ0ICovO1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgfVxuICAgICAgICBVdGlsLmdldE9wcG9zaXRlU2lkZSA9IGdldE9wcG9zaXRlU2lkZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4Y2FsaWJ1cnMgZHluYW1pY2FsbHkgcmVzaXppbmcgY29sbGVjdGlvblxuICAgICAgICAgKiBAY2xhc3MgQ29sbGVjdGlvblxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIFtpbml0aWFsU2l6ZT0yMDBdIHtudW1iZXJ9IEluaXRpYWwgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYmFja2luZyBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIENvbGxlY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbihpbml0aWFsU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBcnJheSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRQb2ludGVyID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGluaXRpYWxTaXplIHx8IENvbGxlY3Rpb24uRGVmYXVsdFNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEFycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaXplID0gdGhpcy5pbnRlcm5hbEFycmF5Lmxlbmd0aCAqIDI7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld1NpemUpO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJyYXlbaV0gPSB0aGlzLmludGVybmFsQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmludGVybmFsQXJyYXk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEFycmF5ID0gbmV3QXJyYXk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQdXNoIGVsZW1lbnRzIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBtZXRob2QgcHVzaFxuICAgICAgICAgICAgICogQHBhcmFtIGVsZW1lbnQge1R9XG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZFBvaW50ZXIgPT09IHRoaXMuaW50ZXJuYWxBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxBcnJheVt0aGlzLmVuZFBvaW50ZXIrK10gPSBlbGVtZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBtZXRob2QgcG9wXG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFBvaW50ZXIgPSB0aGlzLmVuZFBvaW50ZXIgLSAxIDwgMCA/IDAgOiB0aGlzLmVuZFBvaW50ZXIgLSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXlbdGhpcy5lbmRQb2ludGVyXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvdW50XG4gICAgICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5kUG9pbnRlcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVtcHRpZXMgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRQb2ludGVyID0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGludGVybmFsIGJhY2tpbmcgYXJyYXlcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW50ZXJuYWxTaXplXG4gICAgICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJuYWxTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgICAgICAgICAqIEBtZXRob2QgZWxlbWVudEF0XG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gSW5kZXggb2YgZWxlbWVudCB0byByZXRyZWl2ZVxuICAgICAgICAgICAgICogQHJldHVybnMgVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lbGVtZW50QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5jb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxBcnJheVtpbmRleF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAgICAgICAgICogQG1ldGhvZCBpbnNlcnRcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBJbmRleCB0byBpbnNlcnQgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIFRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxBcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAgICAgICAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IEluZGV4IG9mIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBPKG4pIFNoaWZ0IFxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5pbnRlcm5hbEFycmF5W2luZGV4XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBcnJheVtpXSA9IHRoaXMuaW50ZXJuYWxBcnJheVtpICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW5kUG9pbnRlci0tO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGJ5IHJlZmVyZW5jZVxuICAgICAgICAgICAgICogQG1ldGhvZCByZW1vdmVFbGVtZW50XG4gICAgICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCB7VH0gSW5kZXggb2YgZWxlbWVudCB0byByZXRyZWl2ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmludGVybmFsQXJyYXkuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIFRbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQXJyYXkuc2xpY2UoMCwgdGhpcy5lbmRQb2ludGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEl0ZXJhdGUgb3ZlciBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICAgICAgICAgICAqIEBwYXJhbSBmdW5jIHsoVCxudW1iZXIpPT5hbnl9IENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggZWxlbWVudCBwYXNzaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgsIHJldHVybmVkIHZhbHVlcyBhcmUgaWdub3JlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzLCB0aGlzLmludGVybmFsQXJyYXlbaV0sIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE11dGF0ZSBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIG1hcFxuICAgICAgICAgICAgICogQHBhcmFtIGZ1bmMgeyhULG51bWJlcik9PmFueX0gQ2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBlbGVtZW50IHBhc3NpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCwgYW55IHZhbHVlcyByZXR1cm5lZCBtdXRhdGUgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxBcnJheVtpXSA9IGZ1bmMuY2FsbCh0aGlzLCB0aGlzLmludGVybmFsQXJyYXlbaV0sIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlZmF1bHQgY29sbGVjdGlvbiBzaXplXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRGVmYXVsdFNpemUge251bWJlcn1cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLkRlZmF1bHRTaXplID0gMjAwO1xuICAgICAgICAgICAgcmV0dXJuIENvbGxlY3Rpb247XG4gICAgICAgIH0pKCk7XG4gICAgICAgIFV0aWwuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG4gICAgfSkoVXRpbCA9IGV4LlV0aWwgfHwgKGV4LlV0aWwgPSB7fSkpO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBIFNwcml0ZSBpcyBvbmUgb2YgdGhlIG1haW4gZHJhd2luZyBwcmltaXRpdmVzLiBJdCBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZ1xuICAgICAqIGltYWdlcyBvciBwYXJ0cyBvZiBpbWFnZXMga25vd24gYXMgVGV4dHVyZXMgdG8gdGhlIHNjcmVlbi5cbiAgICAgKiBAY2xhc3MgU3ByaXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGltYWdlIHtUZXh0dXJlfSBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVcbiAgICAgKiBAcGFyYW0gc3gge251bWJlcn0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNwcml0ZVxuICAgICAqIEBwYXJhbSBzeSB7bnVtYmVyfSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc3ByaXRlXG4gICAgICogQHBhcmFtIHN3aWR0aCB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gc2hlaWdodCB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgdmFyIFNwcml0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZShpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnN4ID0gc3g7XG4gICAgICAgICAgICB0aGlzLnN5ID0gc3k7XG4gICAgICAgICAgICB0aGlzLnN3aWR0aCA9IHN3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuc2hlaWdodCA9IHNoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IDEuMDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gMS4wO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtUG9pbnQgPSBuZXcgZXguUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgICAgICAgICB0aGlzLmludGVybmFsSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ3R4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxEYXRhID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGl4ZWxzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpcnR5RWZmZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3ggPCAwIHx8IHN5IDwgMCB8fCBzd2lkdGggPCAwIHx8IHNoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJTcHJpdGUgY2Fubm90IGhhdmUgYW55IG5lZ2F0aXZlIGRpbWVuc2lvbnMgeDpcIiwgc3gsIFwieTpcIiwgc3ksIFwid2lkdGg6XCIsIHN3aWR0aCwgXCJoZWlnaHQ6XCIsIHNoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDYW52YXMud2lkdGggPSBzd2lkdGg7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUNhbnZhcy5oZWlnaHQgPSBzaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHggPSB0aGlzLnNwcml0ZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmxvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zcHJpdGVDYW52YXMud2lkdGggPSBfdGhpcy5zcHJpdGVDYW52YXMud2lkdGggfHwgX3RoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3ByaXRlQ2FudmFzLmhlaWdodCA9IF90aGlzLnNwcml0ZUNhbnZhcy5oZWlnaHQgfHwgX3RoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRQaXhlbHMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXJ0eUVmZmVjdCA9IHRydWU7XG4gICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGxvYWRpbmcgdGV4dHVyZSBcIiwgX3RoaXMudGV4dHVyZS5wYXRoLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHN3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc2hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmxvYWRQaXhlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0dXJlLmlzTG9hZGVkKCkgJiYgIXRoaXMucGl4ZWxzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYW1wID0gZXguVXRpbC5jbGFtcDtcbiAgICAgICAgICAgICAgICB2YXIgbmF0dXJhbFdpZHRoID0gdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAwO1xuICAgICAgICAgICAgICAgIHZhciBuYXR1cmFsSGVpZ2h0ID0gdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxIZWlnaHQgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zd2lkdGggPiBuYXR1cmFsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoZSBzcHJpdGUgd2lkdGhcIiwgdGhpcy5zd2lkdGgsIFwiZXhjZWVkcyB0aGUgd2lkdGhcIiwgbmF0dXJhbFdpZHRoLCBcIm9mIHRoZSBiYWNraW5nIHRleHR1cmVcIiwgdGhpcy50ZXh0dXJlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaGVpZ2h0ID4gbmF0dXJhbEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhlIHNwcml0ZSBoZWlnaHRcIiwgdGhpcy5zaGVpZ2h0LCBcImV4Y2VlZHMgdGhlIGhlaWdodFwiLCBuYXR1cmFsSGVpZ2h0LCBcIm9mIHRoZSBiYWNraW5nIHRleHR1cmVcIiwgdGhpcy50ZXh0dXJlLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLmltYWdlLCBjbGFtcCh0aGlzLnN4LCAwLCBuYXR1cmFsV2lkdGgpLCBjbGFtcCh0aGlzLnN5LCAwLCBuYXR1cmFsSGVpZ2h0KSwgY2xhbXAodGhpcy5zd2lkdGgsIDAsIG5hdHVyYWxXaWR0aCksIGNsYW1wKHRoaXMuc2hlaWdodCwgMCwgbmF0dXJhbEhlaWdodCksIDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5waXhlbERhdGEgPSB0aGlzLnNwcml0ZUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEltYWdlLnNyYyA9IHRoaXMuc3ByaXRlQ2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpeGVsc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgbmV3IHt7I2Nyb3NzTGluayBFZmZlY3RzLklTcHJpdGVFZmZlY3R9fXt7L2Nyb3NzTGlua319IHRvIHRoaXMgZHJhd2luZy5cbiAgICAgICAgICogQG1ldGhvZCBhZGRFZmZlY3RcbiAgICAgICAgICogQHBhcmFtIGVmZmVjdCB7RWZmZWN0cy5JU3ByaXRlRWZmZWN0fSBFZmZlY3QgdG8gYWRkIHRvIHRoZSB0aGlzIGRyYXdpbmdcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICAgICAgICAgIC8vIFdlIG11c3QgY2hlY2sgaWYgdGhlIHRleHR1cmUgYW5kIHRoZSBiYWNraW5nIHNwcml0ZSBwaXhlbHMgYXJlIGxvYWRlZCBhcyB3ZWxsIGJlZm9yZSBcbiAgICAgICAgICAgIC8vIGFuIGVmZmVjdCBjYW4gYmUgYXBwbGllZFxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUuaXNMb2FkZWQoKSB8fCAhdGhpcy5waXhlbHNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5RWZmZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUucmVtb3ZlRWZmZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhUb1JlbW92ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4VG9SZW1vdmUgPSBwYXJhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4VG9SZW1vdmUgPSB0aGlzLmVmZmVjdHMuaW5kZXhPZihwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xuICAgICAgICAgICAgLy8gV2UgbXVzdCBjaGVjayBpZiB0aGUgdGV4dHVyZSBhbmQgdGhlIGJhY2tpbmcgc3ByaXRlIHBpeGVscyBhcmUgbG9hZGVkIGFzIHdlbGwgYmVmb3JlIFxuICAgICAgICAgICAgLy8gYW4gZWZmZWN0IGNhbiBiZSBhcHBsaWVkXG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dHVyZS5pc0xvYWRlZCgpIHx8ICF0aGlzLnBpeGVsc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlFZmZlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5hcHBseUVmZmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsYW1wID0gZXguVXRpbC5jbGFtcDtcbiAgICAgICAgICAgIHZhciBuYXR1cmFsV2lkdGggPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoIHx8IDA7XG4gICAgICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IHRoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLmltYWdlLCBjbGFtcCh0aGlzLnN4LCAwLCBuYXR1cmFsV2lkdGgpLCBjbGFtcCh0aGlzLnN5LCAwLCBuYXR1cmFsSGVpZ2h0KSwgY2xhbXAodGhpcy5zd2lkdGgsIDAsIG5hdHVyYWxXaWR0aCksIGNsYW1wKHRoaXMuc2hlaWdodCwgMCwgbmF0dXJhbEhlaWdodCksIDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5waXhlbERhdGEgPSB0aGlzLnNwcml0ZUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBfdGhpcy5zaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBfdGhpcy5zd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0LnVwZGF0ZVBpeGVsKHgsIHksIF90aGlzLnBpeGVsRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ3R4LnB1dEltYWdlRGF0YSh0aGlzLnBpeGVsRGF0YSwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsSW1hZ2Uuc3JjID0gdGhpcy5zcHJpdGVDYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBlZmZlY3RzIGZyb20gdGhlIGRyYXdpbmcgYW5kIHJldHVybiBpdCB0byBpdHMgb3JpZ2luYWwgc3RhdGUuXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJFZmZlY3RzXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmNsZWFyRWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHBvaW50IGFib3V0IHdoaWNoIHRvIGFwcGx5IHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgZHJhd2luZyByZWxhdGl2ZSB0byB0aGVcbiAgICAgICAgICogdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBkcmF3aW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHRyYW5zZm9ybUFib3RQb2ludFxuICAgICAgICAgKiBAcGFyYW0gcG9pbnQge1BvaW50fSBUaGUgcG9pbnQgYWJvdXQgd2hpY2ggdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnRyYW5zZm9ybUFib3V0UG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtUG9pbnQgPSBwb2ludDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGN1cnJlbnQgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gZm9yIHRoZSBkcmF3aW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHNldFJvdGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSByYWRpYW5zIHtudW1iZXJ9IFRoZSByb3RhdGlvbiB0byBhcHBseSB0byB0aGUgZHJhd2luZy5cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuc2V0Um90YXRpb24gPSBmdW5jdGlvbiAocmFkaWFucykge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJhZGlhbnM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvdGF0aW9uIGZvciB0aGUgZHJhd2luZyBpbiByYWRpYW5zLlxuICAgICAgICAgKiBAbWV0aG9kIGdldFJvdGF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc2NhbGUgdHJhc2Zvcm1hdGlvbiBpbiB0aGUgeCBkaXJlY3Rpb25cbiAgICAgICAgICogQG1ldGhvZCBzZXRTY2FsZVxuICAgICAgICAgKiBAcGFyYW0gc2NhbGUge251bWJlcn0gVGhlIG1hZ25pdHVkZSB0byBzY2FsZSB0aGUgZHJhd2luZyBpbiB0aGUgeCBkaXJlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuc2V0U2NhbGVYID0gZnVuY3Rpb24gKHNjYWxlWCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBzY2FsZSB0cmFzZm9ybWF0aW9uIGluIHRoZSB4IGRpcmVjdGlvblxuICAgICAgICAgKiBAbWV0aG9kIHNldFNjYWxlXG4gICAgICAgICAqIEBwYXJhbSBzY2FsZSB7bnVtYmVyfSBUaGUgbWFnbml0dWRlIHRvIHNjYWxlIHRoZSBkcmF3aW5nIGluIHRoZSB4IGRpcmVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zZXRTY2FsZVkgPSBmdW5jdGlvbiAoc2NhbGVZKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWFnbml0dWRlIG9mIHRoZSBkcmF3aW5nJ3Mgc2NhbGUgaW4gdGhlIHggZGlyZWN0aW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2NhbGVcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmdldFNjYWxlWCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWFnbml0dWRlIG9mIHRoZSBkcmF3aW5nJ3Mgc2NhbGUgaW4gdGhlIHkgZGlyZWN0aW9uXG4gICAgICAgICAqIEBtZXRob2QgZ2V0U2NhbGVcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmdldFNjYWxlWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGRyYXdpbmcgKGlmIGFueSlcbiAgICAgICAgICogQG1ldGhvZCByZXNldFxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIHRoZSBzcHJpdGUgYXBwcm9wcmlhdGVseSB0byB0aGUgMkQgcmVuZGVyaW5nIGNvbnRleHQsIGF0IGFuIHggYW5kIHkgY29vcmRpbmF0ZS5cbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIDJEIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSB4IGNvb3JkaW5hdGUgb2Ygd2hlcmUgdG8gZHJhd1xuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgeSBjb29yZGluYXRlIG9mIHdoZXJlIHRvIGRyYXdcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcnR5RWZmZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5RWZmZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5zd2lkdGgsIDApO1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW50ZXJuYWxJbWFnZSwgMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCwgLSh0aGlzLnRyYW5zZm9ybVBvaW50LnggKiB0aGlzLnN3aWR0aCkgKiB0aGlzLnNjYWxlWCwgLSh0aGlzLnRyYW5zZm9ybVBvaW50LnkgKiB0aGlzLnNoZWlnaHQpICogdGhpcy5zY2FsZVksIHRoaXMuc3dpZHRoICogdGhpcy5zY2FsZVgsIHRoaXMuc2hlaWdodCAqIHRoaXMuc2NhbGVZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgc3ByaXRlXG4gICAgICAgICAqIEBtZXRob2QgY2xvbmVcbiAgICAgICAgICogQHJldHVybnMgU3ByaXRlXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTcHJpdGUodGhpcy50ZXh0dXJlLCB0aGlzLnN4LCB0aGlzLnN5LCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgIHJlc3VsdC5zY2FsZVggPSB0aGlzLnNjYWxlWDtcbiAgICAgICAgICAgIHJlc3VsdC5zY2FsZVkgPSB0aGlzLnNjYWxlWTtcbiAgICAgICAgICAgIHJlc3VsdC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICAgICAgICByZXN1bHQuZmxpcEhvcml6b250YWwgPSB0aGlzLmZsaXBIb3Jpem9udGFsO1xuICAgICAgICAgICAgcmVzdWx0LmZsaXBWZXJ0aWNhbCA9IHRoaXMuZmxpcFZlcnRpY2FsO1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkRWZmZWN0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3ByaXRlO1xuICAgIH0pKCk7XG4gICAgZXguU3ByaXRlID0gU3ByaXRlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTcHJpdGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIFNwcml0ZVNoZWV0cyBhcmUgYSB1c2VmdWwgbWVjaGFuaXNtIGZvciBzbGljaW5nIHVwIGltYWdlIHJlc291cmNlcyBpbnRvXG4gICAgICogc2VwYXJhdGUgc3ByaXRlcyBvciBmb3IgZ2VuZXJhdGluZyBpbiBnYW1lIGFuaW1hdGlvbnMuIFNwcml0ZXMgYXJlIG9yZ2FuaXplZFxuICAgICAqIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgU3ByaXRlU2hlZXQuXG4gICAgICogQGNsYXNzIFNwcml0ZVNoZWV0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGltYWdlIHtUZXh0dXJlfSBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVTaGVldFxuICAgICAqIEBwYXJhbSBjb2x1bW5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgaW1hZ2UgdGV4dHVyZVxuICAgICAqIEBwYXJhbSByb3dzIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgaW1hZ2UgdGV4dHVyZVxuICAgICAqIEBwYXJhbSBzcFdpZHRoIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiBlYWNoIGluZGl2aWR1YWwgc3ByaXRlIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSBzcEhlaWdodCB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIGVhY2ggaW5kaXZpZHVhbCBzcHJpdGUgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgdmFyIFNwcml0ZVNoZWV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlU2hlZXQoaW1hZ2UsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgICAgICAgdGhpcy5yb3dzID0gcm93cztcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEltYWdlID0gaW1hZ2UuaW1hZ2U7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBuZXcgQXJyYXkoY29sdW1ucyAqIHJvd3MpO1xuICAgICAgICAgICAgLy8gVE9ETzogSW5zcGVjdCBhY3R1YWwgaW1hZ2UgZGltZW5zaW9ucyB3aXRoIHByZWxvYWRpbmdcbiAgICAgICAgICAgIC8qaWYoc3BXaWR0aCAqIGNvbHVtbnMgPiB0aGlzLmludGVybmFsSW1hZ2UubmF0dXJhbFdpZHRoKXtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwcml0ZVNoZWV0IHNwZWNpZmllZCBpcyB3aWRlciB0aGFuIGltYWdlIHdpZHRoXCIpO1xuICAgICAgICAgICAgfVxuICAgXG4gICAgICAgICAgICBpZihzcEhlaWdodCAqIHJvd3MgPiB0aGlzLmludGVybmFsSW1hZ2UubmF0dXJhbEhlaWdodCl7XG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpdGVTaGVldCBzcGVjaWZpZWQgaXMgaGlnaGVyIHRoYW4gaW1hZ2UgaGVpZ2h0XCIpO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaiArIGkgKiBjb2x1bW5zXSA9IG5ldyBleC5TcHJpdGUodGhpcy5pbWFnZSwgaiAqIHNwV2lkdGgsIGkgKiBzcEhlaWdodCwgc3BXaWR0aCwgc3BIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiBmcm9tIHRoZSB0aGlzIFNwcml0ZVNoZWV0IGJ5IGxpc3Rpbmcgb3V0IHRoZVxuICAgICAgICAgKiBzcHJpdGUgaW5kaWNlcy4gU3ByaXRlcyBhcmUgb3JnYW5pemVkIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgU3ByaXRlU2hlZXQuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uQnlJbmRpY2VzXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgRW5naW5lXG4gICAgICAgICAqIEBwYXJhbSBpbmRpY2VzIHtudW1iZXJbXX0gQW4gYXJyYXkgb2Ygc3ByaXRlIGluZGljZXMgdG8gdXNlIGluIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIEFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlU2hlZXQucHJvdG90eXBlLmdldEFuaW1hdGlvbkJ5SW5kaWNlcyA9IGZ1bmN0aW9uIChlbmdpbmUsIGluZGljZXMsIHNwZWVkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGltYWdlcyA9IGluZGljZXMubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zcHJpdGVzW2luZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW1hZ2VzID0gaW1hZ2VzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguQW5pbWF0aW9uKGVuZ2luZSwgaW1hZ2VzLCBzcGVlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gYW5pbWF0aW9uIGZyb20gdGhlIHRoaXMgU3ByaXRlU2hlZXQgYnkgc3BlY2lmaW5nIHRoZSByYW5nZSBvZlxuICAgICAgICAgKiBpbWFnZXMgd2l0aCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgaW5kZXhcbiAgICAgICAgICogQG1ldGhvZCBnZXRBbmltYXRpb25CZXR3ZWVuXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgRW5naW5lXG4gICAgICAgICAqIEBwYXJhbSBiZWdpbkluZGV4IHtudW1iZXJ9IFRoZSBpbmRleCB0byBzdGFydCB0YWtpbmcgZnJhbWVzXG4gICAgICAgICAqIEBwYXJhbSBlbmRJbmRleCB7bnVtYmVyfSBUaGUgaW5kZXggdG8gc3RvcCB0YWtpbmcgZnJhbWVzXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBBbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZVNoZWV0LnByb3RvdHlwZS5nZXRBbmltYXRpb25CZXR3ZWVuID0gZnVuY3Rpb24gKGVuZ2luZSwgYmVnaW5JbmRleCwgZW5kSW5kZXgsIHNwZWVkKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gdGhpcy5zcHJpdGVzLnNsaWNlKGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIGltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LkFuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJlYXQgdGhlIGVudGlyZSBTcHJpdGVTaGVldCBhcyBvbmUgYW5pbWF0aW9uLCBvcmdhbml6aW5nIHRoZSBmcmFtZXMgaW5cbiAgICAgICAgICogcm93IG1ham9yIG9yZGVyLlxuICAgICAgICAgKiBAbWV0aG9kIGdldEFuaW1hdGlvbkZvckFsbFxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIEVuZ2luZVxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQge251bWJlcn0gVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogQHJldHVybnMgQW5pbWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGVTaGVldC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRm9yQWxsID0gZnVuY3Rpb24gKGVuZ2luZSwgc3BlZWQpIHtcbiAgICAgICAgICAgIHZhciBzcHJpdGVzID0gdGhpcy5zcHJpdGVzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguQW5pbWF0aW9uKGVuZ2luZSwgc3ByaXRlcywgc3BlZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmVpdmUgYSBzcGVjaWZpYyBzcHJpdGUgZnJvbSB0aGUgU3ByaXRlU2hlZXQgYnkgaXRzIGluZGV4LiBTcHJpdGVzIGFyZSBvcmdhbml6ZWRcbiAgICAgICAgICogaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBTcHJpdGVTaGVldC5cbiAgICAgICAgICogQG1ldGhvZCBnZXRTcHJpdGVcbiAgICAgICAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgc3ByaXRlXG4gICAgICAgICAqIEByZXR1cm5zIFNwcml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlU2hlZXQucHJvdG90eXBlLmdldFNwcml0ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTcHJpdGVTaGVldDtcbiAgICB9KSgpO1xuICAgIGV4LlNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQ7XG4gICAgLyoqXG4gICAgICogU3ByaXRlRm9udHMgYXJlIGEgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEge3sjY3Jvc3NMaW5rIExhYmVsfX17ey9jcm9zc0xpbmt9fSB0byBzcGVjaWZ5XG4gICAgICogYSBwYXJ0aWN1bGFyIGJpdG1hcCBhcyBhIGZvbnQuXG4gICAgICogQGNsYXNzIFNwcml0ZUZvbnRcbiAgICAgKiBAZXh0ZW5kcyBTcHJpdGVTaGVldFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBpbWFnZSB7VGV4dHVyZX0gVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlRm9udFxuICAgICAqIEBwYXJhbSBhbHBoYWJldCB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIHRoZSBjaGFyYXRlcnMgaW4gdGhlIGltYWdlLCBpbiByb3cgbWFqb3Igb3JkZXIuXG4gICAgICogQHBhcmFtIGNhc2VJbnNlbnNpdHZlIHtib29sZWFufSBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgZm9udCB0YWtlcyBjYXNlIGludG8gYWNjb3VudFxuICAgICAqIEBwYXJhbSBjb2x1bW5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucyBvZiBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSByb3dzIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyBvZiBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSBzcFdkaXRoIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiBlYWNoIGNoYXJhY3RlciBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gc3BIZWlnaHQge251bWJlcn0gVGhlIGhlaWdodCBvZiBlYWNoIGNoYXJhY3RlciBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICB2YXIgU3ByaXRlRm9udCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTcHJpdGVGb250LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTcHJpdGVGb250KGltYWdlLCBhbHBoYWJldCwgY2FzZUluc2Vuc2l0aXZlLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaW1hZ2UsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuYWxwaGFiZXQgPSBhbHBoYWJldDtcbiAgICAgICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gY2FzZUluc2Vuc2l0aXZlO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVMb29rdXAgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JMb29rdXAgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IGV4LkNvbG9yLkJsYWNrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgZGljdGlvbmFyeSB0aGF0IG1hcHMgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGFscGhhYmV0IHRvIHRoZSBhcHByb3ByaWF0ZSBTcHJpdGUuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0VGV4dFNwcml0ZXNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZUZvbnQucHJvdG90eXBlLmdldFRleHRTcHJpdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvb2t1cCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLmFscGhhYmV0W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyID0gY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb29rdXBbY2hhcl0gPSB0aGlzLnNwcml0ZXNbaV0uY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb29rdXA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTcHJpdGVGb250O1xuICAgIH0pKFNwcml0ZVNoZWV0KTtcbiAgICBleC5TcHJpdGVGb250ID0gU3ByaXRlRm9udDtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRW5naW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTcHJpdGVTaGVldC50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIFRpbGVTcHJpdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUaWxlU3ByaXRlKHNwcml0ZVNoZWV0S2V5LCBzcHJpdGVJZCkge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVTaGVldEtleSA9IHNwcml0ZVNoZWV0S2V5O1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVJZCA9IHNwcml0ZUlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUaWxlU3ByaXRlO1xuICAgIH0pKCk7XG4gICAgZXguVGlsZVNwcml0ZSA9IFRpbGVTcHJpdGU7XG4gICAgLyoqXG4gICAgICogQSBsaWdodC13ZWlnaHQgb2JqZWN0IHRoYXQgb2NjdXBpZXMgYSBzcGFjZSBpbiBhIGNvbGxpc2lvbiBtYXAuIEdlbmVyYWxseVxuICAgICAqIGNyZWF0ZWQgYnkgYSBDb2xsaXNpb25NYXAuXG4gICAgICogQGNsYXNzIENlbGxcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geCB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHdpZHRoIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIGhlaWdodCB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSBbc29saWQ9ZmFsc2VdIHtib29sZWFufVxuICAgICAqIEBwYXJhbSBbc3ByaXRlSWQ9LTFdIHtudW1iZXJ9XG4gICAgICovXG4gICAgdmFyIENlbGwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDZWxsKFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgeCBjb29yZGluYXRlIG9mIHRoZSBjZWxsIGluIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgeCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB4LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCBpbiB3b3JsZCBjb29yZGluYXRlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHkge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgeSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgd2lkdGggb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB3aWR0aCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB3aWR0aCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgaGVpZ2h0IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhlaWdodCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY2VsbCBpbiByb3cgbWFqb3Igb3JkZXJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpbmRleCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbmRleCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRoaXMgY2VsbCBpcyBzb2xpZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHNvbGlkIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzb2xpZCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgc3ByaXRlIHRvIHVzZSBmcm9tIHRoZSBDb2xsaXNpb25NYXAgU3ByaXRlU2hlZXQsIGlmIC0xIGlzIHNwZWNpZmllZCBub3RoaW5nIGlzIGRyYXduLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IG51bWJlciB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzcHJpdGVzKSB7XG4gICAgICAgICAgICBpZiAoc29saWQgPT09IHZvaWQgMCkgeyBzb2xpZCA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAoc3ByaXRlcyA9PT0gdm9pZCAwKSB7IHNwcml0ZXMgPSBbXTsgfVxuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IHNwcml0ZXM7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMgPSBuZXcgZXguQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnksIHRoaXMueCArIHRoaXMud2lkdGgsIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciB0aGlzIGNlbGxcbiAgICAgICAgICogQG1ldGhvZCBnZXRCb3VuZHNcbiAgICAgICAgICogQHJldHVybnMgQm91bmRpbmdCb3hcbiAgICAgICAgICovXG4gICAgICAgIENlbGwucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgICAgIH07XG4gICAgICAgIENlbGwucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguVmVjdG9yKHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIpO1xuICAgICAgICB9O1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5wdXNoU3ByaXRlID0gZnVuY3Rpb24gKHRpbGVTcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5wdXNoKHRpbGVTcHJpdGUpO1xuICAgICAgICB9O1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5yZW1vdmVTcHJpdGUgPSBmdW5jdGlvbiAodGlsZVNwcml0ZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBpZiAoKGluZGV4ID0gdGhpcy5zcHJpdGVzLmluZGV4T2YodGlsZVNwcml0ZSkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuY2xlYXJTcHJpdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDZWxsO1xuICAgIH0pKCk7XG4gICAgZXguQ2VsbCA9IENlbGw7XG4gICAgLyoqXG4gICAgICogVGhlIENvbGxpc2lvbk1hcCBvYmplY3QgcHJvdmlkZXMgYSBsaWdodHdlaWdodCB3YXkgdG8gZG8gbGFyZ2UgY29tcGxleCBzY2VuZXMgd2l0aCBjb2xsaXNpb25cbiAgICAgKiB3aXRob3V0IHRoZSBvdmVyaGVhZCBvZiBhY3RvcnMuXG4gICAgICogQGNsYXNzIENvbGxpc2lvbk1hcFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSB4IGNvb3JkaW5hdGUgdG8gYW5jaG9yIHRoZSBjb2xsaXNpb24gbWFwJ3MgdXBwZXIgbGVmdCBjb3JuZXIgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcbiAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgeSBjb29yZGluYXRlIHRvIGFuY2hvciB0aGUgY29sbGlzaW9uIG1hcCdzIHVwcGVyIGxlZnQgY29ybmVyIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXG4gICAgICogQHBhcmFtIGNlbGxXaWR0aCB7bnVtYmVyfSBUaGUgaW5kaXZpZHVhbCB3aWR0aCBvZiBlYWNoIGNlbGwgKGluIHBpeGVscykgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcbiAgICAgKiBAcGFyYW0gY2VsbEhlaWdodCB7bnVtYmVyfSBUaGUgaW5kaXZpZHVhbCBoZWlnaHQgb2YgZWFjaCBjZWxsIChpbiBwaXhlbHMpIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXG4gICAgICogQHBhcmFtIHJvd3Mge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBjb2xsaXNpb24gbWFwIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXG4gICAgICogQHBhcmFtIGNvbHMge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2xzIGluIHRoZSBjb2xsaXNpb24gbWFwIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXG4gICAgICogQHBhcmFtIHNwcml0ZVNoZWV0IHtTcHJpdGVTaGVldH0gVGhlIHNwcml0ZVNoZWV0IHRvIHVzZSBmb3IgZHJhd2luZ1xuICAgICAqL1xuICAgIHZhciBUaWxlTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGlsZU1hcCh4LCB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHJvd3MsIGNvbHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgIHRoaXMuY2VsbFdpZHRoID0gY2VsbFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jZWxsSGVpZ2h0ID0gY2VsbEhlaWdodDtcbiAgICAgICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgICAgICAgICB0aGlzLmNvbHMgPSBjb2xzO1xuICAgICAgICAgICAgdGhpcy5fY29sbGlkaW5nWCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fY29sbGlkaW5nWSA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5YU3RhcnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5YRW5kID0gOTk5OTtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWVN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWUVuZCA9IDk5OTk7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVTaGVldHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheShyb3dzICogY29scyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93czsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2QgPSBuZXcgQ2VsbChpICogY2VsbFdpZHRoICsgeCwgaiAqIGNlbGxIZWlnaHQgKyB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIGkgKyBqICogY29scyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kYXRhW2kgKyBqICogY29sc10gPSBjZDtcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUucmVnaXN0ZXJTcHJpdGVTaGVldCA9IGZ1bmN0aW9uIChrZXksIHNwcml0ZVNoZWV0KSB7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVTaGVldHNba2V5XSA9IHNwcml0ZVNoZWV0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW50ZXNlY3Rpb24gdmVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBjb2xsaXNpb25zIHdpdGggYWN0b3JzLiBJZiB0aGVyZVxuICAgICAgICAgKiBpcyBubyBjb2xsaXNpb24gbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgICAgICogQG1ldGhvZCBjb2xsaWRlc1xuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfVxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBhY3Rvci54ICsgYWN0b3IuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBhY3Rvci55ICsgYWN0b3IuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICB2YXIgYWN0b3JCb3VuZHMgPSBhY3Rvci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHZhciBvdmVybGFwcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IGFjdG9yQm91bmRzLmxlZnQ7IHggPD0gd2lkdGg7IHggKz0gTWF0aC5taW4oYWN0b3IuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuY2VsbFdpZHRoIC8gMikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gYWN0b3JCb3VuZHMudG9wOyB5IDw9IGhlaWdodDsgeSArPSBNYXRoLm1pbihhY3Rvci5nZXRIZWlnaHQoKSAvIDIsIHRoaXMuY2VsbEhlaWdodCAvIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsQnlQb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwgJiYgY2VsbC5zb2xpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSBhY3RvckJvdW5kcy5jb2xsaWRlcyhjZWxsLmdldEJvdW5kcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSBhY3Rvci5nZXRDZW50ZXIoKS5taW51cyhjZWxsLmdldENlbnRlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwICYmIG92ZXJsYXAuZG90KGRpcikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMucHVzaChvdmVybGFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdmVybGFwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgc21hbGxlc3QgY2hhbmdlIG90aGVyIHRoYW4gemVyb1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIG5leHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGFjY3VtLng7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBhY2N1bS55O1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhY2N1bS54KSA8IE1hdGguYWJzKG5leHQueCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG5leHQueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGFjY3VtLnkpIDwgTWF0aC5hYnMobmV4dC55KSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gbmV4dC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4LlZlY3Rvcih4LCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgLypcbiAgICAgICAgcHVibGljIGNvbGxpZGVzQWN0b3IoYWN0b3I6IEFjdG9yKTogYm9vbGVhbntcbiAgICAgICAgICAgXG4gICAgICAgICAgIHZhciBwb2ludHM6IFBvaW50W10gPSBbXTtcbiAgICAgICAgICAgdmFyIHdpZHRoID0gYWN0b3IueCArIGFjdG9yLmdldFdpZHRoKCk7XG4gICAgICAgICAgIHZhciBoZWlnaHQgPSBhY3Rvci55ICsgYWN0b3IuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgIGZvcih2YXIgeCA9IGFjdG9yLng7IHggPD0gd2lkdGg7IHggKz0gTWF0aC5taW4oYWN0b3IuZ2V0V2lkdGgoKS8yLHRoaXMuY2VsbFdpZHRoLzIpKXtcbiAgICAgICAgICAgICAgZm9yKHZhciB5ID0gYWN0b3IueTsgeSA8PSBoZWlnaHQ7IHkgKz0gTWF0aC5taW4oYWN0b3IuZ2V0SGVpZ2h0KCkvMiwgdGhpcy5jZWxsSGVpZ2h0LzIpKXtcbiAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gobmV3IFBvaW50KHgseSkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBvaW50cy5zb21lKChwKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVzUG9pbnQocC54LCBwLnkpO1xuICAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gIFxuICAgICAgICB9Ki9cbiAgICAgICAgLypcbiAgICAgICAgcHVibGljIGNvbGxpZGVzUG9pbnQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBib29sZWFue1xuICAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoeC90aGlzLmNlbGxXaWR0aCk7Ly8gLSBNYXRoLmZsb29yKHRoaXMueC90aGlzLmNlbGxXaWR0aCk7XG4gICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcih5L3RoaXMuY2VsbEhlaWdodCk7XG4gIFxuICBcbiAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldENlbGwoeCwgeSk7XG4gICAgICAgICAgIGlmKHggPj0gMCAmJiB5ID49IDAgJiYgeCA8IHRoaXMuY29scyAmJiB5IDwgdGhpcy5yb3dzICYmIGNlbGwpe1xuICAgICAgICAgICAgICBpZihjZWxsLnNvbGlkKXtcbiAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkaW5nWCA9IHg7XG4gICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGluZ1kgPSB5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjZWxsLnNvbGlkO1xuICAgICAgICAgICB9XG4gIFxuICBcbiAgXG4gICAgICAgICAgIFxuICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0qL1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2VsbCBieSBpbmRleCAocm93IG1ham9yIG9yZGVyKVxuICAgICAgICAgKiBAbWV0aG9kIGdldENlbGxCeUluZGV4XG4gICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfVxuICAgICAgICAgKiBAcmV0dXJucyBDZWxsXG4gICAgICAgICAqL1xuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5nZXRDZWxsQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpbmRleF07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjZWxsIGJ5IGl0J3MgeCBhbmQgeSBjb29yZGluYXRlc1xuICAgICAgICAgKiBAbWV0aG9kIGdldENlbGxcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn1cbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn1cbiAgICAgICAgICogQHJldHVybnMgQ2VsbFxuICAgICAgICAgKi9cbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUuZ2V0Q2VsbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+PSB0aGlzLmNvbHMgfHwgeSA+PSB0aGlzLnJvd3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbeCArIHkgKiB0aGlzLmNvbHNdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2VsbCBieSB0ZXN0aW5nIGEgcG9pbnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzLFxuICAgICAgICAgKiByZXR1cm5zIG51bGwgaWYgbm8gY2VsbCB3YXMgZm91bmQuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Q2VsbEJ5UG9pbnRcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn1cbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn1cbiAgICAgICAgICogQHJldHVybnMgQ2VsbFxuICAgICAgICAgKi9cbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUuZ2V0Q2VsbEJ5UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKCh4IC0gdGhpcy54KSAvIHRoaXMuY2VsbFdpZHRoKTsgLy8gLSBNYXRoLmZsb29yKHRoaXMueC90aGlzLmNlbGxXaWR0aCk7XG4gICAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IoKHkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRDZWxsKHgsIHkpO1xuICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB5ID49IDAgJiYgeCA8IHRoaXMuY29scyAmJiB5IDwgdGhpcy5yb3dzICYmIGNlbGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIHdvcmxkQ29vcmRzVXBwZXJMZWZ0ID0gZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgZXguUG9pbnQoMCwgMCkpO1xuICAgICAgICAgICAgdmFyIHdvcmxkQ29vcmRzTG93ZXJSaWdodCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KGVuZ2luZS53aWR0aCwgZW5naW5lLmhlaWdodCkpO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5YU3RhcnQgPSBNYXRoLm1heChNYXRoLmZsb29yKHdvcmxkQ29vcmRzVXBwZXJMZWZ0LnggLyB0aGlzLmNlbGxXaWR0aCkgLSAyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWVN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNVcHBlckxlZnQueSAtIHRoaXMueSkgLyB0aGlzLmNlbGxIZWlnaHQpIC0gMiwgMCk7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlblhFbmQgPSBNYXRoLm1heChNYXRoLmZsb29yKHdvcmxkQ29vcmRzTG93ZXJSaWdodC54IC8gdGhpcy5jZWxsV2lkdGgpICsgMiwgMCk7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlbllFbmQgPSBNYXRoLm1heChNYXRoLmZsb29yKCh3b3JsZENvb3Jkc0xvd2VyUmlnaHQueSAtIHRoaXMueSkgLyB0aGlzLmNlbGxIZWlnaHQpICsgMiwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3cyB0aGUgY29sbGlzaW9uIG1hcCB0byB0aGUgc2NyZWVuLiBDYWxsZWQgYnkgdGhlIFNjZW5lLlxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgZHJhd1xuICAgICAgICAgKi9cbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IHRoaXMuX29uU2NyZWVuWFN0YXJ0OyB4IDwgTWF0aC5taW4odGhpcy5fb25TY3JlZW5YRW5kLCB0aGlzLmNvbHMpOyB4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gdGhpcy5fb25TY3JlZW5ZU3RhcnQ7IHkgPCBNYXRoLm1pbih0aGlzLl9vblNjcmVlbllFbmQsIHRoaXMucm93cyk7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENlbGwoeCwgeSkuc3ByaXRlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnNwcml0ZUlkID4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3MgPSBfdGhpcy5fc3ByaXRlU2hlZXRzW3RzLnNwcml0ZVNoZWV0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcy5nZXRTcHJpdGUodHMuc3ByaXRlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcHJpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmRyYXcoY3R4LCB4ICogX3RoaXMuY2VsbFdpZHRoLCB5ICogX3RoaXMuY2VsbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIlNwcml0ZSBkb2VzIG5vdCBleGlzdCBmb3IgaWRcIiwgdHMuc3ByaXRlSWQsIFwiaW4gc3ByaXRlIHNoZWV0XCIsIHRzLnNwcml0ZVNoZWV0S2V5LCBzcHJpdGUsIHNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIlNwcml0ZSBzaGVldFwiLCB0cy5zcHJpdGVTaGVldEtleSwgXCJkb2VzIG5vdCBleGlzdFwiLCBzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3cyBhbGwgdGhlIGNvbGxpc2lvbiBtYXAncyBkZWJ1ZyBpbmZvLiBDYWxsZWQgYnkgdGhlIFNjZW5lLlxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jb2xzICogdGhpcy5jZWxsV2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5yb3dzICogdGhpcy5jZWxsSGVpZ2h0O1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGV4LkNvbG9yLlJlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmNvbHMgKyAxOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnggKyB4ICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnggKyB4ICogdGhpcy5jZWxsV2lkdGgsIHRoaXMueSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCB0aGlzLnJvd3MgKyAxOyB5KyspIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLngsIHRoaXMueSArIHkgKiB0aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy54ICsgd2lkdGgsIHRoaXMueSArIHkgKiB0aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzb2xpZCA9IGV4LkNvbG9yLlJlZC5jbG9uZSgpO1xuICAgICAgICAgICAgc29saWQuYSA9IC4zO1xuICAgICAgICAgICAgdGhpcy5kYXRhLmZpbHRlcihmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsLnNvbGlkO1xuICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzb2xpZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChjZWxsLngsIGNlbGwueSwgY2VsbC53aWR0aCwgY2VsbC5oZWlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGlkaW5nWSA+IC0xICYmIHRoaXMuX2NvbGxpZGluZ1ggPiAtMSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBleC5Db2xvci5DeWFuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMueCArIHRoaXMuX2NvbGxpZGluZ1ggKiB0aGlzLmNlbGxXaWR0aCwgdGhpcy55ICsgdGhpcy5fY29sbGlkaW5nWSAqIHRoaXMuY2VsbEhlaWdodCwgdGhpcy5jZWxsV2lkdGgsIHRoaXMuY2VsbEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGlsZU1hcDtcbiAgICB9KSgpO1xuICAgIGV4LlRpbGVNYXAgPSBUaWxlTWFwO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9BbGdlYnJhLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAoZnVuY3Rpb24gKENvbGxpc2lvblN0cmF0ZWd5KSB7XG4gICAgICAgIENvbGxpc2lvblN0cmF0ZWd5W0NvbGxpc2lvblN0cmF0ZWd5W1wiTmFpdmVcIl0gPSAwXSA9IFwiTmFpdmVcIjtcbiAgICAgICAgQ29sbGlzaW9uU3RyYXRlZ3lbQ29sbGlzaW9uU3RyYXRlZ3lbXCJEeW5hbWljQUFCQlRyZWVcIl0gPSAxXSA9IFwiRHluYW1pY0FBQkJUcmVlXCI7XG4gICAgICAgIENvbGxpc2lvblN0cmF0ZWd5W0NvbGxpc2lvblN0cmF0ZWd5W1wiU2VwYXJhdGluZ0F4aXNcIl0gPSAyXSA9IFwiU2VwYXJhdGluZ0F4aXNcIjtcbiAgICB9KShleC5Db2xsaXNpb25TdHJhdGVneSB8fCAoZXguQ29sbGlzaW9uU3RyYXRlZ3kgPSB7fSkpO1xuICAgIHZhciBDb2xsaXNpb25TdHJhdGVneSA9IGV4LkNvbGxpc2lvblN0cmF0ZWd5O1xuICAgIC8qKlxuICAgICAqIEF4aXMgQWxpZ25lZCBjb2xsaXNpb24gcHJpbWl0aXZlIGZvciBFeGNhbGlidXIuXG4gICAgICogQGNsYXNzIEJvdW5kaW5nQm94XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGxlZnQge251bWJlcn0geCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IGVkZ2VcbiAgICAgKiBAcGFyYW0gdG9wIHtudW1iZXJ9IHkgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGVkZ2VcbiAgICAgKiBAcGFyYW0gcmlnaHQge251bWJlcn0geCBjb29yZGluYXRlIG9mIHRoZSByaWdodCBlZGdlXG4gICAgICogQHBhcmFtIGJvdHRvbSB7bnVtYmVyfSB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBlZGdlXG4gICAgICovXG4gICAgdmFyIEJvdW5kaW5nQm94ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQm91bmRpbmdCb3gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7IGxlZnQgPSAwOyB9XG4gICAgICAgICAgICBpZiAodG9wID09PSB2b2lkIDApIHsgdG9wID0gMDsgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHsgcmlnaHQgPSAwOyB9XG4gICAgICAgICAgICBpZiAoYm90dG9tID09PSB2b2lkIDApIHsgYm90dG9tID0gMDsgfVxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNhbGN1bGF0ZWQgd2lkdGggb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgICAgICAgKiBAbWV0aG9kIGdldFdpZHRoXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94XG4gICAgICAgICAqIEBtZXRob2QgZ2V0SGVpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcGVyaW1ldGVyIG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAgICAgICogQG1ldGhvZCBnZXRQZXJpbWV0ZXJcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0UGVyaW1ldGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHd4ID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIHd5ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIHJldHVybiAyICogKHd4ICsgd3kpO1xuICAgICAgICB9O1xuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgZXguUG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubGVmdCA8PSB2YWwueCAmJiB0aGlzLnRvcCA8PSB2YWwueSAmJiB0aGlzLmJvdHRvbSA+PSB2YWwueSAmJiB0aGlzLnJpZ2h0ID49IHZhbC54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA8IHZhbC5sZWZ0ICYmIHRoaXMudG9wIDwgdmFsLnRvcCAmJiB2YWwuYm90dG9tIDwgdGhpcy5ib3R0b20gJiYgdmFsLnJpZ2h0IDwgdGhpcy5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tYmluZXMgdGhpcyBib3VuZGluZyBib3ggYW5kIGFub3RoZXIgdG9nZXRoZXIgcmV0dXJuaW5nIGEgbmV3IGJvdW5kaW5nIGJveFxuICAgICAgICAgKiBAbWV0aG9kIGNvbWJpbmVcbiAgICAgICAgICogQHBhcmFtIG90aGVyIHtCb3VuZGluZ0JveH0gVGhlIGJvdW5kaW5nIGJveCB0byBjb21iaW5lXG4gICAgICAgICAqIEByZXR1cm5zIEJvdW5kaW5nQm94XG4gICAgICAgICAqL1xuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgdmFyIGNvbXBvc2l0ZUJCID0gbmV3IEJvdW5kaW5nQm94KE1hdGgubWluKHRoaXMubGVmdCwgb3RoZXIubGVmdCksIE1hdGgubWluKHRoaXMudG9wLCBvdGhlci50b3ApLCBNYXRoLm1heCh0aGlzLnJpZ2h0LCBvdGhlci5yaWdodCksIE1hdGgubWF4KHRoaXMuYm90dG9tLCBvdGhlci5ib3R0b20pKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb3NpdGVCQjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3Qgd2V0aGVyIHRoaXMgYm91bmRpbmcgYm94IGNvbGxpZGVzIHdpdGggYW5vdGhlciByZXR1cm5pbmcsXG4gICAgICAgICAqIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzb3ZsZSB0aGUgY29sbGlzaW9uLiBJZiB0aGVyZVxuICAgICAgICAgKiBpcyBubyBjb2xsaXNpb24gbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgICAgICogQG1ldGhvZCBjb2xsaWRlc1xuICAgICAgICAgKiBAcGFyYW0gY29sbGlkYWJsZSB7SUNvbGxpZGFibGV9IE90aGVyIGNvbGxpZGFibGUgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChjb2xsaWRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoY29sbGlkYWJsZSBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY29sbGlkYWJsZTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxCb3VuZGluZ0JveCA9IHRoaXMuY29tYmluZShvdGhlcik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGJvdW5kaW5nIGJveCBpcyBsZXNzIHRoYW4gdGhlIHN1bSBvZiB0aGUgMiBib3VuZHMgdGhlbiB0aGVyZSBpcyBjb2xsaXNpb25cbiAgICAgICAgICAgICAgICBpZiAodG90YWxCb3VuZGluZ0JveC5nZXRXaWR0aCgpIDwgb3RoZXIuZ2V0V2lkdGgoKSArIHRoaXMuZ2V0V2lkdGgoKSAmJiB0b3RhbEJvdW5kaW5nQm94LmdldEhlaWdodCgpIDwgb3RoZXIuZ2V0SGVpZ2h0KCkgKyB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbGxpc2lvblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcFggPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCA+PSBvdGhlci5sZWZ0ICYmIHRoaXMucmlnaHQgPD0gb3RoZXIucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBYID0gb3RoZXIubGVmdCAtIHRoaXMucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLnJpZ2h0IC0gdGhpcy5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvcCA8PSBvdGhlci5ib3R0b20gJiYgdGhpcy50b3AgPj0gb3RoZXIudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLmJvdHRvbSAtIHRoaXMudG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci50b3AgLSB0aGlzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMob3ZlcmxhcFgpIDwgTWF0aC5hYnMob3ZlcmxhcFkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4LlZlY3RvcihvdmVybGFwWCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4LlZlY3RvcigwLCBvdmVybGFwWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQm91bmRpbmdCb3g7XG4gICAgfSkoKTtcbiAgICBleC5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94O1xuICAgIHZhciBTQVRCb3VuZGluZ0JveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNBVEJvdW5kaW5nQm94KHBvaW50cykge1xuICAgICAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50b1ZlY3RvcigpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0U2lkZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobmV3IGV4LkxpbmUodGhpcy5fcG9pbnRzW2ldLCB0aGlzLl9wb2ludHNbKGkgKyAxKSAlIGxlbl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lcztcbiAgICAgICAgfTtcbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXhlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXhlcy5wdXNoKHRoaXMuX3BvaW50c1tpXS5taW51cyh0aGlzLl9wb2ludHNbKGkgKyAxKSAlIGxlbl0pLm5vcm1hbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBheGVzO1xuICAgICAgICB9O1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGFycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2NhbGFycy5wdXNoKHRoaXMuX3BvaW50c1tpXS5kb3QoYXhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qcm9qZWN0aW9uKE1hdGgubWluLmFwcGx5KE1hdGgsIHNjYWxhcnMpLCBNYXRoLm1heC5hcHBseShNYXRoLCBzY2FsYXJzKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIHRoZSBib3VuZGluZyBib3gsIGJ5IGdlbmVyYXRpbmcgYW4gYXhpcyBhbGlnbmVkIGJveCBhcm91bmQgdGhlIGN1cnJlbnRcbiAgICAgICAgICogQG1ldGhvZCBnZXRXaWR0aFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHAsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihhY2N1bSwgcC54KTtcbiAgICAgICAgICAgIH0sIEluZmluaXR5KTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBwLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoYWNjdW0sIHAueCk7XG4gICAgICAgICAgICB9LCAtSW5maW5pdHkpO1xuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNhbGN1bGF0ZWQgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyBib3gsIGJ5IGdlbmVyYXRpbmcgYW4gYXhpcyBhbGlnbmVkIGJveCBhcm91bmQgdGhlIGN1cnJlbnRcbiAgICAgICAgICogQG1ldGhvZCBnZXRIZWlnaHRcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBwLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oYWNjdW0sIHAueSk7XG4gICAgICAgICAgICB9LCBJbmZpbml0eSk7XG4gICAgICAgICAgICB2YXIgYm90dG9tID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHAsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChhY2N1bSwgcC55KTtcbiAgICAgICAgICAgIH0sIC1JbmZpbml0eSk7XG4gICAgICAgICAgICByZXR1cm4gdG9wIC0gYm90dG9tO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgd2V0aGVyIGEgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgYm91bmRpbmcgYm94LCB1c2luZyB0aGUgUElQIGFsZ29yaXRobVxuICAgICAgICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvaW50X2luX3BvbHlnb25cbiAgICAgICAgICogQG1ldGhvZCBjb250YWluc1xuICAgICAgICAgKiBAcGFyYW0gcCB7UG9pbnR9IFRoZSBwb2ludCB0byB0ZXN0XG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgY2FzdCB0byB0aGUgcmlnaHQsIGFzIGxvbmcgYXMgd2UgY2FzdCBpbiBhIGNvbnNpdGVudCBmaXhlZCBkaXJlY3Rpb24gd2VcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgZmluZVxuICAgICAgICAgICAgdmFyIHRlc3RSYXkgPSBuZXcgZXguUmF5KHAsIG5ldyBleC5WZWN0b3IoMSwgMCkpO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdENvdW50ID0gdGhpcy5nZXRTaWRlcygpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHNpZGUsIGksIGFycikge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0UmF5LmludGVyc2VjdChzaWRlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdENvdW50ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoY29sbGlkYWJsZSkge1xuICAgICAgICAgICAgaWYgKGNvbGxpZGFibGUgaW5zdGFuY2VvZiBTQVRCb3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNvbGxpZGFibGU7XG4gICAgICAgICAgICAgICAgdmFyIGF4ZXMgPSB0aGlzLmdldEF4ZXMoKTtcbiAgICAgICAgICAgICAgICBheGVzID0gb3RoZXIuZ2V0QXhlcygpLmNvbmNhdChheGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgbWluT3ZlcmxhcCA9IDk5OTk5O1xuICAgICAgICAgICAgICAgIHZhciBtaW5BeGlzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2oxID0gdGhpcy5wcm9qZWN0KGF4ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvajIgPSBvdGhlci5wcm9qZWN0KGF4ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IHByb2oxLmdldE92ZXJsYXAocHJvajIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA8PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQXhpcyA9IGF4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbkF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pbkF4aXMubm9ybWFsaXplKCkuc2NhbGUobWluT3ZlcmxhcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzdXBwbGllZCBwb2ludHMgYW5kIGNvbnRydWN0IGEgJ3BvbHlnb24nXG4gICAgICAgICAgICB2YXIgZmlyc3RQb2ludCA9IHRoaXMuX3BvaW50c1swXTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBleC5Db2xvci5CbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTQVRCb3VuZGluZ0JveDtcbiAgICB9KSgpO1xuICAgIGV4LlNBVEJvdW5kaW5nQm94ID0gU0FUQm91bmRpbmdCb3g7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50cy50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogRXhjYWxpYnVyIGJhc2UgY2xhc3NcbiAgICAgKiBAY2xhc3MgQ2xhc3NcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ2xhc3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDbGFzcygpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IGV4LkV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyLiBZb3UgY2FuIGxpc3RlbiBmb3IgYSB2YXJpZXR5IG9mXG4gICAgICAgICAqIGV2ZW50cyBvZmYgb2YgdGhlIGVuZ2luZTsgc2VlIHRoZSBldmVudHMgc2VjdGlvbiBiZWxvdyBmb3IgYSBjb21wbGV0ZSBsaXN0LlxuICAgICAgICAgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyIHtldmVudD0+dm9pZH0gRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5zdWJzY3JpYmUoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuIElmIG9ubHkgdGhlIGV2ZW50TmFtZSBpcyBzcGVjaWZpZWRcbiAgICAgICAgICogaXQgd2lsbCByZW1vdmUgYWxsIGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIHRoYXQgc3BlY2lmaWMgZXZlbnQuIElmIHRoZSBldmVudE5hbWVcbiAgICAgICAgICogYW5kIHRoZSBoYW5kbGVyIGluc3RhbmNlIGFyZSBzcGVjaWZpZWQganVzdCB0aGF0IGhhbmRsZXIgd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgICAqIEBwYXJhbSBbaGFuZGxlcj11bmRlZmluZWRdIHtldmVudD0+dm9pZH0gRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci51bnN1YnNjcmliZShldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIFwiYWRkRXZlbnRMaXN0ZW5lclwiLiBZb3UgY2FuIGxpc3RlbiBmb3IgYSB2YXJpZXR5IG9mXG4gICAgICAgICAqIGV2ZW50cyBvZmYgb2YgdGhlIGVuZ2luZTsgc2VlIHRoZSBldmVudHMgc2VjdGlvbiBiZWxvdyBmb3IgYSBjb21wbGV0ZSBsaXN0LlxuICAgICAgICAgKiBAbWV0aG9kIG9uXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIENsYXNzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnN1YnNjcmliZShldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLiBJZiBvbmx5IHRoZSBldmVudE5hbWUgaXMgc3BlY2lmaWVkXG4gICAgICAgICAqIGl0IHdpbGwgcmVtb3ZlIGFsbCBoYW5kbGVycyByZWdpc3RlcmVkIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50LiBJZiB0aGUgZXZlbnROYW1lXG4gICAgICAgICAqIGFuZCB0aGUgaGFuZGxlciBpbnN0YW5jZSBhcmUgc3BlY2lmaWVkIG9ubHkgdGhhdCBoYW5kbGVyIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBvZmZcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgICAqIEBwYXJhbSBbaGFuZGxlcj11bmRlZmluZWRdIHtldmVudD0+dm9pZH0gRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnVuc3Vic2NyaWJlKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgbWF5IHdpc2ggdG8gZXh0ZW5kIG5hdGl2ZSBFeGNhbGlidXIgZnVuY3Rpb25hbGl0eS4gQW55IG1ldGhvZCBvblxuICAgICAgICAgKiBhY3RvciBtYXkgYmUgZXh0ZW5kZWQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpeS4gSW4gdGhlXG4gICAgICAgICAqIGV4YW1wbGUgYmVsb3cgd2UgY3JlYXRlIGEgbmV3IHR5cGUgY2FsbGVkIFwiTXlBY3RvclwiXG4gICAgICAgICAqIDxici8+PGI+RXhhbXBsZTwvYj48cHJlPnZhciBNeUFjdG9yID0gQWN0b3IuZXh0ZW5kKHtcbiAgICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm5ld3Byb3AgPSAnc29tZXRoaW5nJztcbiAgICAgICAgQWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgfSxcbiAgICAgdXBkYXRlIDogZnVuY3Rpb24oZW5naW5lLCBkZWx0YSl7XG4gICAgICAgIC8vIEltcGxlbWVudCBjdXN0b20gdXBkYXRlXG4gIFxuICAgICAgICAgICAvLyBDYWxsIHN1cGVyIGNvbnN0cnVjdG9yIHVwZGF0ZVxuICAgICAgICAgICBBY3Rvci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZW5naW5lLCBkZWx0YSk7XG4gICAgICAgICAgIGNvbnNvbGUubG9nKFwiU29tZXRoaW5nIGNvb2whXCIpO1xuICAgICB9XG4gIH0pO1xuICB2YXIgbXlBY3RvciA9IG5ldyBNeUFjdG9yKDEwMCwgMTAwLCAxMDAsIDEwMCwgQ29sb3IuQXp1cmUpOzwvcHJlPlxuICAgICAgICAgKiBAbWV0aG9kIGV4dGVuZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSBtZXRob2RzIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICBDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAobWV0aG9kcykge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBtZXRob2RzLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBtZXRob2RzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNpbmcgY29uc3RydWN0b3IgYWxsb3dzIEpTIHRvIGxhemlseSBpbnN0YW50aWF0ZSBzdXBlciBjbGFzc2VzXG4gICAgICAgICAgICB2YXIgU3VwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFN1cGVyLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgU3VwZXI7XG4gICAgICAgICAgICBpZiAobWV0aG9kcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gbWV0aG9kcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlW3Byb3BdID0gbWV0aG9kc1twcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2Ugc3ViY2xhc3NlcyBleHRlbmRhYmxlXG4gICAgICAgICAgICBjaGlsZC5leHRlbmQgPSBDbGFzcy5leHRlbmQ7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDbGFzcztcbiAgICB9KSgpO1xuICAgIGV4LkNsYXNzID0gQ2xhc3M7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBUaW1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRXhjYWxpYnVyIHRpbWVyIGhvb2tzIGludG8gdGhlIGludGVybmFsIHRpbWVyIGFuZCBmaXJlcyBjYWxsYmFja3MsIGFmdGVyIGEgY2VydGFpbiBpbnRlcnZhbCwgb3B0aW9uYWxseSByZXBlYXRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBUaW1lclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHtjYWxsYmFja30gVGhlIGNhbGxiYWNrIHRvIGJlIGZpcmVkIGFmdGVyIHRoZSBpbnRlcnZhbCBpcyBjb21wbGV0ZS5cbiAgICAgICAgICogQHBhcmFtIFtyZXBlYXRzPWZhbHNlXSB7Ym9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYWxsIGJhY2sgc2hvdWxkIGJlIGZpcmVkIG9ubHkgb25jZSwgb3IgcmVwZWF0IGFmdGVyIGV2ZXJ5IGludGVydmFsIGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRpbWVyKGZjbiwgaW50ZXJ2YWwsIHJlcGVhdHMpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IDEwO1xuICAgICAgICAgICAgdGhpcy5mY24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZUFsaXZlID0gMDtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pZCA9IFRpbWVyLmlkKys7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWwgfHwgdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuZmNuID0gZmNuIHx8IHRoaXMuZmNuO1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRzID0gcmVwZWF0cyB8fCB0aGlzLnJlcGVhdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHRpbWVyIGFmdGVyIGEgY2VydGFpbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZC4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIGVuZ2luZS5cbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IE51bWJlciBvZiBlbGFwc2VkIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBUaW1lci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICB0aGlzLl90b3RhbFRpbWVBbGl2ZSArPSBkZWx0YTtcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGFwc2VkVGltZSA+IHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZjbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS5nZXRUaW1lUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3RhbFRpbWVBbGl2ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbmNlbHMgdGhlIHRpbWVyLCBwcmV2ZW50aW5nIGFueSBmdXJ0aGVyIGV4ZWN1dGlvbnMuXG4gICAgICAgICAqIEBtZXRob2QgY2FuY2VsXG4gICAgICAgICAqL1xuICAgICAgICBUaW1lci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmNhbmNlbFRpbWVyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBUaW1lci5pZCA9IDA7XG4gICAgICAgIHJldHVybiBUaW1lcjtcbiAgICB9KSgpO1xuICAgIGV4LlRpbWVyID0gVGltZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0FjdG9yLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNpZGUudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSUNvbGxpc2lvblJlc29sdmVyLnRzXCIvPiBcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgTmFpdmVDb2xsaXNpb25SZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTmFpdmVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBwYXNzXG4gICAgICAgIH07XG4gICAgICAgIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0YXJ0ZXQpIHtcbiAgICAgICAgICAgIC8vIHBhc3NcbiAgICAgICAgfTtcbiAgICAgICAgTmFpdmVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgcG90ZW50aWFsIGNvbGxpZGVycywgZXhjbHVkZSBraWxsZWQsIHByZXZlbnRlZCwgYW5kIHNlbGZcbiAgICAgICAgICAgIHZhciBwb3RlbnRpYWxDb2xsaWRlcnMgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW90aGVyLmlzS2lsbGVkKCkgJiYgb3RoZXIuY29sbGlzaW9uVHlwZSAhPT0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYWN0b3IxO1xuICAgICAgICAgICAgdmFyIGFjdG9yMjtcbiAgICAgICAgICAgIHZhciBjb2xsaXNpb25QYWlycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBwb3RlbnRpYWxDb2xsaWRlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYWN0b3IxID0gcG90ZW50aWFsQ29sbGlkZXJzW2pdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBqICsgMTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhY3RvcjIgPSBwb3RlbnRpYWxDb2xsaWRlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IgPSBhY3RvcjEuY29sbGlkZXMoYWN0b3IyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGUgPSBhY3RvcjEuZ2V0U2lkZUZyb21JbnRlcnNlY3QobWluaW11bVRyYW5zbGF0aW9uVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb25QYWlyID0gbmV3IGV4LkNvbGxpc2lvblBhaXIoYWN0b3IxLCBhY3RvcjIsIG1pbmltdW1UcmFuc2xhdGlvblZlY3Rvciwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvblBhaXJzLnNvbWUoZnVuY3Rpb24gKGNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNwLmVxdWFscyhjb2xsaXNpb25QYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uUGFpcnMucHVzaChjb2xsaXNpb25QYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxpc2lvblBhaXJzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuZXZhbHVhdGUoKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uUGFpcnM7XG4gICAgICAgIH07XG4gICAgICAgIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICAgICAgTmFpdmVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5haXZlQ29sbGlzaW9uUmVzb2x2ZXI7XG4gICAgfSkoKTtcbiAgICBleC5OYWl2ZUNvbGxpc2lvblJlc29sdmVyID0gTmFpdmVDb2xsaXNpb25SZXNvbHZlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQm91bmRpbmdCb3gudHNcIi8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIFRyZWVOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJlZU5vZGUocGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICAgICAgICB0aGlzLmFjdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gbmV3IGV4LkJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoIXRoaXMubGVmdCAmJiAhdGhpcy5yaWdodCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUcmVlTm9kZTtcbiAgICB9KSgpO1xuICAgIGV4LlRyZWVOb2RlID0gVHJlZU5vZGU7XG4gICAgdmFyIER5bmFtaWNUcmVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRHluYW1pY1RyZWUoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobGVhZikge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG5vZGVzIGluIHRoZSB0cmVlLCBtYWtlIHRoaXMgdGhlIHJvb3QgbGVhZlxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlYWY7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VhcmNoIHRoZSB0cmVlIGZvciBhIG5vZGUgdGhhdCBpcyBub3QgYSBsZWFmIGFuZCBmaW5kIHRoZSBiZXN0IHBsYWNlIHRvIGluc2VydFxuICAgICAgICAgICAgdmFyIGxlYWZBQUJCID0gbGVhZi5ib3VuZHM7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnJlbnRSb290LmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBjdXJyZW50Um9vdC5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGN1cnJlbnRSb290LnJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBhcmVhID0gY3VycmVudFJvb3QuYm91bmRzLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZEFBQkIgPSBjdXJyZW50Um9vdC5ib3VuZHMuY29tYmluZShsZWFmQUFCQik7XG4gICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVkQXJlYSA9IGNvbWJpbmVkQUFCQi5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgY29zdCBoZXVyaXN0aWMgZm9yIGNyZWF0aW5nIGEgbmV3IHBhcmVudCBhbmQgbGVhZlxuICAgICAgICAgICAgICAgIHZhciBjb3N0ID0gMiAqIGNvbWJpbmVkQXJlYTtcbiAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIGNvc3Qgb2YgcHVzaGluZyB0aGUgbGVhZiBkb3duIHRoZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGluaGVyaXRhbmNlQ29zdCA9IDIgKiAoY29tYmluZWRBcmVhIC0gYXJlYSk7XG4gICAgICAgICAgICAgICAgLy8gQ29zdCBvZiBkZXNjZW5kaW5nXG4gICAgICAgICAgICAgICAgdmFyIGxlZnRDb3N0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENvbWJpbmVkID0gbGVhZkFBQkIuY29tYmluZShsZWZ0LmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0FyZWE7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEFyZWE7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdENvc3QgPSBsZWZ0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCkgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRBcmVhID0gbGVmdC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FyZWEgPSBsZWZ0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDb3N0ID0gKG5ld0FyZWEgLSBvbGRBcmVhKSArIGluaGVyaXRhbmNlQ29zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29zdCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q29tYmluZWQgPSBsZWFmQUFCQi5jb21iaW5lKHJpZ2h0LmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q29zdCA9IHJpZ2h0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCkgKyBpbmhlcml0YW5jZUNvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRBcmVhID0gcmlnaHQuYm91bmRzLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICBuZXdBcmVhID0gcmlnaHRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDb3N0ID0gKG5ld0FyZWEgLSBvbGRBcmVhKSArIGluaGVyaXRhbmNlQ29zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29zdCBpcyBhY2NlcHRhYmxlXG4gICAgICAgICAgICAgICAgaWYgKGNvc3QgPCBsZWZ0Q29zdCAmJiBjb3N0IDwgcmlnaHRDb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIHRvIHRoZSBkZXB0aHNcbiAgICAgICAgICAgICAgICBpZiAobGVmdENvc3QgPCByaWdodENvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvb3QgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvb3QgPSByaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBwYXJlbnQgbm9kZSBhbmQgaW5zZXJ0IGludG8gdGhlIHRyZWVcbiAgICAgICAgICAgIHZhciBvbGRQYXJlbnQgPSBjdXJyZW50Um9vdC5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3IFRyZWVOb2RlKG9sZFBhcmVudCk7XG4gICAgICAgICAgICBuZXdQYXJlbnQuYm91bmRzID0gbGVhZkFBQkIuY29tYmluZShjdXJyZW50Um9vdC5ib3VuZHMpO1xuICAgICAgICAgICAgbmV3UGFyZW50LmhlaWdodCA9IGN1cnJlbnRSb290LmhlaWdodCArIDE7XG4gICAgICAgICAgICBpZiAob2xkUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgbm9kZSB3YXMgbm90IHRoZSByb290XG4gICAgICAgICAgICAgICAgaWYgKG9sZFBhcmVudC5sZWZ0ID09PSBjdXJyZW50Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRQYXJlbnQubGVmdCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFBhcmVudC5yaWdodCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmxlZnQgPSBjdXJyZW50Um9vdDtcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQucmlnaHQgPSBsZWFmO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSb290LnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIG5vZGUgd2FzIHRoZSByb290XG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmxlZnQgPSBjdXJyZW50Um9vdDtcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQucmlnaHQgPSBsZWFmO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSb290LnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXdQYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYWxrIHVwIHRoZSB0cmVlIGZpeGluZyBoZWlnaHRzIGFuZCBBQUJCc1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gbGVhZi5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMuYmFsYW5jZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBvZiBjdXJyZW50IGxlYWYgY2Fubm90IGhhdmUgYSBudWxsIGxlZnQgY2hpbGRcIiArIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgb2YgY3VycmVudCBsZWFmIGNhbm5vdCBoYXZlIGEgbnVsbCByaWdodCBjaGlsZFwiICsgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoY3VycmVudE5vZGUubGVmdC5oZWlnaHQsIGN1cnJlbnROb2RlLnJpZ2h0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzID0gY3VycmVudE5vZGUubGVmdC5ib3VuZHMuY29tYmluZShjdXJyZW50Tm9kZS5yaWdodC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgICAgIGlmIChsZWFmID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBsZWFmLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBncmFuZFBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgc2libGluZztcbiAgICAgICAgICAgIGlmIChwYXJlbnQubGVmdCA9PT0gbGVhZikge1xuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQubGVmdCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LmxlZnQgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQucmlnaHQgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IGdyYW5kUGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGdyYW5kUGFyZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMuYmFsYW5jZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcyA9IGN1cnJlbnROb2RlLmxlZnQuYm91bmRzLmNvbWJpbmUoY3VycmVudE5vZGUucmlnaHQuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGN1cnJlbnROb2RlLmxlZnQuaGVpZ2h0LCBjdXJyZW50Tm9kZS5yaWdodC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJlZ2lzdGVyQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IFRyZWVOb2RlKCk7XG4gICAgICAgICAgICBub2RlLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICBub2RlLmJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgbm9kZS5ib3VuZHMubGVmdCAtPSAyO1xuICAgICAgICAgICAgbm9kZS5ib3VuZHMudG9wIC09IDI7XG4gICAgICAgICAgICBub2RlLmJvdW5kcy5yaWdodCArPSAyO1xuICAgICAgICAgICAgbm9kZS5ib3VuZHMuYm90dG9tICs9IDI7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2FjdG9yLmlkXSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLmluc2VydChub2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnVwZGF0ZUFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbYWN0b3IuaWRdO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBiID0gYWN0b3IuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICBpZiAobm9kZS5ib3VuZHMuY29udGFpbnMoYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShub2RlKTtcbiAgICAgICAgICAgIGIubGVmdCAtPSA1O1xuICAgICAgICAgICAgYi50b3AgLT0gNTtcbiAgICAgICAgICAgIGIucmlnaHQgKz0gNTtcbiAgICAgICAgICAgIGIuYm90dG9tICs9IDU7XG4gICAgICAgICAgICB2YXIgbXVsdGR4ID0gYWN0b3IuZHggKiAyO1xuICAgICAgICAgICAgdmFyIG11bHRkeSA9IGFjdG9yLmR5ICogMjtcbiAgICAgICAgICAgIGlmIChtdWx0ZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgYi5sZWZ0ICs9IG11bHRkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGIucmlnaHQgKz0gbXVsdGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11bHRkeSA8IDApIHtcbiAgICAgICAgICAgICAgICBiLnRvcCArPSBtdWx0ZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiLmJvdHRvbSArPSBtdWx0ZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmJvdW5kcyA9IGI7XG4gICAgICAgICAgICB0aGlzLmluc2VydChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUucmVtb3ZlQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1thY3Rvci5pZF07XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2FjdG9yLmlkXSA9IG51bGw7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1thY3Rvci5pZF07XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5iYWxhbmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGJhbGFuY2UgYXQgbnVsbCBub2RlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKCkgfHwgbm9kZS5oZWlnaHQgPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVmdCA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB2YXIgYSA9IG5vZGU7XG4gICAgICAgICAgICB2YXIgYiA9IGxlZnQ7XG4gICAgICAgICAgICB2YXIgYyA9IHJpZ2h0O1xuICAgICAgICAgICAgdmFyIGQgPSBsZWZ0LmxlZnQ7XG4gICAgICAgICAgICB2YXIgZSA9IGxlZnQucmlnaHQ7XG4gICAgICAgICAgICB2YXIgZiA9IHJpZ2h0LmxlZnQ7XG4gICAgICAgICAgICB2YXIgZyA9IHJpZ2h0LnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGJhbGFuY2UgPSBjLmhlaWdodCAtIGIuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gUm90YXRlIGMgbm9kZSB1cFxuICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gU3dhcCB0aGUgcmlnaHQgbm9kZSB3aXRoIGl0J3MgcGFyZW50XG4gICAgICAgICAgICAgICAgYy5sZWZ0ID0gYTtcbiAgICAgICAgICAgICAgICBjLnBhcmVudCA9IGEucGFyZW50O1xuICAgICAgICAgICAgICAgIGEucGFyZW50ID0gYztcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgbm9kZSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIHRoZSByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBtZWdhIGNvbmZ1c2luZ1xuICAgICAgICAgICAgICAgIGlmIChjLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5wYXJlbnQubGVmdCA9PT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQubGVmdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnBhcmVudC5yaWdodCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJvdGF0ZVxuICAgICAgICAgICAgICAgIGlmIChmLmhlaWdodCA+IGcuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGMucmlnaHQgPSBmO1xuICAgICAgICAgICAgICAgICAgICBhLnJpZ2h0ID0gZztcbiAgICAgICAgICAgICAgICAgICAgZy5wYXJlbnQgPSBhO1xuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGIuYm91bmRzLmNvbWJpbmUoZy5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBjLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZi5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChiLmhlaWdodCwgZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYy5yaWdodCA9IGc7XG4gICAgICAgICAgICAgICAgICAgIGEucmlnaHQgPSBmO1xuICAgICAgICAgICAgICAgICAgICBmLnBhcmVudCA9IGE7XG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYi5ib3VuZHMuY29tYmluZShmLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGMuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShnLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGIuaGVpZ2h0LCBmLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBnLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUm90YXRlIGxlZnQgbm9kZSB1cFxuICAgICAgICAgICAgaWYgKGJhbGFuY2UgPCAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXBcbiAgICAgICAgICAgICAgICBiLmxlZnQgPSBhO1xuICAgICAgICAgICAgICAgIGIucGFyZW50ID0gYS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgYS5wYXJlbnQgPSBiO1xuICAgICAgICAgICAgICAgIC8vIG5vZGUncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byBiXG4gICAgICAgICAgICAgICAgaWYgKGIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudC5sZWZ0ID09PSBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnBhcmVudC5sZWZ0ID0gYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudC5yaWdodCAhPT0gYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkVycm9yIHJvdGF0aW5nIER5bmFtaWMgVHJlZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5wYXJlbnQucmlnaHQgPSBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByb3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoZC5oZWlnaHQgPiBlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBiLnJpZ2h0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgYS5sZWZ0ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgZS5wYXJlbnQgPSBhO1xuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGMuYm91bmRzLmNvbWJpbmUoZS5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBiLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChjLmhlaWdodCwgZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBiLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYi5yaWdodCA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGEubGVmdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGQucGFyZW50ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBjLmJvdW5kcy5jb21iaW5lKGQuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYi5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGUuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYy5oZWlnaHQsIGQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QuaGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoYWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gYWN0b3IuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLmJvdW5kcy5jb2xsaWRlcyhib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5pc0xlYWYoKSAmJiBjdXJyZW50Tm9kZS5hY3RvciAhPT0gYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGFjdG9yLCBjdXJyZW50Tm9kZS5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXIoY3VycmVudE5vZGUubGVmdCkgfHwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXIodGhpcy5yb290KTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLnJheUNhc3QgPSBmdW5jdGlvbiAocmF5LCBtYXgpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gaW1wbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhlbHBlciA9IGZ1bmN0aW9uIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2N1cnJlbnROb2RlXS5jb25jYXQoaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpLCBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcih0aGlzLnJvb3QpO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIGRyYXcgYWxsIHRoZSBub2RlcyBpbiB0aGUgRHluYW1pYyBUcmVlXG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubGVmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaGVscGVyKHRoaXMucm9vdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEeW5hbWljVHJlZTtcbiAgICB9KSgpO1xuICAgIGV4LkR5bmFtaWNUcmVlID0gRHluYW1pY1RyZWU7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIklDb2xsaXNpb25SZXNvbHZlci50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJEeW5hbWljVHJlZS50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIoKSB7XG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZSA9IG5ldyBleC5EeW5hbWljVHJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucmVnaXN0ZXJBY3Rvcih0YXJnZXQpO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5yZW1vdmVBY3Rvcih0YXJnZXQpO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBwb3RlbnRpYWwgY29sbGlkZXJzLCBleGNsdWRlIGtpbGxlZCwgcHJldmVudGVkLCBhbmQgc2VsZlxuICAgICAgICAgICAgdmFyIHBvdGVudGlhbENvbGxpZGVycyA9IHRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhb3RoZXIuaXNLaWxsZWQoKSAmJiBvdGhlci5jb2xsaXNpb25UeXBlICE9PSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhY3RvcjtcbiAgICAgICAgICAgIHZhciBjb2xsaXNpb25QYWlycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBwb3RlbnRpYWxDb2xsaWRlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYWN0b3IgPSBwb3RlbnRpYWxDb2xsaWRlcnNbal07XG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucXVlcnkoYWN0b3IsIGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIuY29sbGlzaW9uVHlwZSA9PT0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovIHx8IG90aGVyLmlzS2lsbGVkKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IgPSBhY3Rvci5jb2xsaWRlcyhvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gYWN0b3IuZ2V0U2lkZUZyb21JbnRlcnNlY3QobWluaW11bVRyYW5zbGF0aW9uVmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb25QYWlyID0gbmV3IGV4LkNvbGxpc2lvblBhaXIoYWN0b3IsIG90aGVyLCBtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25QYWlycy5zb21lKGZ1bmN0aW9uIChjcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcC5lcXVhbHMoY29sbGlzaW9uUGFpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvblBhaXJzLnB1c2goY29sbGlzaW9uUGFpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsaXNpb25QYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmV2YWx1YXRlKCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxpc2lvblBhaXJzO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodGFyZ2V0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB1cGRhdGVkID0gMDtcbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudXBkYXRlQWN0b3IoYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5kZWJ1Z0RyYXcoY3R4LCBkZWx0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyO1xuICAgIH0pKCk7XG4gICAgZXguRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlciA9IER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIENvbGxpc2lvbiBwYWlycyBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IEV4Y2FsaWJ1ciB0byByZXNvbHZlIGNvbGxpc2lvbiBiZXR3ZWVuIGFjdG9ycy4gVGhlXG4gICAgICogUGFpciBwcmV2ZW50cyBjb2xsaXNpb25zIGZyb20gYmVpbmcgZXZhbHVhdGVkIG1vcmUgdGhhbiBvbmUgdGltZVxuICAgICAqIEBjbGFzcyBDb2xsaXNpb25QYWlyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGxlZnQge0FjdG9yfSBUaGUgZmlyc3QgYWN0b3IgaW4gdGhlIGNvbGxpc2lvbiBwYWlyXG4gICAgICogQHBhcmFtIHJpZ2h0IHtBY3Rvcn0gVGhlIHNlY29uZCBhY3RvciBpbiB0aGUgY29sbGlzaW9uIHBhaXJcbiAgICAgKiBAcGFyYW0gaW50ZXJzZWN0IHtWZWN0b3J9IFRoZSBtaW5pbXVtIHRyYW5zbGF0aW9uIHZlY3RvciB0byBzZXBhcmF0ZSB0aGUgYWN0b3JzIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBsZWZ0IGFjdG9yXG4gICAgICogQHBhcmFtIHNpZGUge1NpZGV9IFRoZSBzaWRlIG9uIHdoaWNoIHRoZSBjb2xsaXNpb24gb2NjdXJlZCBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiB0aGUgbGVmdCBhY3RvclxuICAgICAqL1xuICAgIHZhciBDb2xsaXNpb25QYWlyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29sbGlzaW9uUGFpcihsZWZ0LCByaWdodCwgaW50ZXJzZWN0LCBzaWRlKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG4gICAgICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgY29sbGlzaW9uIHBhaXIgYW5kIGFub3RoZXIgYXJlIGVxdWl2YWxlbnQuXG4gICAgICAgICAqIEBtZXRob2QgZXF1YWxzXG4gICAgICAgICAqIEBwYXJhbSBjb2xsaXNpb25QYWlyIHtDb2xsaXNpb25QYWlyfVxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25QYWlyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoY29sbGlzaW9uUGFpcikge1xuICAgICAgICAgICAgcmV0dXJuIChjb2xsaXNpb25QYWlyLmxlZnQgPT09IHRoaXMubGVmdCAmJiBjb2xsaXNpb25QYWlyLnJpZ2h0ID09PSB0aGlzLnJpZ2h0KSB8fCAoY29sbGlzaW9uUGFpci5yaWdodCA9PT0gdGhpcy5sZWZ0ICYmIGNvbGxpc2lvblBhaXIubGVmdCA9PT0gdGhpcy5yaWdodCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmFsdWF0ZXMgdGhlIGNvbGxpc2lvbiBwYWlyLCBwZXJmb3JtaW5nIGNvbGxpc2lvbiByZXNvbHV0aW9uIGFuZCBldmVudCBwdWJsaXNoaW5nIGFwcHJvcHJpYXRlIHRvIGVhY2ggY29sbGlzaW9uIHR5cGUuXG4gICAgICAgICAqIEBtZXRob2QgZXZhbHVhdGVcbiAgICAgICAgICovXG4gICAgICAgIENvbGxpc2lvblBhaXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdG9kbyBmaXJlIGNvbGxpc2lvbiBldmVudHMgb24gbGVmdCBhbmQgcmlnaHQgYWN0b3JcbiAgICAgICAgICAgIC8vIHRvZG8gcmVzb2x2ZSBjb2xsaXNpb25zICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGNvbGxpc2lvbiBldmVudHMgb24gYm90aCBwYXJ0aWNpcGFudHNcbiAgICAgICAgICAgIHRoaXMubGVmdC5ldmVudERpc3BhdGNoZXIucHVibGlzaCgnY29sbGlzaW9uJywgbmV3IGV4LkNvbGxpc2lvbkV2ZW50KHRoaXMubGVmdCwgdGhpcy5yaWdodCwgdGhpcy5zaWRlLCB0aGlzLmludGVyc2VjdCkpO1xuICAgICAgICAgICAgdGhpcy5yaWdodC5ldmVudERpc3BhdGNoZXIucHVibGlzaCgnY29sbGlzaW9uJywgbmV3IGV4LkNvbGxpc2lvbkV2ZW50KHRoaXMucmlnaHQsIHRoaXMubGVmdCwgZXguVXRpbC5nZXRPcHBvc2l0ZVNpZGUodGhpcy5zaWRlKSwgdGhpcy5pbnRlcnNlY3Quc2NhbGUoLTEuMCkpKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBhY3RvciBpcyBhY3RpdmUgcHVzaCB0aGUgYWN0b3Igb3V0IGlmIGl0cyBub3QgcGFzc2l2ZVxuICAgICAgICAgICAgdmFyIGxlZnRTaWRlID0gdGhpcy5zaWRlO1xuICAgICAgICAgICAgaWYgKCh0aGlzLmxlZnQuY29sbGlzaW9uVHlwZSA9PT0gMiAvKiBBY3RpdmUgKi8gfHwgdGhpcy5sZWZ0LmNvbGxpc2lvblR5cGUgPT09IDMgLyogRWxhc3RpYyAqLykgJiYgdGhpcy5yaWdodC5jb2xsaXNpb25UeXBlICE9PSAxIC8qIFBhc3NpdmUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQueSArPSB0aGlzLmludGVyc2VjdC55O1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdC54ICs9IHRoaXMuaW50ZXJzZWN0Lng7XG4gICAgICAgICAgICAgICAgLy8gTmFpdmUgZWxhc3RpYyBib3VuY2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0LmNvbGxpc2lvblR5cGUgPT09IDMgLyogRWxhc3RpYyAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFNpZGUgPT09IDMgLyogTGVmdCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmR4ID0gTWF0aC5hYnModGhpcy5sZWZ0LmR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsZWZ0U2lkZSA9PT0gNCAvKiBSaWdodCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmR4ID0gLU1hdGguYWJzKHRoaXMubGVmdC5keCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdFNpZGUgPT09IDEgLyogVG9wICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZHkgPSBNYXRoLmFicyh0aGlzLmxlZnQuZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRTaWRlID09PSAyIC8qIEJvdHRvbSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmR5ID0gLU1hdGguYWJzKHRoaXMubGVmdC5keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmlnaHRTaWRlID0gZXguVXRpbC5nZXRPcHBvc2l0ZVNpZGUodGhpcy5zaWRlKTtcbiAgICAgICAgICAgIHZhciByaWdodEludGVyc2VjdCA9IHRoaXMuaW50ZXJzZWN0LnNjYWxlKC0xLjApO1xuICAgICAgICAgICAgaWYgKCh0aGlzLnJpZ2h0LmNvbGxpc2lvblR5cGUgPT09IDIgLyogQWN0aXZlICovIHx8IHRoaXMucmlnaHQuY29sbGlzaW9uVHlwZSA9PT0gMyAvKiBFbGFzdGljICovKSAmJiB0aGlzLmxlZnQuY29sbGlzaW9uVHlwZSAhPT0gMSAvKiBQYXNzaXZlICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC55ICs9IHJpZ2h0SW50ZXJzZWN0Lnk7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC54ICs9IHJpZ2h0SW50ZXJzZWN0Lng7XG4gICAgICAgICAgICAgICAgLy8gTmFpdmUgZWxhc3RpYyBib3VuY2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodC5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0U2lkZSA9PT0gMyAvKiBMZWZ0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmR4ID0gTWF0aC5hYnModGhpcy5yaWdodC5keCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRTaWRlID09PSA0IC8qIFJpZ2h0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmR4ID0gLU1hdGguYWJzKHRoaXMucmlnaHQuZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0U2lkZSA9PT0gMSAvKiBUb3AgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZHkgPSBNYXRoLmFicyh0aGlzLnJpZ2h0LmR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFNpZGUgPT09IDIgLyogQm90dG9tICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmR5ID0gLU1hdGguYWJzKHRoaXMucmlnaHQuZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29sbGlzaW9uUGFpcjtcbiAgICB9KSgpO1xuICAgIGV4LkNvbGxpc2lvblBhaXIgPSBDb2xsaXNpb25QYWlyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFsZ2VicmEudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICogQSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGEgY2FtZXJhLiBUaGlzIGNsYXNzIGlzIG1lYW50IHRvIGJlIGV4dGVuZGVkLlxuICAgICogQGNsYXNzIENhbWVyYVxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBlbmdpbmVcbiAgICAqL1xuICAgIHZhciBCYXNlQ2FtZXJhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQmFzZUNhbWVyYSgpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBuZXcgZXguUG9pbnQoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmxlcnAgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IDEgKiAxMDAwOyAvLyA1IHNlY29uZHNcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVycFRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBudWxsO1xuICAgICAgICAgICAgLy9jYW1lcmEgZWZmZWN0c1xuICAgICAgICAgICAgdGhpcy5pc1NoYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2hha2VNYWduaXR1ZGVYID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2hha2VNYWduaXR1ZGVZID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2hha2VEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRTaGFrZVRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFpvb21TY2FsZSA9IDE7XG4gICAgICAgICAgICB0aGlzLm1heFpvb21TY2FsZSA9IDE7XG4gICAgICAgICAgICB0aGlzLnpvb21EdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRab29tVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLnpvb21JbmNyZW1lbnQgPSAwLjAxO1xuICAgICAgICB9XG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmVhc2VJbk91dEN1YmljID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPCAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLT0gMjtcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiAoY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgMikgKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBTZXRzIHRoZSB7eyNjcm9zc0xpbmsgQWN0b3J9fXt7L2Nyb3NzTGlua319IHRvIGZvbGxvdyB3aXRoIHRoZSBjYW1lcmFcbiAgICAgICAgKiBAbWV0aG9kIHNldEFjdG9yVG9Gb2xsb3dcbiAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gZm9sbG93XG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnNldEFjdG9yVG9Gb2xsb3cgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZm9sbG93ID0gYWN0b3I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFJldHVybnMgdGhlIGZvY2FsIHBvaW50IG9mIHRoZSBjYW1lcmFcbiAgICAgICAgKiBAbWV0aG9kIGdldEZvY3VzXG4gICAgICAgICogQHJldHVybnMgUG9pbnRcbiAgICAgICAgKi9cbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZ2V0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb2N1cztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogU2V0cyB0aGUgZm9jYWwgcG9pbnQgb2YgdGhlIGNhbWVyYS4gVGhpcyB2YWx1ZSBjYW4gb25seSBiZSBzZXQgaWYgdGhlcmUgaXMgbm8gYWN0b3IgdG8gYmUgZm9sbG93ZWQuXG4gICAgICAgICogQG1ldGhvZCBzZXRGb2N1c1xuICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGZvY2FsIHBvaW50XG4gICAgICAgICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgZm9jYWwgcG9pbnRcbiAgICAgICAgKi9cbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuc2V0Rm9jdXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvbGxvdyAmJiAhdGhpcy5sZXJwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cy54ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLnkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGVycCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IHRoaXMuZm9jdXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbmV3IGV4LlBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogU2V0cyB0aGUgY2FtZXJhIHRvIHNoYWtlIGF0IHRoZSBzcGVjaWZpZWQgbWFnbml0dWRlcyBmb3IgdGhlIHNwZWNpZmllZCBkdXJhdGlvblxuICAgICAgICAqIEBtZXRob2Qgc2hha2VcbiAgICAgICAgKiBAcGFyYW0gbWFnbml0dWRlWCB7bnVtYmVyfSB0aGUgeCBtYWduaXR1ZGUgb2YgdGhlIHNoYWtlXG4gICAgICAgICogQHBhcmFtIG1hZ25pdHVkZVkge251bWJlcn0gdGhlIHkgbWFnbml0dWRlIG9mIHRoZSBzaGFrZVxuICAgICAgICAqIEBwYXJhbSBkdXJhdGlvbiB7bnVtYmVyfSB0aGUgZHVyYXRpb24gb2YgdGhlIHNoYWtlXG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnNoYWtlID0gZnVuY3Rpb24gKG1hZ25pdHVkZVgsIG1hZ25pdHVkZVksIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2hha2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWCA9IG1hZ25pdHVkZVg7XG4gICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWSA9IG1hZ25pdHVkZVk7XG4gICAgICAgICAgICB0aGlzLnNoYWtlRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogWm9vbXMgdGhlIGNhbWVyYSBpbiBvciBvdXQgYnkgdGhlIHNwZWNpZmllZCBzY2FsZSBvdmVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gICAgICAgICogSWYgbm8gZHVyYXRpb24gaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHpvb20gYnkgYSBzZXQgYW1vdW50IHVudGlsIHRoZSBzY2FsZSBpcyByZWFjaGVkLlxuICAgICAgICAqIEBtZXRob2Qgem9vbVxuICAgICAgICAqIEBwYXJhbSBzY2FsZSB7bnVtYmVyfSB0aGUgc2NhbGUgb2YgdGhlIHpvb21cbiAgICAgICAgKiBAcGFyYW0gW2R1cmF0aW9uXSB7bnVtYmVyfSB0aGUgZHVyYXRpb24gb2YgdGhlIHpvb21cbiAgICAgICAgKi9cbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuem9vbSA9IGZ1bmN0aW9uIChzY2FsZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaXNab29taW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWF4Wm9vbVNjYWxlID0gc2NhbGU7XG4gICAgICAgICAgICB0aGlzLnpvb21EdXJhdGlvbiA9IGR1cmF0aW9uIHwgMDtcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbUluY3JlbWVudCA9IE1hdGguYWJzKHRoaXMubWF4Wm9vbVNjYWxlIC0gdGhpcy5jdXJyZW50Wm9vbVNjYWxlKSAvIGR1cmF0aW9uICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1heFpvb21TY2FsZSA8IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tSW5jcmVtZW50ID0gLTEgKiB0aGlzLnpvb21JbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRab29tU2NhbGUodGhpcy5tYXhab29tU2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50Wm9vbVNjYWxlKHRoaXMubWF4Wm9vbVNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInpvb20gaW5jcmVtZW50OiBcIiArIHRoaXMuem9vbUluY3JlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIGdldHMgdGhlIGN1cnJlbnQgem9vbSBzY2FsZVxuICAgICAgICAqIEBtZXRob2QgZ2V0Wm9vbVxuICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBjdXJyZW50IHpvb20gc2NhbGVcbiAgICAgICAgKi9cbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZ2V0Wm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRab29tU2NhbGU7XG4gICAgICAgIH07XG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnNldEN1cnJlbnRab29tU2NhbGUgPSBmdW5jdGlvbiAoem9vbVNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRab29tU2NhbGUgPSB6b29tU2NhbGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIEFwcGxpZXMgdGhlIHJlbGV2YW50IHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgZ2FtZSBjYW52YXMgdG8gXCJtb3ZlXCIgb3IgYXBwbHkgZWZmZWN0cyB0byB0aGUgQ2FtZXJhXG4gICAgICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlXG4gICAgICAgICovXG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmdldEZvY3VzKCk7XG4gICAgICAgICAgICB2YXIgeFNoYWtlID0gMDtcbiAgICAgICAgICAgIHZhciB5U2hha2UgPSAwO1xuICAgICAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gY3R4LmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSBjdHguY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBuZXdDYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoICogdGhpcy5nZXRab29tKCk7XG4gICAgICAgICAgICB2YXIgbmV3Q2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0ICogdGhpcy5nZXRab29tKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5sZXJwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbiAmJiB0aGlzLl9jYW1lcmFNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueCA8IHRoaXMuX2xlcnBTdGFydC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLnggPSB0aGlzLl9sZXJwU3RhcnQueCAtICh0aGlzLmVhc2VJbk91dEN1YmljKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLnggPSB0aGlzLmVhc2VJbk91dEN1YmljKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycER1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC55IDwgdGhpcy5fbGVycFN0YXJ0LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMueSA9IHRoaXMuX2xlcnBTdGFydC55IC0gKHRoaXMuZWFzZUluT3V0Q3ViaWModGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMueSA9IHRoaXMuZWFzZUluT3V0Q3ViaWModGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueSwgdGhpcy5fbGVycEVuZC55LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RvbmVTaGFraW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2hha2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFNoYWtlVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFrZU1hZ25pdHVkZVggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hha2VNYWduaXR1ZGVZID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWtlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkU2hha2VUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgIHhTaGFrZSA9IChNYXRoLnJhbmRvbSgpICogdGhpcy5zaGFrZU1hZ25pdHVkZVggfCAwKSArIDE7XG4gICAgICAgICAgICAgICAgeVNoYWtlID0gKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNoYWtlTWFnbml0dWRlWSB8IDApICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWZvY3VzLnggKyB4U2hha2UgKyAobmV3Q2FudmFzV2lkdGggLyAyKSwgLWZvY3VzLnkgKyB5U2hha2UgKyAobmV3Q2FudmFzSGVpZ2h0IC8gMikpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEb25lWm9vbWluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRab29tVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy56b29tRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFpvb21TY2FsZSh0aGlzLm1heFpvb21TY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRab29tVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRab29tU2NhbGUodGhpcy5nZXRab29tKCkgKyB0aGlzLnpvb21JbmNyZW1lbnQgKiBkZWx0YSAvIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnNjYWxlKHRoaXMuZ2V0Wm9vbSgpLCB0aGlzLmdldFpvb20oKSk7XG4gICAgICAgIH07XG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuZ2V0Rm9jdXMoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMoZm9jdXMueCwgZm9jdXMueSwgMTUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH07XG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmlzRG9uZVNoYWtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISh0aGlzLmlzU2hha2luZykgfHwgKHRoaXMuZWxhcHNlZFNoYWtlVGltZSA+PSB0aGlzLnNoYWtlRHVyYXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5pc0RvbmVab29taW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbUR1cmF0aW9uICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZWxhcHNlZFpvb21UaW1lID49IHRoaXMuem9vbUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFpvb21TY2FsZSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmN1cnJlbnRab29tU2NhbGUgPD0gdGhpcy5tYXhab29tU2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmN1cnJlbnRab29tU2NhbGUgPj0gdGhpcy5tYXhab29tU2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJhc2VDYW1lcmE7XG4gICAgfSkoKTtcbiAgICBleC5CYXNlQ2FtZXJhID0gQmFzZUNhbWVyYTtcbiAgICAvKipcbiAgICAqIEFuIGV4dGVuc2lvbiBvZiBCYXNlQ2FtZXJhIHRoYXQgaXMgbG9ja2VkIHZlcnRpY2FsbHk7IGl0IHdpbGwgb25seSBtb3ZlIHNpZGUgdG8gc2lkZS5cbiAgICAqIEBjbGFzcyBTaWRlQ2FtZXJhXG4gICAgKiBAZXh0ZW5kcyBCYXNlQ2FtZXJhXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVuZ2luZVxuICAgICovXG4gICAgdmFyIFNpZGVDYW1lcmEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU2lkZUNhbWVyYSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2lkZUNhbWVyYSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFNpZGVDYW1lcmEucHJvdG90eXBlLmdldEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9sbG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludCh0aGlzLmZvbGxvdy54ICsgdGhpcy5mb2xsb3cuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuZm9jdXMueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNpZGVDYW1lcmE7XG4gICAgfSkoQmFzZUNhbWVyYSk7XG4gICAgZXguU2lkZUNhbWVyYSA9IFNpZGVDYW1lcmE7XG4gICAgLyoqXG4gICAgKiBBbiBleHRlbnNpb24gb2YgQmFzZUNhbWVyYSB0aGF0IGlzIGxvY2tlZCB0byBhbiBhY3RvciBvciBmb2NhbCBwb2ludDsgdGhlIGFjdG9yIHdpbGwgYXBwZWFyIGluIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbi5cbiAgICAqIEBjbGFzcyBUb3BDYW1lcmFcbiAgICAqIEBleHRlbmRzIEJhc2VDYW1lcmFcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW5naW5lXG4gICAgKi9cbiAgICB2YXIgVG9wQ2FtZXJhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFRvcENhbWVyYSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVG9wQ2FtZXJhKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgVG9wQ2FtZXJhLnByb3RvdHlwZS5nZXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbGxvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQodGhpcy5mb2xsb3cueCArIHRoaXMuZm9sbG93LmdldFdpZHRoKCkgLyAyLCB0aGlzLmZvbGxvdy55ICsgdGhpcy5mb2xsb3cuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvY3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVG9wQ2FtZXJhO1xuICAgIH0pKEJhc2VDYW1lcmEpO1xuICAgIGV4LlRvcENhbWVyYSA9IFRvcENhbWVyYTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ2xhc3MudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRpbWVyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb2xsaXNpb24vTmFpdmVDb2xsaXNpb25SZXNvbHZlci50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb2xsaXNpb24vRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb2xsaXNpb25QYWlyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDYW1lcmEudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEFjdG9ycyBhcmUgY29tcG9zZWQgdG9nZXRoZXIgaW50byBncm91cGluZ3MgY2FsbGVkIFNjZW5lcyBpblxuICAgICAqIEV4Y2FsaWJ1ci4gVGhlIG1ldGFwaG9yIG1vZGVscyB0aGUgc2FtZSBpZGVhIGJlaGluZCByZWFsIHdvcmxkXG4gICAgICogYWN0b3JzIGluIGEgc2NlbmUuIE9ubHkgYWN0b3JzIGluIHNjZW5lcyB3aWxsIGJlIHVwZGF0ZWQgYW5kIGRyYXduLlxuICAgICAqIEBjbGFzcyBTY2VuZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBTY2VuZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTY2VuZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2NlbmUoZW5naW5lKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGFjdG9ycyBpbiB0aGUgY3VycmVudCBzY2VuZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IGNoaWxkcmVuIHtBY3RvcltdfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICB0aGlzLnRpbGVNYXBzID0gW107XG4gICAgICAgICAgICB0aGlzLnVpQWN0b3JzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25SZXNvbHZlciA9IG5ldyBleC5EeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9raWxsUXVldWUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IGV4LkJhc2VDYW1lcmEoKTtcbiAgICAgICAgICAgIGlmIChlbmdpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS5zZXRGb2N1cyhlbmdpbmUud2lkdGggLyAyLCBlbmdpbmUuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIG1hZGUgYWN0aXZlIGFuZCBzdGFydGVkLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4sXG4gICAgICAgICAqIHRoaXMgaXMgd2hlcmUgeW91IHNob3VsZCBzZXR1cCBhbnkgRE9NIFVJIG9yIGV2ZW50IGhhbmRsZXJzIG5lZWRlZCBmb3IgdGhlIHNjZW5lLlxuICAgICAgICAgKiBAbWV0aG9kIG9uQWN0aXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBtYWRlIHRyYW5zaXRpb25lZCBhd2F5IGZyb20gYW5kIHN0b3BwZWQuIEl0IGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbixcbiAgICAgICAgICogdGhpcyBpcyB3aGVyZSB5b3Ugc2hvdWxkIGNsZWFudXAgYW55IERPTSBVSSBvciBldmVudCBoYW5kbGVycyBuZWVkZWQgZm9yIHRoZSBzY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBvbkRlYWN0aXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIG9mIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcbiAgICAgICAgICogb3ZlcnJpZGRlbi4gVGhpcyBpcyB3aGVyZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZCBhY3RvcnMgc2hvdWxkIHRha2UgcGxhY2UuXG4gICAgICAgICAqIEBtZXRob2Qgb25Jbml0aWFsaXplXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5vbkluaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gYWxsIGFjdG9ycyBpbiB0aGUgc2NlbmVcbiAgICAgICAgICogQG1ldGhvZCBwdWJsaXNoXG4gICAgICAgICAqIEBwYXJhbSBldmVudFR5cGUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IHtHYW1lRXZlbnR9IFRoZSBldmVudCBvYmplY3QgdG8gc2VuZFxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBldmVudCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgIGFjdG9yLnRyaWdnZXJFdmVudChldmVudFR5cGUsIGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBhbGwgdGhlIGFjdG9ycyBhbmQgdGltZXJzIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBFbmdpbmUuXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IEVuZ2luZVxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplKGVuZ2luZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaCgnaW5pdGlhbGl6ZScsIG5ldyBleC5Jbml0aWFsaXplRXZlbnQoZW5naW5lKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVpQWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHVpKSB7XG4gICAgICAgICAgICAgICAgdWkudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRpbGVNYXBzLmZvckVhY2goZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgY20udXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSdW4gY29sbGlzaW9uIHJlc29sdXRpb24gc3RyYXRlZ3lcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsaXNpb25SZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblJlc29sdmVyLnVwZGF0ZSh0aGlzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25SZXNvbHZlci5ldmFsdWF0ZSh0aGlzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhY3RvcnMgZnJvbSBzY2VuZSBncmFwaCBhZnRlciBiZWluZyBraWxsZWRcbiAgICAgICAgICAgIHZhciBhY3RvckluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9raWxsUXVldWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY3RvckluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKHRoaXMuX2tpbGxRdWV1ZVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdG9ySW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShhY3RvckluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9raWxsUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aW1lcnMgaW4gdGhlIGNhbmNlbCBxdWV1ZSBiZWZvcmUgdXBkYXRpbmcgdGhlbVxuICAgICAgICAgICAgdmFyIHRpbWVySW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2NhbmNlbFF1ZXVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcih0aGlzLl9jYW5jZWxRdWV1ZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCB0aW1lcnMgdXBkYXRpbmcgdGltZXJzXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMgPSB0aGlzLl90aW1lcnMuZmlsdGVyKGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgICAgIHRpbWVyLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aW1lci5jb21wbGV0ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgYWxsIHRoZSBhY3RvcnMgaW4gdGhlIFNjZW5lLiBDYWxsZWQgYnkgdGhlIEVuZ2luZS5cbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW1lcmEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGUoY3R4LCBkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRpbGVNYXBzLmZvckVhY2goZnVuY3Rpb24gKGNtKSB7XG4gICAgICAgICAgICAgICAgY20uZHJhdyhjdHgsIGRlbHRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgICAgdmFyIGVuZCA9IDA7XG4gICAgICAgICAgICB2YXIgYWN0b3I7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFjdG9yID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRyYXcgYWN0b3JzIHRoYXQgYXJlIHZpc2libGVcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRyYXcoY3R4LCBkZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lICYmIHRoaXMuZW5naW5lLmlzRGVidWcpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAneWVsbG93JztcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHRoaXMudWlBY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAodWkpIHtcbiAgICAgICAgICAgICAgICBpZiAodWkudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB1aS5kcmF3KGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lICYmIHRoaXMuZW5naW5lLmlzRGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVpQWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHVpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgYWxsIHRoZSBhY3RvcnMnIGRlYnVnIGluZm9ybWF0aW9uIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBFbmdpbmUuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgICAgICBtYXAuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICBhY3Rvci5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdG9kbyBwb3NzaWJseSBlbmFibGUgdGhpcyB3aXRoIGV4Y2FsaWJ1ciBmbGFncyBmZWF0dXJlcz9cbiAgICAgICAgICAgIC8vdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIuZGVidWdEcmF3KGN0eCwgMjApO1xuICAgICAgICAgICAgLy90aGlzLmNhbWVyYS5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5VSUFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRVSUFjdG9yKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LkFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaW1lcihlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbGVNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbGVNYXAoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5VSUFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVVSUFjdG9yKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LkFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIucmVtb3ZlKGVudGl0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcihlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlRpbGVNYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGVNYXAoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gYWN0b3IgdG8gYWN0IGFzIGEgcGllY2Ugb2YgVUksIG1lYW5pbmcgaXQgaXMgYWx3YXlzIHBvc2l0aW9uZWRcbiAgICAgICAgICogaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBVSSBhY3RvcnMgZG8gbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnNcbiAgICAgICAgICogQG1ldGhvZCBhZGRVSUFjdG9yXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkVUlBY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5wdXNoKGFjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gYWN0b3IgYXMgYSBwaWVjIG9mIFVJXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlVUlBY3RvclxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZVVJQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMudWlBY3RvcnMuaW5kZXhPZihhY3Rvcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMudWlBY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gYWN0b3IgdG8gdGhlIFNjZW5lLCBvbmNlIHRoaXMgaXMgZG9uZSB0aGUgYWN0b3Igd2lsbCBiZSBkcmF3biBhbmQgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25SZXNvbHZlci5yZWdpc3RlcihhY3Rvcik7XG4gICAgICAgICAgICBhY3Rvci5zY2VuZSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYWN0b3IpO1xuICAgICAgICAgICAgYWN0b3IucGFyZW50ID0gdGhpcy5hY3RvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBUaWxlTWFwIHRvIHRoZSBTY2VuZSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIFRpbGVNYXAgd2lsbCBiZSBkcmF3biBhbmQgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRUaWxlTWFwXG4gICAgICAgICAqIEBwYXJhbSB0aWxlTWFwIHtUaWxlTWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZFRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xuICAgICAgICAgICAgdGhpcy50aWxlTWFwcy5wdXNoKHRpbGVNYXApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIFRpbGVNYXAgZnJvbSB0aGUgU2NlbmUsIGl0IHdpbGxubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVUaWxlTWFwXG4gICAgICAgICAqIEBwYXJhbSB0aWxlTWFwIHtUaWxlTWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZVRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy50aWxlTWFwcy5pbmRleE9mKHRpbGVNYXApO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVNYXBzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGZyb20gdGhlIFNjZW5lLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0byByZW1vdmVcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIucmVtb3ZlKGFjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuX2tpbGxRdWV1ZS5wdXNoKGFjdG9yKTtcbiAgICAgICAgICAgIGFjdG9yLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgdGltZXIgdG8gdGhlIFNjZW5lXG4gICAgICAgICAqIEBtZXRob2QgYWRkVGltZXJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyIHtUaW1lcn0gVGhlIHRpbWVyIHRvIGFkZFxuICAgICAgICAgKiBAcmV0dXJucyBUaW1lclxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmFkZFRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMucHVzaCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lci5zY2VuZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgdGltZXIgdG8gdGhlIFNjZW5lLCBjYW4gYmUgZGFuZ2Vyb3VzXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlVGltZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHRpbWVyIHtUaW1lcn0gVGhlIHRpbWVyIHRvIHJlbW92ZVxuICAgICAgICAgKiBAcmV0dXJucyBUaW1lclxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZVRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX3RpbWVycy5pbmRleE9mKHRpbWVyKTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWxzIGEgdGltZXIsIHJlbW92aW5nIGl0IGZyb20gdGhlIHNjZW5lIG5pY2VseVxuICAgICAgICAgKiBAbWV0aG9kIGNhbmNlbFRpbWVyXG4gICAgICAgICAqIEBwYXJhbSB0aW1lciB7VGltZXJ9IFRoZSB0aW1lciB0byBjYW5jZWxcbiAgICAgICAgICogQHJldHVybnMgVGltZXJcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5jYW5jZWxUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUucHVzaCh0aW1lcik7XG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyB3aGV0aGVyIGEgdGltZXIgaXMgYWN0aXZlIGluIHRoZSBzY2VuZVxuICAgICAgICAgKiBAbWV0aG9kIGlzVGltZXJBY3RpdmVcbiAgICAgICAgICogQHBhcmFtIHRpbWVyIHtUaW1lcn1cbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmlzVGltZXJBY3RpdmUgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fdGltZXJzLmluZGV4T2YodGltZXIpID4gLTEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2NlbmU7XG4gICAgfSkoZXguQ2xhc3MpO1xuICAgIGV4LlNjZW5lID0gU2NlbmU7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFsZ2VicmEudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVuZ2luZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBJbnRlcm5hbDtcbiAgICAoZnVuY3Rpb24gKEludGVybmFsKSB7XG4gICAgICAgIHZhciBBY3Rpb25zO1xuICAgICAgICAoZnVuY3Rpb24gKEFjdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBFYXNlVG8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEVhc2VUbyhhY3RvciwgeCwgeSwgZHVyYXRpb24sIGVhc2luZ0Zjbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFzaW5nRmNuID0gZWFzaW5nRmNuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxICogMTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBleC5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBleC5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbmV3IGV4LlBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBFYXNlVG8ucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBuZXcgZXguUG9pbnQodGhpcy5hY3Rvci54LCB0aGlzLmFjdG9yLnkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xlcnBTdGFydC50b1ZlY3RvcigpLmRpc3RhbmNlKHRoaXMuX2xlcnBFbmQudG9WZWN0b3IoKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBFYXNlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ggPSB0aGlzLmFjdG9yLng7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdZID0gdGhpcy5hY3Rvci55O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudExlcnBUaW1lIDwgdGhpcy5fbGVycER1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC54IDwgdGhpcy5fbGVycFN0YXJ0LngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdYID0gdGhpcy5fbGVycFN0YXJ0LnggLSAodGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC54KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ggPSB0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC55IDwgdGhpcy5fbGVycFN0YXJ0LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdZID0gdGhpcy5fbGVycFN0YXJ0LnkgLSAodGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1kgPSB0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnggPSBuZXdYO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci55ID0gbmV3WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueCA9IHRoaXMuX2xlcnBFbmQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IHRoaXMuX2xlcnBFbmQueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChuZXcgZXguVmVjdG9yKGFjdG9yLngsIGFjdG9yLnkpKS5kaXN0YW5jZSh0aGlzLl9sZXJwU3RhcnQudG9WZWN0b3IoKSkgPj0gdGhpcy5fZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBFYXNlVG8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRWFzZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBFYXNlVG87XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5FYXNlVG8gPSBFYXNlVG87XG4gICAgICAgICAgICB2YXIgTW92ZVRvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNb3ZlVG8oYWN0b3IsIGRlc3R4LCBkZXN0eSwgc3BlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgZXguVmVjdG9yKGRlc3R4LCBkZXN0eSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTW92ZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgZXguVmVjdG9yKHRoaXMuYWN0b3IueCwgdGhpcy5hY3Rvci55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLnN0YXJ0LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyID0gdGhpcy5lbmQubWludXModGhpcy5zdGFydCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLmRpci5zY2FsZSh0aGlzLnNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IG0ueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IG0ueTtcbiAgICAgICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5sb2coXCJQb3MgeDogXCIgKyB0aGlzLmFjdG9yLnggK1wiICB5OlwiICsgdGhpcy5hY3Rvci55LCBMb2cuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnggPSB0aGlzLmVuZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci55ID0gdGhpcy5lbmQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1vdmVUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAobmV3IGV4LlZlY3RvcihhY3Rvci54LCBhY3Rvci55KSkuZGlzdGFuY2UodGhpcy5zdGFydCkgPj0gdGhpcy5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1vdmVUby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1vdmVUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNb3ZlVG87XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5Nb3ZlVG8gPSBNb3ZlVG87XG4gICAgICAgICAgICB2YXIgTW92ZUJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNb3ZlQnkoYWN0b3IsIGRlc3R4LCBkZXN0eSwgdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBleC5WZWN0b3IoZGVzdHgsIGRlc3R5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXguTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoXCJBdHRlbXB0ZWQgdG8gbW92ZUJ5IHRpbWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gOiBcIiArIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1vdmUgaW4gdGltZSA8PSAwXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE1vdmVCeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IGV4LlZlY3Rvcih0aGlzLmFjdG9yLngsIHRoaXMuYWN0b3IueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdGhpcy5zdGFydC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuZW5kLm1pbnVzKHRoaXMuc3RhcnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHRoaXMuZGlzdGFuY2UgLyAodGhpcy50aW1lIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLmRpci5zY2FsZSh0aGlzLnNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IG0ueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IG0ueTtcbiAgICAgICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5sb2coXCJQb3MgeDogXCIgKyB0aGlzLmFjdG9yLnggK1wiICB5OlwiICsgdGhpcy5hY3Rvci55LCBMb2cuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnggPSB0aGlzLmVuZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci55ID0gdGhpcy5lbmQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1vdmVCeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAobmV3IGV4LlZlY3RvcihhY3Rvci54LCBhY3Rvci55KSkuZGlzdGFuY2UodGhpcy5zdGFydCkgPj0gdGhpcy5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1vdmVCeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1vdmVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNb3ZlQnk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5Nb3ZlQnkgPSBNb3ZlQnk7XG4gICAgICAgICAgICB2YXIgRm9sbG93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGb2xsb3coYWN0b3IsIGFjdG9yVG9Gb2xsb3csIGZvbGxvd0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3JUb0ZvbGxvdyA9IGFjdG9yVG9Gb2xsb3c7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBleC5WZWN0b3IodGhpcy5hY3Rvci54LCB0aGlzLmFjdG9yLnkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBleC5WZWN0b3IoYWN0b3JUb0ZvbGxvdy54LCBhY3RvclRvRm9sbG93LnkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heGltdW1EaXN0YW5jZSA9IChmb2xsb3dEaXN0YW5jZSAhPSB1bmRlZmluZWQpID8gZm9sbG93RGlzdGFuY2UgOiB0aGlzLmN1cnJlbnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRm9sbG93LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5jdXJyZW50LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyID0gdGhpcy5lbmQubWludXModGhpcy5jdXJyZW50KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0b3JUb0ZvbGxvd1NwZWVkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuYWN0b3JUb0ZvbGxvdy5keCwgMikgKyBNYXRoLnBvdyh0aGlzLmFjdG9yVG9Gb2xsb3cuZHksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yVG9Gb2xsb3dTcGVlZCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gYWN0b3JUb0ZvbGxvd1NwZWVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5hY3Rvci54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuYWN0b3IueTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQueCA9IHRoaXMuYWN0b3JUb0ZvbGxvdy54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZC55ID0gdGhpcy5hY3RvclRvRm9sbG93Lnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5jdXJyZW50LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmVuZC5taW51cyh0aGlzLmN1cnJlbnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXN0YW5jZUJldHdlZW4gPj0gdGhpcy5tYXhpbXVtRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5kaXIuc2NhbGUodGhpcy5zcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gbS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IG0ueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBuZXZlciBvY2N1clxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gdGhpcy5lbmQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IHRoaXMuZW5kLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGb2xsb3cucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGb2xsb3cucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdG9yIGZvbGxvd2luZyBzaG91bGQgbmV2ZXIgc3RvcCB1bmxlc3Mgc3BlY2lmaWVkIHRvIGRvIHNvXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRm9sbG93LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvbGxvdztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLkZvbGxvdyA9IEZvbGxvdztcbiAgICAgICAgICAgIHZhciBNZWV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNZWV0KGFjdG9yLCBhY3RvclRvTWVldCwgc3BlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvclRvTWVldCA9IGFjdG9yVG9NZWV0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgZXguVmVjdG9yKHRoaXMuYWN0b3IueCwgdGhpcy5hY3Rvci55KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgZXguVmVjdG9yKGFjdG9yVG9NZWV0LngsIGFjdG9yVG9NZWV0LnkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWVkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE1lZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZUJldHdlZW4gPSB0aGlzLmN1cnJlbnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmVuZC5taW51cyh0aGlzLmN1cnJlbnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvclRvTWVldFNwZWVkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuYWN0b3JUb01lZXQuZHgsIDIpICsgTWF0aC5wb3codGhpcy5hY3RvclRvTWVldC5keSwgMikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGFjdG9yVG9NZWV0U3BlZWQgIT0gMCkgJiYgKCF0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBhY3RvclRvTWVldFNwZWVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5hY3Rvci54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuYWN0b3IueTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQueCA9IHRoaXMuYWN0b3JUb01lZXQueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQueSA9IHRoaXMuYWN0b3JUb01lZXQueTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZUJldHdlZW4gPSB0aGlzLmN1cnJlbnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuZW5kLm1pbnVzKHRoaXMuY3VycmVudCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5kaXIuc2NhbGUodGhpcy5zcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSBtLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSBtLnk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibWVldGluZyBpcyBjb21wbGV0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gdGhpcy5lbmQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueSA9IHRoaXMuZW5kLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNZWV0LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLmRpc3RhbmNlQmV0d2VlbiA8PSAxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1lZXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNZWV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1lZXQ7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5NZWV0ID0gTWVldDtcbiAgICAgICAgICAgIHZhciBSb3RhdGVUbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUm90YXRlVG8oYWN0b3IsIGFuZ2xlUmFkaWFucywgc3BlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQgPSBhbmdsZVJhZGlhbnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuYWN0b3Iucm90YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gTWF0aC5hYnModGhpcy5lbmQgLSB0aGlzLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gdGhpcy5zcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5sb2coXCJQb3MgeDogXCIgKyB0aGlzLmFjdG9yLnggK1wiICB5OlwiICsgdGhpcy5hY3Rvci55LCBMb2cuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJvdGF0aW9uID0gdGhpcy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKE1hdGguYWJzKHRoaXMuYWN0b3Iucm90YXRpb24gLSB0aGlzLnN0YXJ0KSA+PSB0aGlzLmRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnJ4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBSb3RhdGVUbztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlJvdGF0ZVRvID0gUm90YXRlVG87XG4gICAgICAgICAgICB2YXIgUm90YXRlQnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFJvdGF0ZUJ5KGFjdG9yLCBhbmdsZVJhZGlhbnMsIHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQgPSBhbmdsZVJhZGlhbnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSAodGhpcy5lbmQgLSB0aGlzLmFjdG9yLnJvdGF0aW9uKSAvIHRpbWUgKiAxMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5hY3Rvci5yb3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBNYXRoLmFicyh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucnggPSB0aGlzLnNwZWVkO1xuICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIlBvcyB4OiBcIiArIHRoaXMuYWN0b3IueCArXCIgIHk6XCIgKyB0aGlzLmFjdG9yLnksIExvZy5ERUJVRyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iucm90YXRpb24gPSB0aGlzLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucnggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoTWF0aC5hYnModGhpcy5hY3Rvci5yb3RhdGlvbiAtIHRoaXMuc3RhcnQpID49IHRoaXMuZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucnggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJvdGF0ZUJ5O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuUm90YXRlQnkgPSBSb3RhdGVCeTtcbiAgICAgICAgICAgIHZhciBTY2FsZVRvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBTY2FsZVRvKGFjdG9yLCBzY2FsZVgsIHNjYWxlWSwgc3BlZWRYLCBzcGVlZFkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRYID0gc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFkgPSBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWRYID0gc3BlZWRYO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkWSA9IHNwZWVkWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgU2NhbGVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0WCA9IHRoaXMuYWN0b3Iuc2NhbGUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRZID0gdGhpcy5hY3Rvci5zY2FsZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZVggPSBNYXRoLmFicyh0aGlzLmVuZFggLSB0aGlzLnN0YXJ0WCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlWSA9IE1hdGguYWJzKHRoaXMuZW5kWSAtIHRoaXMuc3RhcnRZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnggLSB0aGlzLnN0YXJ0WCkgPj0gdGhpcy5kaXN0YW5jZVgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uWCA9IHRoaXMuZW5kWSA8IHRoaXMuc3RhcnRZID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IHRoaXMuc3BlZWRYICogZGlyZWN0aW9uWDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKE1hdGguYWJzKHRoaXMuYWN0b3Iuc2NhbGUueSAtIHRoaXMuc3RhcnRZKSA+PSB0aGlzLmRpc3RhbmNlWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGhpcy5lbmRZIDwgdGhpcy5zdGFydFkgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gdGhpcy5zcGVlZFkgKiBkaXJlY3Rpb25ZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5sb2coXCJQb3MgeDogXCIgKyB0aGlzLmFjdG9yLnggK1wiICB5OlwiICsgdGhpcy5hY3Rvci55LCBMb2cuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnNjYWxlLnggPSB0aGlzLmVuZFg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnNjYWxlLnkgPSB0aGlzLmVuZFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICgoTWF0aC5hYnModGhpcy5hY3Rvci5zY2FsZS55IC0gdGhpcy5zdGFydFgpID49IHRoaXMuZGlzdGFuY2VYKSAmJiAoTWF0aC5hYnModGhpcy5hY3Rvci5zY2FsZS55IC0gdGhpcy5zdGFydFkpID49IHRoaXMuZGlzdGFuY2VZKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2NhbGVUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBTY2FsZVRvO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuU2NhbGVUbyA9IFNjYWxlVG87XG4gICAgICAgICAgICB2YXIgU2NhbGVCeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2NhbGVCeShhY3Rvciwgc2NhbGVYLCBzY2FsZVksIHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRYID0gc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFkgPSBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWRYID0gKHRoaXMuZW5kWCAtIHRoaXMuYWN0b3Iuc2NhbGUueCkgLyB0aW1lICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZFkgPSAodGhpcy5lbmRZIC0gdGhpcy5hY3Rvci5zY2FsZS55KSAvIHRpbWUgKiAxMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRYID0gdGhpcy5hY3Rvci5zY2FsZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFkgPSB0aGlzLmFjdG9yLnNjYWxlLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlWCA9IE1hdGguYWJzKHRoaXMuZW5kWCAtIHRoaXMuc3RhcnRYKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VZID0gTWF0aC5hYnModGhpcy5lbmRZIC0gdGhpcy5zdGFydFkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25YID0gdGhpcy5lbmRYIDwgdGhpcy5zdGFydFggPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGhpcy5lbmRZIDwgdGhpcy5zdGFydFkgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSB0aGlzLnNwZWVkWCAqIGRpcmVjdGlvblg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSB0aGlzLnNwZWVkWSAqIGRpcmVjdGlvblk7XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zY2FsZS54ID0gdGhpcy5lbmRYO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zY2FsZS55ID0gdGhpcy5lbmRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoKE1hdGguYWJzKHRoaXMuYWN0b3Iuc2NhbGUueCAtIHRoaXMuc3RhcnRYKSA+PSB0aGlzLmRpc3RhbmNlWCkgJiYgKE1hdGguYWJzKHRoaXMuYWN0b3Iuc2NhbGUueSAtIHRoaXMuc3RhcnRZKSA+PSB0aGlzLmRpc3RhbmNlWSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlQnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2NhbGVCeTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlNjYWxlQnkgPSBTY2FsZUJ5O1xuICAgICAgICAgICAgdmFyIERlbGF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBEZWxheShhY3RvciwgZGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRGVsYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5hY3Rvci55O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGVsYXkucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuZWxhcHNlZFRpbWUgPj0gdGhpcy5kZWxheSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEZWxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEZWxheS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVsYXk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5EZWxheSA9IERlbGF5O1xuICAgICAgICAgICAgdmFyIEJsaW5rID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCbGluayhhY3RvciwgdGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bUJsaW5rcyA9PT0gdm9pZCAwKSB7IG51bUJsaW5rcyA9IDE7IH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lVmlzaWJsZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZU5vdFZpc2libGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVWaXNpYmxlID0gdGltZVZpc2libGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZU5vdFZpc2libGUgPSB0aW1lTm90VmlzaWJsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9ICh0aW1lVmlzaWJsZSArIHRpbWVOb3RWaXNpYmxlKSAqIG51bUJsaW5rcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQmxpbmsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG90YWxUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3Rvci52aXNpYmxlICYmIHRoaXMuZWxhcHNlZFRpbWUgPj0gdGhpcy50aW1lVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0b3IudmlzaWJsZSAmJiB0aGlzLmVsYXBzZWRUaW1lID49IHRoaXMudGltZU5vdFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbGluay5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy50b3RhbFRpbWUgPj0gdGhpcy5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbGluay5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCbGluay5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBCbGluaztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLkJsaW5rID0gQmxpbms7XG4gICAgICAgICAgICB2YXIgRmFkZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRmFkZShhY3RvciwgZW5kT3BhY2l0eSwgc3BlZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBseWVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRPcGFjaXR5ID0gZW5kT3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kT3BhY2l0eSA8IGFjdG9yLm9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbHllciA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEZhZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5vcGFjaXR5ICs9IHRoaXMubXVsdGlwbHllciAqIChNYXRoLmFicyh0aGlzLmFjdG9yLm9wYWNpdHkgLSB0aGlzLmVuZE9wYWNpdHkpICogZGVsdGEpIC8gdGhpcy5zcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkIC09IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhcImFjdG9yIG9wYWNpdHk6IFwiICsgdGhpcy5hY3Rvci5vcGFjaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5vcGFjaXR5ID0gdGhpcy5lbmRPcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGYWRlLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChNYXRoLmFicyh0aGlzLmFjdG9yLm9wYWNpdHkgLSB0aGlzLmVuZE9wYWNpdHkpIDwgMC4wNSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGYWRlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZhZGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFkZTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLkZhZGUgPSBGYWRlO1xuICAgICAgICAgICAgdmFyIERpZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRGllKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIERpZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iua2lsbCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIERpZS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEaWUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEaWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIERpZTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLkRpZSA9IERpZTtcbiAgICAgICAgICAgIHZhciBDYWxsTWV0aG9kID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBDYWxsTWV0aG9kKGFjdG9yLCBtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGhvZC5jYWxsKHRoaXMuX2FjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNCZWVuQ2FsbGVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIENhbGxNZXRob2Q7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5DYWxsTWV0aG9kID0gQ2FsbE1ldGhvZDtcbiAgICAgICAgICAgIHZhciBSZXBlYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFJlcGVhdChhY3RvciwgcmVwZWF0LCBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlID0gbmV3IEFjdGlvblF1ZXVlKGFjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBlYXQgPSByZXBlYXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxSZXBlYXQgPSByZXBlYXQ7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGlvblF1ZXVlLmFkZChhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUmVwZWF0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5hY3Rvci54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLmFjdG9yLnk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY3Rpb25RdWV1ZS5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVwZWF0LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5yZXBlYXQgPD0gMCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSZXBlYXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVwZWF0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBlYXQgPSB0aGlzLm9yaWdpbmFsUmVwZWF0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlcGVhdDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLlJlcGVhdCA9IFJlcGVhdDtcbiAgICAgICAgICAgIHZhciBSZXBlYXRGb3JldmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSZXBlYXRGb3JldmVyKGFjdG9yLCBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlID0gbmV3IEFjdGlvblF1ZXVlKGFjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWN0aW9uUXVldWUuYWRkKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5hY3Rvci54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLmFjdG9yLnk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGlvblF1ZXVlLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBSZXBlYXRGb3JldmVyO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuUmVwZWF0Rm9yZXZlciA9IFJlcGVhdEZvcmV2ZXI7XG4gICAgICAgICAgICB2YXIgQWN0aW9uUXVldWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEFjdGlvblF1ZXVlKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fYWN0aW9ucy5pbmRleE9mKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5jbGVhckFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5nZXRBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5jb25jYXQodGhpcy5fY29tcGxldGVkQWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucyA9IHRoaXMuZ2V0QWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSB0aGlzLl9hY3Rpb25zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbi51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBY3Rpb24uaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiQWN0aW9uIGNvbXBsZXRlIVwiLCBMb2cuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMucHVzaCh0aGlzLl9hY3Rpb25zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQWN0aW9uUXVldWU7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5BY3Rpb25RdWV1ZSA9IEFjdGlvblF1ZXVlO1xuICAgICAgICB9KShBY3Rpb25zID0gSW50ZXJuYWwuQWN0aW9ucyB8fCAoSW50ZXJuYWwuQWN0aW9ucyA9IHt9KSk7XG4gICAgfSkoSW50ZXJuYWwgPSBleC5JbnRlcm5hbCB8fCAoZXguSW50ZXJuYWwgPSB7fSkpO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgRWFzaW5nRnVuY3Rpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRWFzaW5nRnVuY3Rpb25zKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgZWFzZUluUXVhZDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0IH0sXG4gICAgICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiAoMiAtIHQpIH0sXG4gICAgICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0IH0sXG4gICAgICAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAgIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAoLS10KSAqIHQgKiB0ICsgMSB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAgIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA8IC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMSB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgICBlYXNlSW5RdWFydDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogdCAqIHQgfSxcbiAgICAgICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgICAgIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSAoLS10KSAqIHQgKiB0ICogdCB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAgIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA8IC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqICgtLXQpICogdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAgIGVhc2VJblF1aW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQgfSxcbiAgICAgICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgICAgIGVhc2VPdXRRdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgKyAoLS10KSAqIHQgKiB0ICogdCAqIHQgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgPCAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAoLS10KSAqIHQgKiB0ICogdCAqIHQgfVxuICAgICAgICAqL1xuICAgICAgICBFYXNpbmdGdW5jdGlvbnMuTGluZWFyID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAvIGR1cmF0aW9uICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJblF1YWQgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgLy9lbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VPdXRRdWFkID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIC1lbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0UXVhZCA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICBjdXJyZW50VGltZS0tO1xuICAgICAgICAgICAgcmV0dXJuIC1lbmRWYWx1ZSAvIDIgKiAoY3VycmVudFRpbWUgKiAoY3VycmVudFRpbWUgLSAyKSAtIDEpICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJbkN1YmljID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlT3V0Q3ViaWMgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDEpICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPCAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLT0gMjtcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiAoY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgMikgKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRWFzaW5nRnVuY3Rpb25zO1xuICAgIH0pKCk7XG4gICAgZXguRWFzaW5nRnVuY3Rpb25zID0gRWFzaW5nRnVuY3Rpb25zO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJbnRlcmZhY2VzL0lEcmF3YWJsZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9kdWxlcy9Nb3ZlbWVudE1vZHVsZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9kdWxlcy9PZmZzY3JlZW5DdWxsaW5nTW9kdWxlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJNb2R1bGVzL0NhcHR1cmVQb2ludGVyTW9kdWxlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJNb2R1bGVzL0NvbGxpc2lvbkRldGVjdGlvbk1vZHVsZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uL1NpZGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFsZ2VicmEudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlV0aWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRpbGVNYXAudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbGxpc2lvbi9Cb3VuZGluZ0JveC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2NlbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdGlvbi50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRWFzaW5nRnVuY3Rpb25zLnRzXCIvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHR5cGVzIG9mIGNvbGxpc2lvbnMgYWN0b3JzIGNhbiBwYXJ0aWNpcGF0ZSBpblxuICAgICAqIEBjbGFzcyBDb2xsaXNpb25UeXBlXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChDb2xsaXNpb25UeXBlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgUHJldmVudENvbGxpc2lvbiBzZXR0aW5nIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBhbnlcbiAgICAgICAgICogY29sbGlzaW9ucyBhbmQgZG8gbm90IHJhaXNlIGNvbGxpc2lvbiBldmVudHMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBQcmV2ZW50Q29sbGlzaW9uIHtDb2xsaXNpb25UeXBlfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJQcmV2ZW50Q29sbGlzaW9uXCJdID0gMF0gPSBcIlByZXZlbnRDb2xsaXNpb25cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBQYXNzaXZlIHNldHRpbmcgb25seSByYWlzZSBjb2xsaXNpb24gZXZlbnRzLCBidXQgYXJlIG5vdFxuICAgICAgICAgKiBpbmZsdWVuY2VkIG9yIG1vdmVkIGJ5IG90aGVyIGFjdG9ycyBhbmQgZG8gbm90IGluZmx1ZW5jZSBvciBtb3ZlIG90aGVyIGFjdG9ycy5cbiAgICAgICAgICogQHByb3BlcnR5IFBhc3NpdmUge0NvbGxpc2lvblR5cGV9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIlBhc3NpdmVcIl0gPSAxXSA9IFwiUGFzc2l2ZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIEFjdGl2ZSBzZXR0aW5nIHJhaXNlIGNvbGxpc2lvbiBldmVudHMgYW5kIHBhcnRpY2lwYXRlXG4gICAgICAgICAqIGluIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBhY3RvcnMgYW5kIHdpbGwgYmUgcHVzaCBvciBtb3ZlZCBieSBhY3RvcnMgc2hhcmluZ1xuICAgICAgICAgKiB0aGUgQWN0aXZlIG9yIEZpeGVkIHNldHRpbmcuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBBY3RpdmUge0NvbGxpc2lvblR5cGV9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIkFjdGl2ZVwiXSA9IDJdID0gXCJBY3RpdmVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBFbGFzdGljIHNldHRpbmcgd2lsbCBiZWhhdmUgdGhlIHNhbWUgYXMgQWN0aXZlLCBleGNlcHQgdGhhdCB0aGV5IHdpbGxcbiAgICAgICAgICogXCJib3VuY2VcIiBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGdpdmVuIHRoZWlyIHZlbG9jaXR5IGR4L2R5LiBUaGlzIGlzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gbWVhbnQgZm9yXG4gICAgICAgICAqIHByb3RvdHlwaW5nLCBmb3IgYSBtb3JlIHJvYnVzdCBlbGFzdGljIGNvbGxpc2lvbiBsaXN0ZW4gdG8gdGhlIFwiY29sbGlzaW9uXCIgZXZlbnQgYW5kIHBlcmZvcm0geW91ciBjdXN0b20gbG9naWMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBFbGFzdGljIHtDb2xsaXNpb25UeXBlfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJFbGFzdGljXCJdID0gM10gPSBcIkVsYXN0aWNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBGaXhlZCBzZXR0aW5nIHJhaXNlIGNvbGxpc2lvbiBldmVudHMgYW5kIHBhcnRpY2lwYXRlIGluXG4gICAgICAgICAqIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBhY3RvcnMuIEFjdG9ycyB3aXRoIHRoZSBGaXhlZCBzZXR0aW5nIHdpbGwgbm90IGJlXG4gICAgICAgICAqIHB1c2hlZCBvciBtb3ZlZCBieSBvdGhlciBhY3RvcnMgc2hhcmluZyB0aGUgRml4ZWQgb3IgQWN0b3JzLiBUaGluayBvZiBGaXhlZFxuICAgICAgICAgKiBhY3RvcnMgYXMgXCJpbW1vdmFibGUvb25zdG9wcGFibGVcIiBvYmplY3RzLiBJZiB0d28gRml4ZWQgYWN0b3JzIG1lZXQgdGhleSB3aWxsXG4gICAgICAgICAqIG5vdCBiZSBwdXNoZWQgb3IgbW92ZWQgYnkgZWFjaCBvdGhlciwgdGhleSB3aWxsIG5vdCBpbnRlcmFjdCBleGNlcHQgdG8gdGhyb3dcbiAgICAgICAgICogY29sbGlzaW9uIGV2ZW50cy5cbiAgICAgICAgICogQHByb3BlcnR5IEZpeGVkIHtDb2xsaXNpb25UeXBlfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBDb2xsaXNpb25UeXBlW0NvbGxpc2lvblR5cGVbXCJGaXhlZFwiXSA9IDRdID0gXCJGaXhlZFwiO1xuICAgIH0pKGV4LkNvbGxpc2lvblR5cGUgfHwgKGV4LkNvbGxpc2lvblR5cGUgPSB7fSkpO1xuICAgIHZhciBDb2xsaXNpb25UeXBlID0gZXguQ29sbGlzaW9uVHlwZTtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCBpbXBvcnRhbnQgcHJpbWl0aXZlIGluIEV4Y2FsaWJ1ciBpcyBhbiBcIkFjdG9yLlwiIEFueXRoaW5nIHRoYXRcbiAgICAgKiBjYW4gbW92ZSBvbiB0aGUgc2NyZWVuLCBjb2xsaWRlIHdpdGggYW5vdGhlciBBY3RvciwgcmVzcG9uZCB0byBldmVudHMsXG4gICAgICogb3IgaW50ZXJhY3Qgd2l0aCB0aGUgY3VycmVudCBzY2VuZSwgbXVzdCBiZSBhbiBhY3Rvci4gQW4gQWN0b3IgPGI+bXVzdDwvYj5cbiAgICAgKiBiZSBwYXJ0IG9mIGEge3sjY3Jvc3NMaW5rIFwiU2NlbmVcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGl0IHRvIGJlIGRyYXduIHRvIHRoZSBzY3JlZW4uXG4gICAgICogQGNsYXNzIEFjdG9yXG4gICAgICogQGV4dGVuZHMgQ2xhc3NcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW3g9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgeCBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbeT0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyB5IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFt3aWR0aD0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyB3aWR0aCBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW2hlaWdodD0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyBoZWlnaHQgb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFtjb2xvcj11bmRlZmluZWRdIHtDb2xvcn0gVGhlIHN0YXJ0aW5nIGNvbG9yIG9mIHRoZSBhY3RvclxuICAgICAqL1xuICAgIHZhciBBY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhBY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQWN0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBhY3RvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlkID0gQWN0b3IubWF4SWQrKztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3IgKGxlZnQgZWRnZSlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yICh0b3AgZWRnZSlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB5IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBhY3RvciBpbiByYWRpYW5zXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgcm90YXRpb24ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7IC8vIHJhZGlhbnNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2Vjb25kXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgcngge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yeCA9IDA7IC8vcmFkaW9ucy9zZWNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHNjYWxlIHZlY3RvciBvZiB0aGUgYWN0b3JcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzY2FsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gbmV3IGV4LlZlY3RvcigxLCAxKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHggc2NhbGFyIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBzY2FsZS9zZWNvbmRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzeCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnN4ID0gMDsgLy9zY2FsZS9zZWNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHkgc2NhbGFyIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBzY2FsZS9zZWNvbmRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzeSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnN5ID0gMDsgLy9zY2FsZS9zZWNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHggdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkeCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmR4ID0gMDsgLy8gcGl4ZWxzL3NlY1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGR4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZHkgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeCBhY2NlbGVyYXRpb24gb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmReMlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGF4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYXggPSAwOyAvLyBwaXhlbHMvc2VjL3NlY1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeSBhY2NlbGVyYXRpb24gb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmReMlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGF5IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYXkgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2V0aGVyIHRoZSBhY3RvciBpcyBwaHlzaWNhbGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGlzT2ZmU2NyZWVuIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzT2ZmU2NyZWVuID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB2aXNpYmlsaXR5IG9mIGFuIGFjdG9yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdmlzaWJsZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIG9wYWNpdHkgb2YgYW4gYWN0b3JcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBvcGFjaXR5IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzT3BhY2l0eSA9IDE7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlbmllbmNlIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIGxvZ2dlclxuICAgICAgICAgICAgICogQHByb3BlcnR5IGxvZ2dlciB7TG9nZ2VyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIFRoZSBzY2VuZSB0aGF0IHRoZSBhY3RvciBpcyBpblxuICAgICAgICAgICAgKiBAcHJvcGVydHkgc2NlbmUge1NjZW5lfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBudWxsOyAvL2Zvcm1lcmx5IFwicGFyZW50XCJcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBUaGUgcGFyZW50IG9mIHRoaXMgYWN0b3JcbiAgICAgICAgICAgICogQHByb3BlcnR5IHBhcmVudCB7QWN0b3J9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgY29sbGlzaW9uIHR5cGUgb2YgdGhpcyBhY3Rvci4gQnlcbiAgICAgICAgICAgICAqIGRlZmF1bHQgYWxsIGFjdG9ycyBwYXJ0aWNpcGF0ZSBpbiBBY3RpdmUgY29sbGlzaW9ucy5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25UeXBlIHtDb2xsaXNpb25UeXBlfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblR5cGUgPSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3VwcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0ge307XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFjY2VzcyB0byB0aGUgY3VycmVudCBkcmF3aW5nIG9uIGZvciB0aGUgYWN0b3IsIHRoaXMgY2FuIGJlIGFuIHt7I2Nyb3NzTGluayBcIkFuaW1hdGlvblwifX17ey9jcm9zc0xpbmt9fSxcbiAgICAgICAgICAgICAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVwifX17ey9jcm9zc0xpbmt9fSwgb3Ige3sjY3Jvc3NMaW5rIFwiUG9seWdvblwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICAgICAqIFNldCBkcmF3aW5ncyB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJBY3Rvci9zZXREcmF3aW5nOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBjdXJyZW50RHJhd2luZyB7SURyYXdhYmxlfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyRHJhd2luZ1ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyRHJhd2luZ1kgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTW9kaWZ5IHRoZSBjdXJyZW50IGFjdG9yIHVwZGF0ZSBwaXBlbGluZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBpcGVsaW5lID0gW107XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGVuYWJsZSB0aGUgQ2FwdHVyZVBvaW50ZXIgdHJhaXQgdGhhdCBwcm9wb2dhdGVzIHBvaW50ZXIgZXZlbnRzIHRvIHRoaXMgYWN0b3JcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZW5hYmxlQ2FwdHVyZVBvaW50ZXI9ZmFsc2VdIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIENhcHR1cmVQb2ludGVyIHRyYWl0XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY2FwdHVyZVBvaW50ZXIge0lDYXB0dXJlUG9pbnRlckNvbmZpZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlUG9pbnRlciA9IHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlTW92ZUV2ZW50czogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9pc0tpbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy54ID0geCB8fCAwO1xuICAgICAgICAgICAgdGhpcy55ID0geSB8fCAwO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgb3BhY2l0eSBvZiBhbiBhY3RvciB0byB0aGUgY29sb3JcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBjb2xvci5hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVpbGQgZGVmYXVsdCBwaXBlbGluZVxuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5Nb3ZlbWVudE1vZHVsZSgpKTtcbiAgICAgICAgICAgIC8vdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5Db2xsaXNpb25EZXRlY3Rpb25Nb2R1bGUoKSk7XG4gICAgICAgICAgICB0aGlzLnBpcGVsaW5lLnB1c2gobmV3IGV4Lk9mZnNjcmVlbkN1bGxpbmdNb2R1bGUoKSk7XG4gICAgICAgICAgICB0aGlzLnBpcGVsaW5lLnB1c2gobmV3IGV4LkNhcHR1cmVQb2ludGVyTW9kdWxlKCkpO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkFjdGlvblF1ZXVlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZU5vZGUgPSBuZXcgZXguU2NlbmUoKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVOb2RlLmFjdG9yID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yID0gbmV3IGV4LlBvaW50KC41LCAuNSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIG9mIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcbiAgICAgICAgICogb3ZlcnJpZGRlbi4gVGhpcyBpcyB3aGVyZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZCBhY3RvcnMgc2hvdWxkIHRha2UgcGxhY2UuXG4gICAgICAgICAqIEBtZXRob2Qgb25Jbml0aWFsaXplXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX1cbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5vbkluaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgIH07XG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5fY2hlY2tGb3JQb2ludGVyT3B0SW4gPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lICYmIChldmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3BvaW50ZXJkb3duJyB8fCBldmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3BvaW50ZXJkb3duJyB8fCBldmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3BvaW50ZXJtb3ZlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwb2ludGVybW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlUG9pbnRlci5jYXB0dXJlTW92ZUV2ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIuIFlvdSBjYW4gbGlzdGVuIGZvciBhIHZhcmlldHkgb2ZcbiAgICAgICAgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cbiAgICAgICAgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcbiAgICAgICAgKiBAcGFyYW0gaGFuZGxlciB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvclBvaW50ZXJPcHRJbihldmVudE5hbWUpO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBcImFkZEV2ZW50TGlzdGVuZXJcIi4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxuICAgICAgICAgKiBldmVudHMgb2ZmIG9mIHRoZSBlbmdpbmU7IHNlZSB0aGUgZXZlbnRzIHNlY3Rpb24gYmVsb3cgZm9yIGEgY29tcGxldGUgbGlzdC5cbiAgICAgICAgICogQG1ldGhvZCBvblxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIge2V2ZW50PT52b2lkfSBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvclBvaW50ZXJPcHRJbihldmVudE5hbWUpO1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuc3Vic2NyaWJlKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgY3VycmVudCBhY3RvcnMgaXMgYSBtZW1iZXIgb2YgdGhlIHNjZW5lLiBUaGlzIHdpbGwgcmVtb3ZlXG4gICAgICAgICAqIGl0IGZyb20gdGhlIHNjZW5lIGdyYXBoLiBJdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGtpbGxcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzS2lsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJDYW5ub3Qga2lsbCBhY3RvciwgaXQgd2FzIG5ldmVyIGFkZGVkIHRvIHRoZSBTY2VuZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3ZXRoZXIgdGhlIGFjdG9yIGhhcyBiZWVuIGtpbGxlZC5cbiAgICAgICAgICogQG1ldGhvZCBpc0tpbGxlZFxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuaXNLaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNLaWxsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY2hpbGQgYWN0b3IgdG8gdGhpcyBhY3Rvci4gQWxsIG1vdmVtZW50IG9mIHRoZSBjaGlsZCBhY3RvciB3aWxsIGJlXG4gICAgICAgICAqIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgYWN0b3IuIE1lYW5pbmcgaWYgdGhlIHBhcmVudCBtb3ZlcyB0aGUgY2hpbGQgd2lsbFxuICAgICAgICAgKiBtb3ZlIHdpdGhcbiAgICAgICAgICogQG1ldGhvZCBhZGRDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgY2hpbGQgYWN0b3IgdG8gYWRkXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIGFjdG9yLmNvbGxpc2lvblR5cGUgPSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB0aGlzLnNjZW5lTm9kZS5hZGRDaGlsZChhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgY2hpbGQgYWN0b3IgZnJvbSB0aGlzIGFjdG9yLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBjaGlsZCBhY3RvciB0byByZW1vdmVcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5zY2VuZU5vZGUucmVtb3ZlQ2hpbGQoYWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgY3VycmVudCBkcmF3aW5nIG9mIHRoZSBhY3RvciB0byB0aGUgZHJhd2luZyBjb3JyZXNwb2RpbmcgdG9cbiAgICAgICAgICogdGhlIGtleS5cbiAgICAgICAgICogQG1ldGhvZCBzZXREcmF3aW5nXG4gICAgICAgICAqIEBwYXJhbSBrZXkge3N0cmluZ30gVGhlIGtleSBvZiB0aGUgZHJhd2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNldERyYXdpbmcgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhd2luZyAhPSB0aGlzLmZyYW1lc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNba2V5XS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZyA9IHRoaXMuZnJhbWVzW2tleV07XG4gICAgICAgIH07XG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hZGREcmF3aW5nID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudERyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgZXguU3ByaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRHJhd2luZyhcImRlZmF1bHRcIiwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIGV4LlRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREcmF3aW5nKFwiZGVmYXVsdFwiLCBhcmd1bWVudHNbMF0uYXNTcHJpdGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZpY2lhbGx5IHRyaWdnZXIgYW4gZXZlbnQgb24gYW4gYWN0b3IsIHVzZWZ1bCB3aGVuIGNyZWF0aW5nIGN1c3RvbSBldmVudHMuXG4gICAgICAgICAqIEBtZXRob2QgdHJpZ2dlckV2ZW50XG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyaWdnZXJcbiAgICAgICAgICogQHBhcmFtIFtldmVudD11bmRlZmluZWRdIHtHYW1lRXZlbnR9IFRoZSBldmVudCBvYmplY3QgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaChldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gYWN0b3IgdG8gYSBjb2xsaXNpb24gZ3JvdXAuIEFjdG9ycyB3aXRoIG5vIG5hbWVkIGNvbGxpc2lvbiBncm91cCBhcmVcbiAgICAgICAgICogY29uc2lkZXJlZCB0byBiZSBpbiBldmVyeSBjb2xsaXNpb24gZ3JvdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9uY2UgaW4gYSBjb2xsaXNpb24gZ3JvdXAocykgYWN0b3JzIHdpbGwgb25seSBjb2xsaWRlIHdpdGggb3RoZXIgYWN0b3JzIGluXG4gICAgICAgICAqIHRoYXQgZ3JvdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgYWRkQ29sbGlzaW9uR3JvdXBcbiAgICAgICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmFkZENvbGxpc2lvbkdyb3VwID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXBzLnB1c2gobmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYW4gYWN0b3IgZnJvbSBhIGNvbGxpc2lvbiBncm91cC5cbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVDb2xsaXNpb25Hcm91cFxuICAgICAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgY29sbGlzaW9uIGdyb3VwXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucmVtb3ZlQ29sbGlzaW9uR3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb2xsaXNpb25Hcm91cHMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjZW50ZXIgcG9pbnQgb2YgYW4gYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRDZW50ZXJcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2dldENhbGN1bGF0ZWRBbmNob3IoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguVmVjdG9yKHRoaXMueCArIHRoaXMuZ2V0V2lkdGgoKSAvIDIsIHRoaXMueSArIHRoaXMuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGNhbGN1bGF0ZWQgd2lkdGggb2YgYW4gYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRXaWR0aFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5zY2FsZS54O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgd2lkdGggb2YgYW4gYWN0b3IsIGZhY3RvcmluZyBpbiB0aGUgY3VycmVudCBzY2FsZVxuICAgICAgICAgKiBAbWV0aG9kIHNldFdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHRoaXMuc2NhbGUueDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGNhbGN1bGF0ZWQgaGVpZ2h0IG9mIGFuIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0SGVpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodCAqIHRoaXMuc2NhbGUueTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBhbiBhY3RvciwgZmFjdG9yaW5nIGluIHRoZSBjdXJyZW50IHNjYWxlXG4gICAgICAgICAqIEBtZXRob2Qgc2V0SGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyB0aGlzLnNjYWxlLnk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDZW50ZXJzIHRoZSBhY3RvcidzIGRyYXdpbmcgYXJvdW5kIHRoZSBjZW50ZXIgb2YgdGhlIGFjdG9yJ3MgYm91bmRpbmcgYm94XG4gICAgICAgICAqIEBtZXRob2Qgc2V0Q2VudGVyRHJhd2luZ1xuICAgICAgICAgKiBAcGFyYW0gY2VudGVyIHtib29sZWFufSBJbmRpY2F0ZXMgdG8gY2VudGVyIHRoZSBkcmF3aW5nIGFyb3VuZCB0aGUgYWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zZXRDZW50ZXJEcmF3aW5nID0gZnVuY3Rpb24gKGNlbnRlcikge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJEcmF3aW5nWSA9IGNlbnRlcjtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyRHJhd2luZ1ggPSBjZW50ZXI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0TGVmdFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmlnaHRcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgZ2V0VG9wXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRCb3R0b21cbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIEdldHMgdGhlIHggdmFsdWUgb2YgdGhlIEFjdG9yIGluIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAgICAqIEBtZXRob2QgZ2V0R2xvYmFsWFxuICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0R2xvYmFsWCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnBhcmVudC5zY2FsZS55ICsgdGhpcy5wYXJlbnQuZ2V0R2xvYmFsWCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBHZXRzIHRoZSB5IHZhbHVlIG9mIHRoZSBBY3RvciBpbiBnbG9iYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgKiBAbWV0aG9kIGdldEdsb2JhbFlcbiAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEdsb2JhbFkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICogdGhpcy5wYXJlbnQuc2NhbGUueSArIHRoaXMucGFyZW50LmdldEdsb2JhbFkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGdsb2JhbCBzY2FsZSBvZiB0aGUgQWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRHbG9iYWxTY2FsZVxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRTY2FsZSA9IHRoaXMucGFyZW50LmdldEdsb2JhbFNjYWxlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KHRoaXMuc2NhbGUueCAqIHBhcmVudFNjYWxlLngsIHRoaXMuc2NhbGUueSAqIHBhcmVudFNjYWxlLnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgYWN0b3IncyBib3VuZGluZyBib3ggY2FsY3VsYXRlZCBmb3IgdGhpcyBpbnN0YW50LlxuICAgICAgICAgKiBAbWV0aG9kIGdldEJvdW5kc1xuICAgICAgICAgKiBAcmV0dXJucyBCb3VuZGluZ0JveFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9nZXRDYWxjdWxhdGVkQW5jaG9yKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LkJvdW5kaW5nQm94KHRoaXMuZ2V0R2xvYmFsWCgpIC0gYW5jaG9yLngsIHRoaXMuZ2V0R2xvYmFsWSgpIC0gYW5jaG9yLnksIHRoaXMuZ2V0R2xvYmFsWCgpICsgdGhpcy5nZXRXaWR0aCgpIC0gYW5jaG9yLngsIHRoaXMuZ2V0R2xvYmFsWSgpICsgdGhpcy5nZXRIZWlnaHQoKSAtIGFuY2hvci55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3RzIHdoZXRoZXIgdGhlIHgveSBzcGVjaWZpZWQgYXJlIGNvbnRhaW5lZCBpbiB0aGUgYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBjb250YWluc1xuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBYIGNvb3JkaW5hdGUgdG8gdGVzdCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFkgY29vcmRpbmF0ZSB0byB0ZXN0IChpbiB3b3JsZCBjb29yZGluYXRlcylcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5jb250YWlucyhuZXcgZXguUG9pbnQoeCwgeSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2lkZSBvZiB0aGUgY29sbGlzaW9uIGJhc2VkIG9uIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgICAgICogQG1ldGhvZCBnZXRTaWRlRnJvbUludGVyc2VjdFxuICAgICAgICAgKiBAcGFyYW0gaW50ZXJzZWN0IHtWZWN0b3J9IFRoZSBkaXNwbGFjZW1lbnQgdmVjdG9yIHJldHVybmVkIGJ5IGEgY29sbGlzaW9uXG4gICAgICAgICAqIEByZXR1cm5zIFNpZGVcbiAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldFNpZGVGcm9tSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGludGVyc2VjdCkge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbnRlcnNlY3QueCkgPiBNYXRoLmFicyhpbnRlcnNlY3QueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdC54IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQgLyogUmlnaHQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogTGVmdCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3QueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEJvdHRvbSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBUb3AgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgYWN0b3IgaGFzIGNvbGxpZGVkIHdpdGggYW5vdGhlciBhY3RvciwgcmV0dXJucyB0aGUgc2lkZSBvZiB0aGUgY3VycmVudCBhY3RvciB0aGF0IGNvbGxpZGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGNvbGxpZGVzXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBvdGhlciBhY3RvciB0byB0ZXN0XG4gICAgICAgICAqIEByZXR1cm5zIFNpZGVcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5jb2xsaWRlc1dpdGhTaWRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdGlvblZlY3RvciA9IHRoaXMuY29sbGlkZXMoYWN0b3IpO1xuICAgICAgICAgICAgaWYgKCFzZXBhcmF0aW9uVmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzZXBhcmF0aW9uVmVjdG9yLngpID4gTWF0aC5hYnMoc2VwYXJhdGlvblZlY3Rvci55KSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnggPCBhY3Rvci54KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0IC8qIFJpZ2h0ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMgLyogTGVmdCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy55IDwgYWN0b3IueSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBCb3R0b20gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBUb3AgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3Qgd2hldGhlciB0aGUgYWN0b3IgaGFzIGNvbGxpZGVkIHdpdGggYW5vdGhlciBhY3RvciwgcmV0dXJucyB0aGUgaW50ZXJzZWN0aW9uIHZlY3RvciBvbiBjb2xsaXNpb24uIFJldHVybnNcbiAgICAgICAgICogbnVsbCB3aGVuIHRoZXJlIGlzIG5vIGNvbGxpc2lvbjtcbiAgICAgICAgICogQG1ldGhvZCBjb2xsaWRlc1xuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgb3RoZXIgYWN0b3IgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB2YXIgb3RoZXJCb3VuZHMgPSBhY3Rvci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBib3VuZHMuY29sbGlkZXMob3RoZXJCb3VuZHMpO1xuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgaGFuZGxlciB0byBmaXJlIHdoZW4gdGhpcyBhY3RvciBjb2xsaWRlcyB3aXRoIGFub3RoZXIgaW4gYSBzcGVjaWZpZWQgZ3JvdXBcbiAgICAgICAgICogQG1ldGhvZCBvbkNvbGxpZGVzV2l0aFxuICAgICAgICAgKiBAcGFyYW0gZ3JvdXAge3N0cmluZ30gVGhlIGdyb3VwIG5hbWUgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gZnVuYyB7Y2FsbGJhY2t9IFRoZSBjYWxsYmFjayB0byBmaXJlIG9uIGNvbGxpc2lvbiB3aXRoIGFub3RoZXIgYWN0b3IgZnJvbSB0aGUgZ3JvdXAuIFRoZSBjYWxsYmFjayBpcyBwYXNzZWQgdGhlIG90aGVyIGFjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm9uQ29sbGlkZXNXaXRoID0gZnVuY3Rpb24gKGdyb3VwLCBmdW5jKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzW2dyb3VwXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdLnB1c2goZnVuYyk7XG4gICAgICAgIH07XG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRDb2xsaXNpb25IYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25IYW5kbGVycztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGNvbGxpc2lvbiBoYW5kbGVycyBmb3IgdGhpcyBncm91cCBvbiB0aGlzIGFjdG9yXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQ29sbGlkZXNXaXRoXG4gICAgICAgICAqIEBwYXJhbSBncm91cCB7c3RyaW5nfSBHcm91cCB0byByZW1vdmUgYWxsIGhhbmRsZXJzIGZvciBvbiB0aGlzIGFjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJlbW92ZUNvbGxpZGVzV2l0aCA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdID0gW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBhY3RvcnMgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZGlzdGFuY2Ugc3BlY2lmaWVkIGZyb20gZWFjaCBvdGhlclxuICAgICAgICAgKiBAbWV0aG9kIHdpdGhpblxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBBY3RvciB0byB0ZXN0XG4gICAgICAgICAqIEBwYXJhbSBkaXN0YW5jZSB7bnVtYmVyfSBEaXN0YW5jZSBpbiBwaXhlbHMgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUud2l0aGluID0gZnVuY3Rpb24gKGFjdG9yLCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSBhY3Rvci54LCAyKSArIE1hdGgucG93KHRoaXMueSAtIGFjdG9yLnksIDIpKSA8PSBkaXN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgcXVldWVkIGFjdGlvbnMgZnJvbSB0aGUgQWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBjbGVhckFjdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5jbGVhckFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xuICAgICAgICB9O1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZWFzZVRvID0gZnVuY3Rpb24gKHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pIHtcbiAgICAgICAgICAgIGlmIChlYXNpbmdGY24gPT09IHZvaWQgMCkgeyBlYXNpbmdGY24gPSBleC5FYXNpbmdGdW5jdGlvbnMuTGluZWFyOyB9XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5FYXNlVG8odGhpcywgeCwgeSwgZHVyYXRpb24sIGVhc2luZ0ZjbikpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1vdmUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGF0IHRoZVxuICAgICAgICAgKiBzcGVlZCBzcGVjaWZpZWQgKGluIHBpeGVscyBwZXIgc2Vjb25kKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzXG4gICAgICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBtb3ZlVG9cbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn0gVGhlIHggbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cbiAgICAgICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBzcGVlZCBpbiBwaXhlbHMgcGVyIHNlY29uZCB0byBtb3ZlXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHksIHNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5Nb3ZlVG8odGhpcywgeCwgeSwgc3BlZWQpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtb3ZlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBieSBhXG4gICAgICAgICAqIGNlcnRhaW4gdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3JcbiAgICAgICAgICogJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgbW92ZUJ5XG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSB4IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IGxvY2F0aW9uIHRvIG1vdmUgdGhlIGFjdG9yIHRvXG4gICAgICAgICAqIEBwYXJhbSB0aW1lIHtudW1iZXJ9IFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRoZSBhY3RvciB0byBtb3ZlIHRvIHRoZSBuZXcgbG9jYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUubW92ZUJ5ID0gZnVuY3Rpb24gKHgsIHksIHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLk1vdmVCeSh0aGlzLCB4LCB5LCB0aW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcm90YXRlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgYW5nbGUgYXQgdGhlIHNwZWVkXG4gICAgICAgICAqIHNwZWNpZmllZCAoaW4gcmFkaWFucyBwZXIgc2Vjb25kKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzXG4gICAgICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCByb3RhdGVUb1xuICAgICAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zIHtudW1iZXJ9IFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFuc1xuICAgICAgICAgKiBAcGFyYW0gc3BlZWQge251bWJlcn0gVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIHJvdGF0aW9uIHNwZWNpZmllZCBpbiByYWRpYW5zIHBlciBzZWNvbmRcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yb3RhdGVUbyA9IGZ1bmN0aW9uIChhbmdsZVJhZGlhbnMsIHNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5Sb3RhdGVUbyh0aGlzLCBhbmdsZVJhZGlhbnMsIHNwZWVkKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcm90YXRlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgYW5nbGUgYnkgYSBjZXJ0YWluXG4gICAgICAgICAqIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgcGFydFxuICAgICAgICAgKiBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2Qgcm90YXRlQnlcbiAgICAgICAgICogQHBhcmFtIGFuZ2xlUmFkaWFucyB7bnVtYmVyfSBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcbiAgICAgICAgICogQHBhcmFtIHRpbWUge251bWJlcn0gVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdGhlIGFjdG9yIHRvIGNvbXBsZXRlIHRoZSByb3RhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yb3RhdGVCeSA9IGZ1bmN0aW9uIChhbmdsZVJhZGlhbnMsIHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLlJvdGF0ZUJ5KHRoaXMsIGFuZ2xlUmFkaWFucywgdGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNjYWxlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgc2l6ZSBhdCB0aGUgc3BlZWRcbiAgICAgICAgICogc3BlY2lmaWVkIChpbiBtYWduaXR1ZGUgaW5jcmVhc2UgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZVxuICAgICAgICAgKiBhY3Rvci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZ1xuICAgICAgICAgKiBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2Qgc2NhbGVUb1xuICAgICAgICAgKiBAcGFyYW0gc2l6ZSB7bnVtYmVyfSBUaGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHlcbiAgICAgICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBzcGVlZCBvZiBzY2FsaW5nIHNwZWNpZmllZCBpbiBtYWduaXR1ZGUgaW5jcmVhc2UgcGVyIHNlY29uZFxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNjYWxlVG8gPSBmdW5jdGlvbiAoc2l6ZVgsIHNpemVZLCBzcGVlZFgsIHNwZWVkWSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuU2NhbGVUbyh0aGlzLCBzaXplWCwgc2l6ZVksIHNwZWVkWCwgc3BlZWRZKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgc2NhbGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBzaXplIGJ5IGEgY2VydGFpbiB0aW1lXG4gICAgICAgICAqIChpbiBtaWxsaXNlY29uZHMpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlXG4gICAgICAgICAqIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHNjYWxlQnlcbiAgICAgICAgICogQHBhcmFtIHNpemUge251bWJlcn0gVGhlIHNjYWxpbmcgZmFjdG9yIHRvIGFwcGx5XG4gICAgICAgICAqIEBwYXJhbSB0aW1lIHtudW1iZXJ9IFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIGNvbXBsZXRlIHRoZSBzY2FsaW5nIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNjYWxlQnkgPSBmdW5jdGlvbiAoc2l6ZVgsIHNpemVZLCB0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5TY2FsZUJ5KHRoaXMsIHNpemVYLCBzaXplWSwgdGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yIHRvIGJsaW5rIChiZWNvbWUgdmlzaWJsZSBhbmQgbm90XG4gICAgICAgICAqIHZpc2libGUpLiBPcHRpb25hbGx5LCB5b3UgbWF5IHNwZWNpZnkgdGhlIG51bWJlciBvZiBibGlua3MuIFNwZWNpZnkgdGhlIGFtb3VudCBvZiB0aW1lXG4gICAgICAgICAqIHRoZSBhY3RvciBzaG91bGQgYmUgdmlzaWJsZSBwZXIgYmxpbmssIGFuZCB0aGUgYW1vdW50IG9mIHRpbWUgbm90IHZpc2libGUuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIGJsaW5rXG4gICAgICAgICAqIEBwYXJhbSB0aW1lVmlzaWJsZSB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSB2aXNpYmxlIHBlciBibGluayBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQHBhcmFtIHRpbWVOb3RWaXNpYmxlIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IG5vdCB2aXNpYmxlIHBlciBibGluayBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQHBhcmFtIFtudW1CbGlua3NdIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgdGltZXMgdG8gYmxpbmtcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5ibGluayA9IGZ1bmN0aW9uICh0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykge1xuICAgICAgICAgICAgaWYgKG51bUJsaW5rcyA9PT0gdm9pZCAwKSB7IG51bUJsaW5rcyA9IDE7IH1cbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkJsaW5rKHRoaXMsIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgYW4gYWN0b3IncyBvcGFjaXR5IHRvIGNoYW5nZSBmcm9tIGl0cyBjdXJyZW50IHZhbHVlXG4gICAgICAgICAqIHRvIHRoZSBwcm92aWRlZCB2YWx1ZSBieSBhIHNwZWNpZmllZCB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpc1xuICAgICAgICAgKiBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBmYWRlXG4gICAgICAgICAqIEBwYXJhbSBvcGFjaXR5IHtudW1iZXJ9IFRoZSBlbmRpbmcgb3BhY2l0eVxuICAgICAgICAgKiBAcGFyYW0gdGltZSB7bnVtYmVyfSBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0byBmYWRlIHRoZSBhY3RvciAoaW4gbWlsbGlzZWNvbmRzKVxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmZhZGUgPSBmdW5jdGlvbiAob3BhY2l0eSwgdGltZSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuRmFkZSh0aGlzLCBvcGFjaXR5LCB0aW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgZGVsYXkgdGhlIG5leHQgYWN0aW9uIGZyb20gZXhlY3V0aW5nIGZvciBhIGNlcnRhaW5cbiAgICAgICAgICogYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yXG4gICAgICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIGRlbGF5XG4gICAgICAgICAqIEBwYXJhbSB0aW1lIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlIHF1ZXVlIGZyb20gZXhlY3V0aW5nIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkRlbGF5KHRoaXMsIHRpbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBhZGQgYW4gYWN0aW9uIHRvIHRoZSBxdWV1ZSB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhY3RvciBmcm9tIHRoZVxuICAgICAgICAgKiBzY2VuZSBvbmNlIGl0IGhhcyBjb21wbGV0ZWQgaXRzIHByZXZpb3VzIGFjdGlvbnMuIEFueSBhY3Rpb25zIG9uIHRoZVxuICAgICAgICAgKiBhY3Rpb24gcXVldWUgYWZ0ZXIgdGhpcyBhY3Rpb24gd2lsbCBub3QgYmUgZXhlY3V0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgZGllXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZGllID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuRGllKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBjYWxsIGFuIGFyYml0cmFyeSBtZXRob2QgYXMgdGhlIG5leHQgYWN0aW9uIGluIHRoZVxuICAgICAgICAgKiBhY3Rpb24gcXVldWUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGV4ZWN1dGUgY29kZSBpbiBhZnRlciBhIHNwZWNpZmljXG4gICAgICAgICAqIGFjdGlvbiwgaS5lIEFuIGFjdG9yIGFycml2ZXMgYXQgYSBkZXN0aW5hdGlubyBhZnRlciB0cmF2ZXJzaW5nIGEgcGF0aFxuICAgICAgICAgKiBAbWV0aG9kIGNhbGxNZXRob2RcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5jYWxsTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuQ2FsbE1ldGhvZCh0aGlzLCBtZXRob2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgcHJldmlvdXNseVxuICAgICAgICAgKiBjYWxsZWQgYWN0aW9ucyBhIGNlcnRhaW4gbnVtYmVyIG9mIHRpbWVzLiBJZiB0aGUgbnVtYmVyIG9mIHJlcGVhdHNcbiAgICAgICAgICogaXMgbm90IHNwZWNpZmllZCBpdCB3aWxsIHJlcGVhdCBmb3JldmVyLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mXG4gICAgICAgICAqIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZ1xuICAgICAgICAgKiBAbWV0aG9kIHJlcGVhdFxuICAgICAgICAgKiBAcGFyYW0gW3RpbWVzPXVuZGVmaW5lZF0ge251bWJlcn0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgYWxsIHRoZSBwcmV2aW91cyBhY3Rpb25zIGluIHRoZSBhY3Rpb24gcXVldWUuIElmIG5vdGhpbmcgaXMgc3BlY2lmaWVkIHRoZSBhY3Rpb25zIHdpbGwgcmVwZWF0IGZvcmV2ZXJcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yZXBlYXQgPSBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgICAgIGlmICghdGltZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEZvcmV2ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLlJlcGVhdCh0aGlzLCB0aW1lcywgdGhpcy5hY3Rpb25RdWV1ZS5nZXRBY3Rpb25zKCkpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgcHJldmlvdXNseVxuICAgICAgICAgKiBjYWxsZWQgYWN0aW9ucyBmb3JldmVyLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJ1xuICAgICAgICAgKiBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCByZXBlYXRGb3JldmVyXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucmVwZWF0Rm9yZXZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLlJlcGVhdEZvcmV2ZXIodGhpcywgdGhpcy5hY3Rpb25RdWV1ZS5nZXRBY3Rpb25zKCkpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gZm9sbG93IGFub3RoZXIgYXQgYSBzcGVjaWZpZWQgZGlzdGFuY2VcbiAgICAgICAgICogQG1ldGhvZCBmb2xsb3dcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRvIGZvbGxvd1xuICAgICAgICAgKiBAcGFyYW0gW2ZvbGxvd0Rpc3RhbmNlPWN1cnJlbnREaXN0YW5jZV0ge251bWJlcn0gVGhlIGRpc3RhbmNlIHRvIG1haW50YWluIHdoZW4gZm9sbG93aW5nLCBpZiBub3Qgc3BlY2lmaWVkIHRoZSBhY3RvciB3aWxsIGZvbGxvdyBhdCB0aGUgY3VycmVudCBkaXN0YW5jZS5cbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5mb2xsb3cgPSBmdW5jdGlvbiAoYWN0b3IsIGZvbGxvd0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoZm9sbG93RGlzdGFuY2UgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuRm9sbG93KHRoaXMsIGFjdG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5Gb2xsb3codGhpcywgYWN0b3IsIGZvbGxvd0Rpc3RhbmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIG1vdmUgdG93YXJkcyBhbm90aGVyIHVudGlsIHRoZXlcbiAgICAgICAgICogY29sbGlkZSBcIm1lZXRcIiBhdCBhIHNwZWNpZmllZCBzcGVlZC5cbiAgICAgICAgICogQG1ldGhvZCBtZWV0XG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0byBtZWV0XG4gICAgICAgICAqIEBwYXJhbSBbc3BlZWQ9MF0ge251bWJlcn0gVGhlIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kIHRvIG1vdmUsIGlmIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCBtYXRjaCB0aGUgc3BlZWQgb2YgdGhlIG90aGVyIGFjdG9yXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUubWVldCA9IGZ1bmN0aW9uIChhY3Rvciwgc3BlZWQpIHtcbiAgICAgICAgICAgIGlmIChzcGVlZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5NZWV0KHRoaXMsIGFjdG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5NZWV0KHRoaXMsIGFjdG9yLCBzcGVlZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGN1cnJlbnQgYWN0aW9uIHF1ZXVlIHVwIHRvIG5vd1xuICAgICAgICAgKiBpcyBmaW5pc2hlZC5cbiAgICAgICAgICogQG1ldGhvZCBhc1Byb21pc2VcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmFzUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxNZXRob2QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuX2dldENhbGN1bGF0ZWRBbmNob3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuYW5jaG9yLngsIHRoaXMuZ2V0SGVpZ2h0KCkgKiB0aGlzLmFuY2hvci55KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgZW5naW5lXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUoZW5naW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdpbml0aWFsaXplJywgbmV3IGV4LkluaXRpYWxpemVFdmVudChlbmdpbmUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudERpc3BhdGNoZXIgPSB0aGlzLmV2ZW50RGlzcGF0Y2hlcjtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3Rpb24gcXVldWVcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5waXBlbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucGlwZWxpbmVbaV0udXBkYXRlKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goZXguRXZlbnRUeXBlWzUgLyogVXBkYXRlICovXSwgbmV3IGV4LlVwZGF0ZUV2ZW50KGRlbHRhKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgZHJhd3MgdGhlIGFjdG9yIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgdGltZSBzaW5jZSB0aGUgbGFzdCBkcmF3IGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNPZmZTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5jaG9yUG9pbnQgPSB0aGlzLl9nZXRDYWxjdWxhdGVkQW5jaG9yKCk7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBjaGFuZ2luZyBvcGFjaXR5XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c09wYWNpdHkgIT0gdGhpcy5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZHJhd2luZyBpbiB0aGlzLmZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1tkcmF3aW5nXS5hZGRFZmZlY3QobmV3IGV4LkVmZmVjdHMuT3BhY2l0eSh0aGlzLm9wYWNpdHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c09wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhd2luZykge1xuICAgICAgICAgICAgICAgIHZhciB4RGlmZiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHlEaWZmID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jZW50ZXJEcmF3aW5nWCkge1xuICAgICAgICAgICAgICAgICAgICB4RGlmZiA9ICh0aGlzLmN1cnJlbnREcmF3aW5nLndpZHRoICogdGhpcy5jdXJyZW50RHJhd2luZy5nZXRTY2FsZVgoKSAtIHRoaXMuZ2V0V2lkdGgoKSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jZW50ZXJEcmF3aW5nWSkge1xuICAgICAgICAgICAgICAgICAgICB5RGlmZiA9ICh0aGlzLmN1cnJlbnREcmF3aW5nLmhlaWdodCAqIHRoaXMuY3VycmVudERyYXdpbmcuZ2V0U2NhbGVZKCkgLSB0aGlzLmdldEhlaWdodCgpKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcuZHJhdyhjdHgsIC14RGlmZiAtIGFuY2hvclBvaW50LngsIC15RGlmZiAtIGFuY2hvclBvaW50LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KC1hbmNob3JQb2ludC54LCAtYW5jaG9yUG9pbnQueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NlbmVOb2RlLmRyYXcoY3R4LCBkZWx0YSk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIGRyYXdzIHRoZSBhY3RvcnMgZGVidWdnaW5nIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICogQG1ldGhvZCBkZWJ1Z0RyYXdcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgYmIgPSB0aGlzLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgYmIuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZXguQ29sb3IuWWVsbG93LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKHRoaXMueCwgdGhpcy55LCAzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoZSBuZXh0IGlkIHRvIGJlIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IubWF4SWQgPSAwO1xuICAgICAgICByZXR1cm4gQWN0b3I7XG4gICAgfSkoZXguQ2xhc3MpO1xuICAgIGV4LkFjdG9yID0gQWN0b3I7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIExvZ2dpbmcgbGV2ZWwgdGhhdCBFeGNhbGlidXIgd2lsbCB0YWdcbiAgICAgKiBAY2xhc3MgTG9nTGV2ZWxcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgQHByb3BlcnR5IERlYnVnIHtMb2dMZXZlbH1cbiAgICAgICAgIEBzdGF0aWNcbiAgICAgICAgIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBJbmZvIHtMb2dMZXZlbH1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBXYXJuIHtMb2dMZXZlbH1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBFcnJvciB7TG9nTGV2ZWx9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgRmF0YWwge0xvZ0xldmVsfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRlYnVnXCJdID0gMF0gPSBcIkRlYnVnXCI7XG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSW5mb1wiXSA9IDFdID0gXCJJbmZvXCI7XG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV2FyblwiXSA9IDJdID0gXCJXYXJuXCI7XG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJGYXRhbFwiXSA9IDRdID0gXCJGYXRhbFwiO1xuICAgIH0pKGV4LkxvZ0xldmVsIHx8IChleC5Mb2dMZXZlbCA9IHt9KSk7XG4gICAgdmFyIExvZ0xldmVsID0gZXguTG9nTGV2ZWw7XG4gICAgLyoqXG4gICAgICogU3RhdGljIHNpbmdsZXRvbiB0aGF0IHJlcHJlc2VudHMgdGhlIGxvZ2dpbmcgZmFjaWxpdHkgZm9yIEV4Y2FsaWJ1ci5cbiAgICAgKiBFeGNhbGlidXIgY29tZXMgYnVpbHQtaW4gd2l0aCBhIENvbnNvbGVBcHBlbmRlciBhbmQgU2NyZWVuQXBwZW5kZXIuXG4gICAgICogRGVyaXZlIGZyb20gSUFwcGVuZGVyIHRvIGNyZWF0ZSB5b3VyIG93biBsb2dnaW5nIGFwcGVuZGVycy5cbiAgICAgKiBAY2xhc3MgTG9nZ2VyXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhciBMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMb2dnZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVycyA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGRlZmF1bHQgbG9nZ2luZyBsZXZlbC4gRXhjYWxpYnVyIHdpbGwgb25seSBsb2dcbiAgICAgICAgICAgICAqIG1lc3NhZ2VzIGlmIGVxdWFsIHRvIG9yIGFib3ZlIHRoaXMgbGV2ZWwuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZGVmYXVsdExldmVsIHtMb2dMZXZlbH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TGV2ZWwgPSAxIC8qIEluZm8gKi87XG4gICAgICAgICAgICBpZiAoTG9nZ2VyLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2dlciBpcyBhIHNpbmdsZXRvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIExvZ2dlci5faW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBjb25zb2xlIGFwcGVuZGVyXG4gICAgICAgICAgICBMb2dnZXIuX2luc3RhbmNlLmFkZEFwcGVuZGVyKG5ldyBDb25zb2xlQXBwZW5kZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gTG9nZ2VyLl9pbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0aWMgaW5zdGFuY2Ugb2YgTG9nZ2VyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0SW5zdGFuY2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcmV0dXJucyBMb2dnZXJcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChMb2dnZXIuX2luc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuX2luc3RhbmNlID0gbmV3IExvZ2dlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIExvZ2dlci5faW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgbmV3IElBcHBlbmRlciB0byB0aGUgbGlzdCBvZiBhcHBlbmRlcnMgdG8gd3JpdGUgdG9cbiAgICAgICAgICogQG1ldGhvZCBhZGRBcHBlbmRlclxuICAgICAgICAgKiBAcGFyYW0gYXBwZW5kZXIge0lBcHBlbmRlcn0gQXBwZW5kZXIgdG8gYWRkXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmFkZEFwcGVuZGVyID0gZnVuY3Rpb24gKGFwcGVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVycy5wdXNoKGFwcGVuZGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgYXBwZW5kZXJzIGZyb20gdGhlIGxvZ2dlclxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyQXBwZW5kZXJzXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmNsZWFyQXBwZW5kZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvZ3MgYSBtZXNzYWdlIGF0IGEgZ2l2ZW4gTG9nTGV2ZWxcbiAgICAgICAgICogQG1ldGhvZCBfbG9nXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBsZXZlbCB7TG9nTGV2ZWx9VGhlIExvZ0xldmVsYHRvIGxvZyB0aGUgbWVzc2FnZSBhdFxuICAgICAgICAgKiBAcGFyYW0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gd3JpdGUgdG8gYW4gYXBwZW5kZXJcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuX2xvZyA9IGZ1bmN0aW9uIChsZXZlbCwgYXJncykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmRlZmF1bHRMZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZXJzLmZvckVhY2goZnVuY3Rpb24gKGFwcGVuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID49IF90aGlzLmRlZmF1bHRMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRlci5sb2cobGV2ZWwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIExvZ0xldmVsLkRlYnVnIGxldmVsXG4gICAgICAgICAqIEBtZXRob2QgZGVidWdcbiAgICAgICAgICogQHBhcmFtIC4uLmFyZ3MgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2coMCAvKiBEZWJ1ZyAqLywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgTG9nTGV2ZWwuSW5mbyBsZXZlbFxuICAgICAgICAgKiBAbWV0aG9kIGluZm9cbiAgICAgICAgICogQHBhcmFtIC4uLmFyZ3MgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvZygxIC8qIEluZm8gKi8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIExvZ0xldmVsLldhcm4gbGV2ZWxcbiAgICAgICAgICogQG1ldGhvZCB3YXJuXG4gICAgICAgICAqIEBwYXJhbSAuLi5hcmdzIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2coMiAvKiBXYXJuICovLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBMb2dMZXZlbC5FcnJvciBsZXZlbFxuICAgICAgICAgKiBAbWV0aG9kIGVycm9yXG4gICAgICAgICAqIEBwYXJhbSAuLi5hcmdzIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nKDMgLyogRXJyb3IgKi8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIExvZ0xldmVsLkZhdGFsIGxldmVsXG4gICAgICAgICAqIEBtZXRob2QgZmF0YWxcbiAgICAgICAgICogQHBhcmFtIC4uLmFyZ3MgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5mYXRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2coNCAvKiBGYXRhbCAqLywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIExvZ2dlci5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICByZXR1cm4gTG9nZ2VyO1xuICAgIH0pKCk7XG4gICAgZXguTG9nZ2VyID0gTG9nZ2VyO1xuICAgIC8qKlxuICAgICAqIENvbnNvbGUgYXBwZW5kZXIgZm9yIGJyb3dzZXJzIChpLmUuIGNvbnNvbGUubG9nKVxuICAgICAqIEBjbGFzcyBDb25zb2xlQXBwZW5kZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBJQXBwZW5kZXJcbiAgICAgKi9cbiAgICB2YXIgQ29uc29sZUFwcGVuZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29uc29sZUFwcGVuZGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbnNvbGVBcHBlbmRlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY29uc29sZSBzdXBwb3J0XG4gICAgICAgICAgICBpZiAoIWNvbnNvbGUgJiYgIWNvbnNvbGUubG9nICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyBtYXliZSBkbyBzb21ldGhpbmcgYmV0dGVyIHRoYW4gbm90aGluZ1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb25zb2xlIGFyZ3MgYXJyYXlcbiAgICAgICAgICAgIHZhciBjb25zb2xlQXJncyA9IFtdO1xuICAgICAgICAgICAgY29uc29sZUFyZ3MudW5zaGlmdC5hcHBseShjb25zb2xlQXJncywgYXJncyk7XG4gICAgICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0KFwiW1wiICsgTG9nTGV2ZWxbbGV2ZWxdICsgXCJdIDogXCIpO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMiAvKiBXYXJuICovKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCAubG9nIGZvciBEZWJ1Zy9JbmZvXG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgb24gc29tZSBvbGRlciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgYXBwbHkgb24gY29uc29sZS5sb2cgOihcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29uc29sZUFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZXZlbCA8IDMgLyogRXJyb3IgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIC53YXJuIGZvciBXYXJuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybi5hcHBseSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCAuZXJyb3IgZm9yIEVycm9yL0ZhdGFsXG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29uc29sZUFwcGVuZGVyO1xuICAgIH0pKCk7XG4gICAgZXguQ29uc29sZUFwcGVuZGVyID0gQ29uc29sZUFwcGVuZGVyO1xuICAgIC8qKlxuICAgICAqIE9uLXNjcmVlbiAoY2FudmFzKSBhcHBlbmRlclxuICAgICAqIEB0b2RvIENsZWFuIHRoaXMgdXBcbiAgICAgKiBAY2xhc3MgU2NyZWVuQXBwZW5kZXJcbiAgICAgKiBAZXh0ZW5kcyBJQXBwZW5kZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gd2lkdGgge251bWJlcn0gV2lkdGggb2YgdGhlIHNjcmVlbiBhcHBlbmRlciBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9IEhlaWdodCBvZiB0aGUgc2NyZWVuIGFwcGVuZGVyIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHZhciBTY3JlZW5BcHBlbmRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNjcmVlbkFwcGVuZGVyKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodCB8fCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBTY3JlZW5BcHBlbmRlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGFyZ3Muam9pbihcIixcIik7XG4gICAgICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy51bnNoaWZ0KFwiW1wiICsgTG9nTGV2ZWxbbGV2ZWxdICsgXCJdIDogXCIgKyBtZXNzYWdlKTtcbiAgICAgICAgICAgIHZhciBwb3MgPSAxMDtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMS4wO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LCcgKyBvcGFjaXR5LnRvRml4ZWQoMikgKyAnKSc7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQodGhpcy5fbWVzc2FnZXNbaV0sIDIwMCwgcG9zKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgb3BhY2l0eSA9IG9wYWNpdHkgPiAwID8gb3BhY2l0eSAtIC4wNSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTY3JlZW5BcHBlbmRlcjtcbiAgICB9KSgpO1xuICAgIGV4LlNjcmVlbkFwcGVuZGVyID0gU2NyZWVuQXBwZW5kZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVuZ2luZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvZy50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQW4gZW51bSByZXByZXNlbnRpbmcgYWxsIG9mIHRoZSBidWlsdCBpbiBldmVudCB0eXBlcyBmb3IgRXhjYWxpYnVyXG4gICAgICogQGNsYXNzIEV2ZW50VHlwZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoRXZlbnRUeXBlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgVXNlckV2ZW50IHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgQmx1ciB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEZvY3VzIHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgVXBkYXRlIHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgRW50ZXJWaWV3UG9ydCB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEV4aXRWaWV3UG9ydCB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEFjdGl2YXRlIHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgRGVhY3RpdmF0ZSB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEluaXRpYWxpemUge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkNvbGxpc2lvblwiXSA9IDBdID0gXCJDb2xsaXNpb25cIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkVudGVyVmlld1BvcnRcIl0gPSAxXSA9IFwiRW50ZXJWaWV3UG9ydFwiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiRXhpdFZpZXdQb3J0XCJdID0gMl0gPSBcIkV4aXRWaWV3UG9ydFwiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiQmx1clwiXSA9IDNdID0gXCJCbHVyXCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJGb2N1c1wiXSA9IDRdID0gXCJGb2N1c1wiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiVXBkYXRlXCJdID0gNV0gPSBcIlVwZGF0ZVwiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiQWN0aXZhdGVcIl0gPSA2XSA9IFwiQWN0aXZhdGVcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkRlYWN0aXZhdGVcIl0gPSA3XSA9IFwiRGVhY3RpdmF0ZVwiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiSW5pdGlhbGl6ZVwiXSA9IDhdID0gXCJJbml0aWFsaXplXCI7XG4gICAgfSkoZXguRXZlbnRUeXBlIHx8IChleC5FdmVudFR5cGUgPSB7fSkpO1xuICAgIHZhciBFdmVudFR5cGUgPSBleC5FdmVudFR5cGU7XG4gICAgLyoqXG4gICAgICogQmFzZSBldmVudCB0eXBlIGluIEV4Y2FsaWJ1ciB0aGF0IGFsbCBvdGhlciBldmVudCB0eXBlcyBkZXJpdmUgZnJvbS5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IHthbnl9IEV2ZW50cyBjYW4gaGF2ZSB0YXJnZXQgZ2FtZSBvYmplY3QsIGxpa2UgdGhlIEVuZ2luZSwgb3IgYW4gQWN0b3IuXG4gICAgICovXG4gICAgdmFyIEdhbWVFdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEdhbWVFdmVudCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR2FtZUV2ZW50O1xuICAgIH0pKCk7XG4gICAgZXguR2FtZUV2ZW50ID0gR2FtZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBFbmdpbmUgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgdmlzaWJsZVxuICAgICAqXG4gICAgICogQGNsYXNzIFZpc2libGVFdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBWaXNpYmxlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVmlzaWJsZUV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBWaXNpYmxlRXZlbnQoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlzaWJsZUV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguVmlzaWJsZUV2ZW50ID0gVmlzaWJsZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBFbmdpbmUgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgaGlkZGVuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgSGlkZGVuRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgSGlkZGVuRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoSGlkZGVuRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEhpZGRlbkV2ZW50KCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhpZGRlbkV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguSGlkZGVuRXZlbnQgPSBIaWRkZW5FdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gYWN0b3Igd2hlbiBhIGNvbGxpc2lvbiBoYXMgb2NjdXJlZFxuICAgICAqXG4gICAgICogQGNsYXNzIENvbGxpc2lvbkV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRoZSBldmVudCB3YXMgdGhyb3duIG9uXG4gICAgICogQHBhcmFtIG90aGVyIHtBY3Rvcn0gVGhlIGFjdG9yIHRoYXQgd2FzIGNvbGxpZGVkIHdpdGhcbiAgICAgKiBAcGFyYW0gc2lkZSB7U2lkZX0gVGhlIHNpZGUgdGhhdCB3YXMgY29sbGlkZWQgd2l0aFxuICAgICAqL1xuICAgIHZhciBDb2xsaXNpb25FdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhDb2xsaXNpb25FdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29sbGlzaW9uRXZlbnQoYWN0b3IsIG90aGVyLCBzaWRlLCBpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xuICAgICAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25FdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkNvbGxpc2lvbkV2ZW50ID0gQ29sbGlzaW9uRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGEgZ2FtZSBvYmplY3Qgb24gRXhjYWxpYnVyIHVwZGF0ZVxuICAgICAqXG4gICAgICogQGNsYXNzIFVwZGF0ZUV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAqL1xuICAgIHZhciBVcGRhdGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhVcGRhdGVFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVXBkYXRlRXZlbnQoZGVsdGEpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVcGRhdGVFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LlVwZGF0ZUV2ZW50ID0gVXBkYXRlRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIEFjdG9yIG9ubHkgb25jZSBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBjYWxsXG4gICAgICpcbiAgICAgKiBAY2xhc3MgSW5pdGlhbGl6ZUV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVuZ2luZVxuICAgICAqL1xuICAgIHZhciBJbml0aWFsaXplRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoSW5pdGlhbGl6ZUV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBJbml0aWFsaXplRXZlbnQoZW5naW5lKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbml0aWFsaXplRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5Jbml0aWFsaXplRXZlbnQgPSBJbml0aWFsaXplRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGEgU2NlbmUgb24gYWN0aXZhdGlvblxuICAgICAqXG4gICAgICogQGNsYXNzIEFjdGl2YXRlRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gb2xkU2NlbmUge1NjZW5lfSBUaGUgcmVmZXJlbmNlIHRvIHRoZSBvbGQgc2NlbmVcbiAgICAgKi9cbiAgICB2YXIgQWN0aXZhdGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhBY3RpdmF0ZUV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBY3RpdmF0ZUV2ZW50KG9sZFNjZW5lKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub2xkU2NlbmUgPSBvbGRTY2VuZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWN0aXZhdGVFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkFjdGl2YXRlRXZlbnQgPSBBY3RpdmF0ZUV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhIFNjZW5lIG9uIGRlYWN0aXZhdGlvblxuICAgICAqXG4gICAgICogQGNsYXNzIERlYWN0aXZhdGVFdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBuZXdTY2VuZSB7U2NlbmV9IFRoZSByZWZlcmVuY2UgdG8gdGhlIG5ldyBzY2VuZVxuICAgICAqL1xuICAgIHZhciBEZWFjdGl2YXRlRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRGVhY3RpdmF0ZUV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBEZWFjdGl2YXRlRXZlbnQobmV3U2NlbmUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5uZXdTY2VuZSA9IG5ld1NjZW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWFjdGl2YXRlRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5EZWFjdGl2YXRlRXZlbnQgPSBEZWFjdGl2YXRlRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGFuIEFjdG9yIHdoZW4gaXQgY29tcGxldGVseSBsZWF2ZXMgdGhlIHNjcmVlbi5cbiAgICAgKiBAY2xhc3MgRXhpdFZpZXdQb3J0RXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgRXhpdFZpZXdQb3J0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRXhpdFZpZXdQb3J0RXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEV4aXRWaWV3UG9ydEV2ZW50KCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEV4aXRWaWV3UG9ydEV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguRXhpdFZpZXdQb3J0RXZlbnQgPSBFeGl0Vmlld1BvcnRFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gQWN0b3Igd2hlbiBpdCBjb21wbGV0ZWx5IGxlYXZlcyB0aGUgc2NyZWVuLlxuICAgICAqIEBjbGFzcyBFbnRlclZpZXdQb3J0RXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgRW50ZXJWaWV3UG9ydEV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVudGVyVmlld1BvcnRFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRW50ZXJWaWV3UG9ydEV2ZW50KCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVudGVyVmlld1BvcnRFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkVudGVyVmlld1BvcnRFdmVudCA9IEVudGVyVmlld1BvcnRFdmVudDtcbiAgICAvKipcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IG1vdXNlIGJ1dHRvbnNcbiAgICAgKiBAY2xhc3MgTW91c2VCdXR0b25cbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKE1vdXNlQnV0dG9uKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBNb3VzZUJ1dHRvbltNb3VzZUJ1dHRvbltcIkxlZnRcIl0gPSAwXSA9IFwiTGVmdFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IExlZnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXCJNaWRkbGVcIl0gPSAxXSA9IFwiTWlkZGxlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBNb3VzZUJ1dHRvbltNb3VzZUJ1dHRvbltcIlJpZ2h0XCJdID0gMl0gPSBcIlJpZ2h0XCI7XG4gICAgfSkoZXguTW91c2VCdXR0b24gfHwgKGV4Lk1vdXNlQnV0dG9uID0ge30pKTtcbiAgICB2YXIgTW91c2VCdXR0b24gPSBleC5Nb3VzZUJ1dHRvbjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRXZlbnRzLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBFeGNhbGlidXIncyBpbnRlcm5hbCBldmVudCBkaXNwYXRjaGVyIGltcGxlbWVudGF0aW9uLiBDYWxsYmFja3MgYXJlIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIGFuIGV2ZW50IGlzIHB1Ymxpc2hlZFxuICAgICAqIEBjbGFzcyBFdmVudERpc3BhdGNoZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IHthbnl9IFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZSByZWNpcGllbnQgb2YgZXZlbnRzIGZyb20gdGhpcyBldmVudCBkaXNwYXRjaGVyXG4gICAgICovXG4gICAgdmFyIEV2ZW50RGlzcGF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcih0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLmxvZyA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFB1Ymxpc2ggYW4gZXZlbnQgZm9yIHRhcmdldFxuICAgICAgICAgKiBAbWV0aG9kIHB1Ymxpc2hcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcHVibGlzaFxuICAgICAgICAgKiBAcGFyYW0gW2V2ZW50PXVuZGVmaW5lZF0ge0dhbWVFdmVudH0gT3B0aW9uYWxseSBwYXNzIGFuIGV2ZW50IGRhdGEgb2JqZWN0IHRvIHRoZSBoYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBrZXkgbm90IG1hcHBlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV4LkdhbWVFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGFyZ2V0LCBldmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlciB0byBhIHBhcnRpY3VsYXIgZXZlbnQgbmFtZSwgbXVsdGlwbGUgaGFuZGxlcnMgcGVyIGV2ZW50IG5hbWUgYXJlIGFsbG93ZWQuXG4gICAgICAgICAqIEBtZXRob2Qgc3Vic2NyaWJlXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciB7R2FtZUV2ZW50PT52b2lkfSBUaGUgaGFuZGxlciBjYWxsYmFjayB0byBmaXJlIG9uIHRoaXMgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnN1YnNjcmliZSBhIGV2ZW50IGhhbmRsZXIocykgZnJvbSBhbiBldmVudC4gSWYgYSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICAgICAqIGlzIHNwZWNpZmllZCBmb3IgYW4gZXZlbnQsIG9ubHkgdGhhdCBoYW5kbGVyIHdpbGwgYmUgdW5zdWJzY3JpYmVkLlxuICAgICAgICAgKiBPdGhlcndpc2UgYWxsIGhhbmRsZXJzIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGZvciB0aGF0IGV2ZW50LlxuICAgICAgICAgKiBAbWV0aG9kIHVuc3Vic2NyaWJlXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHVuc3Vic2NyaWJlXG4gICAgICAgICAqIEBwYXJhbSBbaGFuZGxlcj11bmRlZmluZWRdIE9wdGlvbmFsbHkgdGhlIHNwZWNpZmljIGhhbmRsZXIgdG8gdW5zdWJzY3JpYmVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gZXhwbGljaXQgaGFuZGxlciBpcyBnaXZlIHdpdGggdGhlIGV2ZW50IG5hbWUgY2xlYXIgYWxsIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGV2ZW50SGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RGlzcGF0Y2hlcjtcbiAgICB9KSgpO1xuICAgIGV4LkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIENvbG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhbiByLCBnLCBiLCBhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBDb2xvclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHIge251bWJlcn0gVGhlIHJlZCBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxuICAgICAgICAgKiBAcGFyYW0gZyB7bnVtYmVyfSBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcbiAgICAgICAgICogQHBhcmFtIGIge251bWJlcn0gVGhlIGJsdWUgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcbiAgICAgICAgICogQHBhcmFtIFthPTFdIHtudW1iZXJ9IFRoZSBhbHBoYSBjb21wb25lbnQgb2YgY29sb3IgKDAtMS4wKVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29sb3IociwgZywgYiwgYSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICAgICAgICB0aGlzLmIgPSBiO1xuICAgICAgICAgICAgdGhpcy5hID0gYTtcbiAgICAgICAgICAgIHRoaXMuYSA9IChhICE9IG51bGwgPyBhIDogMSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhbiByLCBnLCBiLCBhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZnJvbVJHQlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSByIHtudW1iZXJ9IFRoZSByZWQgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcbiAgICAgICAgICogQHBhcmFtIGcge251bWJlcn0gVGhlIGdyZWVuIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBiIHtudW1iZXJ9IFRoZSBibHVlIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBbYT0xXSB7bnVtYmVyfSBUaGUgYWxwaGEgY29tcG9uZW50IG9mIGNvbG9yICgwLTEuMClcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLmZyb21SR0IgPSBmdW5jdGlvbiAociwgZywgYiwgYSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zY2FuY2Ugb2YgQ29sb3IgZnJvbSBhIGhleCBzdHJpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBmcm9tSGV4XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIGhleCB7c3RyaW5nfSBDU1MgY29sb3Igc3RyaW5nIG9mIHRoZSBmb3JtICNmZmZmZmYsIHRoZSBhbHBoYSBjb21wb25lbnQgaXMgb3B0aW9uYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLmZyb21IZXggPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgICAgICB2YXIgaGV4UmVnRXggPSAvXiM/KFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KT8kL2k7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgaWYgKG1hdGNoID0gaGV4Lm1hdGNoKGhleFJlZ0V4KSkge1xuICAgICAgICAgICAgICAgIHZhciByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBwYXJzZUludChtYXRjaFszXSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBhID0gMTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IHBhcnNlSW50KG1hdGNoWzRdLCAxNikgLyAyNTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmc6IFwiICsgaGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBDU1Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXG4gICAgICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgICAgICogQHJldHVybnMgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gU3RyaW5nKHRoaXMuci50b0ZpeGVkKDApKSArIFwiLCBcIiArIFN0cmluZyh0aGlzLmcudG9GaXhlZCgwKSkgKyBcIiwgXCIgKyBTdHJpbmcodGhpcy5iLnRvRml4ZWQoMCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInJnYmEoXCIgKyByZXN1bHQgKyBcIiwgXCIgKyBTdHJpbmcodGhpcy5hKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwicmdiKFwiICsgcmVzdWx0ICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxuICAgICAgICAgKiBAbWV0aG9kIGZpbGxTdHlsZVxuICAgICAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5maWxsU3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IGNvbG9yLlxuICAgICAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICAgICAqIEByZXR1cm5zIENvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgQmxhY2sge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuQmxhY2sgPSBDb2xvci5mcm9tSGV4KCcjMDAwMDAwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgV2hpdGUge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuV2hpdGUgPSBDb2xvci5mcm9tSGV4KCcjRkZGRkZGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgR3JheSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5HcmF5ID0gQ29sb3IuZnJvbUhleCgnIzgwODA4MCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IExpZ2h0R3JheSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5MaWdodEdyYXkgPSBDb2xvci5mcm9tSGV4KCcjRDNEM0QzJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgRGFya0dyYXkge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuRGFya0dyYXkgPSBDb2xvci5mcm9tSGV4KCcjQTlBOUE5Jyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgWWVsbG93IHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLlllbGxvdyA9IENvbG9yLmZyb21IZXgoJyNGRkZGMDAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBPcmFuZ2Uge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuT3JhbmdlID0gQ29sb3IuZnJvbUhleCgnI0ZGQTUwMCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFJlZCB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5SZWQgPSBDb2xvci5mcm9tSGV4KCcjRkYwMDAwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgVmVybWlsbGlvbiB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5WZXJtaWxsaW9uID0gQ29sb3IuZnJvbUhleCgnI0ZGNUIzMScpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFJvc2Uge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuUm9zZSA9IENvbG9yLmZyb21IZXgoJyNGRjAwN0YnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBNYWdlbnRhIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLk1hZ2VudGEgPSBDb2xvci5mcm9tSGV4KCcjRkYwMEZGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgVmlvbGV0IHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLlZpb2xldCA9IENvbG9yLmZyb21IZXgoJyM3RjAwRkYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBCbHVlIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkJsdWUgPSBDb2xvci5mcm9tSGV4KCcjMDAwMEZGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgQXp1cmUge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuQXp1cmUgPSBDb2xvci5mcm9tSGV4KCcjMDA3RkZGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgQ3lhbiB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5DeWFuID0gQ29sb3IuZnJvbUhleCgnIzAwRkZGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFZpcmlkaWFuIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLlZpcmlkaWFuID0gQ29sb3IuZnJvbUhleCgnIzU5OTc4RicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEdyZWVuIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkdyZWVuID0gQ29sb3IuZnJvbUhleCgnIzAwRkYwMCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IENoYXJ0cmV1c2Uge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuQ2hhcnRyZXVzZSA9IENvbG9yLmZyb21IZXgoJyM3RkZGMDAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBUcmFuc3BhcmVudCB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5UcmFuc3BhcmVudCA9IENvbG9yLmZyb21IZXgoJyNGRkZGRkYwMCcpO1xuICAgICAgICByZXR1cm4gQ29sb3I7XG4gICAgfSkoKTtcbiAgICBleC5Db2xvciA9IENvbG9yO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogSGVscGVyIEFjdG9yIHByaW1pdGl2ZSBmb3IgZHJhd2luZyBVSSdzLCBvcHRpbWl6ZWQgZm9yIFVJIGRyYXdpbmcuIERvZXNcbiAgICAgKiBub3QgcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucy5cbiAgICAgKiBAY2xhc3MgVUlBY3RvclxuICAgICAqIEBleHRlbmRzIEFjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt4PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHggY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW3k9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgeSBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbd2lkdGg9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgd2lkdGggb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFtoZWlnaHQ9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgaGVpZ2h0IG9mIHRoZSBhY3RvclxuICAgICAqL1xuICAgIHZhciBVSUFjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFVJQWN0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFVJQWN0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnBpcGVsaW5lID0gW107XG4gICAgICAgICAgICB0aGlzLnBpcGVsaW5lLnB1c2gobmV3IGV4Lk1vdmVtZW50TW9kdWxlKCkpO1xuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKG5ldyBleC5DYXB0dXJlUG9pbnRlck1vZHVsZSgpKTtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yLnNldFRvKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25UeXBlID0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgVUlBY3Rvci5wcm90b3R5cGUub25Jbml0aWFsaXplID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICB9O1xuICAgICAgICBVSUFjdG9yLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh4LCB5LCB1c2VXb3JsZCkge1xuICAgICAgICAgICAgaWYgKHVzZVdvcmxkID09PSB2b2lkIDApIHsgdXNlV29ybGQgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAodXNlV29ybGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY29udGFpbnMuY2FsbCh0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9lbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKG5ldyBleC5Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb250YWlucy5jYWxsKHRoaXMsIGNvb3Jkcy54LCBjb29yZHMueSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBVSUFjdG9yO1xuICAgIH0pKGV4LkFjdG9yKTtcbiAgICBleC5VSUFjdG9yID0gVUlBY3Rvcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVuZ2luZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYSBtZXRob2Qgb2YgZmlyaW5nIGFyYml0cmFyeSBjb2RlIG9uIGNvbGxpc2lvbi4gVGhlc2UgYXJlIHVzZWZ1bFxuICAgICAqIGFzICdidXR0b25zJywgJ3N3aXRjaGVzJywgb3IgdG8gdHJpZ2dlciBlZmZlY3RzIGluIGEgZ2FtZS4gQnkgZGVmdWFsdCB0cmlnZ2Vyc1xuICAgICAqIGFyZSBpbnZpc2libGUsIGFuZCBjYW4gb25seSBiZSBzZWVuIHdpdGggZGVidWcgbW9kZSBlbmFibGVkIG9uIHRoZSBFbmdpbmUuXG4gICAgICogQGNsYXNzIFRyaWdnZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW3g9MF0ge251bWJlcn0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0gW3k9MF0ge251bWJlcn0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0gW3dpZHRoPTBdIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgdHJpZ2dlclxuICAgICAqIEBwYXJhbSBbaGVpZ2h0PTBdIHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0gW2FjdGlvbj1udWxsXSB7KCk9PnZvaWR9IENhbGxiYWNrIHRvIGZpcmUgd2hlbiB0cmlnZ2VyIGlzIGFjdGl2YXRlZFxuICAgICAqIEBwYXJhbSBbcmVwZWF0cz0xXSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgdGhpcyB0cmlnZ2VyIHNob3VsZCBmaXJlLCBieSBkZWZhdWx0IGl0IGlzIDEsIGlmIC0xIGlzIHN1cHBsaWVkIGl0IHdpbGwgZmlyZSBpbmRlZmluaXRlbHlcbiAgICAgKi9cbiAgICB2YXIgVHJpZ2dlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUcmlnZ2VyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUcmlnZ2VyKHgsIHksIHdpZHRoLCBoZWlnaHQsIGFjdGlvbiwgcmVwZWF0cykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJlcGVhdHMgPSAxO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRzID0gcmVwZWF0cyB8fCB0aGlzLnJlcGVhdHM7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbiB8fCB0aGlzLmFjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IGV4LkV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUgPSBuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5BY3Rpb25RdWV1ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGlvbiBxdWV1ZVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcbiAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLmR4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy55ICs9IHRoaXMuZHkgKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uICs9IHRoaXMucnggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggKz0gdGhpcy5zeCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSArPSB0aGlzLnN5ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRyaWdnZXIgY29sbGlzaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sbGlkZXModGhpcy50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hBY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZ2luZS5jdXJyZW50U2NlbmUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyID0gZW5naW5lLmN1cnJlbnRTY2VuZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyICE9PSB0aGlzICYmIG90aGVyLmNvbGxpc2lvblR5cGUgIT09IDAgLyogUHJldmVudENvbGxpc2lvbiAqLyAmJiB0aGlzLmNvbGxpZGVzKG90aGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEFjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyaWdnZXIgaWYgaXRzIGRvbmUsIC0xIHJlcGVhdCBmb3JldmVyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5raWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLmRpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cy0tO1xuICAgICAgICB9O1xuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIGRvZXMgbm90IGRyYXdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcuY2FsbCh0aGlzLCBjdHgpO1xuICAgICAgICAgICAgLy8gTWVhbnQgdG8gZHJhdyBkZWJ1ZyBpbmZvcm1hdGlvbiBhYm91dCBhY3RvcnNcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICBiYi5sZWZ0ID0gYmIubGVmdCAtIHRoaXMuZ2V0R2xvYmFsWCgpO1xuICAgICAgICAgICAgYmIucmlnaHQgPSBiYi5yaWdodCAtIHRoaXMuZ2V0R2xvYmFsWCgpO1xuICAgICAgICAgICAgYmIudG9wID0gYmIudG9wIC0gdGhpcy5nZXRHbG9iYWxZKCk7XG4gICAgICAgICAgICBiYi5ib3R0b20gPSBiYi5ib3R0b20gLSB0aGlzLmdldEdsb2JhbFkoKTtcbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSBjb2xsaXNpb24gcHJpbWl0aXZlcyBjYW5ub3Qgcm90YXRlIFxuICAgICAgICAgICAgLy8gY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBleC5Db2xvci5WaW9sZXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGV4LkNvbG9yLlZpb2xldC50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KCdUcmlnZ2VyJywgMTAsIDEwKTtcbiAgICAgICAgICAgIGJiLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRyaWdnZXI7XG4gICAgfSkoZXguQWN0b3IpO1xuICAgIGV4LlRyaWdnZXIgPSBUcmlnZ2VyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFsZ2VicmEudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlV0aWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBbiBlbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgdHlwZXMgb2YgZW1pdHRlciBub3p6bGVzXG4gICAgICogQGNsYXNzIEVtaXR0ZXJUeXBlXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChFbWl0dGVyVHlwZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgZm9yIHRoZSBjaXJjdWxhciBlbWl0dGVyIHR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IENpcmNsZSB7RW1pdHRlclR5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBFbWl0dGVyVHlwZVtFbWl0dGVyVHlwZVtcIkNpcmNsZVwiXSA9IDBdID0gXCJDaXJjbGVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IGZvciB0aGUgcmVjdGFuZ3VsYXIgZW1pdHRlciB0eXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBSZWN0YW5nbGUge0VtaXR0ZXJUeXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJSZWN0YW5nbGVcIl0gPSAxXSA9IFwiUmVjdGFuZ2xlXCI7XG4gICAgfSkoZXguRW1pdHRlclR5cGUgfHwgKGV4LkVtaXR0ZXJUeXBlID0ge30pKTtcbiAgICB2YXIgRW1pdHRlclR5cGUgPSBleC5FbWl0dGVyVHlwZTtcbiAgICB2YXIgUGFydGljbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQYXJ0aWNsZShlbWl0dGVyLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBleC5WZWN0b3IoMCwgMCk7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IGV4LlZlY3RvcigwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IGV4LlZlY3RvcigwLCAwKTtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Um90YXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5mb2N1cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQWNjZWwgPSAwO1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IGV4LkNvbG9yLldoaXRlLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLmVuZENvbG9yID0gZXguQ29sb3IuV2hpdGUuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vIExpZmUgaXMgY291bnRlZCBpbiBtc1xuICAgICAgICAgICAgdGhpcy5saWZlID0gMzAwO1xuICAgICAgICAgICAgdGhpcy5mYWRlRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ29sb3IgdHJhbnNpdGlvbnNcbiAgICAgICAgICAgIHRoaXMuclJhdGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5nUmF0ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmJSYXRlID0gMTtcbiAgICAgICAgICAgIHRoaXMuYVJhdGUgPSAwO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IgPSBleC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gNTtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zaXplUmF0ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyID0gMDtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgICAgICB0aGlzLmxpZmUgPSBsaWZlIHx8IHRoaXMubGlmZTtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHkgfHwgdGhpcy5vcGFjaXR5O1xuICAgICAgICAgICAgdGhpcy5lbmRDb2xvciA9IGVuZENvbG9yIHx8IHRoaXMuZW5kQ29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IGJlZ2luQ29sb3IgfHwgdGhpcy5iZWdpbkNvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvciA9IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmVsb2NpdHkgfHwgdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gYWNjZWxlcmF0aW9uIHx8IHRoaXMuYWNjZWxlcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5yUmF0ZSA9ICh0aGlzLmVuZENvbG9yLnIgLSB0aGlzLmJlZ2luQ29sb3IucikgLyB0aGlzLmxpZmU7XG4gICAgICAgICAgICB0aGlzLmdSYXRlID0gKHRoaXMuZW5kQ29sb3IuZyAtIHRoaXMuYmVnaW5Db2xvci5nKSAvIHRoaXMubGlmZTtcbiAgICAgICAgICAgIHRoaXMuYlJhdGUgPSAodGhpcy5lbmRDb2xvci5iIC0gdGhpcy5iZWdpbkNvbG9yLmIpIC8gdGhpcy5saWZlO1xuICAgICAgICAgICAgdGhpcy5hUmF0ZSA9IHRoaXMub3BhY2l0eSAvIHRoaXMubGlmZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaXplID0gc3RhcnRTaXplIHx8IDA7XG4gICAgICAgICAgICB0aGlzLmVuZFNpemUgPSBlbmRTaXplIHx8IDA7XG4gICAgICAgICAgICBpZiAoKHRoaXMuZW5kU2l6ZSA+IDApICYmICh0aGlzLnN0YXJ0U2l6ZSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplUmF0ZSA9ICh0aGlzLmVuZFNpemUgLSB0aGlzLnN0YXJ0U2l6ZSkgLyB0aGlzLmxpZmU7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSB0aGlzLnN0YXJ0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQYXJ0aWNsZS5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5yZW1vdmVQYXJ0aWNsZSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5saWZlID0gdGhpcy5saWZlIC0gZGVsdGE7XG4gICAgICAgICAgICB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyID0gdGhpcy5lbGFwc2VkTXVsdGlwbGllciArIGRlbHRhO1xuICAgICAgICAgICAgaWYgKHRoaXMubGlmZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZhZGVGbGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZXguVXRpbC5jbGFtcCh0aGlzLmFSYXRlICogdGhpcy5saWZlLCAwLjAwMDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLnN0YXJ0U2l6ZSA+IDApICYmICh0aGlzLmVuZFNpemUgPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gZXguVXRpbC5jbGFtcCh0aGlzLnNpemVSYXRlICogZGVsdGEgKyB0aGlzLnBhcnRpY2xlU2l6ZSwgTWF0aC5taW4odGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSksIE1hdGgubWF4KHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yLnIgPSBleC5VdGlsLmNsYW1wKHRoaXMuY3VycmVudENvbG9yLnIgKyB0aGlzLnJSYXRlICogZGVsdGEsIDAsIDI1NSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvci5nID0gZXguVXRpbC5jbGFtcCh0aGlzLmN1cnJlbnRDb2xvci5nICsgdGhpcy5nUmF0ZSAqIGRlbHRhLCAwLCAyNTUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IuYiA9IGV4LlV0aWwuY2xhbXAodGhpcy5jdXJyZW50Q29sb3IuYiArIHRoaXMuYlJhdGUgKiBkZWx0YSwgMCwgMjU1KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yLmEgPSBleC5VdGlsLmNsYW1wKHRoaXMub3BhY2l0eSwgMC4wMDAxLCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjY2VsID0gdGhpcy5mb2N1cy5taW51cyh0aGlzLnBvc2l0aW9uKS5ub3JtYWxpemUoKS5zY2FsZSh0aGlzLmZvY3VzQWNjZWwpLnNjYWxlKGRlbHRhIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkuYWRkKGFjY2VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZCh0aGlzLmFjY2VsZXJhdGlvbi5zY2FsZShkZWx0YSAvIDEwMDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmFkZCh0aGlzLnZlbG9jaXR5LnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3RhdGlvbiA9ICh0aGlzLmN1cnJlbnRSb3RhdGlvbiArIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgKiBkZWx0YSAvIDEwMDApICUgKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUGFydGljbGUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUuc2V0Um90YXRpb24odGhpcy5jdXJyZW50Um90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUuc2V0U2NhbGVYKHRoaXMucGFydGljbGVTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLnNldFNjYWxlWSh0aGlzLnBhcnRpY2xlU2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5kcmF3KGN0eCwgdGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yLmEgPSBleC5VdGlsLmNsYW1wKHRoaXMub3BhY2l0eSwgMC4wMDAxLCAxKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnJlbnRDb2xvci50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSwgdGhpcy5wYXJ0aWNsZVNpemUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQYXJ0aWNsZTtcbiAgICB9KSgpO1xuICAgIGV4LlBhcnRpY2xlID0gUGFydGljbGU7XG4gICAgLyoqXG4gICAgICogVXNpbmcgYSBwYXJ0aWNsZSBlbWl0dGVyIGlzIGEgZ3JlYXQgd2F5IHRvIGNyZWF0ZSBpbnRlcmVzdGluZyBlZmZlY3RzXG4gICAgICogaW4geW91ciBnYW1lLCBsaWtlIHNtb2tlLCBmaXJlLCB3YXRlciwgZXhwbG9zaW9ucywgZXRjLiBQYXJ0aWNsZSBFbWl0dGVyc1xuICAgICAqIGV4dGVuZCBBY3RvciBhbGxvd2luZyB5b3UgdG8gdXNlIGFsbCBvZiB0aGUgZmVhdHVyZXMgdGhhdCBjb21lIHdpdGggQWN0b3JcbiAgICAgKiBAY2xhc3MgUGFydGljbGVFbWl0dGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt4PTBdIHtudW1iZXJ9IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlbWl0dGVyXG4gICAgICogQHBhcmFtIFt5PTBdIHtudW1iZXJ9IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbWl0dGVyXG4gICAgICogQHBhcmFtIFt3aWR0aD0wXSB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGVtaXR0ZXJcbiAgICAgKiBAcGFyYW0gW2hlaWdodD0wXSB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBlbWl0dGVyXG4gICAgICovXG4gICAgdmFyIFBhcnRpY2xlRW1pdHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhQYXJ0aWNsZUVtaXR0ZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFBhcnRpY2xlRW1pdHRlcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBleC5Db2xvci5XaGl0ZSk7XG4gICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSAwO1xuICAgICAgICAgICAgdGhpcy5udW1QYXJ0aWNsZXMgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGlzRW1pdHRpbmcgZmxhZ1xuICAgICAgICAgICAgICogQHByb3BlcnR5IGlzRW1pdHRpbmcge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNFbWl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFja2luZyBwYXJ0aWNsZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgcGFydGljbGVzIHtVdGlsLkNvbGxlY3Rpb24mbHQ7UGFydGljbGUmZ3Q7fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFja2luZyBkZWFkUGFydGljbGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHBhcnRpY2xlcyB7VXRpbC5Db2xsZWN0aW9uJmx0O1BhcnRpY2xlJmd0O31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHBhcnRpY2FsIHZlbG9jaXR5XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW21pblZlbD0wXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1pblZlbCA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBwYXJ0aWNhbCB2ZWxvY2l0eVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFttYXhWZWw9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5tYXhWZWwgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGFjY2VsZXJhdGlvbiB2ZWN0b3IgZm9yIGFsbCBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbYWNjZWxlcmF0aW9uPW5ldyBWZWN0b3IoMCwwKV0ge1ZlY3Rvcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgZXguVmVjdG9yKDAsIDApO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gYW5nbGUgaW4gcmFkaWFuc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFttaW5BbmdsZT0wXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1pbkFuZ2xlID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWF4QW5nbGU9MF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5tYXhBbmdsZSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pc3Npb24gcmF0ZSBmb3IgcGFydGljbGVzIChwYXJ0aWNsZXMvc2VjKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtlbWl0UmF0ZT0xXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVtaXRSYXRlID0gMTsgLy9wYXJ0aWNsZXMvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGlmZSBvZiBlYWNoIHBhcnRpY2xlIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFtwYXJ0aWNsZUxpZmU9MjAwMF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZUxpZmUgPSAyMDAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wYWNpdHkgb2YgZWFjaCBwYXJ0aWNsZSBmcm9tIDAgdG8gMS4wXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW29wYWNpdHk9MS4wXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGZhZGUgZmxhZyB3aGljaCBjYXVzZXMgcGFydGljbGVzIHRvIGdyYWR1YWxseSBmYWRlIG91dCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlaXIgbGlmZS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZmFkZT1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmFkZUZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBmb2N1cyB3aGVyZSBhbGwgcGFydGljbGVzIHNob3VsZCBhY2NlbGVyYXRlIHRvd2FyZHNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZm9jdXM9bnVsbF0ge1ZlY3Rvcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mb2N1cyA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWNjZWxlcmF0aW9uIGZvciBmb2N1c2luZyBwYXJ0aWNsZXMgaWYgYSBmb2N1cyBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZm9jdXNBY2NlbD0xXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZvY3VzQWNjZWwgPSAxO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgc3RhcnRpbmcgc2l6ZSBmb3IgdGhlIHBhcnRpY2xlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFtzdGFydFNpemU9bnVsbF0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zdGFydFNpemUgPSBudWxsO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgZW5kaW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZW5kU2l6ZT1udWxsXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVuZFNpemUgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gc2l6ZSBvZiBhbGwgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW21pblNpemU9NV0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5taW5TaXplID0gNTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFttYXhTaXplPTVdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWF4U2l6ZSA9IDU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmVnaW5uaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbYmVnaW5Db2xvcj1Db2xvci5XaGl0ZV0ge0NvbG9yfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBleC5Db2xvci5XaGl0ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbmRpbmcgY29sb3Igb2YgYWxsIHBhcnRpY2xlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFtlbmRDb2xvcj1Db2xvci5XaGl0ZV0ge0NvbG9yfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVuZENvbG9yID0gZXguQ29sb3IuV2hpdGU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc3ByaXRlIHRoYXQgYSBwYXJ0aWNsZSBzaG91bGQgdXNlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW3BhcnRpY2xlU3ByaXRlPW51bGxdIHtTcHJpdGV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXR0ZXIgdHlwZSBmb3IgdGhlIHBhcnRpY2xlIGVtaXR0ZXJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZW1pdHRlclR5cGU9RW1pdHRlclR5cGUuUmVjdGFuZ2xlXSB7RW1pdHRlclR5cGV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW1pdHRlclR5cGUgPSAxIC8qIFJlY3RhbmdsZSAqLztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWl0dGVyIHJhZGl1cywgb25seSB0YWtlcyBlZmZlY3Qgd2hlbiB0aGUgZW1pdHRlclR5cGUgaXMgQ2lyY2xlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW3JhZGl1cz0wXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcGFydGljbGUgcm90YXRpb25hbCBzcGVlZCB2ZWxvY2l0eVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtwYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eT0wXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgcGFydGljbGVzIHNob3VsZCBzdGFydCB3aXRoIGEgcmFuZG9tIHJvdGF0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW3JhbmRvbVJvdGF0aW9uPWZhbHNlXSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yYW5kb21Sb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25UeXBlID0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBuZXcgZXguVXRpbC5Db2xsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMgPSBuZXcgZXguVXRpbC5Db2xsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVQYXJ0aWNsZSA9IGZ1bmN0aW9uIChwYXJ0aWNsZSkge1xuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLnB1c2gocGFydGljbGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2F1c2VzIHRoZSBlbWl0dGVyIHRvIGVtaXQgcGFydGljbGVzXG4gICAgICAgICAqIEBtZXRob2QgZW1pdFxuICAgICAgICAgKiBAcGFyYW0gcGFydGljbGVDb3VudCB7bnVtYmVyfSBOdW1iZXIgb2YgcGFydGljbGVzIHRvIGVtaXQgcmlnaHQgbm93XG4gICAgICAgICAqL1xuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAocGFydGljbGVDb3VudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWNsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5wdXNoKHRoaXMuY3JlYXRlUGFydGljbGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUuY2xlYXJQYXJ0aWNsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5jbGVhcigpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGVzIGEgbmV3IHBhcnRpY2xlIGdpdmVuIHRoZSBjb250cmFpbnRzIG9mIHRoZSBlbWl0dGVyXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUuY3JlYXRlUGFydGljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0b2RvIGltcGxlbWVudCBlbWl0dGVyIGNvbnRyYWludHM7XG4gICAgICAgICAgICB2YXIgcmFuWCA9IDA7XG4gICAgICAgICAgICB2YXIgcmFuWSA9IDA7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBleC5VdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5taW5BbmdsZSwgdGhpcy5tYXhBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdmVsID0gZXguVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluVmVsLCB0aGlzLm1heFZlbCk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc3RhcnRTaXplIHx8IGV4LlV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLm1pblNpemUsIHRoaXMubWF4U2l6ZSk7XG4gICAgICAgICAgICB2YXIgZHggPSB2ZWwgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICB2YXIgZHkgPSB2ZWwgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gMSAvKiBSZWN0YW5nbGUgKi8pIHtcbiAgICAgICAgICAgICAgICByYW5YID0gZXguVXRpbC5yYW5kb21JblJhbmdlKHRoaXMueCwgdGhpcy54ICsgdGhpcy5nZXRXaWR0aCgpKTtcbiAgICAgICAgICAgICAgICByYW5ZID0gZXguVXRpbC5yYW5kb21JblJhbmdlKHRoaXMueSwgdGhpcy55ICsgdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmVtaXR0ZXJUeXBlID09PSAwIC8qIENpcmNsZSAqLykge1xuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBleC5VdGlsLnJhbmRvbUluUmFuZ2UoMCwgdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIHJhblggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkgKyB0aGlzLng7XG4gICAgICAgICAgICAgICAgcmFuWSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSArIHRoaXMueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwID0gbmV3IFBhcnRpY2xlKHRoaXMsIHRoaXMucGFydGljbGVMaWZlLCB0aGlzLm9wYWNpdHksIHRoaXMuYmVnaW5Db2xvciwgdGhpcy5lbmRDb2xvciwgbmV3IGV4LlZlY3RvcihyYW5YLCByYW5ZKSwgbmV3IGV4LlZlY3RvcihkeCwgZHkpLCB0aGlzLmFjY2VsZXJhdGlvbiwgdGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSk7XG4gICAgICAgICAgICBwLmZhZGVGbGFnID0gdGhpcy5mYWRlRmxhZztcbiAgICAgICAgICAgIHAucGFydGljbGVTaXplID0gc2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpY2xlU3ByaXRlKSB7XG4gICAgICAgICAgICAgICAgcC5wYXJ0aWNsZVNwcml0ZSA9IHRoaXMucGFydGljbGVTcHJpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmRvbVJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcC5jdXJyZW50Um90YXRpb24gPSBleC5VdGlsLnJhbmRvbUluUmFuZ2UoMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBwLmZvY3VzID0gdGhpcy5mb2N1cy5hZGQobmV3IGV4LlZlY3Rvcih0aGlzLngsIHRoaXMueSkpO1xuICAgICAgICAgICAgICAgIHAuZm9jdXNBY2NlbCA9IHRoaXMuZm9jdXNBY2NlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9O1xuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW1pdHRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgKz0gdGhpcy5lbWl0UmF0ZSAqIChkZWx0YSAvIDEwMDApO1xuICAgICAgICAgICAgICAgIHZhciBudW1QYXJ0aWNsZXMgPSBNYXRoLmNlaWwodGhpcy5lbWl0UmF0ZSAqIGRlbHRhIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA+IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoTWF0aC5mbG9vcih0aGlzLl9wYXJ0aWNsZXNUb0VtaXQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ID0gdGhpcy5fcGFydGljbGVzVG9FbWl0IC0gTWF0aC5mbG9vcih0aGlzLl9wYXJ0aWNsZXNUb0VtaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJ0aWNsZXMucmVtb3ZlRWxlbWVudChwYXJ0aWNsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcy5jbGVhcigpO1xuICAgICAgICB9O1xuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydGljbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyBpcyB0aGVyZSBhIG1vcmUgZWZmaWNpZW50IHRvIGRyYXcgXG4gICAgICAgICAgICAgICAgLy8gcG9zc2libHkgdXNlIGEgd2ViZ2wgb2Zmc2NyZWVuIGNhbnZhcyBhbmQgc2hhZGVycyB0byBkbyBwYXJ0aWNsZXM/XG4gICAgICAgICAgICAgICAgcGFydGljbGUuZHJhdyhjdHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcuY2FsbCh0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGV4LkNvbG9yLkJsYWNrLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoXCJQYXJ0aWNsZXM6IFwiICsgdGhpcy5wYXJ0aWNsZXMuY291bnQoKSwgdGhpcy54LCB0aGlzLnkgKyAyMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1cykge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLmZvY3VzLnggKyB0aGlzLngsIHRoaXMuZm9jdXMueSArIHRoaXMueSwgMywgMyk7XG4gICAgICAgICAgICAgICAgZXguVXRpbC5kcmF3TGluZShjdHgsIFwieWVsbG93XCIsIHRoaXMuZm9jdXMueCArIHRoaXMueCwgdGhpcy5mb2N1cy55ICsgdGhpcy55LCBfc3VwZXIucHJvdG90eXBlLmdldENlbnRlci5jYWxsKHRoaXMpLngsIF9zdXBlci5wcm90b3R5cGUuZ2V0Q2VudGVyLmNhbGwodGhpcykueSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KFwiRm9jdXNcIiwgdGhpcy5mb2N1cy54ICsgdGhpcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGFydGljbGVFbWl0dGVyO1xuICAgIH0pKGV4LkFjdG9yKTtcbiAgICBleC5QYXJ0aWNsZUVtaXR0ZXIgPSBQYXJ0aWNsZUVtaXR0ZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbnMgYWxsb3cgeW91IHRvIGRpc3BsYXkgYSBzZXJpZXMgb2YgaW1hZ2VzIG9uZSBhZnRlciBhbm90aGVyLFxuICAgICAqIGNyZWF0aW5nIHRoZSBpbGx1c2lvbiBvZiBjaGFuZ2UuIEdlbmVyYWxseSB0aGVzZSBpbWFnZXMgd2lsbCBjb21lIGZyb20gYSBzcHJpdGUgc2hlZXQgc291cmNlLlxuICAgICAqIEBjbGFzcyBBbmltYXRpb25cbiAgICAgKiBAZXh0ZW5kcyBJRHJhd2FibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIGVuZ2luZVxuICAgICAqIEBwYXJhbSBpbWFnZXMge1Nwcml0ZVtdfSBBbiBhcnJheSBvZiBzcHJpdGVzIHRvIGNyZWF0ZSB0aGUgZnJhbWVzIGZvciB0aGUgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIFtsb29wPWZhbHNlXSB7Ym9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcCBhZnRlciBpdCBpcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uKGVuZ2luZSwgaW1hZ2VzLCBzcGVlZCwgbG9vcCkge1xuICAgICAgICAgICAgdGhpcy5jdXJySW5kZXggPSAwO1xuICAgICAgICAgICAgdGhpcy5vbGRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwLjA7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IDEuMDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gMS4wO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIHNob3VsZCBsb29wIGFmdGVyIGl0IGlzIGNvbXBsZXRlZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtsb29wPWZhbHNlXSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMgPSBpbWFnZXM7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgICAgIGlmIChsb29wICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBpbWFnZXNbMF0gPyBpbWFnZXNbMF0uaGVpZ2h0IDogMDtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBpbWFnZXNbMF0gPyBpbWFnZXNbMF0ud2lkdGggOiAwO1xuICAgICAgICB9XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuYWRkRWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uYWRkRWZmZWN0KGVmZmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucmVtb3ZlRWZmZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5yZW1vdmVFZmZlY3QocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmNsZWFyRWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmNsZWFyRWZmZWN0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnRyYW5zZm9ybUFib3V0UG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnRyYW5zZm9ybUFib3V0UG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnNldFJvdGF0aW9uID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSByYWRpYW5zO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uc2V0Um90YXRpb24ocmFkaWFucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRTY2FsZVggPSBmdW5jdGlvbiAoc2NhbGVYKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnNldFNjYWxlWChzY2FsZVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnNldFNjYWxlWSA9IGZ1bmN0aW9uIChzY2FsZVkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uc2V0U2NhbGVZKHNjYWxlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuZ2V0U2NhbGVYID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmdldFNjYWxlWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgYW5pbWF0aW9uIHRvIGZpcnN0IGZyYW1lLlxuICAgICAgICAgKiBAbWV0aG9kIHJlc2V0XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jdXJySW5kZXggPSAwO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgYW5pbWF0aW9ucyB0aGF0IGxvb3AgYXJlIG5ldmVyIGNvbXBsZXRlLlxuICAgICAgICAgKiBAbWV0aG9kIGlzRG9uZVxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoIXRoaXMubG9vcCAmJiB0aGlzLmN1cnJJbmRleCA+PSB0aGlzLnNwcml0ZXMubGVuZ3RoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdCBtZWFudCB0byBiZSBjYWxsZWQgYnkgZ2FtZSBkZXZlbG9wZXJzLiBUaWNrcyB0aGUgYW5pbWF0aW9uIGZvcndhcmQgaW50ZXJuYWxseSBhblxuICAgICAgICAgKiBjYWxjdWxhdGVzIHdoZXRoZXIgdG8gY2hhbmdlIHRvIHRlaCBmcmFtZS5cbiAgICAgICAgICogQG1ldGhvZCB0aWNrXG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAoKHRpbWUgLSB0aGlzLm9sZFRpbWUpID4gdGhpcy5zcGVlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gKHRoaXMubG9vcCA/ICh0aGlzLmN1cnJJbmRleCArIDEpICUgdGhpcy5zcHJpdGVzLmxlbmd0aCA6IHRoaXMuY3VyckluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRUaW1lID0gdGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNraXBzIGFoZWFkIGEgc3BlY2lmaWVkIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiBAbWV0aG9kIHNraXBcbiAgICAgICAgICogQHBhcmFtIGZyYW1lcyB7bnVtYmVyfSBGcmFtZXMgdG8gc2tpcCBhaGVhZFxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKGZyYW1lcykge1xuICAgICAgICAgICAgdGhpcy5jdXJySW5kZXggPSAodGhpcy5jdXJySW5kZXggKyBmcmFtZXMpICUgdGhpcy5zcHJpdGVzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSkge1xuICAgICAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJySW5kZXggPCB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJTcHJpdGUgPSB0aGlzLnNwcml0ZXNbdGhpcy5jdXJySW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsaXBWZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyU3ByaXRlLmZsaXBWZXJ0aWNhbCA9IHRoaXMuZmxpcFZlcnRpY2FsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyU3ByaXRlLmZsaXBIb3Jpem9udGFsID0gdGhpcy5mbGlwSG9yaXpvbnRhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGN0eCwgeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mcmVlemVGcmFtZSAhPT0gLTEgJiYgdGhpcy5jdXJySW5kZXggPj0gdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyU3ByaXRlID0gdGhpcy5zcHJpdGVzW2V4LlV0aWwuY2xhbXAodGhpcy5mcmVlemVGcmFtZSwgMCwgdGhpcy5zcHJpdGVzLmxlbmd0aCAtIDEpXTtcbiAgICAgICAgICAgICAgICBjdXJyU3ByaXRlLmRyYXcoY3R4LCB4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYXlzIGFuIGFuaW1hdGlvbiBhdCBhbiBhcmJpdHJhcnkgbG9jYXRpb24gaW4gdGhlIGdhbWUuXG4gICAgICAgICAqIEBtZXRob2QgcGxheVxuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB0byBwbGF5XG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBnYW1lIHRvIHBsYXlcbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5wbGF5QW5pbWF0aW9uKHRoaXMsIHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uO1xuICAgIH0pKCk7XG4gICAgZXguQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJNb25rZXlQYXRjaC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVXRpbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTG9nLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgSW50ZXJuYWw7XG4gICAgKGZ1bmN0aW9uIChJbnRlcm5hbCkge1xuICAgICAgICB2YXIgRmFsbGJhY2tBdWRpbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBGYWxsYmFja0F1ZGlvKHBhdGgsIHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcIlVzaW5nIG5ldyBXZWIgQXVkaW8gQXBpIGZvciBcIiArIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbCA9IG5ldyBXZWJBdWRpbyhwYXRoLCB2b2x1bWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJGYWxsaW5nIGJhY2sgdG8gQXVkaW8gRWxlbWVudCBmb3IgXCIgKyBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwgPSBuZXcgQXVkaW9UYWcocGF0aCwgdm9sdW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBGYWxsYmFja0F1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwuc2V0TG9vcChsb29wKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBGYWxsYmFja0F1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLm9ubG9hZCA9IHRoaXMub25sb2FkO1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwub25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5sb2FkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdW5kSW1wbC5pc1BsYXlpbmcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBGYWxsYmFja0F1ZGlvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdW5kSW1wbC5wbGF5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRmFsbGJhY2tBdWRpby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwucGF1c2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBGYWxsYmFja0F1ZGlvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLnN0b3AoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tBdWRpbztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgSW50ZXJuYWwuRmFsbGJhY2tBdWRpbyA9IEZhbGxiYWNrQXVkaW87XG4gICAgICAgIHZhciBBdWRpb1RhZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBBdWRpb1RhZyhwYXRoLCB2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzID0gbmV3IEFycmF5KDUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlZEF1ZGlvID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdWRpb0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXVkaW9FbGVtZW50c1tpXSA9IG5ldyBBdWRpbygpO1xuICAgICAgICAgICAgICAgICAgICB9KShpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZvbHVtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZvbHVtZShleC5VdGlsLmNsYW1wKHZvbHVtZSwgMCwgMS4wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZvbHVtZSgxLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUuYXVkaW9Mb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBhLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5sb29wID0gbG9vcDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUuZ2V0TG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHMuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5sb29wOyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHRoaXMucGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2cuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBhdWRpbyByZXNvdXJjZSBcIiwgX3RoaXMucGF0aCwgXCIgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIGNvZGVcIiwgcmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvYWRlZEF1ZGlvID0gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXVkaW9FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnNyYyA9IF90aGlzLl9sb2FkZWRBdWRpbztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9ubG9hZChlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzW3RoaXMuaW5kZXhdLmxvYWQoKTtcbiAgICAgICAgICAgICAgICAvL3RoaXMuYXVkaW9FbGVtZW50c1t0aGlzLmluZGV4XS5jdXJyZW50VGltZSA9IHRoaXMuX2N1cnJlbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzW3RoaXMuaW5kZXhdLnBsYXkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0TG9vcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50c1t0aGlzLmluZGV4XS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAodGhpcy5pbmRleCArIDEpICUgdGhpcy5hdWRpb0VsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9ICh0aGlzLmluZGV4IC0gMSArIHRoaXMuYXVkaW9FbGVtZW50cy5sZW5ndGgpICUgdGhpcy5hdWRpb0VsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gdGhpcy5hdWRpb0VsZW1lbnRzW3RoaXMuaW5kZXhdLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBhLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vYS5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEF1ZGlvVGFnO1xuICAgICAgICB9KSgpO1xuICAgICAgICBJbnRlcm5hbC5BdWRpb1RhZyA9IEF1ZGlvVGFnO1xuICAgICAgICBpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGF1ZGlvQ29udGV4dCA9IG5ldyB3aW5kb3cuQXVkaW9Db250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFdlYkF1ZGlvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFdlYkF1ZGlvKHNvdW5kUGF0aCwgdm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gc291bmRQYXRoO1xuICAgICAgICAgICAgICAgIGlmICh2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52b2x1bWUuZ2Fpbi52YWx1ZSA9IGV4LlV0aWwuY2xhbXAodm9sdW1lLCAwLCAxLjApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52b2x1bWUuZ2Fpbi52YWx1ZSA9IDEuMDsgLy8gbWF4IHZvbHVtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52b2x1bWUuZ2Fpbi52YWx1ZSA9IHZvbHVtZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgYXVkaW8gcmVzb3VyY2UgXCIsIF90aGlzLnBhdGgsIFwiIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlXCIsIHJlcXVlc3Quc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9ubG9hZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIFwiICsgX3RoaXMucGF0aCArIFwiIHRoaXMgYnJvd3NlciBtYXkgbm90IGZ1bGx5IHN1cHBvcnQgdGhpcyBmb3JtYXQsIG9yIHRoZSBmaWxlIG1heSBiZSBjb3JydXB0LCBcIiArIFwiaWYgdGhpcyBpcyBhbiBtcDMgdHJ5IHJlbW92aW5nIGlkMyB0YWdzIGFuZCBhbGJ1bSBhcnQgZnJvbSB0aGUgZmlsZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25sb2FkKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgc291bmQhIElmIHRoaXMgaXMgYSBjcm9zcyBvcmlnaW4gZXJyb3IsIHlvdSBtdXN0IGhvc3QgeW91ciBzb3VuZCB3aXRoIHlvdXIgaHRtbCBhbmQgamF2YXNjcmlwdC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQuYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQubG9vcCA9IHRoaXMubG9vcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5jb25uZWN0KHRoaXMudm9sdW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52b2x1bWUuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLnN0YXJ0KDAsIHRoaXMuX2N1cnJlbnRPZmZzZXQgJSB0aGlzLmJ1ZmZlci5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5fcGxheVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRoaXMuX3BsYXlQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLm9uZW5kZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wbGF5UHJvbWlzZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4LlByb21pc2Uud3JhcCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fcGxheWluZ1RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc3RvcCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoZSBzb3VuZCBjbGlwXCIsIHRoaXMucGF0aCwgXCJoYXMgYWxyZWFkeSBiZWVuIHBhdXNlZCFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc291bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fcGxheWluZ1RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5zdG9wKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhlIHNvdW5kIGNsaXBcIiwgdGhpcy5wYXRoLCBcImhhcyBhbHJlYWR5IGJlZW4gc3RvcHBlZCFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFdlYkF1ZGlvO1xuICAgICAgICB9KSgpO1xuICAgICAgICBJbnRlcm5hbC5XZWJBdWRpbyA9IFdlYkF1ZGlvO1xuICAgIH0pKEludGVybmFsID0gZXguSW50ZXJuYWwgfHwgKGV4LkludGVybmFsID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTG9nLnRzXCIgLz5cbi8vIFByb21pc2VzL0ErIFNwZWMgaHR0cDovL3Byb21pc2VzLWFwbHVzLmdpdGh1Yi5pby9wcm9taXNlcy1zcGVjL1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIFZhbGlkIHN0YXRlcyBmb3IgYSBwcm9taXNlIHRvIGJlIGluXG4gICAgICogQGNsYXNzIFByb21pc2VTdGF0ZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoUHJvbWlzZVN0YXRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgUmVzb2x2ZWQge1Byb21pc2VTdGF0ZX1cbiAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlJlc29sdmVkXCJdID0gMF0gPSBcIlJlc29sdmVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgUmVqZWN0ZWQge1Byb21pc2VTdGF0ZX1cbiAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlJlamVjdGVkXCJdID0gMV0gPSBcIlJlamVjdGVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgUGVuZGluZyB7UHJvbWlzZVN0YXRlfVxuICAgICAgICAqL1xuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUGVuZGluZ1wiXSA9IDJdID0gXCJQZW5kaW5nXCI7XG4gICAgfSkoZXguUHJvbWlzZVN0YXRlIHx8IChleC5Qcm9taXNlU3RhdGUgPSB7fSkpO1xuICAgIHZhciBQcm9taXNlU3RhdGUgPSBleC5Qcm9taXNlU3RhdGU7XG4gICAgLyoqXG4gICAgICogUHJvbWlzZXMvQSsgc3BlYyBpbXBsZW1lbnRhdGlvbiBvZiBwcm9taXNlc1xuICAgICAqIEBjbGFzcyBQcm9taXNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFByb21pc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcm9taXNlKCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAyIC8qIFBlbmRpbmcgKi87XG4gICAgICAgICAgICB0aGlzLnN1Y2Nlc3NDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcCBhIHZhbHVlIGluIGEgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgICAgKiBAbWV0aG9kIHdyYXA8VD5cbiAgICAgICAgICogQHBhcmFtIFt2YWx1ZT11bmRlZmluZWRdIHtUfSBBbiBvcHRpb25hbCB2YWx1ZSB0byB3cmFwIGluIGEgcmVzb2x2ZWQgcHJvbWlzZVxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlJmx0O1QmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gKG5ldyBQcm9taXNlKCkpLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCB0aGUgcHJvbWlzZXMgcGFzc2VkIHRvIGl0IHJlc29sdmUsIG9yIHJlamVjdHNcbiAgICAgICAgICogd2hlbiBhdCBsZWFzdCAxIHByb21pc2UgcmVqZWN0cy5cbiAgICAgICAgICogQHBhcmFtIHByb21pc2VzIHtQcm9taXNlW119XG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIFByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBqb2luZWRQcm9taXNlID0gbmV3IFByb21pc2UoKTtcbiAgICAgICAgICAgIGlmICghcHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbmVkUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG90YWwgPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc3VjY2Vzc2VzID0gMDtcbiAgICAgICAgICAgIHZhciByZWplY3RzID0gMDtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHByb21pc2VzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN1Y2Nlc3NlcyArIHJlamVjdHMgKyBlcnJvcnMubGVuZ3RoID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0cyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgcmVqZWN0cyArIGVycm9ycy5sZW5ndGggPT09IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZXJyb3JzLmxlbmd0aCArIHN1Y2Nlc3NlcyArIHJlamVjdHMpID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gam9pbmVkUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYWluIHN1Y2Nlc3MgYW5kIHJlamVjdCBjYWxsYmFja3MgYWZ0ZXIgdGhlIHByb21pc2UgaXMgcmVzb3ZsZWRcbiAgICAgICAgICogQG1ldGhvZCB0aGVuXG4gICAgICAgICAqIEBwYXJhbSBzdWNjZXNzQ2FsbGJhY2sge1Q9PmFueX0gQ2FsbCBvbiByZXNvbHV0aW9uIG9mIHByb21pc2VcbiAgICAgICAgICogQHBhcmFtIHJlamVjdENhbGxiYWNrIHthbnk9PmFueX0gQ2FsbCBvbiByZWplY3Rpb24gb2YgcHJvbWlzZVxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlJmx0O1QmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKHN1Y2Nlc3NDYWxsYmFjaywgcmVqZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3NDYWxsYmFja3MucHVzaChzdWNjZXNzQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9taXNlIGlzIGFscmVhZHkgcmVzb3ZsZWQgY2FsbCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPT09IDAgLyogUmVzb2x2ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlamVjdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3RDYWxsYmFjayA9IHJlamVjdENhbGxiYWNrO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcm9taXNlIGlzIGFscmVhZHkgcmVqZWN0ZWQgY2FsbCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPT09IDEgLyogUmVqZWN0ZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdENhbGxiYWNrLmNhbGwodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbiBlcnJvciBjYWxsYmFjayB0byB0aGUgcHJvbWlzZVxuICAgICAgICAgKiBAbWV0aG9kIGVycm9yXG4gICAgICAgICAqIEBwYXJhbSBlcnJvckNhbGxiYWNrIHthbnk9PmFueX0gQ2FsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgaW4gYSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlJmx0O1QmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JDYWxsYmFjayA9IGVycm9yQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmUgdGhlIHByb21pc2UgYW5kIHBhc3MgYW4gb3B0aW9uIHZhbHVlIHRvIHRoZSBzdWNjZXNzIGNhbGxiYWNrc1xuICAgICAgICAgKiBAbWV0aG9kIHJlc29sdmVcbiAgICAgICAgICogQHBhcmFtIFt2YWx1ZT11bmRlZmluZWRdIHtUfSBWYWx1ZSB0byBwYXNzIHRvIHRoZSBzdWNjZXNzIGNhbGxiYWNrc1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gMiAvKiBQZW5kaW5nICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMCAvKiBSZXNvbHZlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKF90aGlzLCBfdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHRoYXQgaXMgbm90IGluIGEgcGVuZGluZyBzdGF0ZSEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVqZWN0IHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgcmVqZWN0IGNhbGxiYWNrc1xuICAgICAgICAgKiBAbWV0aG9kIHJlamVjdFxuICAgICAgICAgKiBAcGFyYW0gW3ZhbHVlPXVuZGVmaW5lZF0ge1R9IFZhbHVlIHRvIHBhc3MgdG8gdGhlIHJlamVjdCBjYWxsYmFja3NcbiAgICAgICAgICovXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAyIC8qIFBlbmRpbmcgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAxIC8qIFJlamVjdGVkICovO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdENhbGxiYWNrLmNhbGwodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVqZWN0IGEgcHJvbWlzZSB0aGF0IGlzIG5vdCBpbiBhIHBlbmRpbmcgc3RhdGUhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElucGVjdCB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIHByb21pc2VcbiAgICAgICAgICogQG1ldGhvZCBzdGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlU3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZTtcbiAgICB9KSgpO1xuICAgIGV4LlByb21pc2UgPSBQcm9taXNlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJbnRlcmZhY2VzL0lMb2FkYWJsZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogVGhlIFJlc291cmNlIHR5cGUgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGdlbmVyaWMgcmVzb3VyY2VzLlxuICAgICAqIEZvciBhbnkgdHlwZSBvZiByZW1vdGUgcmVzb3VyY2UgaXQgaXMgcmVjb21lXG4gICAgICogQGNsYXNzIFJlc291cmNlXG4gICAgICogQGV4dGVuZCBJTG9hZGFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcGF0aCB7c3RyaW5nfSBQYXRoIHRvIHRoZSByZW1vdGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICB2YXIgUmVzb3VyY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZXNvdXJjZShwYXRoLCByZXNwb25zZVR5cGUsIGJ1c3RDYWNoZSkge1xuICAgICAgICAgICAgaWYgKGJ1c3RDYWNoZSA9PT0gdm9pZCAwKSB7IGJ1c3RDYWNoZSA9IHRydWU7IH1cbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgIHRoaXMuYnVzdENhY2hlID0gYnVzdENhY2hlO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgUmVzb3VyY2UgaXMgY29tcGxldGVseSBsb2FkZWQgYW5kIGlzIHJlYWR5XG4gICAgICAgICAqIHRvIGJlIGRyYXduLlxuICAgICAgICAgKiBAbWV0aG9kIGlzTG9hZGVkXG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5jYWNoZUJ1c3QgPSBmdW5jdGlvbiAodXJpKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSAvXFw/XFx3Kj1cXHcqLztcbiAgICAgICAgICAgIGlmIChxdWVyeS50ZXN0KHVyaSkpIHtcbiAgICAgICAgICAgICAgICB1cmkgKz0gKFwiJl9fPVwiICsgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmkgKz0gKFwiP19fPVwiICsgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgICB9O1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3RhcnRlZCBsb2FkaW5nIHJlc291cmNlIFwiICsgdGhpcy5wYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJlZ2luIGxvYWRpbmcgdGhlIHJlc291cmNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXG4gICAgICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlJmx0O2FueSZndDtcbiAgICAgICAgICovXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHRoaXMuYnVzdENhY2hlID8gdGhpcy5jYWNoZUJ1c3QodGhpcy5wYXRoKSA6IHRoaXMucGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWRzdGFydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0YXJ0KGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCByZXNvdXJjZSBcIiwgX3RoaXMucGF0aCwgXCIgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIGNvZGVcIiwgcmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmRhdGEgPSBfdGhpcy5wcm9jZXNzRG93bmxvYWQocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMub25jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIkNvbXBsZXRlZCBsb2FkaW5nIHJlc291cmNlXCIsIF90aGlzLnBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsb2FkZWQgZGF0YSBvbmNlIHRoZSByZXNvdXJjZSBpcyBsb2FkZWRcbiAgICAgICAgICogQG1ldGhvZCBHZXREYXRhXG4gICAgICAgICAqIEByZXR1cm5zIGFueVxuICAgICAgICAgKi9cbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIHRvIGhhbmRsZSBhbnkgYWRkaXRpb25hbFxuICAgICAgICAgKiBwcm9jZXNzaW5nLiBTdWNoIGFzIGRlY29kaW5nIGRvd25sb2FkZWQgYXVkaW8gYml0cy5cbiAgICAgICAgICogQG1ldGhvZCBQcm9jZXNzRG93bmxvYWRcbiAgICAgICAgICovXG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5wcm9jZXNzRG93bmxvYWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGFueSBhZGRpdGlvbmFsIGxvYWRpbmcgYWZ0ZXIgdGhlIHhociBoYXMgY29tcGxldGVkLlxuICAgICAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXNvdXJjZTtcbiAgICB9KSgpO1xuICAgIGV4LlJlc291cmNlID0gUmVzb3VyY2U7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNvdW5kLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVdGlsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQcm9taXNlcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUmVzb3VyY2UudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkludGVyZmFjZXMvSUxvYWRhYmxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgVGV4dHVyZSBvYmplY3QgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGltYWdlIHJlc291cmNlcy5cbiAgICAgKiBJdCBpcyBnZW5lcmFsbHkgcmVjb21tZW5kZWQgdG8gcHJlbG9hZCBpbWFnZXMgdXNpbmcgdGhlIFwiVGV4dHVyZVwiIG9iamVjdC5cbiAgICAgKiBAY2xhc3MgVGV4dHVyZVxuICAgICAqIEBleHRlbmQgUmVzb3VyY2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcGF0aCB7c3RyaW5nfSBQYXRoIHRvIHRoZSBpbWFnZSByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBbYnVzdENhY2hlPXRydWVdIHtib29sZWFufSBPcHRpb25hbGx5IGxvYWQgdGV4dHVyZSB3aXRoIGNhY2hlIGJ1c3RpbmdcbiAgICAgKi9cbiAgICB2YXIgVGV4dHVyZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUZXh0dXJlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUZXh0dXJlKHBhdGgsIGJ1c3RDYWNoZSkge1xuICAgICAgICAgICAgaWYgKGJ1c3RDYWNoZSA9PT0gdm9pZCAwKSB7IGJ1c3RDYWNoZSA9IHRydWU7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHBhdGgsICdibG9iJywgYnVzdENhY2hlKTtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB0aGlzLmJ1c3RDYWNoZSA9IGJ1c3RDYWNoZTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlID0gbmV3IGV4LlNwcml0ZSh0aGlzLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBUZXh0dXJlIGlzIGNvbXBsZXRlbHkgbG9hZGVkIGFuZCBpcyByZWFkeVxuICAgICAgICAgKiB0byBiZSBkcmF3bi5cbiAgICAgICAgICogQG1ldGhvZCBpc0xvYWRlZFxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0dXJlLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xvYWRlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSB0ZXh0dXJlIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXG4gICAgICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlJmx0O0hUTUxJbWFnZUVsZW1lbnQmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBUZXh0dXJlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gX3N1cGVyLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBsb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLndpZHRoID0gX3RoaXMuX3Nwcml0ZS5zd2lkdGggPSBfdGhpcy5fc3ByaXRlLndpZHRoID0gX3RoaXMuaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oZWlnaHQgPSBfdGhpcy5fc3ByaXRlLnNoZWlnaHQgPSBfdGhpcy5fc3ByaXRlLmhlaWdodCA9IF90aGlzLmltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvYWRlZC5yZXNvbHZlKF90aGlzLmltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShfdGhpcy5pbWFnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2Uuc3JjID0gX3N1cGVyLnByb3RvdHlwZS5nZXREYXRhLmNhbGwoX3RoaXMpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlamVjdChcIkVycm9yIGxvYWRpbmcgdGV4dHVyZS5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgVGV4dHVyZS5wcm90b3R5cGUuYXNTcHJpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3ByaXRlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGV4dHVyZTtcbiAgICB9KShleC5SZXNvdXJjZSk7XG4gICAgZXguVGV4dHVyZSA9IFRleHR1cmU7XG4gICAgLyoqXG4gICAgICogVGhlIFNvdW5kIG9iamVjdCBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgYXVkaW9cbiAgICAgKiBjb21wb25lbnRzLCBmcm9tIHNvdW5kdHJhY2tzIHRvIHNvdW5kIGVmZmVjdHMuIEl0IGlzIGdlbmVyYWxseVxuICAgICAqIHJlY29tbWVuZGVkIHRvIGxvYWQgc291bmQgcmVzb3VyY2VzIHdoZW4gdXNpbmcgRXhjYWxpYnVyXG4gICAgICogQGNsYXNzIFNvdW5kXG4gICAgICogQGV4dGVuZCBSZXNvdXJjZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSAuLi5wYXRocyB7c3RyaW5nW119IEEgbGlzdCBvZiBhdWRpbyBzb3VyY2VzIChjbGlwLndhdiwgY2xpcC5tcDMsIGNsaXAub2dnKSBmb3IgdGhpcyBhdWRpbyBjbGlwLiBUaGlzIGlzIGRvbmUgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cbiAgICB2YXIgU291bmQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTb3VuZCgpIHtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBwYXRoc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWxlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgLyogQ2hyb21lIDogTVAzLCBXQVYsIE9nZ1xuICAgICAgICAgICAgICogRmlyZWZveCA6IFdBViwgT2dnLFxuICAgICAgICAgICAgICogSUUgOiBNUDMsIFdBViBjb21pbmcgc29vblxuICAgICAgICAgICAgICogU2FmYXJpIE1QMywgV0FWLCBPZ2dcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWxlID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoU291bmQuY2FuUGxheUZpbGUocGF0aHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsZSA9IHBhdGhzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NlbGVjdGVkRmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbnkgb2YgdGhlIGZpbGVzIHNwZWNpZmllZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEZpbGUgPSBwYXRoc1swXTsgLy8gc2VsZWN0IHRoZSBmaXJzdCBzcGVjaWZpZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc291bmQgPSBuZXcgZXguSW50ZXJuYWwuRmFsbGJhY2tBdWRpbyh0aGlzLl9zZWxlY3RlZEZpbGUsIDEuMCk7XG4gICAgICAgIH1cbiAgICAgICAgU291bmQuY2FuUGxheUZpbGUgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBBdWRpbygpO1xuICAgICAgICAgICAgICAgIHZhciBmaWxldHlwZSA9IC8uKlxcLihbQS1aYS16MC05XSspJC87XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWxlLm1hdGNoKGZpbGV0eXBlKVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoYS5jYW5QbGF5VHlwZSgnYXVkaW8vJyArIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oXCJDYW5ub3QgZGV0ZXJtaW5lIGF1ZGlvIHN1cHBvcnQsIGFzc3VtaW5nIG5vIHN1cHBvcnQgZm9yIHRoZSBBdWRpbyBUYWdcIiwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUud2lyZUVuZ2luZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5vbignaGlkZGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5naW5lLnBhdXNlQXVkaW9XaGVuSGlkZGVuICYmIF90aGlzLmlzUGxheWluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ3Zpc2libGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucGF1c2VBdWRpb1doZW5IaWRkZW4gJiYgX3RoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGxheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kIGNsaXBcbiAgICAgICAgICogQG1ldGhvZCBzZXRWb2x1bWVcbiAgICAgICAgICogQHBhcmFtIHZvbHVtZSB7bnVtYmVyfSBBIHZvbHVtZSB2YWx1ZSBiZXR3ZWVuIDAtMS4wXG4gICAgICAgICAqL1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291bmQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjbGlwIHNob3VsZCBsb29wIHdoZW4gY29tcGxldGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRMb29wXG4gICAgICAgICAqIEBwYXJhbSBsb29wIHtib29sZWFufSBTZXQgdGhlIGxvb3BpbmcgZmxhZ1xuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291bmQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5zZXRMb29wKGxvb3ApO1xuICAgICAgICB9O1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUuaXNQbGF5aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291bmQuaXNQbGF5aW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGF5IHRoZSBzb3VuZCwgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBzb3VuZCBpcyBkb25lIHBsYXlpbmdcbiAgICAgICAgICogQG1ldGhvZCBwbGF5XG4gICAgICAgICAqIEByZXR1cm4gZXguUHJvbWlzZVxuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZC5wbGF5KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIHRoZSBzb3VuZCwgYW5kIGRvIG5vdCByZXdpbmRcbiAgICAgICAgICogQG1ldGhvZCBwYXVzZVxuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291bmQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5wYXVzZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCB0aGUgc291bmQgYW5kIHJld2luZFxuICAgICAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291bmQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5zdG9wKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNvdW5kIGlzIGxvYWRlZFxuICAgICAgICAgKiBAbWV0aG9kIGlzTG9hZGVkXG4gICAgICAgICAqL1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMb2FkZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgc291bmQgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cbiAgICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UmbHQ7U291bmQmZ3Q7XG4gICAgICAgICAqL1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJTdGFydGVkIGxvYWRpbmcgc291bmRcIiwgdGhpcy5fc2VsZWN0ZWRGaWxlKTtcbiAgICAgICAgICAgIHRoaXMuc291bmQub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcbiAgICAgICAgICAgIHRoaXMuc291bmQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIkNvbXBsZXRlZCBsb2FkaW5nIHNvdW5kXCIsIF90aGlzLl9zZWxlY3RlZEZpbGUpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoX3RoaXMuc291bmQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc291bmQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihlKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc291bmQubG9hZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU291bmQ7XG4gICAgfSkoKTtcbiAgICBleC5Tb3VuZCA9IFNvdW5kO1xuICAgIC8qKlxuICAgICAqIFRoZSBsb2FkZXIgcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gcHJlbG9hZCBtdWx0aXBsZSByZXNvdXJjZXMgYXRcbiAgICAgKiBvbmUgdGltZS4gVGhlIGxvYWRlciBtdXN0IGJlIHBhc3NlZCB0byB0aGUgZW5naW5lIGluIG9yZGVyIHRvXG4gICAgICogdHJpZ2dlciB0aGUgbG9hZGluZyBwcm9ncmVzcyBiYXJcbiAgICAgKiBAY2xhc3MgTG9hZGVyXG4gICAgICogQGV4dGVuZCBJTG9hZGFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW2xvYWRhYmxlcz11bmRlZmluZWRdIHtJTG9hZGFibGVbXX0gT3B0aW9uYWxseSBwcm92aWRlIHRoZSBsaXN0IG9mIHJlc291cmNlcyB5b3Ugd2FudCB0byBsb2FkIGF0IGNvbnN0cnVjdG9yIHRpbWVcbiAgICAgKi9cbiAgICB2YXIgTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG9hZGVyKGxvYWRhYmxlcykge1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUxpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMubnVtTG9hZGVkID0gMDtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDb3VudHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMudG90YWxDb3VudHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChsb2FkYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJlc291cmNlcyhsb2FkYWJsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExvYWRlci5wcm90b3R5cGUud2lyZUVuZ2luZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIHJlc291cmNlIHRvIHRoZSBsb2FkZXIgdG8gbG9hZFxuICAgICAgICAgKiBAbWV0aG9kIGFkZFJlc291cmNlXG4gICAgICAgICAqIEBwYXJhbSBsb2FkYWJsZSB7SUxvYWRhYmxlfSBSZXNvdXJjZSB0byBhZGRcbiAgICAgICAgICovXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUuYWRkUmVzb3VyY2UgPSBmdW5jdGlvbiAobG9hZGFibGUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTGlzdC5wdXNoKGxvYWRhYmxlKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NDb3VudHNba2V5XSA9IDA7XG4gICAgICAgICAgICB0aGlzLnRvdGFsQ291bnRzW2tleV0gPSAxO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUNvdW50Kys7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBsaXN0IG9mIHJlc291cmNlcyB0byB0aGUgbG9hZGVyIHRvIGxvYWRcbiAgICAgICAgICogQG1ldGhvZCBhZGRSZXNvdXJjZXNcbiAgICAgICAgICogQHBhcmFtIGxvYWRhYmxlcyB7SUxvYWRhYmxlW119IFRoZSBsaXN0IG9mIHJlc291cmNlcyB0byBsb2FkXG4gICAgICAgICAqL1xuICAgICAgICBMb2FkZXIucHJvdG90eXBlLmFkZFJlc291cmNlcyA9IGZ1bmN0aW9uIChsb2FkYWJsZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBsb2FkYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZFJlc291cmNlKGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIExvYWRlci5wcm90b3R5cGUuc3VtQ291bnRzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICB2YXIgcHJldiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIHN1bSArPSBvYmpbaV0gfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbG9hZGVyIGhhcyBjb21wbGV0ZWx5IGxvYWRlZCBhbGwgcmVzb3VyY2VzXG4gICAgICAgICAqIEBtZXRob2QgaXNMb2FkZWRcbiAgICAgICAgICovXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW1Mb2FkZWQgPT09IHRoaXMucmVzb3VyY2VDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJlZ2luIGxvYWRpbmcgYWxsIG9mIHRoZSBzdXBwbGllZCByZXNvdXJjZXMsIHJldHVybmluZyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGxvYWRpbmcgb2YgYWxsIGlzIGNvbXBsZXRlXG4gICAgICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAgICAgKiBAcmV0dXJucyBQcm9tc2llJmx0O2FueSZndDtcbiAgICAgICAgICovXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc291cmNlTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBtZS5vbmNvbXBsZXRlLmNhbGwobWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9ncmVzc0FycmF5ID0gbmV3IEFycmF5KHRoaXMucmVzb3VyY2VMaXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NDaHVua3MgPSB0aGlzLnJlc291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9lbmdpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgci53aXJlRW5naW5lKF90aGlzLl9lbmdpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQXJyYXlbaV0gPSB7IGxvYWRlZDogKChsb2FkZWQgLyB0b3RhbCkgKiAoMTAwIC8gcHJvZ3Jlc3NDaHVua3MpKSwgdG90YWw6IDEwMCB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NSZXN1bHQgPSBwcm9ncmVzc0FycmF5LnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxvYWRlZDogKGFjY3VtLmxvYWRlZCArIG5leHQubG9hZGVkKSwgdG90YWw6IDEwMCB9O1xuICAgICAgICAgICAgICAgICAgICB9LCB7IGxvYWRlZDogMCwgdG90YWw6IDEwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgbWUub25wcm9ncmVzcy5jYWxsKG1lLCBwcm9ncmVzc1Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByLm9uY29tcGxldGUgPSByLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLm51bUxvYWRlZCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWUubnVtTG9hZGVkID09PSBtZS5yZXNvdXJjZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5vbnByb2dyZXNzLmNhbGwobWUsIHsgbG9hZGVkOiAxMDAsIHRvdGFsOiAxMDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5vbmNvbXBsZXRlLmNhbGwobWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gbG9hZE5leHQobGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RbaW5kZXhdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGlzdFtpbmRleF0ubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkTmV4dChsaXN0LCBpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZE5leHQodGhpcy5yZXNvdXJjZUxpc3QsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTG9hZGVyO1xuICAgIH0pKCk7XG4gICAgZXguTG9hZGVyID0gTG9hZGVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQcm9taXNlcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTG9hZGVyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2cudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEV4Y2FsaWJ1cidzIGJ1aWx0IGluIHRlbXBsYXRpbmcgY2xhc3MsIGl0IGlzIGEgbG9hZGFibGUgdGhhdCB3aWxsIGxvYWRcbiAgICAgKiBhbmQgaHRtbCBmcmFnbWVudCBmcm9tIGEgdXJsLiBFeGNhbGlidXIgdGVtcGxhdGluZyBpcyB2ZXJ5IGJhc2ljIG9ubHlcbiAgICAgKiBhbGxvd2luZyBiaW5kaW5ncyBvZiB0aGUgdHlwZSBkYXRhLXRleHQ9XCJ0aGlzLm9iai5zb21lcHJvcFwiLFxuICAgICAqIGRhdGEtc3R5bGU9XCJjb2xvcjp0aGlzLm9iai5jb2xvci50b1N0cmluZygpXCIuIEJpbmRpbmdzIGFsbG93IGFsbCB2YWxpZFxuICAgICAqIGphdmFzY3JpcHQgZXhwcmVzc2lvbnMuXG4gICAgICogQGNsYXNzIFRlbXBsYXRlXG4gICAgICogQGV4dGVuZHMgSUxvYWRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gTG9jYXRpb24gb2YgdGhlIGh0bWwgdGVtcGxhdGVcbiAgICAgKi9cbiAgICB2YXIgVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZShwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9pbm5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyRWxlbWVudC5jbGFzc05hbWUgPSBcImV4Y2FsaWJ1ci10ZW1wbGF0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZnVsbCBodG1sIHRlbXBsYXRlIHN0cmluZyBvbmNlIGxvYWRlZC5cbiAgICAgICAgICogQG1ldGhvZCBnZXRUZW1wbGF0ZVN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5nZXRUZW1wbGF0ZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMb2FkZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faHRtbFN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5faW5uZXJFbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX2h0bWxTdHJpbmc7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZUVsZW1lbnRzID0gdGhpcy5faW5uZXJFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXN0eWxlXScpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dEVsZW1lbnRzID0gdGhpcy5faW5uZXJFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRleHRdJyk7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5fZXZhbHVhdGVFeHByZXNpb24gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgY3R4KSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IG5ldyBGdW5jdGlvbihcInJldHVybiBcIiArIGV4cHJlc3Npb24gKyBcIjtcIik7XG4gICAgICAgICAgICB2YXIgdmFsID0gZnVuYy5jYWxsKGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhbnkgY3R4IG9iamVjdCB5b3Ugd2lzaCBhbmQgZXZhbHVhdGVzIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgICogT3ZlcmxvYWQgdGhpcyBtZXRob2QgdG8gaW5jbHVkZSB5b3VyIGZhdm9yaXRlIHRlbXBsYXRlIGxpYnJhcnkuXG4gICAgICAgICAqIFlvdSBtYXkgcmV0dXJuIGVpdGhlciBhbiBIVE1MIHN0cmluZyBvciBhIERvbSBub2RlLlxuICAgICAgICAgKiBAbWV0aG9kIGFwcGx5XG4gICAgICAgICAqIEBwYXJhbSBjdHgge2FueX0gQW55IG9iamVjdCB5b3Ugd2lzaCB0byBhcHBseSB0byB0aGUgdGVtcGxhdGVcbiAgICAgICAgICogQHJldHVybnMgYW55XG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zdHlsZUVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9vciBtYW4ncyBqc29uIHBhcnNlIGZvciB0aGluZ3MgdGhhdCBhcmVuJ3QgZXhhY3RseSBqc29uIDooXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc3R5bGUgZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3R5bGVFbGVtZW50c1tqXS5kYXRhc2V0W1wic3R5bGVcIl0uc3BsaXQoXCI7XCIpLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHMgPSBzLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbdmFsc1swXS50cmltKCldID0gdmFsc1sxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzdHlsZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdHlsZUVsZW1lbnRzW2pdLnN0eWxlW3N0eWxlXSA9IF90aGlzLl9ldmFsdWF0ZUV4cHJlc2lvbihleHByZXNzaW9uLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RleHRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRleHQgZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBfdGhpcy5fdGV4dEVsZW1lbnRzW2ldLmRhdGFzZXRbXCJ0ZXh0XCJdO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdGV4dEVsZW1lbnRzW2ldLmlubmVyVGV4dCA9IF90aGlzLl9ldmFsdWF0ZUV4cHJlc2lvbihleHByZXNzaW9uLCBjdHgpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGVtcGxhdGUgSFRNTCBoYXMgYSByb290IGVsZW1lbnQgcmV0dXJuIHRoYXQsIG90aGVyd2lzZSB1c2UgY29uc3RydWN0ZWQgcm9vdFxuICAgICAgICAgICAgaWYgKHRoaXMuX2lubmVyRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbm5lckVsZW1lbnQgPSB0aGlzLl9pbm5lckVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbm5lckVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgdGVtcGxhdGUuIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdGVtcGxhdGUgc3RyaW5nIHdoZW4gbG9hZGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHRoaXMub25lcnJvcjtcbiAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBodG1sIHRlbXBsYXRlIHJlc291cmNlIFwiLCBfdGhpcy5wYXRoLCBcIiBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZVwiLCByZXF1ZXN0LnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX2h0bWxTdHJpbmcgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoXCJDb21wbGV0ZWQgbG9hZGluZyB0ZW1wbGF0ZVwiLCBfdGhpcy5wYXRoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29tcGlsZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShfdGhpcy5faHRtbFN0cmluZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGVtcGxhdGUgaGFzIGJlZW4gbG9hZGVkXG4gICAgICAgICAqIEBtZXRob2QgaXNMb2FkZWRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNMb2FkZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZTtcbiAgICB9KSgpO1xuICAgIGV4LlRlbXBsYXRlID0gVGVtcGxhdGU7XG4gICAgLyoqXG4gICAgICogRXhjYWxpYnVyJ3MgYmluZGluZyBsaWJyYXJ5IHRoYXQgYWxsb3dzIHlvdSB0byBiaW5kIGFuIGh0bWxcbiAgICAgKiB0ZW1wbGF0ZSB0byB0aGUgZG9tIGdpdmVuIGEgY2VydGFpbiBjb250ZXh0LiBFeGNhbGlidXIgYmluZGluZ3MgYXJlIG9ubHkgdXBkYXRlZFxuICAgICAqIHdoZW4gdGhlIHVwZGF0ZSgpIG1ldGhvZCBpcyBjYWxsZWRcbiAgICAgKiBAY2xhc3MgQmluZGluZ1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBwYXJlbnRFbGVtZW50SWQge3N0cmluZ30gVGhlIGlkIG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb20gdG8gYXR0YWNoIHRoZSB0ZW1wbGF0ZSBiaW5kaW5nXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIHtUZW1wbGF0ZX0gVGhlIHRlbXBsYXRlIHlvdSB3aXNoIHRvIGJpbmRcbiAgICAgKiBAcGFyYW0gY3R4IHthbnl9IFRoZSBjb250ZXh0IG9mIHRoZSBiaW5kaW5nLCB3aGljaCBjYW4gYmUgYW55IG9iamVjdFxuICAgICAqL1xuICAgIHZhciBCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQmluZGluZyhwYXJlbnRFbGVtZW50SWQsIHRlbXBsYXRlLCBjdHgpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFyZW50RWxlbWVudElkKTtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbiB0byBhbnkgYXJiaXRyYXJ5IG9iamVjdCdzIGV2ZW50cyB0byB1cGRhdGUgdGhpcyBiaW5kaW5nXG4gICAgICAgICAqIEBtZXRob2QgbGlzdGVuXG4gICAgICAgICAqIEBwYXJhbSBvYmoge2FueX0gQW55IG9iamVjdCB0aGF0IHN1cHBvcnRzIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIGV2ZW50cyB7c3RyaW5nW119IEEgbGlzdCBvZiBldmVudHMgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gW2hhbmRlcj1kZWZhdWx0SGFuZGxlcl0ge2NhbGxiYWNrfSBBIG9wdGlvbmFsIGhhbmRsZXIgdG8gZmlyZSBvbiBhbnkgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEJpbmRpbmcucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChvYmosIGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIHRvZG9cbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcihlLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGlzIHRlbXBsYXRlIGJpbmRpbmcgd2l0aCB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIHRoZSBjdHggcmVmZXJlbmNlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIEJpbmRpbmcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gdGhpcy5fYXBwbHlUZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCB0aGlzLl9jdHgpO1xuICAgICAgICAgICAgaWYgKGh0bWwgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGh0bWwgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Lmxhc3RDaGlsZCAhPT0gaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZChodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJpbmRpbmcucHJvdG90eXBlLl9hcHBseVRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBjdHgpIHtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZS5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmFwcGx5KGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCaW5kaW5nO1xuICAgIH0pKCk7XG4gICAgZXguQmluZGluZyA9IEJpbmRpbmc7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGhvcml6b250YWwgdGV4dCBhbGlnbm1lbnRzXG4gICAgICogQGNsYXNzIFRleHRBbGlnblxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoVGV4dEFsaWduKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBsZWZ0LWFsaWduZWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIHJpZ2h0LWFsaWduZWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBSaWdodFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiUmlnaHRcIl0gPSAxXSA9IFwiUmlnaHRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGNlbnRlcmVkLlxuICAgICAgICAgKiBAcHJvcGVydHkgQ2VudGVyXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBhbGlnbmVkIGF0IHRoZSBub3JtYWwgc3RhcnQgb2YgdGhlIGxpbmUgKGxlZnQtYWxpZ25lZCBmb3IgbGVmdC10by1yaWdodCBsb2NhbGVzLCByaWdodC1hbGlnbmVkIGZvciByaWdodC10by1sZWZ0IGxvY2FsZXMpLlxuICAgICAgICAgKiBAcHJvcGVydHkgU3RhcnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIlN0YXJ0XCJdID0gM10gPSBcIlN0YXJ0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBpcyBhbGlnbmVkIGF0IHRoZSBub3JtYWwgZW5kIG9mIHRoZSBsaW5lIChyaWdodC1hbGlnbmVkIGZvciBsZWZ0LXRvLXJpZ2h0IGxvY2FsZXMsIGxlZnQtYWxpZ25lZCBmb3IgcmlnaHQtdG8tbGVmdCBsb2NhbGVzKS5cbiAgICAgICAgICogQHByb3BlcnR5IEVuZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiRW5kXCJdID0gNF0gPSBcIkVuZFwiO1xuICAgIH0pKGV4LlRleHRBbGlnbiB8fCAoZXguVGV4dEFsaWduID0ge30pKTtcbiAgICB2YXIgVGV4dEFsaWduID0gZXguVGV4dEFsaWduO1xuICAgIC8qKlxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgYmFzZWxpbmUgdGV4dCBhbGlnbm1lbnRzXG4gICAgICogQGNsYXNzIEJhc2VBbGlnblxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoQmFzZUFsaWduKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgdG9wIG9mIHRoZSBlbSBzcXVhcmUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBUb3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIlRvcFwiXSA9IDBdID0gXCJUb3BcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBoYW5naW5nIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGwgYWN0IGxpa2UgYWxwaGFiZXRpYy5cbiAgICAgICAgICogQHByb3BlcnR5IEhhbmdpbmdcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIkhhbmdpbmdcIl0gPSAxXSA9IFwiSGFuZ2luZ1wiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIG1pZGRsZSBvZiB0aGUgZW0gc3F1YXJlLlxuICAgICAgICAgKiBAcHJvcGVydHkgTWlkZGxlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJNaWRkbGVcIl0gPSAyXSA9IFwiTWlkZGxlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgbm9ybWFsIGFscGhhYmV0aWMgYmFzZWxpbmUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBBbHBoYWJldGljXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJBbHBoYWJldGljXCJdID0gM10gPSBcIkFscGhhYmV0aWNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZTsgdGhpcyBpcyB0aGUgYm90dG9tIG9mXG4gICAgICAgICAqIHRoZSBib2R5IG9mIHRoZSBjaGFyYWN0ZXJzLCBpZiB0aGUgbWFpbiBib2R5IG9mIGNoYXJhY3RlcnMgcHJvdHJ1ZGVzXG4gICAgICAgICAqIGJlbmVhdGggdGhlIGFscGhhYmV0aWMgYmFzZWxpbmUuICBDdXJyZW50bHkgdW5zdXBwb3J0ZWQ7IHRoaXMgd2lsbFxuICAgICAgICAgKiBhY3QgbGlrZSBhbHBoYWJldGljLlxuICAgICAgICAgKiBAcHJvcGVydHkgSWRlb2dyYXBoaWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIklkZW9ncmFwaGljXCJdID0gNF0gPSBcIklkZW9ncmFwaGljXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgYm90dG9tIG9mIHRoZSBib3VuZGluZyBib3guICBUaGlzIGRpZmZlcnNcbiAgICAgICAgICogZnJvbSB0aGUgaWRlb2dyYXBoaWMgYmFzZWxpbmUgaW4gdGhhdCB0aGUgaWRlb2dyYXBoaWMgYmFzZWxpbmVcbiAgICAgICAgICogZG9lc24ndCBjb25zaWRlciBkZXNjZW5kZXJzLlxuICAgICAgICAgKiBAcHJvcGVydHkgQm90dG9tXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIEJhc2VBbGlnbltCYXNlQWxpZ25bXCJCb3R0b21cIl0gPSA1XSA9IFwiQm90dG9tXCI7XG4gICAgfSkoZXguQmFzZUFsaWduIHx8IChleC5CYXNlQWxpZ24gPSB7fSkpO1xuICAgIHZhciBCYXNlQWxpZ24gPSBleC5CYXNlQWxpZ247XG4gICAgLyoqXG4gICAgICogTGFiZWxzIGFyZSB0aGUgd2F5IHRvIGRyYXcgc21hbGwgYW1vdW50cyBvZiB0ZXh0IHRvIHRoZSBzY3JlZW4gaW4gRXhjYWxpYnVyLiBUaGV5IGFyZVxuICAgICAqIGFjdG9ycyBhbmQgaW5oZXJpdCBhbGwgb2YgdGhlIGJlbmlmaXRzIGFuZCBjYXBhYmlsaXRpZXMuXG4gICAgICogQGNsYXNzIExhYmVsXG4gICAgICogQGV4dGVuZHMgQWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW3RleHQ9ZW1wdHldIHtzdHJpbmd9IFRoZSB0ZXh0IG9mIHRoZSBsYWJlbFxuICAgICAqIEBwYXJhbSBbeD0wXSB7bnVtYmVyfSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgbGFiZWxcbiAgICAgKiBAcGFyYW0gW3k9MF0ge251bWJlcn0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGxhYmVsXG4gICAgICogQHBhcmFtIFtmb250PXNhbnMtc2VyaWZdIHtzdHJpbmd9IFVzZSBhbnkgdmFsaWQgY3NzIGZvbnQgc3RyaW5nIGZvciB0aGUgbGFiZWwncyBmb250LiBEZWZhdWx0IGlzIFwiMTBweCBzYW5zLXNlcmlmXCIuXG4gICAgICogQHBhcmFtIFtzcHJpdGVGb250PXVuZGVmaW5lZF0ge1Nwcml0ZUZvbnR9IFVzZSBhbiBFeGNhbGlidXIgc3ByaXRlIGZvbnQgZm9yIHRoZSBsYWJlbCdzIGZvbnQsIGlmIGEgU3ByaXRlRm9udCBpcyBwcm92aWRlZCBpdCB3aWxsIHRha2UgcHJlY2VuZGVuY2Ugb3ZlciBhIGNzcyBmb250LlxuICAgICAqXG4gICAgICovXG4gICAgdmFyIExhYmVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKExhYmVsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBMYWJlbCh0ZXh0LCB4LCB5LCBmb250LCBzcHJpdGVGb250KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBsZXR0ZXIgc3BhY2luZyBvbiBhIExhYmVsLiBPbmx5IHN1cHBvcnRlZCB3aXRoIFNwcml0ZSBGb250cy5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbGV0dGVyU3BhY2luZz0wXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxldHRlclNwYWNpbmcgPSAwOyAvL3B4XG4gICAgICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSAwO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvciA9IGV4LkNvbG9yLkJsYWNrLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvckRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl90ZXh0U3ByaXRlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93U3ByaXRlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBleC5Db2xvci5CbGFjay5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGV4dCB8fCBcIlwiO1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IGV4LkNvbG9yLkJsYWNrLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUZvbnQgPSBzcHJpdGVGb250O1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25UeXBlID0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgdGhpcy5mb250ID0gZm9udCB8fCBcIjEwcHggc2Fucy1zZXJpZlwiOyAvLyBjb2FsbGVzY2UgdG8gZGVmYXVsdCBjYW52YXMgZm9udFxuICAgICAgICAgICAgaWYgKHNwcml0ZUZvbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U3ByaXRlcyA9IHNwcml0ZUZvbnQuZ2V0VGV4dFNwcml0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHRleHQgaW4gdGhlIGxhYmVsIChpbiBwaXhlbHMpO1xuICAgICAgICAgKiBAbWV0aG9kIGdldFRleHRXaWR0aCB7bnVtYmVyfVxuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFJlbmRpbmcgY29udGV4dCB0byBtZWFzdXJlIHRoZSBzdHJpbmcgd2l0aFxuICAgICAgICAgKi9cbiAgICAgICAgTGFiZWwucHJvdG90eXBlLmdldFRleHRXaWR0aCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBvbGRGb250ID0gY3R4LmZvbnQ7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuZm9udDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBvbGRGb250O1xuICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBzdHJpbmcgZW51bXMgOihcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLl9sb29rdXBUZXh0QWxpZ24gPSBmdW5jdGlvbiAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBMZWZ0ICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBSaWdodCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIENlbnRlciAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBFbmQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVuZFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU3RhcnQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuX2xvb2t1cEJhc2VBbGlnbiA9IGZ1bmN0aW9uIChiYXNlQWxpZ24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYmFzZUFsaWduKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIEFscGhhYmV0aWMgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImFscGhhYmV0aWNcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1IC8qIEJvdHRvbSAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYm90dG9tXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBIYW5naW5nICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJoYW5naW5cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIElkZW9ncmFwaGljICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpZGVvZ3JhcGhpY1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogTWlkZGxlICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtaWRkbGVcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFRvcCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidG9wXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImFscGhhYmV0aWNcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB0ZXh0IHNoYWRvdyBmb3Igc3ByaXRlIGZvbnRzXG4gICAgICAgICAqIEBtZXRob2Qgc2V0VGV4dFNoYWRvd1xuICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0WCB7bnVtYmVyfSBUaGUgeCBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcbiAgICAgICAgICogQHBhcmFtIG9mZnNldFkge251bWJlcn0gVGhlIHkgb2Zmc2V0IGluIHBpeGxlcyB0byBwbGFjZSB0aGUgc2hhZG93XG4gICAgICAgICAqIEBwYXJhbSBzaGFkb3dDb2xvciB7Q29sb3J9IFRoZSBjb2xvciBvZiB0aGUgdGV4dCBzaGFkb3dcbiAgICAgICAgICovXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5zZXRUZXh0U2hhZG93ID0gZnVuY3Rpb24gKG9mZnNldFgsIG9mZnNldFksIHNoYWRvd0NvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gb2Zmc2V0WTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NvbG9yRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgY2hhcmFjdGVyIGluIHRoaXMuX3RleHRTcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdID0gdGhpcy5fdGV4dFNwcml0ZXNbY2hhcmFjdGVyXS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHRleHQgc2hhZG93XG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJUZXh0U2hhZG93XG4gICAgICAgICAqL1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuY2xlYXJUZXh0U2hhZG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSAwO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3IgPSBleC5Db2xvci5CbGFjay5jbG9uZSgpO1xuICAgICAgICB9O1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZW5naW5lLCBkZWx0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVGb250ICYmIHRoaXMuX2NvbG9yICE9PSB0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhcmFjdGVyIGluIHRoaXMuX3RleHRTcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTcHJpdGVzW2NoYXJhY3Rlcl0uY2xlYXJFZmZlY3RzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTcHJpdGVzW2NoYXJhY3Rlcl0uYWRkRWZmZWN0KG5ldyBleC5FZmZlY3RzLkZpbGwodGhpcy5jb2xvci5jbG9uZSgpKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zcHJpdGVGb250ICYmIHRoaXMuX3RleHRTaGFkb3dPbiAmJiB0aGlzLl9zaGFkb3dDb2xvckRpcnR5ICYmIHRoaXMuX3NoYWRvd0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2hhcmFjdGVyIGluIHRoaXMuX3NoYWRvd1Nwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLmNsZWFyRWZmZWN0cygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0uYWRkRWZmZWN0KG5ldyBleC5FZmZlY3RzLkZpbGwodGhpcy5fc2hhZG93Q29sb3IuY2xvbmUoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvckRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RleHRTaGFkb3dPbikge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLl9zaGFkb3dPZmZzZXRYLCB0aGlzLl9zaGFkb3dPZmZzZXRZKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb250RHJhdyhjdHgsIGRlbHRhLCB0aGlzLl9zaGFkb3dTcHJpdGVzKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZm9udERyYXcoY3R4LCBkZWx0YSwgdGhpcy5fdGV4dFNwcml0ZXMpO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcywgY3R4LCBkZWx0YSk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuX2ZvbnREcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEsIHNwcml0ZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwcml0ZUZvbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSB0aGlzLnRleHRbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyU3ByaXRlID0gc3ByaXRlc1tjaGFyYWN0ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNPcGFjaXR5ICE9PSB0aGlzLm9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLmNsZWFyRWZmZWN0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJTcHJpdGUuYWRkRWZmZWN0KG5ldyBleC5FZmZlY3RzLk9wYWNpdHkodGhpcy5vcGFjaXR5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLmRyYXcoY3R4LCBjdXJyWCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyWCArPSAoY2hhclNwcml0ZS5zd2lkdGggKyB0aGlzLmxldHRlclNwYWNpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihcIlNwcml0ZUZvbnQgRXJyb3IgZHJhd2luZyBjaGFyIFwiICsgY2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c09wYWNpdHkgIT09IHRoaXMub3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQWxpZ24gPSBjdHgudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIHZhciBvbGRUZXh0QmFzZWxpbmUgPSBjdHgudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLl9sb29rdXBUZXh0QWxpZ24odGhpcy50ZXh0QWxpZ24pO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLl9sb29rdXBCYXNlQWxpZ24odGhpcy5iYXNlQWxpZ24pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3IuYSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRoaXMuZm9udDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCAwLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnRleHQsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gb2xkQWxpZ247XG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IG9sZFRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVidWdEcmF3LmNhbGwodGhpcywgY3R4KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIExhYmVsO1xuICAgIH0pKGV4LkFjdG9yKTtcbiAgICBleC5MYWJlbCA9IExhYmVsO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9FdmVudHMudHNcIi8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIElucHV0O1xuICAgIChmdW5jdGlvbiAoSW5wdXQpIHtcbiAgICAgICAgKGZ1bmN0aW9uIChQb2ludGVyVHlwZSkge1xuICAgICAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJUb3VjaFwiXSA9IDBdID0gXCJUb3VjaFwiO1xuICAgICAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJNb3VzZVwiXSA9IDFdID0gXCJNb3VzZVwiO1xuICAgICAgICAgICAgUG9pbnRlclR5cGVbUG9pbnRlclR5cGVbXCJQZW5cIl0gPSAyXSA9IFwiUGVuXCI7XG4gICAgICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIlVua25vd25cIl0gPSAzXSA9IFwiVW5rbm93blwiO1xuICAgICAgICB9KShJbnB1dC5Qb2ludGVyVHlwZSB8fCAoSW5wdXQuUG9pbnRlclR5cGUgPSB7fSkpO1xuICAgICAgICB2YXIgUG9pbnRlclR5cGUgPSBJbnB1dC5Qb2ludGVyVHlwZTtcbiAgICAgICAgKGZ1bmN0aW9uIChQb2ludGVyQnV0dG9uKSB7XG4gICAgICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcbiAgICAgICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIk1pZGRsZVwiXSA9IDFdID0gXCJNaWRkbGVcIjtcbiAgICAgICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIlJpZ2h0XCJdID0gMl0gPSBcIlJpZ2h0XCI7XG4gICAgICAgICAgICBQb2ludGVyQnV0dG9uW1BvaW50ZXJCdXR0b25bXCJVbmtub3duXCJdID0gM10gPSBcIlVua25vd25cIjtcbiAgICAgICAgfSkoSW5wdXQuUG9pbnRlckJ1dHRvbiB8fCAoSW5wdXQuUG9pbnRlckJ1dHRvbiA9IHt9KSk7XG4gICAgICAgIHZhciBQb2ludGVyQnV0dG9uID0gSW5wdXQuUG9pbnRlckJ1dHRvbjtcbiAgICAgICAgdmFyIFBvaW50ZXJFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoUG9pbnRlckV2ZW50LCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUG9pbnRlckV2ZW50KHgsIHksIGluZGV4LCBwb2ludGVyVHlwZSwgYnV0dG9uLCBldikge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuICAgICAgICAgICAgICAgIHRoaXMuZXYgPSBldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQb2ludGVyRXZlbnQ7XG4gICAgICAgIH0pKGV4LkdhbWVFdmVudCk7XG4gICAgICAgIElucHV0LlBvaW50ZXJFdmVudCA9IFBvaW50ZXJFdmVudDtcbiAgICAgICAgO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBwb2ludGVyIGV2ZW50cyAobW91c2UsIHRvdWNoLCBzdHlsdXMsIGV0Yy4pIGFuZCBub3JtYWxpemVzIHRvIFczQyBQb2ludGVyIEV2ZW50cy5cbiAgICAgICAgICogVGhlcmUgaXMgYWx3YXlzIGF0IGxlYXN0IG9uZSBwb2ludGVyIGF2YWlsYWJsZSAocHJpbWFyeSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBQb2ludGVyc1xuICAgICAgICAgKiBAZXh0ZW5kcyBDbGFzc1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIHZhciBQb2ludGVycyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoUG9pbnRlcnMsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBQb2ludGVycyhlbmdpbmUpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyRG93biA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJVcCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJNb3ZlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlckNhbmNlbCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlcnMucHVzaChuZXcgUG9pbnRlcigpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQb2ludGVycyA9IFstMV07XG4gICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5ID0gdGhpcy5fcG9pbnRlcnNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHBvaW50ZXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFRvdWNoIEV2ZW50c1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KFwiZG93blwiLCB0aGlzLl9wb2ludGVyRG93bikpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFdmVudChcInVwXCIsIHRoaXMuX3BvaW50ZXJVcCkpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoXCJtb3ZlXCIsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KFwiY2FuY2VsXCIsIHRoaXMuX3BvaW50ZXJDYW5jZWwpKTtcbiAgICAgICAgICAgICAgICAvLyBXM0MgUG9pbnRlciBFdmVudHNcbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50OiBJRTExLCBJRTEwXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUxMVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwiZG93blwiLCB0aGlzLl9wb2ludGVyRG93bikpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJ1cFwiLCB0aGlzLl9wb2ludGVyVXApKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJtb3ZlXCIsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJjYW5jZWxcIiwgdGhpcy5fcG9pbnRlck1vdmUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFMTBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckRvd24nLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJkb3duXCIsIHRoaXMuX3BvaW50ZXJEb3duKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlclVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwidXBcIiwgdGhpcy5fcG9pbnRlclVwKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJtb3ZlXCIsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckNhbmNlbCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcImNhbmNlbFwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW91c2UgRXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoXCJkb3duXCIsIHRoaXMuX3BvaW50ZXJEb3duKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KFwidXBcIiwgdGhpcy5fcG9pbnRlclVwKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoXCJtb3ZlXCIsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyVXAubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyRG93bi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJNb3ZlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlckNhbmNlbC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2FmZWx5IGdldHMgYSBQb2ludGVyIGF0IGEgc3BlY2lmaWMgaW5kZXggYW5kIGluaXRpYWxpemVzIG9uZSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgICAgICAgICAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IFRoZSBwb2ludGVyIGluZGV4IHRvIHJldHJpZXZlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9wb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCAtIDEsIG1heCA9IGluZGV4OyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJzLnB1c2gobmV3IFBvaW50ZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQb2ludGVycy5wdXNoKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IG51bWJlciBvZiBwb2ludGVycyBiZWluZyB3YXRjaGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcG9nYXRlcyBldmVudHMgdG8gYWN0b3IgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5wcm9wb2dhdGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNVSUFjdG9yID0gYWN0b3IgaW5zdGFuY2VvZiBleC5VSUFjdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJVcC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyhlLngsIGUueSwgIWlzVUlBY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwicG9pbnRlcnVwXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlckRvd24uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29udGFpbnMoZS54LCBlLnksICFpc1VJQWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIucHVibGlzaChcInBvaW50ZXJkb3duXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJNb3ZlLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyhlLngsIGUueSwgIWlzVUlBY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIucHVibGlzaChcInBvaW50ZXJtb3ZlXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlckNhbmNlbC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyhlLngsIGUueSwgIWlzVUlBY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwicG9pbnRlcmNhbmNlbFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlTW91c2VFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGUucGFnZVggLSBleC5VdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS54O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGUucGFnZVkgLSBleC5VdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBleC5Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZSA9IG5ldyBQb2ludGVyRXZlbnQodHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnksIDAsIDEgLyogTW91c2UgKi8sIGUuYnV0dG9uLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0KDApLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKGV2ZW50TmFtZSwgcGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVUb3VjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSA/IF90aGlzLl9nZXRQb2ludGVySW5kZXgoZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VYIC0gZXguVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWSAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBleC5Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBpbmRleCwgMCAvKiBUb3VjaCAqLywgMyAvKiBVbmtub3duICovLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKGV2ZW50TmFtZSwgcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSB3aXRoIG11bHRpLXBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwidXBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcG9pbnRlciBJRCBmcm9tIHBvb2wgd2hlbiBwb2ludGVyIGlzIGxpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJkb3duXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgSUQgdG8gZ2l2ZW4gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IGUuY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5faGFuZGxlUG9pbnRlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggZm9yIHRoaXMgcG9pbnRlciBJRCBpZiBtdWx0aS1wb2ludGVyIGlzIGFza2VkIGZvclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSA/IF90aGlzLl9nZXRQb2ludGVySW5kZXgoZS5wb2ludGVySWQpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlLnBhZ2VYIC0gZXguVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBlLnBhZ2VZIC0gZXguVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnQgPSBfdGhpcy5fZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgZXguUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGUgPSBuZXcgUG9pbnRlckV2ZW50KHRyYW5zZm9ybWVkUG9pbnQueCwgdHJhbnNmb3JtZWRQb2ludC55LCBpbmRleCwgX3RoaXMuX3N0cmluZ1RvUG9pbnRlclR5cGUoZS5wb2ludGVyVHlwZSksIGUuYnV0dG9uLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5ldmVudERpc3BhdGNoZXIucHVibGlzaChldmVudE5hbWUsIHBlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSB3aXRoIG11bHRpLXBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcInVwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcG9pbnRlciBJRCBmcm9tIHBvb2wgd2hlbiBwb2ludGVyIGlzIGxpZnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJkb3duXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBJRCB0byBnaXZlbiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSBlLnBvaW50ZXJJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcG9pbnRlciBzcGVjaWZpZWQgZm9yIHRoZSBnaXZlbiBwb2ludGVyIElEIG9yIGZpbmRzIHRoZSBuZXh0IGVtcHR5IHBvaW50ZXIgc2xvdCBhdmFpbGFibGUuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgSUUxMC8xMSB1c2VzIGluY3JlbWVudGluZyBwb2ludGVyIElEcyBzbyB3ZSBuZWVkIHRvIHN0b3JlIGEgbWFwcGluZyBvZiBJRCA9PiBpZHhcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5fZ2V0UG9pbnRlckluZGV4ID0gZnVuY3Rpb24gKHBvaW50ZXJJZCkge1xuICAgICAgICAgICAgICAgIHZhciBpZHg7XG4gICAgICAgICAgICAgICAgaWYgKChpZHggPSB0aGlzLl9hY3RpdmVQb2ludGVycy5pbmRleE9mKHBvaW50ZXJJZCkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmVQb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlUG9pbnRlcnNbaV0gPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBwb2ludGVyIGJlY2F1c2UgZ2FtZSBpc24ndCB3YXRjaGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX3N0cmluZ1RvUG9pbnRlclR5cGUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG91Y2hcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIFRvdWNoICovO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibW91c2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIE1vdXNlICovO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBQZW4gKi87XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBVbmtub3duICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUG9pbnRlcnM7XG4gICAgICAgIH0pKGV4LkNsYXNzKTtcbiAgICAgICAgSW5wdXQuUG9pbnRlcnMgPSBQb2ludGVycztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcHR1cmVzIGFuZCBkaXNwYXRjaGVzIFBvaW50ZXJFdmVudHNcbiAgICAgICAgICogQGNsYXNzIFBvaW50ZXJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBleHRlbmRzIENsYXNzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgUG9pbnRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoUG9pbnRlciwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBvaW50ZXIoKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUG9pbnRlcjtcbiAgICAgICAgfSkoZXguQ2xhc3MpO1xuICAgICAgICBJbnB1dC5Qb2ludGVyID0gUG9pbnRlcjtcbiAgICB9KShJbnB1dCA9IGV4LklucHV0IHx8IChleC5JbnB1dCA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBJbnB1dDtcbiAgICAoZnVuY3Rpb24gKElucHV0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEVudW0gcmVwcmVzZW50aW5nIGlucHV0IGtleSBjb2Rlc1xuICAgICAgICAqIEBjbGFzcyBLZXlzXG4gICAgICAgICpcbiAgICAgICAgKi9cbiAgICAgICAgKGZ1bmN0aW9uIChLZXlzKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW0xIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTIge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtMyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW00IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTUge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtNiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW03IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTgge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtOSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW0wIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTFcIl0gPSA5N10gPSBcIk51bTFcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTJcIl0gPSA5OF0gPSBcIk51bTJcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTNcIl0gPSA5OV0gPSBcIk51bTNcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTRcIl0gPSAxMDBdID0gXCJOdW00XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW01XCJdID0gMTAxXSA9IFwiTnVtNVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtNlwiXSA9IDEwMl0gPSBcIk51bTZcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTdcIl0gPSAxMDNdID0gXCJOdW03XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW04XCJdID0gMTA0XSA9IFwiTnVtOFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtOVwiXSA9IDEwNV0gPSBcIk51bTlcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTBcIl0gPSA5Nl0gPSBcIk51bTBcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bWxvY2sge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtbG9ja1wiXSA9IDE0NF0gPSBcIk51bWxvY2tcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFNlbWljb2xvbiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlzW0tleXNbXCJTZW1pY29sb25cIl0gPSAxODZdID0gXCJTZW1pY29sb25cIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEEge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgQiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBDIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgRSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBGIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEcge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgSCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBJIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEoge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgSyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBMIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE0ge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBPIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFAge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgUSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBSIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFMge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgVCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBVIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFYge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgVyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBYIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFkge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgWiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlzW0tleXNbXCJBXCJdID0gNjVdID0gXCJBXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJCXCJdID0gNjZdID0gXCJCXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJDXCJdID0gNjddID0gXCJDXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJEXCJdID0gNjhdID0gXCJEXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJFXCJdID0gNjldID0gXCJFXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJGXCJdID0gNzBdID0gXCJGXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJHXCJdID0gNzFdID0gXCJHXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJIXCJdID0gNzJdID0gXCJIXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJJXCJdID0gNzNdID0gXCJJXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJKXCJdID0gNzRdID0gXCJKXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJLXCJdID0gNzVdID0gXCJLXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJMXCJdID0gNzZdID0gXCJMXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJNXCJdID0gNzddID0gXCJNXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOXCJdID0gNzhdID0gXCJOXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJPXCJdID0gNzldID0gXCJPXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJQXCJdID0gODBdID0gXCJQXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJRXCJdID0gODFdID0gXCJRXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJSXCJdID0gODJdID0gXCJSXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJTXCJdID0gODNdID0gXCJTXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJUXCJdID0gODRdID0gXCJUXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJVXCJdID0gODVdID0gXCJVXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJWXCJdID0gODZdID0gXCJWXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJXXCJdID0gODddID0gXCJXXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJYXCJdID0gODhdID0gXCJYXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJZXCJdID0gODldID0gXCJZXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJaXCJdID0gOTBdID0gXCJaXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBTaGlmdCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBBbHQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgVXAge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgRG93biB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBMZWZ0IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFJpZ2h0IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFNwYWNlIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEVzYyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlzW0tleXNbXCJTaGlmdFwiXSA9IDE2XSA9IFwiU2hpZnRcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkFsdFwiXSA9IDE4XSA9IFwiQWx0XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJVcFwiXSA9IDM4XSA9IFwiVXBcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkRvd25cIl0gPSA0MF0gPSBcIkRvd25cIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkxlZnRcIl0gPSAzN10gPSBcIkxlZnRcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlJpZ2h0XCJdID0gMzldID0gXCJSaWdodFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiU3BhY2VcIl0gPSAzMl0gPSBcIlNwYWNlXCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJFc2NcIl0gPSAyN10gPSBcIkVzY1wiO1xuICAgICAgICB9KShJbnB1dC5LZXlzIHx8IChJbnB1dC5LZXlzID0ge30pKTtcbiAgICAgICAgdmFyIEtleXMgPSBJbnB1dC5LZXlzO1xuICAgICAgICA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCB0aHJvd24gb24gYSBnYW1lIG9iamVjdCBmb3IgYSBrZXkgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzIEtleUV2ZW50XG4gICAgICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIGtleSB7SW5wdXRLZXl9IFRoZSBrZXkgcmVzcG9uc2libGUgZm9yIHRocm93aW5nIHRoZSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEtleUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhLZXlFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEtleUV2ZW50KGtleSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEtleUV2ZW50O1xuICAgICAgICB9KShleC5HYW1lRXZlbnQpO1xuICAgICAgICBJbnB1dC5LZXlFdmVudCA9IEtleUV2ZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFuYWdlcyBLZXlib2FyZCBpbnB1dCBldmVudHMgdGhhdCB5b3UgY2FuIHF1ZXJ5IG9yIGxpc3RlbiBmb3IgZXZlbnRzIG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBLZXlib2FyZFxuICAgICAgICAgKiBAZXh0ZW5kcyBDbGFzc1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHZhciBLZXlib2FyZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoS2V5Ym9hcmQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBLZXlib2FyZChlbmdpbmUpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5c1VwID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5c0Rvd24gPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemUgS2V5Ym9hcmQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXMubGVuZ3RoID0gMDsgLy8gZW1wdGllcyBhcnJheSBlZmZpY2llbnRseVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGtleSB1cCBpcyBvbiB3aW5kb3cgYmVjYXVzZSBjYW52YXMgY2Fubm90IGhhdmUgZm9jdXNcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF90aGlzLl9rZXlzLmluZGV4T2YoZXYua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLnNwbGljZShrZXksIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5c1VwLnB1c2goZXYua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlFdmVudCA9IG5ldyBLZXlFdmVudChldi5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJ1cFwiLCBrZXlFdmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8ga2V5IGRvd24gaXMgb24gd2luZG93IGJlY2F1c2UgY2FudmFzIGNhbm5vdCBoYXZlIGZvY3VzXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9rZXlzLmluZGV4T2YoZXYua2V5Q29kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5wdXNoKGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXNEb3duLnB1c2goZXYua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5RXZlbnQgPSBuZXcgS2V5RXZlbnQoZXYua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaChcImRvd25cIiwga2V5RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGtleXNEb3duIGFuZCBrZXlzVXAgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5c0Rvd24ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzVXAubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgbGlzdCBvZiBrZXlzIGJlaW5nIHByZXNzZWQgZG93blxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuZ2V0S2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5cztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IGlzIGRvd24uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGlzS2V5RG93blxuICAgICAgICAgICAgICogQHBhcmFtIGtleSB7S2V5c30gVGVzdCB3ZXRoZXIgYSBrZXkgaXMgZG93blxuICAgICAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuaXNLZXlEb3duID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzRG93bi5pbmRleE9mKGtleSkgPiAtMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IGlzIHByZXNzZWQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGlzS2V5UHJlc3NlZFxuICAgICAgICAgICAgICogQHBhcmFtIGtleSB7S2V5c30gVGVzdCB3ZXRoZXIgYSBrZXkgaXMgcHJlc3NlZFxuICAgICAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUuaXNLZXlQcmVzc2VkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KSA+IC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgaXMgdXAuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGlzS2V5VXBcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkge0tleXN9IFRlc3Qgd2V0aGVyIGEga2V5IGlzIHVwXG4gICAgICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5pc0tleVVwID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzVXAuaW5kZXhPZihrZXkpID4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEtleWJvYXJkO1xuICAgICAgICB9KShleC5DbGFzcyk7XG4gICAgICAgIElucHV0LktleWJvYXJkID0gS2V5Ym9hcmQ7XG4gICAgfSkoSW5wdXQgPSBleC5JbnB1dCB8fCAoZXguSW5wdXQgPSB7fSkpO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgSW5wdXQ7XG4gICAgKGZ1bmN0aW9uIChJbnB1dCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFuYWdlcyBHYW1lcGFkIEFQSSBpbnB1dC4gWW91IGNhbiBxdWVyeSB0aGUgZ2FtZXBhZHMgdGhhdCBhcmUgY29ubmVjdGVkXG4gICAgICAgICAqIG9yIGxpc3RlbiB0byBldmVudHMgKFwiYnV0dG9uXCIgYW5kIFwiYXhpc1wiKS5cbiAgICAgICAgICogQGNsYXNzIEdhbWVwYWRzXG4gICAgICAgICAqIEBleHRlbmRzIENsYXNzXG4gICAgICAgICAqIEBwYXJhbSBwYWRzIHtHYW1lcGFkW119IFRoZSBjb25uZWN0ZWQgZ2FtZXBhZHMuXG4gICAgICAgICAqIEBwYXJhbSBzdXBwb3J0ZWQge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBHYW1lcGFkIEFQSSBpcyBwcmVzZW50XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgR2FtZXBhZHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEdhbWVwYWRzLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gR2FtZXBhZHMoZW5naW5lKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gcG9sbCBmb3IgR2FtZXBhZCBpbnB1dCAoZGVmYXVsdDogZmFsc2UpXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGVuYWJsZWQge2Jvb2xlYW59XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgR2FtZXBhZCBBUEkgaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHN1cHBvcnRlZCB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRlZCA9ICEhbmF2aWdhdG9yLmdldEdhbWVwYWRzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbml0U3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEluIENocm9tZSwgdGhpcyB3aWxsIHJldHVybiA0IHVuZGVmaW5lZCBpdGVtcyB1bnRpbCBhIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAgICAgICAgICAgICAgLy8gSW4gRkYsIHRoaXMgd2lsbCBub3QgcmV0dXJuIGFueSBpdGVtcyB1bnRpbCBhIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkUGFkcyA9IHRoaXMuX2Nsb25lUGFkcyh0aGlzLl9uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29sZFBhZHMubGVuZ3RoICYmIHRoaXMuX29sZFBhZHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZXMgR2FtZXBhZCBzdGF0ZSBhbmQgcHVibGlzaGVzIEdhbWVwYWQgZXZlbnRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5zdXBwb3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2FtZXBhZHMgPSB0aGlzLl9uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdhbWVwYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ2FtZXBhZHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgY29ubmVjdGlvbiBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc3VwcG9ydGVkIGluIENocm9tZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0udGltZXN0YW1wICYmIGdhbWVwYWRzW2ldLnRpbWVzdGFtcCA9PT0gdGhpcy5fZ2FtZVBhZFRpbWVTdGFtcHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzW2ldID0gZ2FtZXBhZHNbaV0udGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICAvLyBCdXR0b25zXG4gICAgICAgICAgICAgICAgICAgIHZhciBiLCBhLCB2YWx1ZSwgYnV0dG9uSW5kZXgsIGF4ZXNJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChiIGluIEJ1dHRvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQnV0dG9uc1tiXSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkluZGV4ID0gQnV0dG9uc1tiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYnV0dG9uc1tidXR0b25JbmRleF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX29sZFBhZHNbaV0uZ2V0QnV0dG9uKGJ1dHRvbkluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkc1tpXS5idXR0b25zW2J1dHRvbkluZGV4XS5wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJ1dHRvbkluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJidXR0b25cIiwgbmV3IEdhbWVwYWRCdXR0b25FdmVudChidXR0b25JbmRleCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJ1dHRvbkluZGV4LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChhIGluIEF4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQXhlc1thXSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ZXNJbmRleCA9IEF4ZXNbYV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdhbWVwYWRzW2ldLmF4ZXNbYXhlc0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fb2xkUGFkc1tpXS5nZXRBeGVzKGF4ZXNJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUF4ZXMoYXhlc0luZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5ldmVudERpc3BhdGNoZXIucHVibGlzaChcImF4aXNcIiwgbmV3IEdhbWVwYWRBeGlzRXZlbnQoYXhlc0luZGV4LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHNbaV0gPSB0aGlzLl9jbG9uZVBhZChnYW1lcGFkc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2FmZWx5IHJldHJpZXZlcyBhIEdhbWVwYWQgYXQgYSBzcGVjaWZpYyBpbmRleCBhbmQgY3JlYXRlcyBvbmUgaWYgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BhZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9wYWRzLmxlbmd0aCAtIDEsIG1heCA9IGluZGV4OyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhZHMucHVzaChuZXcgR2FtZXBhZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29sZFBhZHMucHVzaChuZXcgR2FtZXBhZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFkc1tpbmRleF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgY29ubmVjdGVkIGdhbWVwYWRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFkcy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuY29ubmVjdGVkOyB9KS5sZW5ndGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLl9jbG9uZVBhZHMgPSBmdW5jdGlvbiAocGFkcykge1xuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLl9jbG9uZVBhZChwYWRzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYXN0ZXN0IHdheSB0byBjbG9uZSBhIGtub3duIG9iamVjdCBpcyB0byBkbyBpdCB5b3Vyc2VsZlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuX2Nsb25lUGFkID0gZnVuY3Rpb24gKHBhZCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBsZW47XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lZFBhZCA9IG5ldyBHYW1lcGFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWRQYWQ7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcGFkLmJ1dHRvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkUGFkLnVwZGF0ZUJ1dHRvbihpLCBwYWQuYnV0dG9uc1tpXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhZC5heGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVBeGVzKGksIHBhZC5heGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBtaW5pbXVtIHZhbHVlIGFuIGF4aXMgaGFzIHRvIG1vdmUgYmVmb3JlIGNvbnNpZGVyaW5nIGl0IGEgY2hhbmdlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgTWluQXhpc01vdmVUaHJlc2hvbGQge251bWJlcn1cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZHMuTWluQXhpc01vdmVUaHJlc2hvbGQgPSAwLjA1O1xuICAgICAgICAgICAgcmV0dXJuIEdhbWVwYWRzO1xuICAgICAgICB9KShleC5DbGFzcyk7XG4gICAgICAgIElucHV0LkdhbWVwYWRzID0gR2FtZXBhZHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpdmlkdWFsIHN0YXRlIGZvciBhIEdhbWVwYWRcbiAgICAgICAgICogQGNsYXNzIEdhbWVwYWRcbiAgICAgICAgICogQGV4dGVuZHMgQ2xhc3NcbiAgICAgICAgICovXG4gICAgICAgIHZhciBHYW1lcGFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gR2FtZXBhZCgpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvbnMgPSBuZXcgQXJyYXkoMTYpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F4ZXMgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2J1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uc1tpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9heGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F4ZXNbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAgICAgICAgICAgKiBAcGFyYW0gYnV0dG9uIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHBhcmFtIFt0aHJlc2hvbGQ9MV0ge251bWJlcn0gVGhlIHRocmVzaG9sZCBvdmVyIHdoaWNoIHRoZSBidXR0b24gaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzc2VkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWQucHJvdG90eXBlLmlzQnV0dG9uUHJlc3NlZCA9IGZ1bmN0aW9uIChidXR0b24sIHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkgeyB0aHJlc2hvbGQgPSAxOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXSA+PSB0aHJlc2hvbGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBnaXZlbiBidXR0b24gdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBidXR0b24ge0J1dHRvbnN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWQucHJvdG90eXBlLmdldEJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uc1tidXR0b25dO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgZ2l2ZW4gYXhpcyB2YWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtIGF4ZXMge0F4ZXN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWQucHJvdG90eXBlLmdldEF4ZXMgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2F4ZXNbYXhlc107XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IEdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS51cGRhdGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uSW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uc1tidXR0b25JbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBHYW1lcGFkLnByb3RvdHlwZS51cGRhdGVBeGVzID0gZnVuY3Rpb24gKGF4ZXNJbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9heGVzW2F4ZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gR2FtZXBhZDtcbiAgICAgICAgfSkoZXguQ2xhc3MpO1xuICAgICAgICBJbnB1dC5HYW1lcGFkID0gR2FtZXBhZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdhbWVwYWQgQnV0dG9ucyBlbnVtZXJhdGlvblxuICAgICAgICAgKiBAY2xhc3MgQnV0dG9uc1xuICAgICAgICAgKi9cbiAgICAgICAgKGZ1bmN0aW9uIChCdXR0b25zKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZhY2UgMSBidXR0b24gKGUuZy4gQSlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBGYWNlMSB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYWNlIDIgYnV0dG9uIChlLmcuIEIpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRmFjZTIge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFjZSAzIGJ1dHRvbiAoZS5nLiBYKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IEZhY2UzIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZhY2UgNCBidXR0b24gKGUuZy4gWSlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBGYWNlNCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTFcIl0gPSAwXSA9IFwiRmFjZTFcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UyXCJdID0gMV0gPSBcIkZhY2UyXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlM1wiXSA9IDJdID0gXCJGYWNlM1wiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTRcIl0gPSAzXSA9IFwiRmFjZTRcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVmdCBidW1wZXIgYnV0dG9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgTGVmdEJ1bXBlciB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaWdodCBidW1wZXIgYnV0dG9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgUmlnaHRCdW1wZXIge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRCdW1wZXJcIl0gPSA0XSA9IFwiTGVmdEJ1bXBlclwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRCdW1wZXJcIl0gPSA1XSA9IFwiUmlnaHRCdW1wZXJcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVmdCB0cmlnZ2VyIGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IExlZnRUcmlnZ2VyIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJpZ2h0IHRyaWdnZXIgYnV0dG9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgUmlnaHRUcmlnZ2VyIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0VHJpZ2dlclwiXSA9IDZdID0gXCJMZWZ0VHJpZ2dlclwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRUcmlnZ2VyXCJdID0gN10gPSBcIlJpZ2h0VHJpZ2dlclwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWxlY3QgYnV0dG9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgU2VsZWN0IHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0YXJ0IGJ1dHRvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFN0YXJ0IHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJTZWxlY3RcIl0gPSA4XSA9IFwiU2VsZWN0XCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJTdGFydFwiXSA9IDldID0gXCJTdGFydFwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMZWZ0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBMMylcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0U3RpY2sge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmlnaHQgYW5hbG9nIHN0aWNrIHByZXNzIChlLmcuIFIzKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IFN0YXJ0IHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0U3RpY2tcIl0gPSAxMF0gPSBcIkxlZnRTdGlja1wiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRTdGlja1wiXSA9IDExXSA9IFwiUmlnaHRTdGlja1wiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBELXBhZCB1cFxuICAgICAgICAgICAgICogQHByb3BlcnR5IERwYWRVcCB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBELXBhZCBkb3duXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRHBhZERvd24ge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRC1wYWQgbGVmdFxuICAgICAgICAgICAgICogQHByb3BlcnR5IERwYWRMZWZ0IHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEQtcGFkIHJpZ2h0XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRHBhZFJpZ2h0IHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkVXBcIl0gPSAxMl0gPSBcIkRwYWRVcFwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZERvd25cIl0gPSAxM10gPSBcIkRwYWREb3duXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkTGVmdFwiXSA9IDE0XSA9IFwiRHBhZExlZnRcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRSaWdodFwiXSA9IDE1XSA9IFwiRHBhZFJpZ2h0XCI7XG4gICAgICAgIH0pKElucHV0LkJ1dHRvbnMgfHwgKElucHV0LkJ1dHRvbnMgPSB7fSkpO1xuICAgICAgICB2YXIgQnV0dG9ucyA9IElucHV0LkJ1dHRvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHYW1lcGFkIEF4ZXMgZW51bWVyYXRpb25cbiAgICAgICAgICogQGNsYXNzIEF4ZXNcbiAgICAgICAgICovXG4gICAgICAgIChmdW5jdGlvbiAoQXhlcykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMZWZ0IGFuYWxvZ3VlIHN0aWNrIFggZGlyZWN0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFN0aWNrWCB7QXhlc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMZWZ0IGFuYWxvZ3VlIHN0aWNrIFkgZGlyZWN0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFN0aWNrWSB7QXhlc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaWdodCBhbmFsb2d1ZSBzdGljayBYIGRpcmVjdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFJpZ2h0U3RpY2tYIHtBeGVzfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJpZ2h0IGFuYWxvZ3VlIHN0aWNrIFkgZGlyZWN0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgUmlnaHRTdGlja1kge0F4ZXN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEF4ZXNbQXhlc1tcIkxlZnRTdGlja1hcIl0gPSAwXSA9IFwiTGVmdFN0aWNrWFwiO1xuICAgICAgICAgICAgQXhlc1tBeGVzW1wiTGVmdFN0aWNrWVwiXSA9IDFdID0gXCJMZWZ0U3RpY2tZXCI7XG4gICAgICAgICAgICBBeGVzW0F4ZXNbXCJSaWdodFN0aWNrWFwiXSA9IDJdID0gXCJSaWdodFN0aWNrWFwiO1xuICAgICAgICAgICAgQXhlc1tBeGVzW1wiUmlnaHRTdGlja1lcIl0gPSAzXSA9IFwiUmlnaHRTdGlja1lcIjtcbiAgICAgICAgfSkoSW5wdXQuQXhlcyB8fCAoSW5wdXQuQXhlcyA9IHt9KSk7XG4gICAgICAgIHZhciBBeGVzID0gSW5wdXQuQXhlcztcbiAgICAgICAgdmFyIEdhbWVwYWRCdXR0b25FdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZEJ1dHRvbkV2ZW50LCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gR2FtZXBhZEJ1dHRvbkV2ZW50KGJ1dHRvbiwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR2FtZXBhZEJ1dHRvbkV2ZW50O1xuICAgICAgICB9KShleC5HYW1lRXZlbnQpO1xuICAgICAgICBJbnB1dC5HYW1lcGFkQnV0dG9uRXZlbnQgPSBHYW1lcGFkQnV0dG9uRXZlbnQ7XG4gICAgICAgIHZhciBHYW1lcGFkQXhpc0V2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkQXhpc0V2ZW50LCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gR2FtZXBhZEF4aXNFdmVudChheGlzLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXhpcyA9IGF4aXM7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdhbWVwYWRBeGlzRXZlbnQ7XG4gICAgICAgIH0pKGV4LkdhbWVFdmVudCk7XG4gICAgICAgIElucHV0LkdhbWVwYWRBeGlzRXZlbnQgPSBHYW1lcGFkQXhpc0V2ZW50O1xuICAgIH0pKElucHV0ID0gZXguSW5wdXQgfHwgKGV4LklucHV0ID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTW9ua2V5UGF0Y2gudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50cy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRXZlbnREaXNwYXRjaGVyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDbGFzcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sb3IudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvZy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uL1NpZGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNjZW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVUlBY3Rvci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVHJpZ2dlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUGFydGljbGVzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBbmltYXRpb24udHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNhbWVyYS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU291bmQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvYWRlci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUHJvbWlzZXMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlV0aWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkJpbmRpbmcudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRpbGVNYXAudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxhYmVsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQb3N0UHJvY2Vzc2luZy9JUG9zdFByb2Nlc3Nvci50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJbnB1dC9JRW5naW5lSW5wdXQudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW5wdXQvUG9pbnRlci50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJbnB1dC9LZXlib2FyZC50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJbnB1dC9HYW1lcGFkLnRzXCIvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgZGlzcGxheSBtb2RlcyBhdmFpbGFibGUgdG8gRXhjYWxpYnVyXG4gICAgICogQGNsYXNzIERpc3BsYXlNb2RlXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChEaXNwbGF5TW9kZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZ2FtZSBhcyBmdWxsIHNjcmVlblxuICAgICAgICAgKiBAcHJvcGVydHkgRnVsbFNjcmVlbiB7RGlzcGxheU1vZGV9XG4gICAgICAgICAqL1xuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIkZ1bGxTY3JlZW5cIl0gPSAwXSA9IFwiRnVsbFNjcmVlblwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGUgdGhlIGdhbWUgdG8gdGhlIHBhcmVudCBET00gY29udGFpbmVyXG4gICAgICAgICAqIEBwcm9wZXJ0eSBDb250YWluZXIge0Rpc3BsYXlNb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJDb250YWluZXJcIl0gPSAxXSA9IFwiQ29udGFpbmVyXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBnYW1lIGFzIGEgZml4ZWQgc2l6ZVxuICAgICAgICAgKiBAUHJvcGVydHkgRml4ZWQge0Rpc3BsYXlNb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgRGlzcGxheU1vZGVbRGlzcGxheU1vZGVbXCJGaXhlZFwiXSA9IDJdID0gXCJGaXhlZFwiO1xuICAgIH0pKGV4LkRpc3BsYXlNb2RlIHx8IChleC5EaXNwbGF5TW9kZSA9IHt9KSk7XG4gICAgdmFyIERpc3BsYXlNb2RlID0gZXguRGlzcGxheU1vZGU7XG4gICAgLy8gaW50ZXJuYWxcbiAgICB2YXIgQW5pbWF0aW9uTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbk5vZGUoYW5pbWF0aW9uLCB4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25Ob2RlO1xuICAgIH0pKCk7XG4gICAgLyoqXG4gICAgICogVGhlICdFbmdpbmUnIGlzIHRoZSBtYWluIGRyaXZlciBmb3IgYSBnYW1lLiBJdCBpcyByZXNwb25zaWJsZSBmb3JcbiAgICAgKiBzdGFydGluZy9zdG9wcGluZyB0aGUgZ2FtZSwgbWFpbnRhaW5pbmcgc3RhdGUsIHRyYW5zbWl0dGluZyBldmVudHMsXG4gICAgICogbG9hZGluZyByZXNvdXJjZXMsIGFuZCBtYW5hZ2luZyB0aGUgc2NlbmUuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgRW5naW5lXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIFt3aWR0aF0ge251bWJlcn0gVGhlIHdpZHRoIGluIHBpeGVscyBvZiB0aGUgRXhjYWxpYnVyIGdhbWUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gW2hlaWdodF0ge251bWJlcn0gVGhlIGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIEV4Y2FsaWJ1ciBnYW1lIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIFtjYW52YXNFbGVtZW50SWRdIHtzdHJpbmd9IElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlbiBhIG5ldyBjYW52YXMgd2lsbCBiZSBjcmVhdGVkIGFuZCBpbnNlcnRlZCBpbnRvIHRoZSBib2R5LlxuICAgICAqIEBwYXJhbSBbZGlzcGxheU1vZGVdIHtEaXNwbGF5TW9kZX0gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIGl0IHdpbGwgZmFsbCBiYWNrIHRvIGZpeGVkIGlmIGEgaGVpZ2h0IGFuZCB3aWR0aCBhcmUgc3BlY2lmaWVkLCBlbHNlIHRoZSBkaXNwbGF5IG1vZGUgd2lsbCBiZSBGdWxsU2NyZWVuLlxuICAgICAqL1xuICAgIHZhciBFbmdpbmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRW5naW5lLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFbmdpbmUod2lkdGgsIGhlaWdodCwgY2FudmFzRWxlbWVudElkLCBkaXNwbGF5TW9kZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgY29sbGlzaW9uIHN0cmF0ZWd5IGZvciBFeGNhbGlidXJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25TdHJhdGVneSB7Q29sbGlzaW9uU3RyYXRlZ3l9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uU3RyYXRlZ3kgPSAxIC8qIER5bmFtaWNBQUJCVHJlZSAqLztcbiAgICAgICAgICAgIHRoaXMuaGFzU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mcHMgPSAwO1xuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc29ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUhhc2ggPSB7fTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZW5naW5lIGlzIHNldCB0byBmdWxsc2NyZWVuIG9yIG5vdFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGlzRnVsbHNjcmVlbiB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc0Z1bGxzY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHRoZSBjdXJyZW50IERpc3BsYXlNb2RlIG9mIHRoZSBlbmdpbmUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2Rpc3BsYXlNb2RlPUZ1bGxTY3JlZW5dIHtEaXNwbGF5TW9kZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5TW9kZSA9IDAgLyogRnVsbFNjcmVlbiAqLztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYXVkaW8gc2hvdWxkIGJlIHBhdXNlZCB3aGVuIHRoZSBnYW1lIGlzIG5vIGxvbmdlciB2aXNpYmxlLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtwYXVzZUF1ZGlvV2hlbkhpZGRlbj10cnVlXSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXVzZUF1ZGlvV2hlbkhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlbmdpbmUgc2hvdWxkIGRyYXcgd2l0aCBkZWJ1ZyBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtpc0RlYnVnPWZhbHNlXSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc0RlYnVnID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlYnVnQ29sb3IgPSBuZXcgZXguQ29sb3IoMjU1LCAyNTUsIDI1NSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGJhY2tncm91bmQgY29sb3IgZm9yIHRoZSBlbmdpbmUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2JhY2tncm91bmRDb2xvcj1uZXcgQ29sb3IoMCwgMCwgMTAwKV0ge0NvbG9yfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG5ldyBleC5Db2xvcigwLCAwLCAxMDApO1xuICAgICAgICAgICAgdGhpcy5pc1Ntb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdGhpcy50b3RhbCA9IDE7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcIlBvd2VyZWQgYnkgRXhjYWxpYnVyLmpzIHZpc2l0XCIsIFwiaHR0cDovL2V4Y2FsaWJ1cmpzLmNvbVwiLCBcImZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiQnVpbGRpbmcgZW5naW5lLi4uXCIpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50SWQgPSBjYW52YXNFbGVtZW50SWQ7XG4gICAgICAgICAgICBpZiAoY2FudmFzRWxlbWVudElkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJVc2luZyBDYW52YXMgZWxlbWVudCBzcGVjaWZpZWQ6IFwiICsgY2FudmFzRWxlbWVudElkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0VsZW1lbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlVzaW5nIGdlbmVyYXRlZCBjYW52YXMgZWxlbWVudFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5TW9kZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5TW9kZSA9IDIgLyogRml4ZWQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiRW5naW5lIHZpZXdwb3J0IGlzIHNpemUgXCIgKyB3aWR0aCArIFwiIHggXCIgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkaXNwbGF5TW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiRW5naW5lIHZpZXdwb3J0IGlzIGZ1bGxzY3JlZW5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5TW9kZSA9IDAgLyogRnVsbFNjcmVlbiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IGV4LkxvYWRlcigpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJvb3RTY2VuZSA9IHRoaXMuY3VycmVudFNjZW5lID0gbmV3IGV4LlNjZW5lKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hZGRTY2VuZSgncm9vdCcsIHRoaXMucm9vdFNjZW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGxheXMgYSBzcHJpdGUgYW5pbWF0aW9uIG9uIHRoZSBzY3JlZW4gYXQgdGhlIHNwZWNpZmllZCB4IGFuZCB5XG4gICAgICAgICAqIChpbiBnYW1lIGNvb3JkaW5hdGVzLCBub3Qgc2NyZWVuIHBpeGVscykuIFRoZXNlIGFuaW1hdGlvbnMgcGxheVxuICAgICAgICAgKiBpbmRlcGVuZGVudCBvZiBhY3RvcnMsIGFuZCB3aWxsIGJlIGNsZWFuZWQgdXAgaW50ZXJuYWxseSBhcyBzb29uXG4gICAgICAgICAqIGFzIHRoZXkgYXJlIGNvbXBsZXRlLiBOb3RlIGFuaW1hdGlvbnMgdGhhdCBsb29wIHdpbGwgbmV2ZXIgYmVcbiAgICAgICAgICogY2xlYW5lZCB1cC5cbiAgICAgICAgICogQG1ldGhvZCBwbGF5QW5pbWF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBhbmltYXRpb24ge0FuaW1hdGlvbn0gQW5pbWF0aW9uIHRvIHBsYXlcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn0geCBnYW1lIGNvb3JkaW5hdGUgdG8gcGxheSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IHkgZ2FtZSBjb29yZGluYXRlIHRvIHBsYXkgdGhlIGFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1hdGlvbiwgeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLnB1c2gobmV3IEFuaW1hdGlvbk5vZGUoYW5pbWF0aW9uLCB4LCB5KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGFjdG9yIHRvIHRoZSBjdXJyZW50IHNjZW5lIG9mIHRoZSBnYW1lLiBUaGlzIGlzIHN5bm9ueW1vdXNcbiAgICAgICAgICogdG8gY2FsbGluZyBlbmdpbmUuY3VycmVudFNjZW5lLmFkZENoaWxkKGFjdG9yIDogQWN0b3IpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBY3RvcnMgY2FuIG9ubHkgYmUgZHJhd24gaWYgdGhleSBhcmUgYSBtZW1iZXIgb2YgYSBzY2VuZSwgYW5kIG9ubHlcbiAgICAgICAgICogdGhlICdjdXJyZW50U2NlbmUnIG1heSBiZSBkcmF3biBvciB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGFkZENoaWxkXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0byBhZGQgdG8gdGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZENoaWxkKGFjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gYWN0b3IgZnJvbSB0aGUgY3VycmVudFNjZW5lIG9mIHRoZSBnYW1lLiBUaGlzIGlzIHN5bm9ueW1vdXNcbiAgICAgICAgICogdG8gY2FsbGluZyBlbmdpbmUuY3VycmVudFNjZW5lLnJlbW92ZUNoaWxkKGFjdG9yIDogQWN0b3IpLlxuICAgICAgICAgKiBBY3RvcnMgdGhhdCBhcmUgcmVtb3ZlZCBmcm9tIGEgc2NlbmUgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVDaGlsZFxuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gcmVtb3ZlIGZyb20gdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVDaGlsZChhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgVGlsZU1hcCB0byB0aGUgU2NlbmUsIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBUaWxlTWFwIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgYWRkVGlsZU1hcFxuICAgICAgICAgKiBAcGFyYW0gdGlsZU1hcCB7VGlsZU1hcH1cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuYWRkVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRUaWxlTWFwKHRpbGVNYXApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIFRpbGVNYXAgZnJvbSB0aGUgU2NlbmUsIGl0IHdpbGxubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVUaWxlTWFwXG4gICAgICAgICAqIEBwYXJhbSB0aWxlTWFwIHtUaWxlTWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZVRpbGVNYXAodGlsZU1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGFuIGV4Y2FsaWJ1ciB0aW1lciB0byB0aGUgY3VycmVudCBzY2VuZS5cbiAgICAgICAgICogQHBhcmFtIHRpbWVyIHtUaW1lcn0gVGhlIHRpbWVyIHRvIGFkZCB0byB0aGUgY3VycmVudCBzY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCBhZGRUaW1lclxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGRUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNjZW5lLmFkZFRpbWVyKHRpbWVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gZXhjYWxpYnVyIHRpbWVyIGZyb20gdGhlIGN1cnJlbnQgc2NlbmUuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlVGltZXJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyIHtUaW1lcn0gVGhlIHRpbWVyIHRvIHJlbW92ZSB0byB0aGUgY3VycmVudCBzY2VuZS5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVUaW1lcih0aW1lcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgc2NlbmUgdG8gdGhlIGVuZ2luZSwgdGhpbmsgb2Ygc2NlbmVzIGluIGV4Y2FsaWJ1ciBhcyB5b3VcbiAgICAgICAgICogd291bGQgc2NlbmVzIGluIGEgcGxheS5cbiAgICAgICAgICogQG1ldGhvZCBhZGRTY2VuZVxuICAgICAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgc2NlbmUsIG11c3QgYmUgdW5pcXVlXG4gICAgICAgICAqIEBwYXJhbSBzY2VuZSB7U2NlbmV9IFRoZSBzY2VuZSB0byBhZGQgdG8gdGhlIGVuZ2luZVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGRTY2VuZSA9IGZ1bmN0aW9uIChuYW1lLCBzY2VuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVIYXNoW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlNjZW5lXCIsIG5hbWUsIFwiYWxyZWFkeSBleGlzdHMgb3ZlcndyaXRpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lSGFzaFtuYW1lXSA9IHNjZW5lO1xuICAgICAgICAgICAgc2NlbmUuZW5naW5lID0gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVTY2VuZSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5TY2VuZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnNjZW5lSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2VuZUhhc2guaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVIYXNoW2tleV0gPT09IGVudGl0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lSGFzaFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRpdHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgc2NlbmVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2VuZUhhc2hbZW50aXR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVUlBY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZFVJQWN0b3IoZW50aXR5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbWVyKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVGlsZU1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGlsZU1hcChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFNjZW5lKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVUlBY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZVVJQWN0b3IoZW50aXR5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbWVyKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVGlsZU1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZU1hcChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlNjZW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRpdHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNjZW5lKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50bHkgdXBkYXRpbmcgYW5kIGRyYXdpbmcgc2NlbmUgdG8gYSBkaWZmZXJlbnQsXG4gICAgICAgICAqIG5hbWVkIHNjZW5lLlxuICAgICAgICAgKiBAbWV0aG9kIGdvVG9TY2VuZVxuICAgICAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgc2NlbmUgdG8gdHJhc2l0aW9uIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nb1RvU2NlbmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVIYXNoW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25EZWFjdGl2YXRlLmNhbGwodGhpcy5jdXJyZW50U2NlbmUpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTY2VuZSA9IHRoaXMuY3VycmVudFNjZW5lO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lID0gdGhpcy5zY2VuZUhhc2hbbmFtZV07XG4gICAgICAgICAgICAgICAgb2xkU2NlbmUuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2RlYWN0aXZhdGUnLCBuZXcgZXguRGVhY3RpdmF0ZUV2ZW50KHRoaXMuY3VycmVudFNjZW5lKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25BY3RpdmF0ZS5jYWxsKHRoaXMuY3VycmVudFNjZW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5ldmVudERpc3BhdGNoZXIucHVibGlzaCgnYWN0aXZhdGUnLCBuZXcgZXguQWN0aXZhdGVFdmVudChvbGRTY2VuZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJTY2VuZVwiLCBuYW1lLCBcImRvZXMgbm90IGV4aXN0IVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmVzIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0V2lkdGhcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyIFRoZSB3aWR0aCBvZiB0aGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscy5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggLyB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGVuZ2luZXMgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscy5cbiAgICAgICAgICogQG1ldGhvZCBnZXRIZWlnaHRcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyIFRoZSBoZWlnaHQgb2YgdGhlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQgLyB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNmb3JtcyB0aGUgY3VycmVudCB4LCB5IGZyb20gc2NyZWVuIGNvb3JkaW5hdGVzIHRvIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgICAgICAqIEBtZXRob2Qgc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzXG4gICAgICAgICAqIEBwYXJhbSBwb2ludCB7UG9pbnR9IHNjcmVlbiBjb29yZGluYXRlIHRvIGNvbnZlcnRcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAvLyB0b2RvIHNldCB0aGVzZSBiYWNrIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoXG4gICAgICAgICAgICB2YXIgbmV3WCA9IHBvaW50Lng7XG4gICAgICAgICAgICB2YXIgbmV3WSA9IHBvaW50Lnk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5jdXJyZW50U2NlbmUuY2FtZXJhLmdldEZvY3VzKCk7XG4gICAgICAgICAgICAgICAgbmV3WCA9IGZvY3VzLnggKyAocG9pbnQueCAtICh0aGlzLmdldFdpZHRoKCkgLyAyKSk7XG4gICAgICAgICAgICAgICAgbmV3WSA9IGZvY3VzLnkgKyAocG9pbnQueSAtICh0aGlzLmdldEhlaWdodCgpIC8gMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3WCA9IE1hdGguZmxvb3IoKG5ld1ggLyB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCkgKiB0aGlzLmdldFdpZHRoKCkpO1xuICAgICAgICAgICAgbmV3WSA9IE1hdGguZmxvb3IoKG5ld1kgLyB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpICogdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KG5ld1gsIG5ld1kpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNmb3JtcyBhIHdvcmxkIGNvb3JkaW5hdGUsIHRvIGEgc2NyZWVuIGNvb3JkaW5hdGVcbiAgICAgICAgICogQG1ldGhvZCB3b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXNcbiAgICAgICAgICogQHBhcmFtIHBvaW50IHtQb2ludH0gd29ybGQgY29vcmRpbmF0ZSB0byBjb252ZXJ0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgLy8gdG9kbyBzZXQgdGhlc2UgYmFjayB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aFxuICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBjb3JyZWN0IG9uIHpvb21cbiAgICAgICAgICAgIHZhciBzY3JlZW5YID0gcG9pbnQueDtcbiAgICAgICAgICAgIHZhciBzY3JlZW5ZID0gcG9pbnQueTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICBzY3JlZW5YID0gKHBvaW50LnggLSBmb2N1cy54KSArICh0aGlzLmdldFdpZHRoKCkgLyAyKTsgLy8odGhpcy5nZXRXaWR0aCgpIC8gdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpO1xuICAgICAgICAgICAgICAgIHNjcmVlblkgPSAocG9pbnQueSAtIGZvY3VzLnkpICsgKHRoaXMuZ2V0SGVpZ2h0KCkgLyAyKTsgLy8gKHRoaXMuZ2V0SGVpZ2h0KCkgLyB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyZWVuWCA9IE1hdGguZmxvb3IoKHNjcmVlblggLyB0aGlzLmdldFdpZHRoKCkpICogdGhpcy5jYW52YXMuY2xpZW50V2lkdGgpO1xuICAgICAgICAgICAgc2NyZWVuWSA9IE1hdGguZmxvb3IoKHNjcmVlblkgLyB0aGlzLmdldEhlaWdodCgpKSAqIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KHNjcmVlblgsIHNjcmVlblkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaW50ZXJuYWwgY2FudmFzIGhlaWdodCBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgZGlzcGxheSBtb2RlLlxuICAgICAgICAgKiBAbWV0aG9kIHNldEhlaWdodEJ5RGlzcGxheU1vZGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2V0SGVpZ2h0QnlEaXNwbGF5TW9kZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSAxIC8qIENvbnRhaW5lciAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gMCAvKiBGdWxsU2NyZWVuICovKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW4gPSAnMHB4JztcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoID0gcGFyZW50LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgY2FudmFzLCByZW5kZXJpbmcgY29udGV4dCwgZGlzcGxheW1vZGUsIGFuZCBuYXRpdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSAwIC8qIEZ1bGxTY3JlZW4gKi8gfHwgdGhpcy5kaXNwbGF5TW9kZSA9PT0gMSAvKiBDb250YWluZXIgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuZGlzcGxheU1vZGUgPT09IDEgLyogQ29udGFpbmVyICovID8gKHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkgOiB3aW5kb3cpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0QnlEaXNwbGF5TW9kZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiVmlldyBwb3J0IHJlc2l6ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEhlaWdodEJ5RGlzcGxheU1vZGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmluZm8oXCJwYXJlbnQuY2xpZW50SGVpZ2h0IFwiICsgcGFyZW50LmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEFudGlhbGlhc2luZyhfdGhpcy5pc1Ntb290aGluZ0VuYWJsZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBpbnB1dHNcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB7XG4gICAgICAgICAgICAgICAga2V5Ym9hcmQ6IG5ldyBleC5JbnB1dC5LZXlib2FyZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBwb2ludGVyczogbmV3IGV4LklucHV0LlBvaW50ZXJzKHRoaXMpLFxuICAgICAgICAgICAgICAgIGdhbWVwYWRzOiBuZXcgZXguSW5wdXQuR2FtZXBhZHModGhpcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5nYW1lcGFkcy5pbml0KCk7XG4gICAgICAgICAgICAvLyBJc3N1ZSAjMzg1IG1ha2UgdXNlIG9mIHRoZSB2aXNpYmlsaXR5IGFwaVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvVXNlcl9leHBlcmllbmNlL1VzaW5nX3RoZV9QYWdlX1Zpc2liaWxpdHlfQVBJXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbiB8fCBkb2N1bWVudC5tc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaCgnaGlkZGVuJywgbmV3IGV4LkhpZGRlbkV2ZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoXCJXaW5kb3cgaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ3Zpc2libGUnLCBuZXcgZXguVmlzaWJsZUV2ZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoXCJXaW5kb3cgdmlzaWJsZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIGluIGZhdm9yIG9mIHZpc2liaWxpdHkgYXBpXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHtcbiAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goRXZlbnRUeXBlW0V2ZW50VHlwZS5CbHVyXSwgbmV3IEJsdXJFdmVudCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKEV2ZW50VHlwZVtFdmVudFR5cGUuRm9jdXNdLCBuZXcgRm9jdXNFdmVudCgpKTtcbiAgICAgICAgICAgIH0pOyovXG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FudmFzRWxlbWVudElkKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIHRoaXMgd2lsbCBzZXQgdGhlIGFudGlhbGlhc2luZyBmbGFnIG9uIHRoZVxuICAgICAgICAgKiBjYW52YXMuIFNldCB0aGlzIHRvIGZhbHNlIGlmIHlvdSB3YW50IGEgJ2phZ2dlZCcgcGl4ZWwgYXJ0IGxvb2sgdG8geW91clxuICAgICAgICAgKiBpbWFnZSByZXNvdXJjZXMuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QW50aWFsaWFzaW5nXG4gICAgICAgICAqIEBwYXJhbSBpc1Ntb290aCB7Ym9vbGVhbn0gU2V0IHNtb290aGluZyB0byB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNldEFudGlhbGlhc2luZyA9IGZ1bmN0aW9uIChpc1Ntb290aCkge1xuICAgICAgICAgICAgdGhpcy5pc1Ntb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcbiAgICAgICAgICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xuICAgICAgICAgICAgdGhpcy5jdHgud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XG4gICAgICAgICAgICB0aGlzLmN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcbiAgICAgICAgICAgIHRoaXMuY3R4Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUmV0dXJuIHRoZSBjdXJyZW50IHNtb290aGluZyBzdGF0dXMgb2YgdGhlIGNhbnZhc1xuICAgICAgICAgKiBAbWV0aG9kIGdldEFudGlhbGlhc2luZ1xuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdldEFudGlhbGlhc2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgdGhpcy5jdHgud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IHRoaXMuY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCB0aGlzLmN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGVudGlyZSBzdGF0ZSBvZiB0aGUgZ2FtZVxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBzdXNwZW5kIHVwZGF0ZXMgdW50aWxsIGxvYWRpbmcgaXMgZmluaXNoZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9jZXNzIGVuZ2luZSBsZXZlbCBldmVudHNcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnVwZGF0ZSh0aGlzLCBkZWx0YSk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhYS5hbmltYXRpb24uaXNEb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBpbnB1dCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggdXBkYXRlIGV2ZW50XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKGV4LkV2ZW50VHlwZVs1IC8qIFVwZGF0ZSAqL10sIG5ldyBleC5VcGRhdGVFdmVudChkZWx0YSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgdGhlIGVudGlyZSBnYW1lXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gZHJhdyB7bnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgZHJhdy5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdMb2FkaW5nQmFyKGN0eCwgdGhpcy5wcm9ncmVzcywgdGhpcy50b3RhbCk7XG4gICAgICAgICAgICAgICAgLy8gRHJhd2luZyBub3RoaW5nIGVsc2Ugd2hpbGUgbG9hZGluZ1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZHJhdyh0aGlzLmN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgLy8gdG9kbyBuZWVkcyB0byBiZSBhIGJldHRlciB3YXkgb2YgZG9pbmcgdGhpc1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBhLmFuaW1hdGlvbi5kcmF3KGN0eCwgYS54LCBhLnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZwcyA9IDEuMCAvIChkZWx0YSAvIDEwMDApO1xuICAgICAgICAgICAgLy8gRHJhdyBkZWJ1ZyBpbmZvcm1hdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZvbnQgPSBcIkNvbnNvbGFzXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5kZWJ1Z0NvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmlucHV0LmtleWJvYXJkLmdldEtleXMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoa2V5c1tqXS50b1N0cmluZygpICsgXCIgOiBcIiArIChleC5JbnB1dC5LZXlzW2tleXNbal1dID8gZXguSW5wdXQuS2V5c1trZXlzW2pdXSA6IFwiTm90IE1hcHBlZFwiKSwgMTAwLCAxMCAqIGogKyAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KFwiRlBTOlwiICsgdGhpcy5mcHMudG9GaXhlZCgyKS50b1N0cmluZygpLCAxMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc29yc1tpXS5wcm9jZXNzKHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksIHRoaXMuY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY3R4LmRyYXdJbWFnZShjdXJyZW50SW1hZ2UsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyB0aGUgaW50ZXJuYWwgZ2FtZSBsb29wIGZvciBFeGNhbGlidXIgYWZ0ZXIgbG9hZGluZ1xuICAgICAgICAgKiBhbnkgcHJvdmlkZWQgYXNzZXRzLlxuICAgICAgICAgKiBAbWV0aG9kIHN0YXJ0XG4gICAgICAgICAqIEBwYXJhbSBbbG9hZGVyPXVuZGVmaW5lZF0ge0lMb2FkYWJsZX0gT3B0aW9uYWwgcmVzb3VyY2VzIHRvIGxvYWQgYmVmb3JlXG4gICAgICAgICAqIHN0YXJ0aW5nIHRoZSBtYWlubG9vcC4gU29tZSBsb2FkYWJsZSBzdWNoIGFzIGEgTG9hZGVyIGNvbGxlY3Rpb24sIFNvdW5kLCBvciBUZXh0dXJlLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICAgICAgdmFyIGxvYWRpbmdDb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXIud2lyZUVuZ2luZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBsb2FkaW5nQ29tcGxldGUgPSB0aGlzLmxvYWQobG9hZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdDb21wbGV0ZSA9IGV4LlByb21pc2Uud3JhcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgZ2FtZS4uLlwiKTtcbiAgICAgICAgICAgICAgICAvLyBNYWlubG9vcFxuICAgICAgICAgICAgICAgIHZhciBsYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdmFyIGdhbWUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiBtYWlubG9vcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnYW1lLmhhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1haW5sb29wKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0aW1lIHRvIGNhbGN1bGF0ZSB0aW1lLWVsYXBzZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGFwc2VkID0gTWF0aC5mbG9vcihub3cgLSBsYXN0VGltZSkgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZXMgaXNzdWUgIzEzOCBpZiB0aGUgZ2FtZSBoYXMgYmVlbiBwYXVzZWQsIG9yIGJsdXJyZWQgZm9yIFxuICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIHRoYW4gYSAyMDAgbWlsbGlzZWNvbmRzLCByZXNldCBlbGFwc2VkIHRpbWUgdG8gMS4gVGhpcyBpbXByb3ZlcyByZWxpYWJpbGl0eSBcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb3ZpZGVzIG1vcmUgZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiB0aGUgZW5naW5lIGNvbWVzIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byBmb2N1c1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxhcHNlZCA+IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxhcHNlZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2FtZS51cGRhdGUoZWxhcHNlZCk7XG4gICAgICAgICAgICAgICAgICAgIGdhbWUuZHJhdyhlbGFwc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRpbWUgPSBub3c7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIkdhbWUgc3RhcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmdDb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIEV4Y2FsaWJ1cidzIG1haW5sb29wLCB1c2VmdWwgZm9yIHBhdXNpbmcgdGhlIGdhbWUuXG4gICAgICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiR2FtZSBzdG9wcGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBzY3JlZW4gc2hvdCBvZiB0aGUgY3VycmVudCB2aWV3cG9ydCBhbmQgcmV0dXJucyBpdCBhcyBhblxuICAgICAgICAgKiBIVE1MIEltYWdlIEVsZW1lbnQuXG4gICAgICAgICAqIEBtZXRob2Qgc2NyZWVuc2hvdFxuICAgICAgICAgKiBAcmV0dXJucyBIVE1MSW1hZ2VFbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNjcmVlbnNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5jYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgcmVzdWx0LnNyYyA9IHJhdztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3cyB0aGUgRXhjYWxpYnVyIGxvYWRpbmcgYmFyXG4gICAgICAgICAqIEBtZXRob2QgZHJhd0xvYWRpbmdCYXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY2FudmFzIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSBsb2FkZWQge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIGxvYWRlZFxuICAgICAgICAgKiBAcGFyYW0gdG90YWwge251bWJlcn0gVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGxvYWRcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZHJhd0xvYWRpbmdCYXIgPSBmdW5jdGlvbiAoY3R4LCBsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkaW5nRHJhdykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ0RyYXcoY3R4LCBsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAvIDI7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCAvIDM7XG4gICAgICAgICAgICB2YXIgeCA9IHdpZHRoO1xuICAgICAgICAgICAgLy8gbG9hZGluZyBpbWFnZVxuICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAvLyA2NCBiaXQgc3RyaW5nIGVuY29kaW5nIG9mIHRoZSBleGNhbGlidXIgbG9nb1xuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBeUFBQUFFc0NBWUFBQUE3TGRjNkFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWmRFVllkRk52Wm5SM1lYSmxBRkJoYVc1MExrNUZWQ0IyTXk0MUxqZW5oSjNNQUFBNlkwbEVRVlI0WHUzZFVhZ2tXWjNuY1VFRVFZU2lSWEJkbWkyS2RSVVp4Z0paaG1WOXFPZG1rV0pZbG1ZWWhrS1djV2NmcEVEUUZ4OUsyTzRGbTZVYVZob2FoaTRHRjJ3V2gxcG5ZYXdIb1h6eHBWdTZHaW1hdHFuaTBrcFRpR0xoZ3krKzNQbjlNazZra1hsUFpwNFRHU2ZpUk9UM0EzOWFxMjVFbk1pNkdmSC9aY1NKL0JBQUFBQUFBQUFBQUFBQVlBdy8rOW5QTHFsdXFPNnJyb2MvQmdBQUFJRGhoTkJ4VjNVZTZtbjRLd0FBQUFBNG5rTEdkZFVkaDQwUU9ycDFKL3dZQUFBQUFQU2pZSEhWNFVJVkN4M2R1aG9XQVFBQUFJQjBEaE9xMjZxekVDNE8xVmxZRkFBQUFBQU9VNGk0ckxycE1CRkN4WVY2NjYyM3p0OTk5OTN6OTk5Ly8veWRkOTdwL3QzdHNCb0FBQUFBaUZOd2FFUEhneEFrb3RXR2p0Lzg1amVyK3ZXdmY3MzlNOXgrQlFBQUFPQWloWVgyc2JuZEoxaGRLRi9oT0RzN1c0V05ObmkwOWZqeDQrN1BQZ2lyQmdBQUFJQ0dnc0xCMFBIem4vOThaK2pvbG4rdXM5ek5zQWtBQUFBQXAwemhZTjlqYzFmbE1PRXJHaytlUEltR2plM3l6MjJ0NDNMWUhBQUFBSUJUbzBCdzhMRzViNy85OXZsNzc3MlhIRHE2eGUxWEFBQUF3SWxURURqNDJOdzJkSHp3d1FmUllKRmFYazludlRmQ0VBQUFBQUFzbVpyL3JNZm14c0pFYmptOGJHM2pVaGdPQUFBQWdLVlJ3OS9yc2JsRGxhK2dkTFp6Tnd3TEFBQUF3RktvMFQvNnNibERGYmRmQVFBQUFBdmxCbDgxeUdOemg2aGYvZXBYM1cxN2dqdTNYd0VBQUFCenBxWis4TWZtRGxXK3Jhc3pqanRoeUFBQUFBRG1STTE4MGNmbURsV2UwTjRaMC9Vd2ZBQUFBQUMxVXdNLzJtTnpoeWhQYU8rTTdXbllEUUFBQUFDMVV3UHZ1UjNkaG41ZFF6ODJkNmppOWlzQUFBQmdodFM4UjhOSGphR2pMVTl3M3hydjFiQTdBQUFBQUdxbHhuMGpmUGhxeDFoUHNEcW1QTWJPdU0vQzdnQUFBQUNvbFJyM0MrR2pocmtkS2VYdkYrbU0vWGJZSlFBQUFBQTFVdE0rMi9EQjdWY0FBQURBaktoaG4yMzRjUG43UmpyamZ4QjJDd0FBQUVCdDFMRFBPbnk0L0tXSG5YMjRHWFlOQUFBQVFFM1VyTTgrZlBoTEQ3djdvTG9jZGc4QUFBQkFMZFNveno1OHVCNDlldFFOSDl4K0JRQUFBTlJHamZwRytQQXRUSE1NSHk1L0UzdG5YMjZFWFFRQUFBQlFBemZwbllaOUZUNXEvNDZQWGVYUTFOMFgxYVd3bXdBQUFBQ21wZ1o5TWVIRDlkNTc3M1hEeDkyd213QUFBQUNtcGdaOVVlSER4ZTFYQUFBQVFJWGNuSGNhOVVXRWovZmZmNzhiUHA2cXVQMEtBQUFBbUpvYTg4V0ZEOWU3Nzc3YkRTQjN3dTRDQUFBQW1Jb2E4MFdHRDVjZkc5elp0K3RobHdFQUFBQk1RVTM1WXNQSDl1MVhZWmNCQUFBQVRFRk4rV0xEaCt1ZGQ5N3BCcERiWWJjQkFBQUFqRTBOK2FMRGgvZWx1MytxcTJIWEFRQUFBSXhKemZpaXc0ZnI3T3lzR3o3T3dxNERBQUFBR0pPYThjV0hEeGUzWHdFQUFBQVRVeU4rRXVIanlaTW4zZkRodWh4ZUFnQUFBQUJqVUJOK0V1SEQ5Zmp4NDI3NGVCQmVBZ0FBQUFCalVCTitNdUhENWYzcjdPL044RElBQUFBQUtFME4rRW1GRDI2L0FnQUFBQ2FpNXZ1a3dvZnIwYU5IM2ZCeFA3d1VBQUFBQUVwUzgzMXk0Y1AxOXR0dmR3UElqZkJ5QUFBQUFDakZqWGVuQ1QrWjhQSEJCeDkwdzRmclVuaEpBQUFBQUpTZ3B2c2t3NGZydmZmZTY0YVB1K0VsQVFBQUFGQ0NtdTZURFI4dWJyOENBQUFBUnVLR3U5TjhuMXo0ZVAvOTk3dmg0Mmw0V1FBQUFBQU1UUTMzU1ljUDE3dnZ2dHNOSUhmQ1N3TUFBQUJnU0dxMlR6NTh1TjU2NjYxdUFMa2VYaDRBQUFBQVExR2pUZmhRUFg3OHVCcyt1UDBLQUFBQUdKb2FiY0tINnV6c3JCcytYTGZEU3dRQUFBQmdDR3F5Q1IrcVNQaDRvT0s3UHdBQUFJQ2hxTUVtZktnSUh3QUFBRUJoYXJBSkh5ckNCd0FBQUZDWUdtekNoNHJ3QVFBQUFCU21CcHZ3b1NKOEFBQUFBSVdwd1NaOHFBZ2ZBQUFBUUdGcXNBa2ZLc0lIQUFBQVVKZ2FiTUtIaXZBQkFBQUFGS1lHbS9DaElud0FBQUFBaGFuQnZ0MXB1QWtmZnlyQ0J3QUFBREFrTmRoM09nMDM0ZU5QUmZnQUFBQUFocVFHbS9DaElud0FBQUFBaGFuQkpueW9DQjhBQUFCQVlXcXdDUjhxd2djQUFBQlFtQnBzd29lSzhBRUFBQUFVcGdhYjhLRWlmQUFBQUFDRnFjRW1mS2dJSHdBQUFFQmhhckFKSHlyQ0J3QUFBRkNZR216Q2g0cndBUUFBQUJTbUJwdndvU0o4QUFBQUFJV3B3U1o4cUFnZkFBQUFRR0Zxc0FrZktzSUhBQUFBVUpnYWJNS0hpdkFCQUFBQUZLWUdtL0NoSW53QUFBQUFoYW5CSm55b0NCOEFBQUJBWVdxd0NSOHF3Z2NBQUFCUW1CcHN3b2VLOEFFQUFBQVVwZ2FiOEtFaWZBQUFBQUNGcWNFbWZLZ0lId0FBQUVCaGFyQUpIeXJDQndBQUFGQ1lHbXpDaDRyd0FRQUFBQlNtQnB2d29TSjhBQUFBQUlXcHdTWjhxQjQ5ZXRRTkhpN0NCd0FBQURBa05kaUVEOVc3Nzc3YkRSNHV3Z2NBQUFBd0pEWFloQThWNFFNQUFBQW9UQTAyNFVORitBQUFBQUFLVTROTitGQVJQZ0FBQUlEQzFHQVRQbFNFRHdBQUFLQXdOZGlFRHhYaEF3QUFBQ2hNRFRiaFEwWDRBQUFBQUFwVGcwMzRVQkUrQUFBQWdNTFVZQk0rVklRUEFBQUFvREExMklRUEZlRURBQUFBS0V3Tk51RkRSZmdBQUFBQUNsT0RUZmhRRVQ0QUFBQ0F3dFJnRXo1VWhBOEFBQUNnTURYWWhBOFY0UU1BQUFBb1RBMDI0VU5GK0FBQUFBQUtVNE5OK0ZBUlBnQUFBSURDMUdBVFBsU0VEd0FBQUtBd05kaUVEeFhoQXdBQUFDaE1EVGJoUTBYNEFBQUFBQXBUZzAzNFVCRStBQUFBZ01MVVlCTStWSVFQQUFBQW9EQTEySVFQRmVFREFBQUFLRXdOTnVGRFJmZ0FNSGZuNStmZlVDVUxpeFdoMWIvUWJDWEptMkd4SXJUK2U4MW1rdHdMaXdFQVNsQ0RUZmhRRVQ0QUxJR2E1eW9DaUZiOXBXWUxXVjRJaXc5TzZ5YUFBRUFOMUdCdmhJK0hEeDhTUHBvYUxYejRSTmVjN3hiaEcyRzNBRXpFNzhQbTdaZ21MRFk0cmZyTlpndlpyb1JWREVyckpZQUF3TlRVWUcrRUR6ZmhzZVo4NlRYMWxRK2Y2SnJ6M1NJUVFJQ0orWDNZdkIzVGhNVUdwZFZlYWRiZXkxZkRhZ2FsOVJKQUFHQkthckFKSDZvYWJydnlpYTQ1M3kwQ0FRU1ltTitIemRzeFRWaHNVRnB0bjl1dldxK0UxUXhLNnlXQUFNQlUxR0FUUGxRMWhBL3ppYTQ1M3kwQ0FRU1ltTitIemRzeFRWaHNVRnJ0TVFHa1NQUHY5VGFyVDBJQUFZQ2hxTUVtZktocUNSL21FMTF6dmxzRUFnZ3dNYjhQbTdkam1yRFlvTFJhcm9BQUFBZ2ZiZFVVUHN3bnV1Wjh0d2dFRUdCaWZoODJiOGMwWWJGQmFiWE1BUUdBVTZjR20vQ2hxaTE4bUU5MHpmbHVFUWdnd01UOFBtemVqbW5DWW9QVHFoODFXOGpHVTdBQVlPN1VZQk0rVkRXR0QvT0pyam5mTFFJQkJKaVkzNGZOMnpGTldHeHdXdlZ6elJheUZEdUdhTjBFRUFBWWd4cHN3b2VxMXZCaFB0RTE1N3RGSUlBQUUvUDdzSGs3cGdtTEZhSFZ2OUpzSlFuZmhBNEFjNmNHbS9DaHFqbDhtRTkwemZsdUVRZ2d3TVQ4UG16ZWptbkNZc1ZvRXluamNWRDVSRmlrQ0syZkFBSUFKYW5CSm55b2FnOGY1aE5kYzc1YkJBSUlNREcvRDV1M1k1cXdXRkhhakNlbHY2RHFmanU2NTRnNGVId3AvRmhSMmc0QkJBQktVWU5OK0ZETklYeVlUM1ROK1M1TldBd0FvblNZcUM2QTFFQzdTZ0FCZ0JMVVlCTStWSE1KSCtZVFhYTytTeE1XQTRBb0hTWUlJQkhhVlFJSUFBeE5EVGJoUXpXbjhHRSswVFhudXpSaE1RQ0kwbUdDQUJLaFhTV0FBTUNRMUdBVFBsUnpDeC9tRTExenZrc1RGZ09BS0IwbUNDQVIybFVDQ0FBTVJRMDI0VU0xeC9CaFB0RTE1N3MwWVRFQWlOSmhnZ0FTb1YwbGdBREFFTlJnRXo1VWN3MGY1aE5kYzc1TEV4WURnQ2dkSmdnZ0VkcFZBZ2dBSEVzTk51RkROZWZ3WVQ3Uk5lZTdOR0V4QUlqU1lZSUFFcUZkSllBQXdESFVZQk0rVkhNUEgrWVRYWE8rU3hNV0E0QW9IU1lJSUJIYVZRSUlBUFNsQnB2d29WcEMrRENmNkpyelhacXdHQUJFNlRCQkFJblFyaEpBQUtBUE5kaUVEOVZTd29mNVJOZWM3OUtFeFFBZ1NvY0pBa2lFZHBVQUFnQzUxR0FUUGxSTENoL21FMTF6dmtzVEZnT0FLQjBtQ0NBUjJsVUNDQURrVUlOTitGQkZ3c2Q5MVd6RGgvbEUxNXp2MG9URkFDQktod2tDU0lSMmxRQUNBS25VWUJNK1ZKSHdjU2U4UkxQbUUxMXp2a3NURmdPQUtCMG1DQ0FSMmxVQ0NJRHkvdW52UG5SWmRTMmhiaVhVSGRYOVR0MElteW5LVFhhMzZTWjhMQ3Q4bUU5MHpma3VUVmdNQUtKMG1DQ0FSR2hYQ1NBQUxsSlQ3ekN3M2VqdnF2T0o2MVlZZGpGdXNydE5OK0ZqZWVIRGZLSnJ6bmRwd21JQUVLWERCQUVrUXJ1YWM2d2xnQUNud2szOVZwTmZjOTBOd3k3Q1RYYTM2U1o4TEROOG1FOTB6Zmt1VFZnTUFLSjBtQ0NBUkdoWGM0NjFCQkRnVktpcEh6U0EvT2hySHo3LzZiYytkckFldnZUTStTOWUvdVRlZXZ6ZFQ2MnFzLzc3WWRpRGM1UGRiYm9KSDhzTkgrWVRYWE8rU3hNV0F3YWpYNnN2cVo1WHVYSDE3NlBya1dvWC8xMzdjMTdHeTM0aHJLNTZHcXYzOTZ0aDdPMSt2S25hNVhlcTJleHZHR095c05qaWFWZjk3NWRxa0FDaTlYeEI1ZCtYRjd6T1VMdk01bmNNODZMZnBTc3FIL05lVjhXT2RlMHg3aFdWZis1S1dQUTBxS2xmQjVBSEwxNDYvKzMzTHUrc1AvN3dzK2ZuLy96NVVlc1BQL2pNYW14dGhXRVB5azEydCtrbWZDdzdmRmg0MHljTGl3Rzk2ZGZJVFZIYmZBL042NnptQktaeGZFTDFuTW9uMW4waG93K2Z0TDNlNThMbXFxRHhFRUFpdEtzNXYrKzlBNGlXZGNEMTc4VytFSi9LNjZqdWR3enpvTjhiL3k3Mk9jNmYxaFZBTmZYckFPS3JEckVRTUhXMTR3dDFPUXg5RUc2eXUwMDM0V1A1NGNQOFJtL2U3Mm5DWXJPblhmRW5NbTdnY2owZlZqRXBqY09OYmU3NEp6dW9hOXQrdmYwcDdCQk5VU28zL1A0azl4TmhHS1B3OXNKMi9XbmZXUHk2dXZFZmRWOWp3amlTaGNXSzBPcHpqbTlGM3g5ZWY3T1pKTmxqMFRMK25TdjUvdks2SGU1citCMmI5WGxMUThwNmo4aVh3cUtEMDdvSC83M1V6L2xEcHF4L295MEVrTnJLdDJ5MVkxUmREME0vbXB2c2J0Tk4rRGlOOEdGK296ZnY5elJoc1VYUTd2aGttdXRSV0h4U0dvZWIrUndPSzZOZkZkQTIvUW5ZbUkxNGpQZjlHMkZJeFdnYkRsbit0TGhQc0IyS3R6MXBTTmIyQ1NBUlhuK3ptU1RKWTlIUGxnNGUyMnI0SFp2MWVVdERXbXdBMGMvME9hOXVPN2tBNGlkZ25iczgzeUlXQUtZdTN4cldqbEUxeUpPdzNHUjNtMjdDeCttRUQvTWJ2WG0vcHdtTExZWjJLV3YvZytMTjdEN2F2ajlkeXZYVnNQZ290RDAzNDMxZTIyTEMwQWFuVmZlOXphQWtqMmVTVDZxMVhRSkloTmZmYkNaSlNxTTM5WHZNVnhnbm1TZWk3V2J0ZDFpc0doclNJZ09JL3Q0ZndBemg1QUxJK3ZHNm51Y1JDd0JUMXk5Zi9mUnFmS0dPbm9qdUpydmJkQk0rVGl0OG1OL296ZnM5VFZoc01iUkxmWnA1ZndJNDJXMEkybmJXdjVtTWRqRFh0bno3VWU3Vm1WR0VJUTVHcTJ5dmVOVEt2NmVqTjRqYUpnRWt3dXR2TnBQa1VLUG5lVVZUWG1sclRYSTFSTnVjOVhsTFExcGNBTkhmRFhrc0pJRFVWcjkvL2NwcWZLR2VocUgzNGlhNzIzUVRQazR2ZkpqZjZNMzdQVTFZYkZHMFc3a25BM3NsTEQ0cWJkZTNXK1J3Z3pES3JWZmFqc1BjbUxlQ1pBbkRISVJXMStkM1pncWpoeEJ0andBUzRmVTNtMG15cjlITFBRYU1ZZFNyd3RyZXJNOWJHdEtpQW9qK2ZPZ1BZZ2dnTlpZZjc5dU9VM1UxREQrTG0reHUwMDM0T00zd1lYNmpOKy8zTkdHeHhkR3U5WGxDMGRpTlhaK0o1NlBjZXFYdDFOZ1ViUWhEUFpwVzVWdXU1bVMwRUdyYUZnRWt3dXR2TnBOa3JFWnZTS045S0tOdHpmcThwU0V0Sm9Eb3o0YVk4N0dOQUZKanZmSHRqNi9HR09wbUdINFNOZGlYVlBjN0RUZmg0MDkxY3VIRC9FWnYzdTlwd21LTG8xM3IwMVNPZXBEVTluSnZiUnBsZk5wT3pVM1JXaGp1MGJTcXVRVVFlek1NdnpodGl3QVM0ZlUzbTBrU2EvUnltOVlwdkJDR1c1UzJNK3Z6bG9hMGlBQ2kvOS9uRnVZVW81NWJKNmRtZmhZQnBPOFhFcXJCZHZoNDBHbTRDUjkvcXBNTUgrWTNldk4rVHhNV1d5VHRYcCs1QzZNOEgxL2J5VDNRai9LcHQ3WXhpL0JoWWNoSDA2cm1HRUJzbE50a3ZKMW1jMm5DWWtWbzlUbkh0Mm9EaVA1LzlWY1lPNHJQQ2RFMlpuM2UwcENXRWtDRy9tNmpGZ0dreHRyK1FrTFZwYkFMTzZuQkpueUVJbnhzOGh1OWViK25DWXN0a25iUHR6amx6bUVZNWJHODJrN1d2NU1Vdi9WSzJ4Z3lmRGd3K1hHOVBqRzd3WStlY1BYbkRtTCtlMS8yOS9hVC83M0NLbzZtVlIwYlFEem1kbDg5bWRqcnUvQlFBLzlaK0R2dnEzOCs5L2E3bURGQ0tRRWt3dXR2TnBOa1BSYjk3ejZmTXZ0M3pCK29PTGo0ZCtqQ3Y3di9MUHhkKzE0YTR2ZXJWZlQyVksxLzF1Y3REV24yQVVUL3U4U3RWeTBDU0szMTQ2OS9aRFhPVURmQ0xrU3B3U1o4aENKOFhPUTNldk4rVHhNV1d5enRvaHZDWEVXYmZhMC9kMHpGRDk3YXhsRGh3K3M1NmlxU2xuY2o1WlBoM2pBU2Z2eG9XbFdmQU9JQTRXYXdkd0RRc3UwWEhPYUc1SzdpOStsckd3U1FDSysvMlV5UzFWajAzNXdQUlJ3Zy9Ob2Y4enZtWTgwUTM5dmpNUmQ3VXFEV1Bldnpsb1kwNndDaS8rYk1SL1R2azQvUEYvWkJmOVoreU9Mald2Y0RKUUpJcmZYd3BXZFc0d3gxTit6Q0JXcXdDUitoQ0I5eGZxTTM3L2MwWWJGRjAyN21ub0I5SUM1eXN2VjZWVGtOcDhkUzlGTnVyVC8zNUJuamRReittbW1kUHBsRmY2ZkRqeHhOcTBvTklQNTM4NGwzMFAzMCtsVEhCTUNxZmovQ1lrVm85VG5IdHhvRFNNcXhhQlU4VmhzWmlOYm5xeTVaNTRhSVl2TkJ0TzVabjdjMHBMa0hrSlR4K3hpVmZhelJNZzdCbzh3bHFrYW5vVi9kNWhSci9HdXByY2Z4dXFLM1lhbkp2dHR0dWdrZmhJOXRlcVBmVXlVTGl5MmFkalBuMDUxV2tRT20xcHQ3b3FydGFzdzJOMVJGRzJEVE5pNEVrZkJYUjlPcURnVVEzeGM5eG4zd2ZlY0ZGRDI1YS8wRWtBaXZ2OWxNRXY5c3ludk43NmVTVnhxT3ZjMm15SzFZV3Urc3oxc2EwdHdEeUw0UHhmeDNvMy8vMEt4MUcvcFkwMTlicGR5R3BVYjdWcmZ4L3ZXdmZ4MXQwSmRjaEkvOWRLQzR0enBrSkFxTExaNTJ0VTl6TjJoajdmVTFxMDFXdW9IcUU4eGFYbTZLTHl6enYrTnF6T0dQanFaVjdRb2dQdkdPdW8vYVhtNGpZNzhMaXhlaDlSTkFJcnorWmpOSkhHSVBYZmtjNnhIYnZoclM5MzFmNURYMWVwdlZwd21MVlVORG1tMEFVZTBMeHY3N1lvRjRzVHJOZkxUaHI2MjJic09LUGcxTHpiWnZ3WHJhTnQrUEhqMktOdWxMTGNMSFllR0FrU3dzZGhLMHUxbXZqUXg2c3ZYNm10VW1jWU5RK3RhYTNOZWo1YkZOOW9tWXR1M2dOTmkvamRZVkN5QnVLQ1k1OFdxN2ZmNWRTalkwQkpBSXI3L1p6Q0RHRHJySGhKREJmOWUwenF6WE1peFdEUTFwemdGazEyMkJyNGRWSWxlbm1ZODIvTFZWNUdsWWw4T3ViRkRUdmI0Szh0WmJiNTNNVlJEQ1J4b2ROTzQxeDQ0MFliR1RvTjMxRllqY2srNGdKd3F0Si9kV3AxcHZ2ZkludWNWdnVScVQ5cWNiUUNhLzNjRGJYNDBrVDdGSDhucmR6U2JTaE1XSzBPcHpqbTl6Q1NDalgwazBiYmZQNzVrTi9ycDZuYzJxMDRURnFxRWh6VFdBN0xvcTUrTThWejc2NmpienNZYS94dnJwdHo2MkhyUHFkdGlWRFdxOFQrNHFDT0VqblE0YTkxYUhqL2txK3QwR1huK3ptV1JIUDVaWDY4aWRlRjY2Y2VwNzYxWHhxekpUMEQ2MUFhVG8vZmM1Tkk3Y1NlbkZmbWUwYmdKSWhOZmZiT1lvazRTUGxyYmZkMDdJMExlblpyMldZYkZxYUVoekRTQXhpenpPajZyVHlFZWIvUnJybDY5K2VqMW0xVlBWcnNub0czTkJuang1RW0zY2wxQ0Vqenc2Y054YkhVTG1xL2lYcTJrYnVWKzJkRlNUb09WelRrN0ZELzVhZis3SjBqeXVSVTVFMUg0NWdJeHkvMzBxalNmN0NsVllkSEJhTlFFa3d1dHZOdE5iOFVjb3A5QTQrdXpIb0E4KzBQcXl4aEFXcTRhR3RLUUFNc3FYOFM1YXA1R1BOdnUxMXRaazlKdGhkeTVRSTM3V051WHZ2UE5PdEhtZmV4RSs4dW5nY2E4NWhzeldHQUVrOTlZRE45KzlQaG5YY3JrVHowdmZldFgzNmdjbnBaSHBOYy85ZHlyMWhDSUNTSVRYMzJ5bUYxOFJyZVZxVzU5YlV3ZDk4SUhXbC9WYWhzV3FvU0V0SllBVWZjK2NqRTRUSDIzMGE2MWZ2UHpKOWJoVloyRjNMbEF6ZnIzYm5QL3FWNytLTnZGekxjSkhQejZBTk1lUjJTb2VRTXpiYVRhWHJOZTR0RnpPdjBmeGc3KzJrYnZmZGxyUGNLK0VYdmZjMjdDS05EVmFMd0Vrd3V0dk50TkxzUWEwRDQybnozRmhzQThsdEs2czF6SXNWZzBOYVNrQmhGdXZqcVhHL1ZLbmlZODIrclhXSDMvNDJmTWZmZTNENjdHcmRuNHp1cHJ5KzIyRC92YmJieTltUWpyaG96OGRRTzQxeDVIWkdpdUE1TTdMc0t5RHMzNCs1ellhZndKWi9PQ3ZiZVR1Y3pXZjFKNGF2ZTY1OStjWGVlOTR2YzNxMDRURml0RHFjNDV2dFFhUTZqNWwxcGg4UE13MTJBY1RXbGZXYXhrV3E0YUd0SVFBVXNVdGdiT25wdjFhMjhCN1luZXMwYSs1TXE2Q1hGYXRKNlMvOTk1NzBZWitUa1g0T0k0T0luMFBQclVZSllDWXRyWHIreDkyU1g0c29YNDJOK0FVbjRPZ2JmUjU4dFdrazJSUG1WNzczTjlQQXNpbVdnTklWVmMvV2hwWDdoVzNveC9RMGRLNnNsN0xzRmcxTktRbEJCQytiSEFJYXRwbkhVQWlWMEZ1aFYyN1FBMzZ4b1QwT2QrS1JmZzRuZzRpZlE4K3RSZ3RnSmkyVitRMkYvMWN6Z2xwbEU5RXRaMWR6M3ZmWmJBR0EvbjArdWQrS2wzRnQvZUh4WXJRNm5PT2J6VUdrT3F1ZnJRMHRqNlA1UjNrcXEzV2svVmFoc1dxb1NITlBZQzhHUmJIc2RTd3p6cUF1TGF1Z3V4OElwYXBVWC9RTnUxei9XNFF3c2N3ZENEcGMvQ3B5ZGdCSkhkUzlzRUR0WDRtWjFMbldMZGU5Ym5GZ3FzZkV3di9EcW1LTkxkYUx3RWt3dXR2TnBPbDZ2ZVV4cGQ3aStZZzgwQzBucXpYTWl4V0RRMXA3Z0drcXFjQXpwcWE5ZGtIa01oVmtPajNncGlhOWF1cTlhMVljM3NxRnVGak9EcVE5RG40MUdUVUFHTGFadTZ0U1h1YkNQMTl6cFdHVVE3ODJzN3p6ZWFTY2ZXakF2cDN5QW5IQkpCTk5RYVFxdWRUYVh5NVY0UUhPVjVyUFZtdlpWaXNHaHJTM0FNSXQxOE5SYzM2N0FPSTYvRjNQN1hhaDA1ZERidDRnWnIybTkwbWZpNWZVRWo0R0pZT0pQZWE0OGxzalI1QVROdk5DUTA3SjJicnozUHUyeC90ZGd4dEs3ZXg0TWxYRmRDL1E4NzdtUUN5cWJZQU10cjd2UytOTWZlRGlrSDJ5ZXRwVnBjbUxGWU5EV25PQVlRUG00YWtSbjBSQWNUMWsyOStkTFVmb2U2SFhZeFM4MzYzMjh6WFBoK0U4REU4SFV4eUR6NjFtU3FBNUQ0TFB6cE8vWG5xTFF5ajNIclYwclp5YjYzZ0U3RUs2TjhoNS8xTUFObFVXd0NaNU5pV1EyUE0vZDZpUVpwWHJTZnJ0UXlMVlVORG1uTUFTWDY0Q2hLb1VWOU1BUG50OXk2djlxTlQrNzZjOEpKcVl6N0lCeDk4RUczK3B5N0NSeGs2bU54cmppbHB3bUlRdlJ3NWp6MTFnTmk0Q3FML24zTVNHdTJlVzIxcmtxWUM2ZlNhKzhxWmJ3WDA3NUN2VnZsOW5CT0lqUUN5cWJZQVVxenBIRklZYTdLdzJGRzBtbG1mdHpTa09RZVE2b1B4cktoSlgwd0FjVDE0OGRKcVgwSjVRdnJsc0tzWHFKSGZtQS95ODUvL3ZLcEo2UjZMNTZpMDR3dEYrQmlJRGlaWkI1K3dHQUs5SkRtdjMvcTU2ZnJmT1ZkUWlqWkcyN1M5M0RrdVBBKytBTDJ1UTRTTWZRZ2dtMm9MSUxQNFBoMk5NM2UvanI2U3EzVmtiVE1zVmcwTmFjNEJaQmJCZURiVW9OOW9HL1kzdnYzeGFGTS9wNHBNU0Q5MEs5Ykd0NlRYRWtJOEJvK2xPellWNFdOQU9waGtIWHpDWWdqMGt1UStpbkoxOHRWL1UrZVFqSHJybFdsN3VTZEhubjdWazE2NzBpRmpId0xJcHFvQ1NGaXNlaHBxN3VPNmoyNWd0WTVadjVZYTBwd0R5S2pubzhWVGczNnJiZGI5T050WVV6KzNldkxhczZ2OTZkVE83d1l4TmZZM3VvMyt3NGNQbzZGZ3JDSjhqRU1IazN2Tk1TVk5XQXdkZWxseVRpWnVNbk1tbm8vK3VFTnRNN2VoWVA3SEFYNk5WTDVsN3dXVjMzTmpoWXg5Q0NDYmFnb2dzL21lQlkxMTlHWmE2NWoxZVV0RG1tMEFDWXRoS0c3TzIwWjlLUUhFOWZDbFoxYjcxS2xyWVplajNPQjNHMzdQdTRpRmc5SkYrQmlQamlmM21zTkttckFZdHVpbGViTjVoWktrTnArVE5DSGFMcjhUUjlMTDR1OVI4Uk9DSE9acUNCc3hCSkJOTlFXUW9tTVprc1pLQU1ta0lSRkEwRkJqdnNnQTRsdXh0cDZLdGZjTENzMk5mcmZ4SHp1RUVEN0dwZU1KQjU4QjZLWEp1YXFSYXBJckMySGJxWmlBM3FIWHc3ZFQ1VjVCbWdvQlpCTUJwQWVOTmJlWlBub1NzOVl4Ni9PV2hqVFhBREtiMzh2WlVGTyt5QURpK3YzclY3Ym5nendJdTcyVEcvNXVBSEFJR1dOT0NPRmpmRDZnTk1lVk5HRXhST2psOGUwMVE1bnNTU05oKzZrNElZbGVCMS90eUgxMDhkUUlJSnNJSUQxb3JBU1FUQm9TQVFRTk5lV0xEU0N1WDc3NjZkVytkZXBnVSsvR3Z4c0VIQXhLaGhEQ3h6UjhRR21PSzJuQ1lvalF5K1BiYm9ab1FpZTcvMXZiOWo3a09Pa1RrdmJmVjc3bUZqeGFCSkJOQkpBZU5GWUNTQ1lOaVFDQ2hocnlSUWNRVjJRK3lONUo2ZVlBMEEwRXBVSUk0V002UHFBMHg1VTBZVEhzb0pjbzl4RzJNWk5ONnRhMmMyOGxPOGx2UU5kK082Z05lY1ZyQ2dTUVRRU1FIalJXQWtnbURZa0Fnb2FiOGJZeFgyb0FjZmtSdysxK2hyb1JYb0tkSEFTNndXRG9MeXNrZkV6TEI1VG11SkltTElZOTlESWRNd2Rnc2x1dlROdlBEU0NUam5jSzJtZUhqNXlIRHBUZzk2MS96OXpJK1BZdi83dDVYRG52WndMSUpnSklEeG9yQVNTVGhrUUFRVU9OK0RxQStJc0kvVzNpZi9qQlo2Sk4vSndyTWluZGxSSkNiblVEZ2tQSTJkbFpORkRrRk9GamVqNmdOTWVWTkdFeDdLR1hLZmMycHE1SnYzeE0yeWVBN0tIOTllTjB4M2lxbGJmaDk2WWYyN3dSTXNKUW92VDNPZTluQXNnbUFrZ1BHaXNCSkpPR1JBQkJRMDM0M2EybWZGME9KTDU5eWQrcjRRWSsxdGpQcWJ3UFAvNzZSN2IzTXlXRWJIeFBpT3VZSjJRUlB1cmdBMHB6WEVrVEZzTWVlcG44ZlE5OVRYcExrN1pQQU5sQisrcGdPWFQ0OEpXVU5tVDQ5cjJqR2cwdG4vTitKb0JzSW9EMG9MR08za3hySGJNK2IybElCQkEwMUlEZjMycklkNWF2SUxTQkpOYmd6NkVpVDhaeXBZU1FxNnFubmNDd0NoRzV0MlFSUHVyaEEwcHpYRWtURnNNT2VvbHl2eGs5cHRqSjVoQnZ1eGxDc2xNS0lFUGNkdVYxdVBrbzhtK3M5ZWE4bndrZ213Z2dQV2lzQkpCTUdoSUJCQTAxMzFkVjExVytGZXVPS2ptUWVGNkZuekkxdDZzalI0U1FTNm9IbmVDd3VpWHI4ZVBIMGJDeFhZU1B1dmlBMGh4WDBvVEZzSU5lb2lHYVZEOVZhWkpic2JUZDNBQnlFaWNrN2VjeEU4Nzk3K21HNDBwWVhUSGFSczc3bVFDeWlRRFNnOGFhTytlTkFFSUF3U0ZxeUIxTWJxaHVxeDZvenZmVmd4Y3Z6ZXJLU044UVlnb050N2RDeFBuRGh3L1Bueng1RWcwZUxzSkhmWHhBYVk0cmFjSmlpTkRMazN0UzJXZVNXN0cwWFFMSUZ1MWozNnRhdmwzcitiQ2FVV2g3T2U5bkFzZ21Ba2dQSG1zejVHUkhCM0d0WTlibkxRMkpBSUk4YXM0dnFYeWx4RmRKemxUbnNmSWNDejlOYXc1WFJYYUVrS1JRb1BCd1RYWFdDUk9yZXZUbzBTcHNFRDdxNXdOS2MxeEpFeGJERnIwMHVZMTdpbUlublYyMHpkd0o5S2NRUUxMZUk0RS9GUjc5S3BhMm1UTldBc2dtQWtnUEdtdlc5K0NFeFk2aTFjejZ2S1VoRVVCd0hEWHF2a0xpcXlQUk1PTEczbGRGYW4raTFvNm5ZL2sydEV0aFYzZFNpUEF0V1J1UDZuVzkvZmJiNSsrLy96N2hvM0krb0RUSGxUUmhNWFRvWlhIVFh1TEw2Q2E1RmF2WmRMcXcyQ0pwOS9wYy9YZ2xMRDQ2YlR2bi9Vd0EyVVFBNlNHTU45WHZ3bUpIMFhwbWZkN1NrQWdnR0k2YTlXc3FYeGs1ajFYdFFXUkhDUEZ0WjFmREx1NmxRQkc5R3VMYnNnZ2Y5ZklCcFRtdXBBbUxvVU12aTU5aWxNb25ucHl3TXZxdFdOcG03cE9lSm4xMGNFbmF0NXgvVzV2MEJPM3ROOE5JUWdEWlJBREpwSEZPY3N1bTFwTTFKeXNzVmcwTmlRQ0M0YWxoOTIxYU4xWFJxeUsxQnhHUGIydk1UMVdwODBKOE5jVGZHYkx4cEt5dElueFV4QWVVNXJpU0ppeUdRQzlKemplZnZ4bVc4WGM2NUJqMVZpeHRMK3QzUWthL1ZXd3MycmZjTUZaOG92aysybjdPZUFrZ213Z2dtVFRPM0VlT0QvS0JpdFpUemU5WUh4b1NBUVJsdVhGWFhaaTg3bHV6YXA0ajh2aTduOW9ZYnloL1Y4ckJXN0pNSWVPeWcwWW5kQkErS3VVRFNuTmNTUk1XZytqbHlQMWVpQytFUmIxc3p0T3lScjBWUzl2Sy9kUi9rWS9pMVg3bGZybzcyYTFYclRDT1ZBU1FUVFVGa0VkaHNhcHBuTG5IaXErR1JZK2k5Y3c5Z09RK1ZZOEFnbjdVdVB2MnJBdFhSRHhadmRhblp2bmI0Q09UMDcwUDE4SnVIYVRBNGU4TnVVLzRxSmNQS00xeEpVMVlES0tYSStmeGt4dWYvT24vNXphM285MktwVzNsZmpxM3lKT1M5aXYzZFhndUxEb0piZjlLTTR4a0JKQk5OUVdRV1J4ck5jemN1Vy9yRDJHT29mWGt2amVydWtxcjhXVDlMZ2dCQk1kUjgrNHJJaGVDaUw5THBNYXJJUjZUdndsK2U3d3F6M1ZKdWhwaURpTGhmNkl5UHFBMHg1VTBZYkdUcDVjaTU5WURYeVc1Y0FWRGY1Yjc2ZUVvSjFGdnA5bGNsc1hOQTlFK1piMDNaTkxYUU51ZjVINzhiVm92QVNUQzYyODJrMnlRWnIwVWo2OFpacnF3Nk5HMHFya0hrTnhiT3drZ0dJYWFkMy9ob2VkV25MZmxxdzIxWGczeExWbVJxeUhKYzBOUUx4OVFtdU5LbXJEWVNkUEw0RSthYzA0ZzBlK0MwSi9ucm1lMFc3R2F6V1VaOWZzdXhxQjl5dmwwZC9KYlpqU0czS2FNQUxLcHRnQXl5TzFLcFdoOHViY1JEZmI2YWwyNXYrdlYzQ2Fxc2VSZXFUUUNDSWFqNXYyeTZzSTNydGQ2TmNRVDUzZGNEZkVjbCtUYnNsQVhIMUNhNDBxYXNOaEowOHVRTTM5ajd3RmJmei9KSk01RHRKMnMzd3RaM0lrcDdGZXF5ZmZmWTJpR2txekltTFZlQWtpRTE5OXNKdG5yWWRFcWFYeTV0MThORnFpMHJ0bk56MnBwTExrUElURUNDTkw4cStmK3grWHdQdzlTOCs0dk50eTRHdUs1SWY2Q3dGZ1FtTHAyWEExeE9Vd1JSR2JHQjVUbXVKSW1MSGF5OUJMa2Z2SjI4S2xJK3BtY1FHUEZieWZRTm5LRGtWVjl5MGdPN2N1c3ZwQlIyODhkcnhGQU50VVdRS3pLV3hzMXJqNjNhUTUyZk5DNmNyZS9lZ0poRFRTV25MbURMUUlJRGxQNHVLVTZELzlObWllaHh0MlA3cjF3TmVTWHIzNDZHZ0ttTGwraGlUeXV0eTJDeUl6NGdOSWNWOUtFeFU2U2RqLzNudWVreS83NnVkeVRhZkZic2JUK1ByY0pWUE1wNDdHMEwxWE1wMGlsN2ZjSmpBU1FUVFVHa0NwdmJkUzRjcHZvUVc5UjFQcjZCTzdKdzV6SDBBd2xHd0VFK3lsd1hBL2hvNjJucXB2aHJ3OVM0Kzd2RDNFVHZ5NDMrckVRVUVQNUtzMk8yN0pjRGlMWHc2NmhVajZnTk1lVk5HR3hrNk5kOTRtajJLTno5Yk81RTlLTDM0cWxiZVJlbWJGRlhBWFJmc3d0Z09UZURtTUVrRTAxQnBEcUhzZXJNZlg1Y0dMd09SaGFaKzVFN3NuRG5NYVFld1c5UlFEQmJnb2FWMFBnNkFhUXRoNm9rcDRFcGFiOXFtcmpTVmx1OG12OXpoQ1hIOW03SjRoNFh6enBQdm0yTkl6SEI1VG11SkltTEhaeXRPdEZuOXV1bjNmQXFlYkpLS2IxOTdsWGVSRW5LTzNIYkFLSXR0M24zOGtJSUp0cURDQlcxVlVRamFmUGZneitCWjFhWis0NEpwMVRvKzMzT2NhM0NDQ0lVN2k0RkVMR0tuRDg2Ly8wUDFmVi92OU8zVllkdkMxTHpicHZ5ZHI0QXNPZmZQT2pWWWNRMTRFZzR2SlZFVCtLT1BrUnZpakxCNVRtdUpJbUxIWlN0TnU1eldpdkU1Mld5NzJOcHVpdFdGNjNxczhKcytxbjk2VFFQdVRlYmpmSko5WGFyditOK2x6OU1BTElwbG9EaU4rRFZjd0YwVGllVzQwb1Q2bmZzOXdQaFd6d0lKUksyKzU3OWNNSUlJaFRxTGpiQ1Jublgveks5OC8vdzMvN2YrZWZlLzdWYnZob0srZHFpTDl2dzQzN3FqejV1OWJKNmQzeUU3Tjg2OWlPeWVwdE9ZejRsak91akV6SUI1VG11SkltTEhZeXRNdTVUYmgvdHZkSlRzdm0zdlpVOUZZc3JiL3ZTWFAydDJLRi9jZ3hlbk9qYmZacHdsb0VrRTIxQmhDYi9JbFlHa1BmRHlTS05NOWFiNTh3Tk1uamVMVmQzN2JXNTdWckVVQndrY0pFTytsOFZYLzIxNitkLzhmLy92L1g1VER5YjY3L3IyNEFhZXRXV01WZW9VbDN3NzZxdVlRUWw2L1llQ0s5cjk1MDl5RlN2azNMWWN0WFIvalN3aEg1Z05JY1Y5S0V4VTZHZGpsM3N1VlJuLzVyK2R5ckxWYnk1TlMzNmZBeXN3NGh6VzVrR2JXNTBmYjYvSzUwRVVBMjFSeEFiTkpic2JUOVBrOXZLdmFhYXQwK051VTY2Z09pdnJUTlB2UHB1Z2dnMktRUXNUSHAvTi85bDFjMndrZTNQdjlYZjk4TkgyM2RWNlhja3VYRzNJMzZxdVlVUXRyeVZaR0hMejJ6ZXNSd2QxLzJsSytRM0ZaNS9zZzFGY0drQUI5UW11TkttckRZU2REdTVuN0NOc2lqSHJXZTNFKzFTOStLMWZjcWlNYzEyUzBQeDlMWXM5NGI0dVptbEZ0bHRCM2ZJbmJNSjZwR0FObFVld0N4NThMcVJxWHQ1ajRrbzFXc2NUYXR2MDlqUCtyVkpHMnY3MnZYUlFEQm55ZzRiRXc2OTFVTzMzWVZDeDl0L2Z2LytuL1BuLzN5ZDdaRHlKbnFZSE90Qm56MklhUXRoeEYvbjhpQitTTFJDaThIQnVJRFNuTmNTUk1XV3p6dGFwOUw1b044NHEvMTlMbnFVT3hXTEszYjQrazd6OEQ3TWVtVkVHOWZsZjM2ZUJsVnJqR2VUalpFK0RBQ3lLWTVCQkQvdXhkdDZyZHBlMzBiNk9MTnFyYlI1L0hUTnNyVkpHMm43L2kyRVVEUVVHQzRNT244TC83Mkg2T2hZN3NjVW55bHBGMDJsSVBNamJENm5kU0FYd2dodFU5TVR5bFBYdi9GeTU5Y0JaSUQ4MFlJSUFQekFhVTVycVFKaXkyZWRqWHJkWkZCRzArdHI3WnZ5ejNtZGg4M1RaUGNQcUx0dHMxdzlvbFR5L1M1eDl5SzdhdldQVlQ0TUFMSXBqa0VrTlpZRGZReG45NFgvK0JCMi9BSFJYMFZmUTIxL3I1WGptTUlJR2dvTEZ5WWRCNExHL3ZLYzBXNjZ3aDE4RHREMUlSdmhKQTVQQjBydDN5RjVNbHJ6NjVDeVJ2Zi92aDZYMVgzdzh1QWdmaUEwaHhYMG9URkZrMjdtZnVwbFJ2Q3dXKzkwVHF6L20yazlLMVl4MHg0TnQ5RFB0WXRTZzV3M2FzMmZRSkluM3ZNVzRNM04xNm5hbC80OE4vbGhCTUN5S1k1QlJEeis3SEkrMG5yZFdOL3pIaEhtdytsYmZXWm05SXE4VDcxY2VQUW1ISS9SQ0NBNFBDazg1enlMVm1SeC9YZUNadmFTWTM0aFJBU2ErU1hVTDQ2MHRsWEFzakFmRUJwaml1TDB2c2dxV1g3Zk1KYzVMNXNyZGRqeVZYNnFWakhUcWIwYStzR3RVUmc4NGwvTzNpMGV2MU9hTGxqUGdFZXBBblRlbEtiUWIrdU9lOW5Bc2ltbWdLSWY0ZFRqa1ArdWNHYWFLM0w3eUgvKytVZUE3c0dtUXVYU3RzNzltRU1nMzB3b3ZYNHFtbnMrTlBsdjg5Nmp3Z0I1TlFwSENSUE9rOHQzN29WZVVwV1NnalplRHBXemQrWWZrd1JRTXJ5QWFVNXJpektNUUVrdDhFdTNiVDB1ZXBROG1UVloyN01MbTd1anc1dlhrZFkxNzV4OWZwMzBuTEhOamU5RzBRdDUyMm5CcUJWMDZmLzVyeWZpL3p1YXIwRWtBaXZ2OWxNRXY5c3p1dTQrajFUOVdxa3RaemYxOGNHRC9QeVV6eGw2dGp6bU1mdC9lODFkaTNuMXo1MURINWZFMENRVHFFZ2U5SjVhbms5UFVQSXh2ZUUrSkczc1NaK3prVUFLY3NIbE9hNHNpaDltODNjazRJVlBkbHEvZjVFTXJjcGNETlM3Rlluclh2SWVRam1kZm4zMEsrL3c0UlAwQmZHN3o4TGYrZWY4Yy9tL083MlBuRjYyV1lWUi9FK09reTRVYm5RVE9qUDJuM3ozL3ZuRG4yS3VtMTF2NzMrTzhwcnNvL1dtL1UrQ29zVm9kVlAvbnEwdlA1bU0wbFdZOUYvKzF4eDlIYjhiK0RmcHd2ek1QUm4zZDgxZjhCeDdGWE5ycW1lMHRYbmF2RXVmajNhWTlHKzE4KzM2dnJxU2M2eGNIV0ZXdi9OZW84SUFlUlVLUXowbm5TZVdqc21wNmVFRUQrdTlyeXR1VDRaYTFjUlFNcnlBYVU1cml4SzlrRlN5L2lFa211VSs1eTFIVGNLdVVyZmlqVjBDQ210OTRsVHl3N1ozSlN3L3U0Wi9lK2M5M09SWmtMckpZQkVlUDNOWnBLc3hxTC9Ebm5Gc2JTaWs3b1AwZmFQbmFOV21vUE42b01WL1pjQWdqUUtBa2RQT2srdDNCQ2lwdnlTeWwva2QrN3k5MndzYVZJNkFhUXNIMUNhNDhxaVpCMGs5ZlArUkN2M0UrZEhZZkZSYUh0OS9wMktuYlJNNjU5VENEbnF4S25sY3h1R3Nid1NocmlpLzUvemUxS2ttZEI2Q1NBUlhuK3ptU1Ryc2VoLys1UDQyazBhUGxvYXg1QlhjNGJrNCtUNmFvcitOd0VFaHlrQUREYnBQTFY2aEpDcm5TWjk5ZVNvV0RNL3h5S0FsT1VEU25OY1daU3NnNlIrdnFwNUZqSGFuajhKelZYMFZpelQraDFDY3NQYkZJNCtjV29keHp4dHA0UUwrK1EvYS80cVNaRm1RdXNsZ0VSNC9jMW1rbXlNUmYrL3oxWFFzVlFSUGt4ajhZZEpOWDRvc25HKzBQOG5nR0EvTmY2RFR6cFByVWdJMmZ1SVhqWG5HNVBTL1VWL3NZWitia1VBS2NzSGxPYTRzaWpKQjBuOWJKOVBGemMrZFI2THR0dm5VL2d4dmhqUEovM2FmNCtPUG5GcUhkN1BXajVoOWVzZG15ZVQ4KzlRcEpuUWVna2dFVjUvczVra0Y4YWlQNnN0aExqUnJ5Wjh0RFNtMnE3TVhuaU45R2NFRU95bWhyL1lwUE9VMmpFeGZlK1hGYXBCdjlzMjYvNUNQMytmUnF5cG4xTTVTTFg3cERvNEp3WjVmRUJwaml1TGtuU1ExTS8xK2JUTVAxLzBxc0l1M3E2cXo5V0dVYTdXYUR1ZWxGbmpwNDgyeUlsVDY2a2hoT3dNd1BxN25QZHprV1pDNnlXQVJIajl6V2FTUk1laVA2OGxoUGc5VVB5TEJ2dnkyRlJUWDVuMXNURDZHdW5QQ1NDSVU2TmZmTko1U2tWQ2lBUFIxVERNQzlTZ2V6N0kwN1poOXplTHg1cjZPWlcvakxEZEg5V3RzS3NZaUE4b3pYRmxVWklPa3ZxNVByZlVyQ2Y4VGtIYjczUEZwdml0V0MxdHg3ZUsxZlk3NWZFTStyUXlyVytLQ2E5dWFQYisvdW52YzE1N0FzaW02Z09JNmUrbWJxNUgrNUxCWTJpY1UxNlpkVURiZWN6UjN4RkFFS2NtZjdSSjU0Zkt3V2ZyeXdyUFZKZkNVQzlRazM2OTA3Q3Z2bEU4MXRqUHBRZ2daZm1BMGh4WEZ1WGdRVkkvay90dDUxYkZ3ZGZqYUlhVHBmaXRXRjNhbnA4cU52WHZscmRmOHNUdE1EaFdJK2g5T1JpaXdzK2xLdkw3clBVU1FDSzgvbVl6U2ZhT1JYL3Y1bnJzRU96SFF4ZDk3SGdKR3JPdkdvMTFaZGJiT1JqUS9ET3JuMDVIQURrRmF1NUhuM1IrcVB5TjZkMHhxZmJPaFZDanZyNFZhKzVQeFNLQWxPVURTbk5jV1pSREorKytqN2FzNHBZRGphUFBoSFFiNVZhc0xtM1RuOVllK3BMQUlUa1F1REViclZIU3R0eE1sQW9pZm44bS83dUZuMDlGQU5rMG13RFMwcy81V0pENlpaVjkrSDA3eStEUnBmRTdzUG4zc3RSeEtPdDEwczhSUUxCSmpmMWtrODRQMVovL3pUOTBBNGhyWnpPdVJ2MnlhbjBybHB2NFdITS9oeUtBQU11Z2s1ZXZHUGdrUFhTejd0c2RIRG9tRFlqYXZ2Y3Y5NHZKWXRwbXB0cDc3RkVYL2E0NGlBd1ZoTnZmditvbW1BOUIrOVVlaDRZSUl6NzIrR3I2SlBNQ3NSQnE2Q2VkZEo1U2tTZGo3WnNQY3F2VHVNOTJRam9CQkZnZW5iRGRNTGtSY05Qa3B2MmVhdC9rYmpkVy9obVhsL0ZKZi9Rck9xazh0akJHTnpyNzlxM2RMLytjZjU3UWdhUG9kOGp2TGQ5MjVGQys3M2ZQRFhqM1BlVmxUdXIzei91cjh2dXVmYTFjdTNSZkt4KzdDQjA0bmhyNUtpYWRIeW9Ib21lLy9KMXVBRGswSDJUOUJZVVBYcndVYmZCckx3SUlBQUFBRmtkTmZEV1R6ZzlWWkQ3STdiQWJGNmhoMzVpUVBzZXJJQVFRQUFBQUxJb2ErT29tblIrcXovL1YzM2NEaUd2ZnJWajMyd1oramxkQkhyNzBEQUVFQUFBQXk2REd2ZHBKNTRkcTYvdEJIb1JkdWtCTis3Vk9Beis3cXlEK0xwUE8rSytGM1FJQUFBRG1SVTE3OVpQTzkxWGtWcXliWWRjdVVPTSsyNnNnQkJBQUFBRE1ucHIxQzVQTzNkREhHdjJhSy9JdDZkRUo2V3JjWnpzWGhBQUNBQUNBMlZPanZqSHAvT3FOL3hOdDhHc3RYNm01OHBjdmQ4T0h5d0hrY3RqRkM5UzhyNStJTmFmdkJTR0FBQUFBWU5iVXBHOU1PdmVFN2xpVFgydjVTczNXbzNoZHZwcXpNM3lZbXZjYmJTUHZiMGVQTmZzMUZnRUVBQUFBczZVbWZXUFMrYi85ei84NzJ1VFhXdjQyZE44dTF0MEgxUjNWenU4Q2FhbDV2NlJhZnp2Nms5ZWVqVGI4dFJVQkJBQUFBTE9rSm4zV2s4NC85L3lyMjhIRHRYUGllWXdhK0R0dE0vL0d0ejhlYmZockt3SUlBQUFBWmtlTittd25uZStaNzdIenV6OTJVUU4vdGRQTW4vL3hoNStOTnYwMUZRRUVBQUFBczZObWZaYVR6dmZNOXpoNHk5VXVhdUxYazlGLytlcW5vMDEvVGZXanIzMjRHMEQyem5NQkFBQUFKcWRtZlphVHpuZk45d2k3MVp1YStOdHRReitIMjdEYXNickNMZ0FBQUFCMVVzTSt5MG5uL2tiMjdyaEQzUWk3ZFJRMThyTzZEYXM3MXJBTEFBQUFRSDNVc005dTBybkh0L1hsZ3E1ZTh6MzJVVE8vdmcycjlxZGh0ZU4waGVFREFBQUFkVkhEUHJ0SjV4NWY1SmFybytaNzdLSm1mbjBiMW9NWEwwVWIvMXFxSGFjckRCOEFBQUNvaTVyMldVMDY5M3lQN25oREhUM2ZZeGMxODlmYnByNzJMeVZzeCtrS3d3Y0FBQURxb2NaOVZwUE9TODczMktmYjJQL2hCNStKTnY4MVZIZWNZZWdBQUFCQUhkUzR6MmJTK1k3NUhtZXFRZWQ3N0tLRy9uN2IyTmY4T041MmpLNHdkQUFBQUdCNmJ0eFZzNWgwdm1PK3gzM1Y0UE05ZGxGRGY2dHQ3QisrOUV5MCtaKzYvSVN1ZG95dU1IUUFBQUJnV203Y1ZiT1lkTDVqdnNmdHNDdWpVVU8vbmdmaWJ4dVBCWUNwNjdmZnU5d05JUGZEMEFFQUFJQnBxWUd2ZnRLNXI4WkU1bnY0aWszeCtSNHhhdWd2ZDVyN2FBQ1l1Z2dnQUFBQXFJNGErSnVkaHI3S1NlZC84YmYvT09sOGoxM1UxRDl0Ry96ZnYzNGxHZ0ttTEFJSUFBQUFxcUlHL2xxbm9hOXkwdmtYdi9MOXllZDc3T0ttdm0zd2EveENRZ0lJQUFBQXFxRUcvcktxNmtubmYvYlhyMjBIRDlmbzh6MTJVVk8vOFlXRWJ2Z1AxZVB2ZnVyOEZ5OS84bUI1WHNtaCtzazNQOW9OR0llS0FBSUFBSUJwcUltdmV0SjViZk05ZGxGVHYzNFMxZ3lLQUFJQUFJQnBxSkcvMDJuc3E1cDBYdXQ4anhnMTlkZTJtdnhheTNOVnFybHlCQUFBZ0JPaVJyN2FTZWMxei9lSVVWUGZEU0J1OGowbjVGRGRVZm5LeWFIeVkzNjkvcjBWaGdJQUFBRFVSNDE4dFpQT2Q4ejN1QldHRGdBQUFHQk8xTXhYT2VsOHozeVA2MkhvQUFBQUFPWkV6WHlWazg1M3pQZndPS3ViN3dFQUFBQWdrUnI2NmlhZGV3eVIrUjcrUnZZcTUzc0FBQUFBU0tDR3ZycEo1eDVEZDB5aG1POEJBQUFBekptYStxb21uWHUraDhmUUhaT0srUjRBQUFEQTNLbXByMnJTdWVlY01OOERBQUFBV0NBMTlSdVR6bDMram8xWU1CaWptTzhCQUFBQUxKZ2ErNDFKNXk0SEFNKzlHUHNxQ1BNOUFBQUFnSVZUZysrNUh3NGg2MXV3Mm5yMnk5OFo1U2xZZStaNzhPM2RBQUFBd0JLcDJmZXRXSDRLMXBscUl3ejR5LzlLWFEzWk05L2pjaGdhQUFBQWdLVlM0KzhnY2t1MWNVWEVJV0hvTHlUY01kL0RWMk9ZN3dFQUFBQ2NFb1VBUHhucmZnZ0ZxeHJ5VzlFLzkveXIzZERSMXMyd2VRQUFBQUNuU0tIQVYwUFdJZUhZRU9KYnVhNzg1Y3ZkME9GaXZnY0FBQUF3Vi8vMGR4KzZwcnF1dXRXcG15ci9lZmJjQ29XREd5RWtIQlZDdkl3bnRyZnJDY1Y4RHdBQUFHQk9IQ3BDd0xpdk9rK29wNm83cXVSdkZWZEl1S3JhQ0NFNUU5UC8vRy8rZ2ZrZUFBQUF3SndwUURoNE9FakVRa1pxbmFsdWhGWHVwYkRnRUxJT0VKNllIZ3NiMjhWOER3QUFBR0RHRkJndXFXNkhBSEdoZnZ6MWo1ei85RnNmTzMvNDBqUG52M2o1azZ0NjhPS2wxWi9GZmo2VWc4akJlUmdLRHI0ZGF4MGsvT1dCc2REaFlyNEhBQUFBTUhNS0NWZFZEMEpvV05kUHZ2blI4OGZmL2RUNUgzN3dtZlB6Zi83ODNucnkyck9yUVBLanIzMTRZeDJoYm9kTjdhUUFjYnNUS0tMelFaanZBUUFBQU15Y3dvSERoK2R2ckFPRHIzYjg5bnVYbzBIalVQM3hoNTlkWFIzcHJpK1U1NUxzbkp1aEVPSHZDbGwvWWFHdmNuVER4Njc1SG1GeEFBQUFBTFZUSUxnUVBod2VZc0VpdDN6VnhGZFF1dXRXK1NyTHZoQnlyUnN3dnZpVjc2L0N4NDc1SGtselRBQUFBQUJVUUVGZ0kzejQxcW0rVnozMmxXL0xhcmNSYXU5VkN3VUxQOFZxRlRKOEZjU1QwdHYvSDhyelBhNkdId2NBQUFCUU80VUFUemhmei9sdytQajk2MWVpQVdLSWlvU1FuVStyVXJqd3Q2VnZoNDYyUE4rRFIrd0NBQUFBYzZJQXNQRzBxeEpYUHJicmpXOS92QnRBWERzbmppdGtySytDZElyNUhnQUFBTURjdVBIdkJvR2g1bndjS2s5TzkrVDJ6cmJ2aHlGZG9MQ3hNUmRFeFh3UEFBQUFZSTdVK0srL1pOQ1R4R05ob1ZUNVNrdTc3VkE3djd0RG9jTlB4R0srQndBQUFEQlhhdmczcm42TWNldlZkbTE5Y2VITzI2b1VQSzZybU84QkFBQUF6SlVhL3B0dDh6LzIxWSsySWxkQkNCa0FBQURBRXFuWlh6LzV5dDl3SGdzSVk5VFdYQkRtZHdBQUFBQkwxR242VjE4VUdBc0hZOVREbDU3cEJwRGJZWGdBQUFBQWxrS04vclcyNmZjVmlGZ3dHS3VldlBac040RHNmQm9XQUFBQWdKbFNvMytqYmZvOUVUd1dETVlxWDMxcHgrSUtRd1FBQUFDd0ZHcjBiN1VOLzFqZi9iR3Yyckc0d2hBQkFBQUFMSVVhZlFJSUFBQUFnSEdvMFNlQUFBQUFBQmlIR3YxMUFQRlRxR0toWU14cXgrSUtRd1FBQUFDd0ZHcjAxMC9CbW5vUyt0YVhFWjZGSVFJQUFBQllDalg2Vjl1bS8wZGYrM0EwR0l4VnYzejEwOTBBd21ONEFRQUFnQ1ZTcy8rMGJmeC8vL3FWYURnWW85NzQ5c2U3QWVSV0dCNEFBQUNBSlZHemY3ZHQvS2VhQi9MSEgzNTJkUVdtSFlmcWFoZ2VBQUFBZ0NWUnM3LytNa0tIQUllQldFZ29XVnUzWHpIL0F3QUFBRmd5TmYzcjI3REdmaHl2QTgrUHYvNlJiZ0RoOWlzQUFBQmd5ZHowdHdIQVYwSCs4SVBQUk1OQ2lYTGdhYmV0Y2hDNkZJWUZBQUFBWUluYzlLdk9RZ2dZN1pHOG52VGViak1VVno4QUFBQ0FVNkRtLzNvM0REeDQ4VkkwTkF4VnZzcXlOZkg4UVJnS0FBQUFnRk9nRUhDbkV3aUtoUkNIajU5ODg2UGQ4T0ZicjNqeUZRQUFBSEJxRkFRZWRJTEJLb1FNK1dRczMzYTFkZVhEZFNOc0hnQUFBTUFwVVJqd2ZKQ05FT0tyRmIvOTN1Vm9vTWlwclFubmJSRStBQUFBZ0ZPbVVPQVFjcjhURWxibHF5RzUzNWJ1cXlmK25vK3RSKzIyUmZnQUFBQUEwRkJBV0QrZXQxdStJdUtyR2I0cUVyczl5eUhGb2NPQkpYSzdsY3RQM0dMT0J3QUFBSUJORGdxcUMxZERlcFlubXp2VThGMGZBQUFBQUhaVGFMaW11cXVLQll0RFJmQUFBQUFBa004aFFuVkQ1VWYyYmt4Vzc1UURoNithT0hSY0M0c0NBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWcxWWMrOUMrQ3lZRlFzbnBqeGdBQUFBQkpSVTVFcmtKZ2dnPT0nO1xuICAgICAgICAgICAgdmFyIGltYWdlSGVpZ2h0ID0gd2lkdGggKiAzIC8gODtcbiAgICAgICAgICAgIHZhciBvbGRBbnRpYWxpYXMgPSB0aGlzLmdldEFudGlhbGlhc2luZygpO1xuICAgICAgICAgICAgdGhpcy5zZXRBbnRpYWxpYXNpbmcodHJ1ZSk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCA4MDAsIDMwMCwgeCwgeSAtIGltYWdlSGVpZ2h0IC0gMjAsIHdpZHRoLCBpbWFnZUhlaWdodCk7XG4gICAgICAgICAgICAvLyBsb2FkaW5nIGJveFxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIDIwKTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHdpZHRoICogKGxvYWRlZCAvIHRvdGFsKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgdmFyIG1hcmdpbiA9IDU7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwcm9ncmVzcyAtIG1hcmdpbiAqIDI7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMjAgLSBtYXJnaW4gKiAyO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHggKyBtYXJnaW4sIHkgKyBtYXJnaW4sIHdpZHRoID4gMCA/IHdpZHRoIDogMCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0QW50aWFsaWFzaW5nKG9sZEFudGlhbGlhcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBsb2FkaW5nIHNjcmVlbiBkcmF3IGZ1bmN0aW9uIGlmIHlvdSB3YW50IHRvIGN1c3RvbWl6ZSB0aGUgZHJhd1xuICAgICAgICAgKiBAbWV0aG9kIHNldExvYWRpbmdEcmF3RnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIGZjbiB7Y3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGxvYWRlZDogbnVtYmVyLCB0b3RhbDogbnVtYmVyKSA9PiB2b2lkfVxuICAgICAgICAgKiBDYWxsYmFjayB0byBkcmF3IHRoZSBsb2FkaW5nIHNjcmVlbiB3aGljaCBpcyBwYXNzZWQgYSByZW5kZXJpbmcgY29udGV4dCwgdGhlIG51bWJlciBvZiBieXRlcyBsb2FkZWQsIGFuZCB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGxvYWQuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnNldExvYWRpbmdEcmF3RnVuY3Rpb24gPSBmdW5jdGlvbiAoZmNuKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdEcmF3ID0gZmNuO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQW5vdGhlciBvcHRpb24gYXZhaWxhYmxlIHRvIHlvdSB0byBsb2FkIHJlc291cmNlcyBpbnRvIHRoZSBnYW1lLlxuICAgICAgICAgKiBJbW1lZGlhdGVseSBhZnRlciBjYWxsaW5nIHRoaXMgdGhlIGdhbWUgd2lsbCBwYXVzZSBhbmQgdGhlIGxvYWRpbmcgc2NyZWVuXG4gICAgICAgICAqIHdpbGwgYXBwZWFyLlxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHBhcmFtIGxvYWRlciB7SUxvYWRhYmxlfSBTb21lIGxvYWRhYmxlIHN1Y2ggYXMgYSBMb2FkZXIgY29sbGVjdGlvbiwgU291bmQsIG9yIFRleHR1cmUuXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9ncmVzcyA9IGUubG9hZGVkO1xuICAgICAgICAgICAgICAgIF90aGlzLnRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoJ0xvYWRpbmcgJyArICgxMDAgKiBfdGhpcy5wcm9ncmVzcyAvIF90aGlzLnRvdGFsKS50b0ZpeGVkKDApKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2FkZXIub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFbmdpbmU7XG4gICAgfSkoZXguQ2xhc3MpO1xuICAgIGV4LkVuZ2luZSA9IEVuZ2luZTtcbiAgICA7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjYWxpYnVyLTAuMi41LmpzLm1hcFxuO1xuLy8gQ29uY2F0ZW5hdGVkIG9udG8gZXhjYWxpYnVyIGFmdGVyIGJ1aWxkXG4vLyBFeHBvcnRzIHRoZSBleGNhbGlidXIgbW9kdWxlIHNvIGl0IGNhbiBiZSB1c2VkIHdpdGggYnJvd3NlcmlmeVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9pc3N1ZXMvMzEyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHttb2R1bGUuZXhwb3J0cyA9IGV4O30iLCIvKmpzbGludCBub2RlOnRydWUsbm9tZW46dHJ1ZSovXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXJcbiAgICAgICAgcGFydHMgPSBvcHRzLnBhcnRzLFxuICAgICAgICBleCA9IG9wdHMuZXgsXG4gICAgICAgIGdhbWUgPSBvcHRzLmdhbWUsXG4gICAgICAgIGNvbG9yID0gb3B0cy5jb2xvcixcbiAgICAgICAgdyA9IGdhbWUud2lkdGgsXG4gICAgICAgIGggPSBnYW1lLmhlaWdodCxcbiAgICAgICAgc2l6ZSA9IG9wdHMuc2l6ZSxcbiAgICAgICAgZmluZFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNpemUgKiBfLnJhbmRvbSgyLCBNYXRoLmZsb29yKHcgLyBzaXplKSAtIDIpO1xuICAgICAgICAgICAgcmV0dXJuIF8ucGx1Y2socGFydHMsICd4JykuaW5kZXhPZih4KSA9PT0gLTEgPyB4IDogZmluZFgoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHNpemUgKiBfLnJhbmRvbSgyLCBNYXRoLmZsb29yKGggLyBzaXplKSAtIDIpO1xuICAgICAgICAgICAgcmV0dXJuIF8ucGx1Y2socGFydHMsICd5JykuaW5kZXhPZih5KSA9PT0gLTEgPyB5IDogZmluZFkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWN0b3IgPSBuZXcgZXguQWN0b3IoZmluZFgoKSwgZmluZFkoKSwgc2l6ZSwgc2l6ZSwgY29sb3IpO1xuICAgIHRoaXMuZWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhY3Rvci5raWxsKCk7XG4gICAgfTtcbiAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgZ2FtZS5hZGQoYWN0b3IpO1xufTtcbiIsIi8qanNsaW50IG5vZGU6dHJ1ZSxub21lbjp0cnVlKi9cbi8qZ2xvYmFsIHdpbmRvdyovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzbmFrZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgaGFuZGxlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHkgPSBldmVudC5iZXRhLFxuICAgICAgICAgICAgeCA9IGV2ZW50LmdhbW1hLFxuICAgICAgICAgICAgbWF4WCA9IDMwLFxuICAgICAgICAgICAgbWF4WSA9IDIwO1xuICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgIHNuYWtlLmRvd24oKTtcbiAgICAgICAgfSBlbHNlIGlmICh5IDwgLW1heFkpIHtcbiAgICAgICAgICAgIHNuYWtlLnVwKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICAgIHNuYWtlLnJpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA8IC1tYXhYKSB7XG4gICAgICAgICAgICBzbmFrZS5sZWZ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VvcmllbnRhdGlvbicsIGhhbmRsZU9yaWVudGF0aW9uKTtcbn07XG4iLCIvKmpzbGludCBub2RlOnRydWUsbm9tZW46dHJ1ZSovXG52YXIgRm9vZCA9IHJlcXVpcmUoJy4vZm9vZCcpLFxuICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICB2ID0ge30sXG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZSxcbiAgICAgICAgc3BlZWQgPSAxNTAsXG4gICAgICAgIGdhbWUgPSBvcHRzLmdhbWUsXG4gICAgICAgIHNpemUgPSBNYXRoLmZsb29yKE1hdGgubWluKGdhbWUud2lkdGgsIGdhbWUuaGVpZ2h0KSAvIDIyKSxcbiAgICAgICAgZXggPSBvcHRzLmV4LFxuICAgICAgICBjb2xvciA9IG9wdHMuY29sb3IsXG4gICAgICAgIHBhcnQgPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IpIHtcbiAgICAgICAgICAgIHZhciBhY3RvciA9IG5ldyBleC5BY3Rvcih4LCB5LCBzaXplLCBzaXplLCBjb2xvcik7XG4gICAgICAgICAgICBnYW1lLmFkZChhY3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gYWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0UGxhY2VSYW5kWCA9IF8ucmFuZG9tKDIsIE1hdGguZmxvb3IoZ2FtZS53aWR0aCAvIHNpemUpIC0gMiksXG4gICAgICAgIHN0YXJ0UGxhY2VSYW5kWSA9IF8ucmFuZG9tKDIsIE1hdGguZmxvb3IoZ2FtZS5oZWlnaHQgLyBzaXplKSAtIDIpLFxuICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHBhcnQoKHN0YXJ0UGxhY2VSYW5kWCArIDEpICogc2l6ZSwgc3RhcnRQbGFjZVJhbmRZICogc2l6ZSwgY29sb3IuYm9keSksXG4gICAgICAgICAgICBwYXJ0KHN0YXJ0UGxhY2VSYW5kWCAqIHNpemUsIHN0YXJ0UGxhY2VSYW5kWSAqIHNpemUsIGNvbG9yLmJvZHkpXG4gICAgICAgIF0sXG4gICAgICAgIGZvb2QgPSBuZXcgRm9vZCh7XG4gICAgICAgICAgICBleDogZXgsXG4gICAgICAgICAgICBnYW1lOiBnYW1lLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yLmZvb2QsXG4gICAgICAgICAgICBwYXJ0czogcGFydHMsXG4gICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgIH0pLFxuICAgICAgICBjdXRUYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBwYXJ0cy5wb3AoKSxcbiAgICAgICAgICAgICAgICBwcmVsYXN0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsYXN0Lm1vdmVUbyhcbiAgICAgICAgICAgICAgICBwcmVsYXN0LngsXG4gICAgICAgICAgICAgICAgcHJlbGFzdC55LFxuICAgICAgICAgICAgICAgIDIgKiBzcGVlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICB9LFxuICAgICAgICBhZGROZWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdFBhcnQgPSBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICB4ID0gZmlyc3RQYXJ0LngsXG4gICAgICAgICAgICAgICAgeSA9ICBmaXJzdFBhcnQueSxcbiAgICAgICAgICAgICAgICBuZXdQYXJ0ID0gcGFydCh4LCB5LCBjb2xvci5ib2R5KTtcbiAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQobmV3UGFydCk7XG4gICAgICAgICAgICBuZXdQYXJ0Lm1vdmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgdi54ICogc2l6ZSxcbiAgICAgICAgICAgICAgICB5ICsgdi55ICogc2l6ZSxcbiAgICAgICAgICAgICAgICBzcGVlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld1BhcnQub24oJ2V4aXR2aWV3cG9ydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uTG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3UGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgaGlUYWlsID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDI7IGkgPCBwYXJ0cy5sZW5ndGggLSAyOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gJiYgYWN0b3Iud2l0aGluKHBhcnRzW2ldLCBzaXplIC8gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdGVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWRkTmVjaygpLmNhbGxNZXRob2QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpdGhpbihmb29kLmFjdG9yLCBzaXplIC8gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgKz0gNTA7XG4gICAgICAgICAgICAgICAgICAgIGZvb2QuZWF0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvb2QgPSBuZXcgRm9vZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBleDogZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYW1lOiBnYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLmZvb2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogcGFydHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGVwKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaVRhaWwodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbkxvc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXRUYWlsKCkuY2FsbE1ldGhvZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnRpdGxlID0gJ1Njb3JlOiAnICsgKHBhcnRzLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB0aGlzLnJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2LnggPSAxO1xuICAgICAgICB2LnkgPSAwO1xuICAgIH07XG4gICAgdGhpcy5sZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2LnggPSAtMTtcbiAgICAgICAgdi55ID0gMDtcbiAgICB9O1xuICAgIHRoaXMudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHYueCA9IDA7XG4gICAgICAgIHYueSA9IC0xO1xuICAgIH07XG4gICAgdGhpcy5kb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2LnggPSAwO1xuICAgICAgICB2LnkgPSAxO1xuICAgIH07XG4gICAgdGhpcy5ydW4gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHYueCA9IG9iai54IHx8IDA7XG4gICAgICAgIHYueSA9IG9iai55IHx8IDA7XG4gICAgICAgIHN0ZXAoKTtcbiAgICB9O1xufTtcbiIsIi8qIVxuICAqIGRvbXJlYWR5IChjKSBEdXN0aW4gRGlheiAyMDE0IC0gTGljZW5zZSBNSVRcbiAgKi9cbiFmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIHRoaXNbbmFtZV0gPSBkZWZpbml0aW9uKClcblxufSgnZG9tcmVhZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGZucyA9IFtdLCBsaXN0ZW5lclxuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIGhhY2sgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsXG4gICAgLCBkb21Db250ZW50TG9hZGVkID0gJ0RPTUNvbnRlbnRMb2FkZWQnXG4gICAgLCBsb2FkZWQgPSAoaGFjayA/IC9ebG9hZGVkfF5jLyA6IC9ebG9hZGVkfF5pfF5jLykudGVzdChkb2MucmVhZHlTdGF0ZSlcblxuXG4gIGlmICghbG9hZGVkKVxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lcilcbiAgICBsb2FkZWQgPSAxXG4gICAgd2hpbGUgKGxpc3RlbmVyID0gZm5zLnNoaWZ0KCkpIGxpc3RlbmVyKClcbiAgfSlcblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgbG9hZGVkID8gZm4oKSA6IGZucy5wdXNoKGZuKVxuICB9XG5cbn0pO1xuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS43LjBcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICBjb25jYXQgICAgICAgICAgID0gQXJyYXlQcm90by5jb25jYXQsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjcuMCc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVDYWxsYmFjayA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBjcmVhdGVDYWxsYmFjayh2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcyh2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSArbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICBjdXJyZW50S2V5O1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IDAsIGN1cnJlbnRLZXk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICBpZiAoIWxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4KytdIDogaW5kZXgrK107XG4gICAgfVxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaXRlcmF0ZWUgPSBjcmVhdGVDYWxsYmFjayhpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArIG9iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGluZGV4ID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIGN1cnJlbnRLZXk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICBpZiAoIWluZGV4KSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbLS1pbmRleF0gOiAtLWluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uc29tZShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBwcmVkaWNhdGUgPSBfLml0ZXJhdGVlKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKF8uaXRlcmF0ZWUocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICBpbmRleCwgY3VycmVudEtleTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgaW5kZXgsIGN1cnJlbnRLZXk7XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBpZiAob2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGgpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIHRhcmdldCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gb2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGggPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNldCA9IG9iaiAmJiBvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAob2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGgpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IGxvdyArIGhpZ2ggPj4+IDE7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBfLml0ZXJhdGVlKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICBpZiAobiA8IDApIHJldHVybiBbXTtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aFxuICAvLyBgXy5tYXBgLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgTWF0aC5tYXgoYXJyYXkubGVuZ3RoIC0gbiwgMCkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqXG4gIC8vIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgaWYgKHNoYWxsb3cgJiYgXy5ldmVyeShpbnB1dCwgXy5pc0FycmF5KSkge1xuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShvdXRwdXQsIGlucHV0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmICghXy5pc0FycmF5KHZhbHVlKSAmJiAhXy5pc0FyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFzdHJpY3QpIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhbGxvdykge1xuICAgICAgICBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0LCBvdXRwdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UsIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG4gICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IHZhbHVlKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KTtcbiAgICAgICAgaWYgKF8uaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXy5pbmRleE9mKHJlc3VsdCwgdmFsdWUpIDwgMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgW10pKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHRydWUsIHRydWUsIFtdKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XG4gICAgdmFyIGxlbmd0aCA9IF8ubWF4KGFyZ3VtZW50cywgJ2xlbmd0aCcpLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJndW1lbnRzLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIGlmIChsaXN0ID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpID0gaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaWR4ID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZnJvbSA9PSAnbnVtYmVyJykge1xuICAgICAgaWR4ID0gZnJvbSA8IDAgPyBpZHggKyBmcm9tICsgMSA6IE1hdGgubWluKGlkeCwgZnJvbSArIDEpO1xuICAgIH1cbiAgICB3aGlsZSAoLS1pZHggPj0gMCkgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV1c2FibGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHByb3RvdHlwZSBzZXR0aW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICB2YXIgYXJncywgYm91bmQ7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIEN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICB2YXIgc2VsZiA9IG5ldyBDdG9yO1xuICAgICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJnc1tpXSA9PT0gXykgYXJnc1tpXSA9IGFyZ3VtZW50c1twb3NpdGlvbisrXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGksIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9IGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5O1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gXy5kZWxheS5hcHBseShfLCBbZnVuYywgMV0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID4gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGJlZm9yZSBiZWluZyBjYWxsZWQgTiB0aW1lcy5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGtleTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoW10sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICBvYmogPSBuZXcgT2JqZWN0KG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5IGluIG9iaikgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoY29uY2F0LmFwcGx5KFtdLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG4gICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgaWYgKFxuICAgICAgYUN0b3IgIT09IGJDdG9yICYmXG4gICAgICAvLyBIYW5kbGUgT2JqZWN0LmNyZWF0ZSh4KSBjYXNlc1xuICAgICAgJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYiAmJlxuICAgICAgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG4gICAgdmFyIHNpemUsIHJlc3VsdDtcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT09IGIubGVuZ3RoO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gZXEoYVtzaXplXSwgYltzaXplXSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgcmVzdWx0ID0gXy5rZXlzKGIpLmxlbmd0aCA9PT0gc2l6ZTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICAgIGtleSA9IGtleXNbc2l6ZV07XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgYW4gSUUgMTEgYnVnLlxuICBpZiAodHlwZW9mIC8uLyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIHZhciBwYWlycyA9IF8ucGFpcnMoYXR0cnMpLCBsZW5ndGggPSBwYWlycy5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICAgIG9iaiA9IG5ldyBPYmplY3Qob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXSwga2V5ID0gcGFpclswXTtcbiAgICAgICAgaWYgKHBhaXJbMV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3RbcHJvcGVydHldKCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iXX0=
