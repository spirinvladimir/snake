(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/a/snake/index.js":[function(require,module,exports){
/*jslint node:true*/
/*global window*/
var domready = require('domready'),
    ex = require('./lib/excalibur'),
    Snake = require('./lib/snake'),
    mobile = require('./lib/mobile'),
    screenfull = require('screenfull');

domready(function () {
    'use strict';
    var game = new ex.Engine(),
        snake = new Snake({
            ex: ex,
            game: game,
            color: {
                head: ex.Color.Red,
                body: ex.Color.Yellow,
                food: ex.Color.Green
            }
        }),
        replay = function () {
            game.rootScene.children.forEach(function (actor) {
                actor.kill();
            });
            document.title = '';
            setTimeout(function () {
                snake = new Snake({
                    ex: ex,
                    game: game,
                    color: {
                        head: ex.Color.Red,
                        body: ex.Color.Yellow,
                        food: ex.Color.Green
                    }
                });
                snake.onLose = replay;
                snake.run({x: 1});
            }, 500);
        },
        paused = false;
    game.input.keyboard.on('down', function (k) {
        k = k.key;
        if (k === 37) {
            snake.left();
        } else if (k === 38) {
            snake.up();
        } else if (k === 39) {
            snake.right();
        } else if (k === 40) {
            snake.down();
        } else if (k === 32) {
            if (paused) {
                game.start();
                paused = false;
            } else {
                game.stop();
                paused = true;
            }
        }
    });
    document.addEventListener('click', function () {
        replay();
    });
    mobile(snake);
    if (screenfull.enabled) {
        screenfull.request();
    }
    game.start();
    snake.onLose = replay;
    snake.run({x: 1});
});

},{"./lib/excalibur":"/home/a/snake/lib/excalibur.js","./lib/mobile":"/home/a/snake/lib/mobile.js","./lib/snake":"/home/a/snake/lib/snake.js","domready":"/home/a/snake/node_modules/domready/ready.js","screenfull":"/home/a/snake/node_modules/screenfull/dist/screenfull.js"}],"/home/a/snake/lib/excalibur.js":[function(require,module,exports){
/*! excalibur - v0.2.5 - 2015-02-04
* https://github.com/excaliburjs/Excalibur
* Copyright (c) 2015 ; Licensed BSD*/
if (typeof window == 'undefined') {
    window = { audioContext: function () {
    } };
}
if (typeof window != 'undefined' && !window.requestAnimationFrame) {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
        window.setInterval(callback, 1000 / 60);
    };
}
if (typeof window != 'undefined' && !window.AudioContext) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError(' this is null or not defined');
        }
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var O = Object(this);
        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;
        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + ' is not a function');
        }
        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 1) {
            T = thisArg;
        }
        // 6. Let k be 0
        k = 0;
        while (k < len) {
            var kValue;
            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {
                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[k];
                // ii. Call the Call internal method of callback with T as the this value and
                // argument list containing kValue, k, and O.
                callback.call(T, kValue, k, O);
            }
            // d. Increase k by 1.
            k++;
        }
        // 8. return undefined
    };
}
// Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg */) {
        'use strict';
        if (this === void 0 || this === null)
            throw new TypeError();
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== 'function')
            throw new TypeError();
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t))
                return true;
        }
        return false;
    };
}
// Polyfill from  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== 'function') {
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {
        }, fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
var ex;
(function (ex) {
    var Effects;
    (function (Effects) {
        /**
         * Applies the "Grayscale" effect to a sprite, removing color information.
         * @class Effects.Grayscale
         * @constructor
         * @extends ISpriteEffect
         */
        var Grayscale = (function () {
            function Grayscale() {
            }
            Grayscale.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                var avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
                pixel[firstPixel + 0] = avg;
                pixel[firstPixel + 1] = avg;
                pixel[firstPixel + 2] = avg;
            };
            return Grayscale;
        })();
        Effects.Grayscale = Grayscale;
        /**
         * Applies the "Invert" effect to a sprite, inverting the pixel colors.
         * @class Effects.Invert
         * @constructor
         * @extends ISpriteEffect
         */
        var Invert = (function () {
            function Invert() {
            }
            Invert.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
                pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
                pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
            };
            return Invert;
        })();
        Effects.Invert = Invert;
        /**
         * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
         * @class Effects.Opacity
         * @extends ISpriteEffect
         * @constructor
         * @param opacity {number} The new opacity of the sprite from 0-1.0
         */
        var Opacity = (function () {
            function Opacity(opacity) {
                this.opacity = opacity;
            }
            Opacity.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 3] = Math.round(this.opacity * 255);
                }
            };
            return Opacity;
        })();
        Effects.Opacity = Opacity;
        /**
         * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
         * average of the original color and the provided color
         * @class Effects.Colorize
         * @extends ISpriteEffect
         * @constructor
         * @param color {Color} The color to apply to the sprite
         */
        var Colorize = (function () {
            function Colorize(color) {
                this.color = color;
            }
            Colorize.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
                    pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
                    pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
                }
            };
            return Colorize;
        })();
        Effects.Colorize = Colorize;
        /**
         * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
         * a given color
         * @class Effects.Fill
         * @extends ISpriteEffect
         * @constructor
         * @param color {Color} The color to apply to the sprite
         */
        var Fill = (function () {
            function Fill(color) {
                this.color = color;
            }
            Fill.prototype.updatePixel = function (x, y, imageData) {
                var firstPixel = (x + y * imageData.width) * 4;
                var pixel = imageData.data;
                if (pixel[firstPixel + 3] !== 0) {
                    pixel[firstPixel + 0] = this.color.r;
                    pixel[firstPixel + 1] = this.color.g;
                    pixel[firstPixel + 2] = this.color.b;
                }
            };
            return Fill;
        })();
        Effects.Fill = Fill;
    })(Effects = ex.Effects || (ex.Effects = {}));
})(ex || (ex = {}));
/// <reference path="../SpriteEffects.ts" />
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var MovementModule = (function () {
        function MovementModule() {
        }
        MovementModule.prototype.update = function (actor, engine, delta) {
            // Update placements based on linear algebra
            actor.x += actor.dx * delta / 1000;
            actor.y += actor.dy * delta / 1000;
            actor.dx += actor.ax * delta / 1000;
            actor.dy += actor.ay * delta / 1000;
            actor.rotation += actor.rx * delta / 1000;
            actor.scale.x += actor.sx * delta / 1000;
            actor.scale.y += actor.sy * delta / 1000;
        };
        return MovementModule;
    })();
    ex.MovementModule = MovementModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var OffscreenCullingModule = (function () {
        function OffscreenCullingModule() {
        }
        OffscreenCullingModule.prototype.update = function (actor, engine, delta) {
            var eventDispatcher = actor.eventDispatcher;
            var anchor = actor.anchor;
            var globalScale = actor.getGlobalScale();
            var width = globalScale.x * actor.getWidth() / actor.scale.x;
            var height = globalScale.y * actor.getHeight() / actor.scale.y;
            var actorScreenCoords = engine.worldToScreenCoordinates(new ex.Point(actor.getGlobalX() - anchor.x * width, actor.getGlobalY() - anchor.y * height));
            var zoom = 1.0;
            if (actor.scene && actor.scene.camera) {
                zoom = actor.scene.camera.getZoom();
            }
            if (!actor.isOffScreen) {
                if (actorScreenCoords.x + width * zoom < 0 || actorScreenCoords.y + height * zoom < 0 || actorScreenCoords.x > engine.width || actorScreenCoords.y > engine.height) {
                    eventDispatcher.publish('exitviewport', new ex.ExitViewPortEvent());
                    actor.isOffScreen = true;
                }
            }
            else {
                if (actorScreenCoords.x + width * zoom > 0 && actorScreenCoords.y + height * zoom > 0 && actorScreenCoords.x < engine.width && actorScreenCoords.y < engine.height) {
                    eventDispatcher.publish('enterviewport', new ex.EnterViewPortEvent());
                    actor.isOffScreen = false;
                }
            }
        };
        return OffscreenCullingModule;
    })();
    ex.OffscreenCullingModule = OffscreenCullingModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    /**
     * Propogates pointer events to the actor
     */
    var CapturePointerModule = (function () {
        function CapturePointerModule() {
        }
        CapturePointerModule.prototype.update = function (actor, engine, delta) {
            if (!actor.enableCapturePointer)
                return;
            if (actor.isKilled())
                return;
            engine.input.pointers.propogate(actor);
        };
        return CapturePointerModule;
    })();
    ex.CapturePointerModule = CapturePointerModule;
})(ex || (ex = {}));
/// <reference path="../Interfaces/IPipelineModule.ts" />
var ex;
(function (ex) {
    var CollisionDetectionModule = (function () {
        function CollisionDetectionModule() {
        }
        CollisionDetectionModule.prototype.update = function (actor, engine, delta) {
            var eventDispatcher = actor.eventDispatcher;
            if (actor.collisionType !== 0 /* PreventCollision */) {
                for (var j = 0; j < engine.currentScene.tileMaps.length; j++) {
                    var map = engine.currentScene.tileMaps[j];
                    var intersectMap;
                    var side = 0 /* None */;
                    var max = 2;
                    var hasBounced = false;
                    while (intersectMap = map.collides(actor)) {
                        if (max-- < 0) {
                            break;
                        }
                        side = actor.getSideFromIntersect(intersectMap);
                        eventDispatcher.publish('collision', new ex.CollisionEvent(actor, null, side, intersectMap));
                        if ((actor.collisionType === 2 /* Active */ || actor.collisionType === 3 /* Elastic */)) {
                            actor.y += intersectMap.y;
                            actor.x += intersectMap.x;
                            // Naive elastic bounce
                            if (actor.collisionType === 3 /* Elastic */ && !hasBounced) {
                                hasBounced = true;
                                if (side === 3 /* Left */) {
                                    actor.dx = Math.abs(actor.dx);
                                }
                                else if (side === 4 /* Right */) {
                                    actor.dx = -Math.abs(actor.dx);
                                }
                                else if (side === 1 /* Top */) {
                                    actor.dy = Math.abs(actor.dy);
                                }
                                else if (side === 2 /* Bottom */) {
                                    actor.dy = -Math.abs(actor.dy);
                                }
                            }
                        }
                    }
                }
            }
        };
        return CollisionDetectionModule;
    })();
    ex.CollisionDetectionModule = CollisionDetectionModule;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * An enum that describes the sides of an Actor for collision
     * @class Side
     */
    (function (Side) {
        /**
        @property None {Side}
        @static
        @final
        */
        Side[Side["None"] = 0] = "None";
        /**
        @property Top {Side}
        @static
        @final
        */
        Side[Side["Top"] = 1] = "Top";
        /**
        @property Bottom {Side}
        @static
        @final
        */
        Side[Side["Bottom"] = 2] = "Bottom";
        /**
        @property Left {Side}
        @static
        @final
        */
        Side[Side["Left"] = 3] = "Left";
        /**
        @property Right {Side}
        @static
        @final
        */
        Side[Side["Right"] = 4] = "Right";
    })(ex.Side || (ex.Side = {}));
    var Side = ex.Side;
})(ex || (ex = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ex;
(function (ex) {
    /**
     * A simple 2D point on a plane
     * @class Point
     * @constructor
     * @param x {number} X coordinate of the point
     * @param y {number} Y coordinate of the point
     *
     */
    var Point = (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * X Coordinate of the point
         * @property x {number}
         */
        /**
         * Y Coordinate of the point
         * @property y {number}
         */
        /**
         * Convert this point to a vector
         * @method toVector
         * @returns Vector
         */
        Point.prototype.toVector = function () {
            return new Vector(this.x, this.y);
        };
        /**
         * Rotates the current point around another by a certain number of
         * degrees in radians
         * @method rotate
         * @returns Point
         */
        Point.prototype.rotate = function (angle, anchor) {
            if (!anchor) {
                anchor = new ex.Point(0, 0);
            }
            var sinAngle = Math.sin(angle);
            var cosAngle = Math.cos(angle);
            var x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
            var y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
            return new Point(x, y);
        };
        /**
         * Translates the current point by a vector
         * @method add
         * @returns Point
         */
        Point.prototype.add = function (vector) {
            return new Point(this.x + vector.x, this.y + vector.y);
        };
        /**
         * Sets the x and y components at once
         * @method setTo
         * @param x {number}
         * @param y {number}
         */
        Point.prototype.setTo = function (x, y) {
            this.x = x;
            this.y = y;
        };
        /**
         * Clones a new point that is a copy of this one.
         * @method clone
         * @returns Point
         */
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };
        return Point;
    })();
    ex.Point = Point;
    /**
     * A 2D vector on a plane.
     * @class Vector
     * @extends Point
     * @constructor
     * @param x {number} X component of the Vector
     * @param y {number} Y component of the Vector
     */
    var Vector = (function (_super) {
        __extends(Vector, _super);
        function Vector(x, y) {
            _super.call(this, x, y);
            this.x = x;
            this.y = y;
        }
        /**
         * Returns a vector of unit length in the direction of the specified angle.
         * @method fromAngle
         * @static
         * @param angle {number} The angle to generate the vector
         * @returns Vector
         */
        Vector.fromAngle = function (angle) {
            return new Vector(Math.cos(angle), Math.sin(angle));
        };
        /**
         * The distance to another vector
         * @method distance
         * @param v {Vector} The other vector
         * @returns number
         */
        Vector.prototype.distance = function (v) {
            if (!v) {
                v = new Vector(0.0, 0.0);
            }
            return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
        };
        /**
         * Normalizes a vector to have a magnitude of 1.
         * @method normalize
         * @return Vector
         */
        Vector.prototype.normalize = function () {
            var d = this.distance();
            if (d > 0) {
                return new Vector(this.x / d, this.y / d);
            }
            else {
                return new Vector(0, 1);
            }
        };
        /**
         * Scales a vector's by a factor of size
         * @method scale
         * @param size {number} The factor to scale the magnitude by
         * @returns Vector
         */
        Vector.prototype.scale = function (size) {
            return new Vector(this.x * size, this.y * size);
        };
        /**
         * Adds one vector to another
         * @method add
         * @param v {Vector} The vector to add
         * @returns Vector
         */
        Vector.prototype.add = function (v) {
            return new Vector(this.x + v.x, this.y + v.y);
        };
        /**
         * Subtracts a vector from the current vector
         * @method minus
         * @param v {Vector} The vector to subtract
         * @returns Vector
         */
        Vector.prototype.minus = function (v) {
            return new Vector(this.x - v.x, this.y - v.y);
        };
        /**
         * Performs a dot product with another vector
         * @method dot
         * @param v {Vector} The vector to dot
         * @returns number
         */
        Vector.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        /**
         * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.
         * @method cross
         * @param v {Vector} The vector to cross
         * @returns number
         */
        Vector.prototype.cross = function (v) {
            return this.x * v.y - this.y * v.x;
        };
        /**
         * Returns the perpendicular vector to this one
         * @method perpendicular
         * @return Vector
         */
        Vector.prototype.perpendicular = function () {
            return new Vector(this.y, -this.x);
        };
        /**
         * Returns the normal vector to this one
         * @method normal
         * @return Vector
         */
        Vector.prototype.normal = function () {
            return this.perpendicular().normalize();
        };
        /**
         * Returns the angle of this vector.
         * @method toAngle
         * @returns number
         */
        Vector.prototype.toAngle = function () {
            return Math.atan2(this.y, this.x);
        };
        /**
         * Returns the point represention of this vector
         * @method toPoint
         * @returns Point
         */
        Vector.prototype.toPoint = function () {
            return new Point(this.x, this.y);
        };
        /**
         * Rotates the current vector around a point by a certain number of
         * degrees in radians
         * @method rotate
         * @returns Vector
         */
        Vector.prototype.rotate = function (angle, anchor) {
            return _super.prototype.rotate.call(this, angle, anchor).toVector();
        };
        return Vector;
    })(Point);
    ex.Vector = Vector;
    /**
     * A 2D ray that can be cast into the scene to do collision detection
     * @class Ray
     * @constructor
     * @param pos {Point} The starting position for the ray
     * @param dir {Vector} The vector indicating the direction of the ray
     */
    var Ray = (function () {
        function Ray(pos, dir) {
            this.pos = pos;
            this.dir = dir.normalize();
        }
        /**
         * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
         * This number indicates the mathematical intersection time.
         * @method intersect
         * @param line {Line} The line to test
         * @returns number
         */
        Ray.prototype.intersect = function (line) {
            var numerator = line.begin.toVector().minus(this.pos.toVector());
            // Test is line and ray are parallel and non intersecting
            if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
                return -1;
            }
            // Lines are parallel
            var divisor = (this.dir.cross(line.getSlope()));
            if (divisor === 0) {
                return -1;
            }
            var t = numerator.cross(line.getSlope()) / divisor;
            if (t >= 0) {
                var u = (numerator.cross(this.dir) / divisor) / line.getLength();
                if (u >= 0 && u <= 1) {
                    return t;
                }
            }
            return -1;
        };
        /**
         * Returns the point of intersection given the intersection time
         * @method getPoint
         * @returns Point
         */
        Ray.prototype.getPoint = function (time) {
            return this.pos.toVector().add(this.dir.scale(time)).toPoint();
        };
        return Ray;
    })();
    ex.Ray = Ray;
    /**
     * A 2D line segment
     * @class Line
     * @constructor
     * @param begin {Point} The starting point of the line segment
     * @param end {Point} The ending point of the line segment
     */
    var Line = (function () {
        function Line(begin, end) {
            this.begin = begin;
            this.end = end;
        }
        /**
         * Returns the slope of the line in the form of a vector
         * @method getSlope
         * @returns Vector
         */
        Line.prototype.getSlope = function () {
            var begin = this.begin.toVector();
            var end = this.end.toVector();
            var distance = begin.distance(end);
            return end.minus(begin).scale(1 / distance);
        };
        /**
         * Returns the length of the line segment in pixels
         * @method getLength
         * @returns number
         */
        Line.prototype.getLength = function () {
            var begin = this.begin.toVector();
            var end = this.end.toVector();
            var distance = begin.distance(end);
            return distance;
        };
        return Line;
    })();
    ex.Line = Line;
    var Projection = (function () {
        function Projection(min, max) {
            this.min = min;
            this.max = max;
        }
        Projection.prototype.overlaps = function (projection) {
            return this.max > projection.min && projection.max > this.min;
        };
        Projection.prototype.getOverlap = function (projection) {
            if (this.overlaps(projection)) {
                if (this.max > projection.max) {
                    return projection.max - this.min;
                }
                else {
                    return this.max - projection.min;
                }
            }
            return 0;
        };
        return Projection;
    })();
    ex.Projection = Projection;
})(ex || (ex = {}));
/// <reference path="Algebra.ts"/>
/// <reference path="Events.ts"/>
var ex;
(function (ex) {
    var Util;
    (function (Util) {
        Util.TwoPI = Math.PI * 2;
        function base64Encode(inputStr) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var outputStr = "";
            var i = 0;
            while (i < inputStr.length) {
                //all three "& 0xff" added below are there to fix a known bug 
                //with bytes returned by xhr.responseText
                var byte1 = inputStr.charCodeAt(i++) & 0xff;
                var byte2 = inputStr.charCodeAt(i++) & 0xff;
                var byte3 = inputStr.charCodeAt(i++) & 0xff;
                var enc1 = byte1 >> 2;
                var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
                var enc3, enc4;
                if (isNaN(byte2)) {
                    enc3 = enc4 = 64;
                }
                else {
                    enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
                    if (isNaN(byte3)) {
                        enc4 = 64;
                    }
                    else {
                        enc4 = byte3 & 63;
                    }
                }
                outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
            }
            return outputStr;
        }
        Util.base64Encode = base64Encode;
        function clamp(val, min, max) {
            return val <= min ? min : (val >= max ? max : val);
        }
        Util.clamp = clamp;
        function drawLine(ctx, color, startx, starty, endx, endy) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.moveTo(startx, starty);
            ctx.lineTo(endx, endy);
            ctx.closePath();
            ctx.stroke();
        }
        Util.drawLine = drawLine;
        function randomInRange(min, max) {
            return min + Math.random() * (max - min);
        }
        Util.randomInRange = randomInRange;
        function randomIntInRange(min, max) {
            return Math.round(randomInRange(min, max));
        }
        Util.randomIntInRange = randomIntInRange;
        function canonicalizeAngle(angle) {
            var tmpAngle = angle;
            if (angle > this.TwoPI) {
                while (tmpAngle > this.TwoPI) {
                    tmpAngle -= this.TwoPI;
                }
            }
            if (angle < 0) {
                while (tmpAngle < 0) {
                    tmpAngle += this.TwoPI;
                }
            }
            return tmpAngle;
        }
        Util.canonicalizeAngle = canonicalizeAngle;
        function toDegrees(radians) {
            return 180 / Math.PI * radians;
        }
        Util.toDegrees = toDegrees;
        function toRadians(degrees) {
            return degrees / 180 * Math.PI;
        }
        Util.toRadians = toRadians;
        function getPosition(el) {
            var oLeft = 0, oTop = 0;
            var calcOffsetLeft = function (parent) {
                oLeft += parent.offsetLeft;
                if (parent.offsetParent) {
                    calcOffsetLeft(parent.offsetParent);
                }
            };
            var calcOffsetTop = function (parent) {
                oTop += parent.offsetTop;
                if (parent.offsetParent) {
                    calcOffsetTop(parent.offsetParent);
                }
            };
            calcOffsetLeft(el);
            calcOffsetTop(el);
            return new ex.Point(oLeft, oTop);
        }
        Util.getPosition = getPosition;
        function getOppositeSide(side) {
            if (side === 1 /* Top */)
                return 2 /* Bottom */;
            if (side === 2 /* Bottom */)
                return 1 /* Top */;
            if (side === 3 /* Left */)
                return 4 /* Right */;
            if (side === 4 /* Right */)
                return 3 /* Left */;
            return 0 /* None */;
        }
        Util.getOppositeSide = getOppositeSide;
        /**
         * Excaliburs dynamically resizing collection
         * @class Collection
         * @constructor
         * @param [initialSize=200] {number} Initial size of the internal backing array
         */
        var Collection = (function () {
            function Collection(initialSize) {
                this.internalArray = null;
                this.endPointer = 0;
                var size = initialSize || Collection.DefaultSize;
                this.internalArray = new Array(size);
            }
            Collection.prototype.resize = function () {
                var newSize = this.internalArray.length * 2;
                var newArray = new Array(newSize);
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    newArray[i] = this.internalArray[i];
                }
                delete this.internalArray;
                this.internalArray = newArray;
            };
            /**
             * Push elements to the end of the collection
             * @method push
             * @param element {T}
             * @returns T
             */
            Collection.prototype.push = function (element) {
                if (this.endPointer === this.internalArray.length) {
                    this.resize();
                }
                return this.internalArray[this.endPointer++] = element;
            };
            /**
             * Removes elements from the end of the collection
             * @method pop
             * @returns T
             */
            Collection.prototype.pop = function () {
                this.endPointer = this.endPointer - 1 < 0 ? 0 : this.endPointer - 1;
                return this.internalArray[this.endPointer];
            };
            /**
             * Returns the count of the collection
             * @method count
             * @returns number
             */
            Collection.prototype.count = function () {
                return this.endPointer;
            };
            /**
             * Empties the collection
             * @method clear
             */
            Collection.prototype.clear = function () {
                this.endPointer = 0;
            };
            /**
             * Returns the size of the internal backing array
             * @method internalSize
             * @returns number
             */
            Collection.prototype.internalSize = function () {
                return this.internalArray.length;
            };
            /**
             * Returns an element at a specific index
             * @method elementAt
             * @param index {number} Index of element to retreive
             * @returns T
             */
            Collection.prototype.elementAt = function (index) {
                if (index >= this.count()) {
                    return;
                }
                return this.internalArray[index];
            };
            /**
             * Inserts an element at a specific index
             * @method insert
             * @param index {number} Index to insert the element
             * @returns T
             */
            Collection.prototype.insert = function (index, value) {
                if (index >= this.count()) {
                    this.resize();
                }
                return this.internalArray[index] = value;
            };
            /**
             * Removes an element at a specific index
             * @method remove
             * @param index {number} Index of element to remove
             * @returns T
             */
            Collection.prototype.remove = function (index) {
                var count = this.count();
                if (count === 0)
                    return;
                // O(n) Shift 
                var removed = this.internalArray[index];
                for (var i = index; i < count; i++) {
                    this.internalArray[i] = this.internalArray[i + 1];
                }
                this.endPointer--;
                return removed;
            };
            /**
             * Removes an element by reference
             * @method removeElement
             * @param element {T} Index of element to retreive
             */
            Collection.prototype.removeElement = function (element) {
                var index = this.internalArray.indexOf(element);
                this.remove(index);
            };
            /**
             * Returns a array representing the collection
             * @method toArray
             * @returns T[]
             */
            Collection.prototype.toArray = function () {
                return this.internalArray.slice(0, this.endPointer);
            };
            /**
             * Iterate over every element in the collection
             * @method forEach
             * @param func {(T,number)=>any} Callback to call for each element passing a reference to the element and its index, returned values are ignored
             */
            Collection.prototype.forEach = function (func) {
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    func.call(this, this.internalArray[i], i);
                }
            };
            /**
             * Mutate every element in the collection
             * @method map
             * @param func {(T,number)=>any} Callback to call for each element passing a reference to the element and its index, any values returned mutate the collection
             */
            Collection.prototype.map = function (func) {
                var count = this.count();
                for (var i = 0; i < count; i++) {
                    this.internalArray[i] = func.call(this, this.internalArray[i], i);
                }
            };
            /**
             * Default collection size
             * @property DefaultSize {number}
             * @static
             * @final
             */
            Collection.DefaultSize = 200;
            return Collection;
        })();
        Util.Collection = Collection;
    })(Util = ex.Util || (ex.Util = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * A Sprite is one of the main drawing primitives. It is responsible for drawing
     * images or parts of images known as Textures to the screen.
     * @class Sprite
     * @constructor
     * @param image {Texture} The backing image texture to build the Sprite
     * @param sx {number} The x position of the sprite
     * @param sy {number} The y position of the sprite
     * @param swidth {number} The width of the sprite in pixels
     * @param sheight {number} The height of the sprite in pixels
     */
    var Sprite = (function () {
        function Sprite(image, sx, sy, swidth, sheight) {
            var _this = this;
            this.sx = sx;
            this.sy = sy;
            this.swidth = swidth;
            this.sheight = sheight;
            this.scaleX = 1.0;
            this.scaleY = 1.0;
            this.rotation = 0.0;
            this.transformPoint = new ex.Point(0, 0);
            this.logger = ex.Logger.getInstance();
            this.flipVertical = false;
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.effects = [];
            this.internalImage = new Image();
            this.spriteCanvas = null;
            this.spriteCtx = null;
            this.pixelData = null;
            this.pixelsLoaded = false;
            this.dirtyEffect = false;
            if (sx < 0 || sy < 0 || swidth < 0 || sheight < 0) {
                this.logger.error("Sprite cannot have any negative dimensions x:", sx, "y:", sy, "width:", swidth, "height:", sheight);
            }
            this.texture = image;
            this.spriteCanvas = document.createElement('canvas');
            this.spriteCanvas.width = swidth;
            this.spriteCanvas.height = sheight;
            this.spriteCtx = this.spriteCanvas.getContext('2d');
            this.texture.loaded.then(function () {
                _this.spriteCanvas.width = _this.spriteCanvas.width || _this.texture.image.naturalWidth;
                _this.spriteCanvas.height = _this.spriteCanvas.height || _this.texture.image.naturalHeight;
                _this.loadPixels();
                _this.dirtyEffect = true;
            }).error(function (e) {
                _this.logger.error("Error loading texture ", _this.texture.path, e);
            });
            this.width = swidth;
            this.height = sheight;
        }
        Sprite.prototype.loadPixels = function () {
            if (this.texture.isLoaded() && !this.pixelsLoaded) {
                var clamp = ex.Util.clamp;
                var naturalWidth = this.texture.image.naturalWidth || 0;
                var naturalHeight = this.texture.image.naturalHeight || 0;
                if (this.swidth > naturalWidth) {
                    this.logger.warn("The sprite width", this.swidth, "exceeds the width", naturalWidth, "of the backing texture", this.texture.path);
                }
                if (this.sheight > naturalHeight) {
                    this.logger.warn("The sprite height", this.sheight, "exceeds the height", naturalHeight, "of the backing texture", this.texture.path);
                }
                this.spriteCtx.drawImage(this.texture.image, clamp(this.sx, 0, naturalWidth), clamp(this.sy, 0, naturalHeight), clamp(this.swidth, 0, naturalWidth), clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
                //this.pixelData = this.spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
                this.internalImage.src = this.spriteCanvas.toDataURL("image/png");
                this.pixelsLoaded = true;
            }
        };
        /**
         * Adds a new {{#crossLink Effects.ISpriteEffect}}{{/crossLink}} to this drawing.
         * @method addEffect
         * @param effect {Effects.ISpriteEffect} Effect to add to the this drawing
         */
        Sprite.prototype.addEffect = function (effect) {
            this.effects.push(effect);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this.texture.isLoaded() || !this.pixelsLoaded) {
                this.dirtyEffect = true;
            }
            else {
                this.applyEffects();
            }
        };
        Sprite.prototype.removeEffect = function (param) {
            var indexToRemove = null;
            if (typeof param === 'number') {
                indexToRemove = param;
            }
            else {
                indexToRemove = this.effects.indexOf(param);
            }
            this.effects.splice(indexToRemove, 1);
            // We must check if the texture and the backing sprite pixels are loaded as well before 
            // an effect can be applied
            if (!this.texture.isLoaded() || !this.pixelsLoaded) {
                this.dirtyEffect = true;
            }
            else {
                this.applyEffects();
            }
        };
        Sprite.prototype.applyEffects = function () {
            var _this = this;
            var clamp = ex.Util.clamp;
            var naturalWidth = this.texture.image.naturalWidth || 0;
            var naturalHeight = this.texture.image.naturalHeight || 0;
            this.spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this.spriteCtx.drawImage(this.texture.image, clamp(this.sx, 0, naturalWidth), clamp(this.sy, 0, naturalHeight), clamp(this.swidth, 0, naturalWidth), clamp(this.sheight, 0, naturalHeight), 0, 0, this.swidth, this.sheight);
            this.pixelData = this.spriteCtx.getImageData(0, 0, this.swidth, this.sheight);
            this.effects.forEach(function (effect) {
                for (var y = 0; y < _this.sheight; y++) {
                    for (var x = 0; x < _this.swidth; x++) {
                        effect.updatePixel(x, y, _this.pixelData);
                    }
                }
            });
            this.spriteCtx.clearRect(0, 0, this.swidth, this.sheight);
            this.spriteCtx.putImageData(this.pixelData, 0, 0);
            this.internalImage.src = this.spriteCanvas.toDataURL("image/png");
        };
        /**
         * Clears all effects from the drawing and return it to its original state.
         * @method clearEffects
         */
        Sprite.prototype.clearEffects = function () {
            this.effects.length = 0;
            this.applyEffects();
        };
        /**
         * Sets the point about which to apply transformations to the drawing relative to the
         * top left corner of the drawing.
         * @method transformAbotPoint
         * @param point {Point} The point about which to apply transformations
         */
        Sprite.prototype.transformAboutPoint = function (point) {
            this.transformPoint = point;
        };
        /**
         * Sets the current rotation transformation for the drawing.
         * @method setRotation
         * @param radians {number} The rotation to apply to the drawing.
         */
        Sprite.prototype.setRotation = function (radians) {
            this.rotation = radians;
        };
        /**
         * Returns the current rotation for the drawing in radians.
         * @method getRotation
         * @returns number
         */
        Sprite.prototype.getRotation = function () {
            return this.rotation;
        };
        /**
         * Sets the scale trasformation in the x direction
         * @method setScale
         * @param scale {number} The magnitude to scale the drawing in the x direction
         */
        Sprite.prototype.setScaleX = function (scaleX) {
            this.scaleX = scaleX;
        };
        /**
         * Sets the scale trasformation in the x direction
         * @method setScale
         * @param scale {number} The magnitude to scale the drawing in the x direction
         */
        Sprite.prototype.setScaleY = function (scaleY) {
            this.scaleY = scaleY;
        };
        /**
         * Returns the current magnitude of the drawing's scale in the x direction
         * @method getScale
         * @returns number
         */
        Sprite.prototype.getScaleX = function () {
            return this.scaleX;
        };
        /**
         * Returns the current magnitude of the drawing's scale in the y direction
         * @method getScale
         * @returns number
         */
        Sprite.prototype.getScaleY = function () {
            return this.scaleY;
        };
        /**
         * Resets the internal state of the drawing (if any)
         * @method reset
         */
        Sprite.prototype.reset = function () {
            // do nothing
        };
        /**
         * Draws the sprite appropriately to the 2D rendering context, at an x and y coordinate.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The 2D rendering context
         * @param x {number} The x coordinate of where to draw
         * @param y {number} The y coordinate of where to draw
         */
        Sprite.prototype.draw = function (ctx, x, y) {
            if (this.dirtyEffect) {
                this.applyEffects();
                this.dirtyEffect = false;
            }
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(this.rotation);
            if (this.flipHorizontal) {
                ctx.translate(this.swidth, 0);
                ctx.scale(-1, 1);
            }
            if (this.flipVertical) {
                ctx.translate(0, this.sheight);
                ctx.scale(1, -1);
            }
            if (this.internalImage) {
                ctx.drawImage(this.internalImage, 0, 0, this.swidth, this.sheight, -(this.transformPoint.x * this.swidth) * this.scaleX, -(this.transformPoint.y * this.sheight) * this.scaleY, this.swidth * this.scaleX, this.sheight * this.scaleY);
            }
            ctx.restore();
        };
        /**
         * Produces a copy of the current sprite
         * @method clone
         * @returns Sprite
         */
        Sprite.prototype.clone = function () {
            var result = new Sprite(this.texture, this.sx, this.sy, this.swidth, this.sheight);
            result.scaleX = this.scaleX;
            result.scaleY = this.scaleY;
            result.rotation = this.rotation;
            result.flipHorizontal = this.flipHorizontal;
            result.flipVertical = this.flipVertical;
            this.effects.forEach(function (e) {
                result.addEffect(e);
            });
            return result;
        };
        return Sprite;
    })();
    ex.Sprite = Sprite;
})(ex || (ex = {}));
/// <reference path="Sprite.ts" />
var ex;
(function (ex) {
    /**
     * SpriteSheets are a useful mechanism for slicing up image resources into
     * separate sprites or for generating in game animations. Sprites are organized
     * in row major order in the SpriteSheet.
     * @class SpriteSheet
     * @constructor
     * @param image {Texture} The backing image texture to build the SpriteSheet
     * @param columns {number} The number of columns in the image texture
     * @param rows {number} The number of rows in the image texture
     * @param spWidth {number} The width of each individual sprite in pixels
     * @param spHeight {number} The height of each individual sprite in pixels
     */
    var SpriteSheet = (function () {
        function SpriteSheet(image, columns, rows, spWidth, spHeight) {
            this.image = image;
            this.columns = columns;
            this.rows = rows;
            this.sprites = [];
            this.internalImage = image.image;
            this.sprites = new Array(columns * rows);
            // TODO: Inspect actual image dimensions with preloading
            /*if(spWidth * columns > this.internalImage.naturalWidth){
               throw new Error("SpriteSheet specified is wider than image width");
            }
   
            if(spHeight * rows > this.internalImage.naturalHeight){
               throw new Error("SpriteSheet specified is higher than image height");
            }*/
            var i = 0;
            var j = 0;
            for (i = 0; i < rows; i++) {
                for (j = 0; j < columns; j++) {
                    this.sprites[j + i * columns] = new ex.Sprite(this.image, j * spWidth, i * spHeight, spWidth, spHeight);
                }
            }
        }
        /**
         * Create an animation from the this SpriteSheet by listing out the
         * sprite indices. Sprites are organized in row major order in the SpriteSheet.
         * @method getAnimationByIndices
         * @param engine {Engine} Reference to the current game Engine
         * @param indices {number[]} An array of sprite indices to use in the animation
         * @param speed {number} The number in milliseconds to display each frame in the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationByIndices = function (engine, indices, speed) {
            var _this = this;
            var images = indices.map(function (index) {
                return _this.sprites[index];
            });
            images = images.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, images, speed);
        };
        /**
         * Create an animation from the this SpriteSheet by specifing the range of
         * images with the beginning and ending index
         * @method getAnimationBetween
         * @param engine {Engine} Reference to the current game Engine
         * @param beginIndex {number} The index to start taking frames
         * @param endIndex {number} The index to stop taking frames
         * @param speed {number} The number in milliseconds to display each frame in the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationBetween = function (engine, beginIndex, endIndex, speed) {
            var images = this.sprites.slice(beginIndex, endIndex);
            images = images.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, images, speed);
        };
        /**
         * Treat the entire SpriteSheet as one animation, organizing the frames in
         * row major order.
         * @method getAnimationForAll
         * @param engine {Engine} Reference to the current game Engine
         * @param speed {number} The number in milliseconds to display each frame the animation
         * @returns Animation
         */
        SpriteSheet.prototype.getAnimationForAll = function (engine, speed) {
            var sprites = this.sprites.map(function (i) {
                return i.clone();
            });
            return new ex.Animation(engine, sprites, speed);
        };
        /**
         * Retreive a specific sprite from the SpriteSheet by its index. Sprites are organized
         * in row major order in the SpriteSheet.
         * @method getSprite
         * @param index {number} The index of the sprite
         * @returns Sprite
         */
        SpriteSheet.prototype.getSprite = function (index) {
            if (index >= 0 && index < this.sprites.length) {
                return this.sprites[index];
            }
        };
        return SpriteSheet;
    })();
    ex.SpriteSheet = SpriteSheet;
    /**
     * SpriteFonts are a used in conjunction with a {{#crossLink Label}}{{/crossLink}} to specify
     * a particular bitmap as a font.
     * @class SpriteFont
     * @extends SpriteSheet
     * @constructor
     * @param image {Texture} The backing image texture to build the SpriteFont
     * @param alphabet {string} A string representing all the charaters in the image, in row major order.
     * @param caseInsensitve {boolean} Indicate whether this font takes case into account
     * @param columns {number} The number of columns of characters in the image
     * @param rows {number} The number of rows of characters in the image
     * @param spWdith {number} The width of each character in pixels
     * @param spHeight {number} The height of each character in pixels
     */
    var SpriteFont = (function (_super) {
        __extends(SpriteFont, _super);
        function SpriteFont(image, alphabet, caseInsensitive, columns, rows, spWidth, spHeight) {
            _super.call(this, image, columns, rows, spWidth, spHeight);
            this.image = image;
            this.alphabet = alphabet;
            this.caseInsensitive = caseInsensitive;
            this.spriteLookup = {};
            this.colorLookup = {};
            this._currentColor = ex.Color.Black;
        }
        /**
         * Returns a dictionary that maps each character in the alphabet to the appropriate Sprite.
         * @method getTextSprites
         * @returns {Object}
         */
        SpriteFont.prototype.getTextSprites = function () {
            var lookup = {};
            for (var i = 0; i < this.alphabet.length; i++) {
                var char = this.alphabet[i];
                if (this.caseInsensitive) {
                    char = char.toLowerCase();
                }
                lookup[char] = this.sprites[i].clone();
            }
            return lookup;
        };
        return SpriteFont;
    })(SpriteSheet);
    ex.SpriteFont = SpriteFont;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="SpriteSheet.ts" />
var ex;
(function (ex) {
    var TileSprite = (function () {
        function TileSprite(spriteSheetKey, spriteId) {
            this.spriteSheetKey = spriteSheetKey;
            this.spriteId = spriteId;
        }
        return TileSprite;
    })();
    ex.TileSprite = TileSprite;
    /**
     * A light-weight object that occupies a space in a collision map. Generally
     * created by a CollisionMap.
     * @class Cell
     * @constructor
     * @param x {number}
     * @param y {number}
     * @param width {number}
     * @param height {number}
     * @param index {number}
     * @param [solid=false] {boolean}
     * @param [spriteId=-1] {number}
     */
    var Cell = (function () {
        function Cell(
            /**
             * Gets or sets x coordinate of the cell in world coordinates
             * @property x {number}
             */
            x, 
            /**
             * Gets or sets y coordinate of the cell in world coordinates
             * @property y {number}
             */
            y, 
            /**
             * Gets or sets the width of the cell
             * @property width {number}
             */
            width, 
            /**
             * Gets or sets the height of the cell
             * @property height {number}
             */
            height, 
            /**
             * The index of the cell in row major order
             * @property index {number}
             */
            index, 
            /**
             * Gets or sets whether this cell is solid
             * @property solid {boolean}
             */
            solid, 
            /**
             * The index of the sprite to use from the CollisionMap SpriteSheet, if -1 is specified nothing is drawn.
             * @property number {number}
             */
            sprites) {
            if (solid === void 0) { solid = false; }
            if (sprites === void 0) { sprites = []; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.index = index;
            this.solid = solid;
            this.sprites = sprites;
            this._bounds = new ex.BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
        }
        /**
         * Returns the bounding box for this cell
         * @method getBounds
         * @returns BoundingBox
         */
        Cell.prototype.getBounds = function () {
            return this._bounds;
        };
        Cell.prototype.getCenter = function () {
            return new ex.Vector(this.x + this.width / 2, this.y + this.height / 2);
        };
        Cell.prototype.pushSprite = function (tileSprite) {
            this.sprites.push(tileSprite);
        };
        Cell.prototype.removeSprite = function (tileSprite) {
            var index = -1;
            if ((index = this.sprites.indexOf(tileSprite)) > -1) {
                this.sprites.splice(index, 1);
            }
        };
        Cell.prototype.clearSprites = function () {
            this.sprites.length = 0;
        };
        return Cell;
    })();
    ex.Cell = Cell;
    /**
     * The CollisionMap object provides a lightweight way to do large complex scenes with collision
     * without the overhead of actors.
     * @class CollisionMap
     * @constructor
     * @param x {number} The x coordinate to anchor the collision map's upper left corner (should not be changed once set)
     * @param y {number} The y coordinate to anchor the collision map's upper left corner (should not be changed once set)
     * @param cellWidth {number} The individual width of each cell (in pixels) (should not be changed once set)
     * @param cellHeight {number} The individual height of each cell (in pixels) (should not be changed once set)
     * @param rows {number} The number of rows in the collision map (should not be changed once set)
     * @param cols {number} The number of cols in the collision map (should not be changed once set)
     * @param spriteSheet {SpriteSheet} The spriteSheet to use for drawing
     */
    var TileMap = (function () {
        function TileMap(x, y, cellWidth, cellHeight, rows, cols) {
            var _this = this;
            this.x = x;
            this.y = y;
            this.cellWidth = cellWidth;
            this.cellHeight = cellHeight;
            this.rows = rows;
            this.cols = cols;
            this._collidingX = -1;
            this._collidingY = -1;
            this._onScreenXStart = 0;
            this._onScreenXEnd = 9999;
            this._onScreenYStart = 0;
            this._onScreenYEnd = 9999;
            this._spriteSheets = {};
            this.logger = ex.Logger.getInstance();
            this.data = [];
            this.data = new Array(rows * cols);
            for (var i = 0; i < cols; i++) {
                for (var j = 0; j < rows; j++) {
                    (function () {
                        var cd = new Cell(i * cellWidth + x, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                        _this.data[i + j * cols] = cd;
                    })();
                }
            }
        }
        TileMap.prototype.registerSpriteSheet = function (key, spriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        };
        /**
         * Returns the intesection vector that can be used to resolve collisions with actors. If there
         * is no collision null is returned.
         * @method collides
         * @param actor {Actor}
         * @returns Vector
         */
        TileMap.prototype.collides = function (actor) {
            var points = [];
            var width = actor.x + actor.getWidth();
            var height = actor.y + actor.getHeight();
            var actorBounds = actor.getBounds();
            var overlaps = [];
            for (var x = actorBounds.left; x <= width; x += Math.min(actor.getWidth() / 2, this.cellWidth / 2)) {
                for (var y = actorBounds.top; y <= height; y += Math.min(actor.getHeight() / 2, this.cellHeight / 2)) {
                    var cell = this.getCellByPoint(x, y);
                    if (cell && cell.solid) {
                        var overlap = actorBounds.collides(cell.getBounds());
                        var dir = actor.getCenter().minus(cell.getCenter());
                        if (overlap && overlap.dot(dir) > 0) {
                            overlaps.push(overlap);
                        }
                    }
                }
            }
            if (overlaps.length === 0) {
                return null;
            }
            // Return the smallest change other than zero
            var result = overlaps.reduce(function (accum, next) {
                var x = accum.x;
                var y = accum.y;
                if (Math.abs(accum.x) < Math.abs(next.x)) {
                    x = next.x;
                }
                if (Math.abs(accum.y) < Math.abs(next.y)) {
                    y = next.y;
                }
                return new ex.Vector(x, y);
            });
            return result;
        };
        /*
        public collidesActor(actor: Actor): boolean{
           
           var points: Point[] = [];
           var width = actor.x + actor.getWidth();
           var height = actor.y + actor.getHeight();
           for(var x = actor.x; x <= width; x += Math.min(actor.getWidth()/2,this.cellWidth/2)){
              for(var y = actor.y; y <= height; y += Math.min(actor.getHeight()/2, this.cellHeight/2)){
                 points.push(new Point(x,y))
              }
           }
  
           var result = points.some((p) => {
              return this.collidesPoint(p.x, p.y);
           });
  
           return result;
  
        }*/
        /*
        public collidesPoint(x: number, y: number): boolean{
           var x = Math.floor(x/this.cellWidth);// - Math.floor(this.x/this.cellWidth);
           var y = Math.floor(y/this.cellHeight);
  
  
           var cell = this.getCell(x, y);
           if(x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell){
              if(cell.solid){
                 this._collidingX = x;
                 this._collidingY = y;
              }
              return cell.solid;
           }
  
  
  
           
           return false;
        }*/
        /**
         * Returns the cell by index (row major order)
         * @method getCellByIndex
         * @param index {number}
         * @returns Cell
         */
        TileMap.prototype.getCellByIndex = function (index) {
            return this.data[index];
        };
        /**
         * Returns the cell by it's x and y coordinates
         * @method getCell
         * @param x {number}
         * @param y {number}
         * @returns Cell
         */
        TileMap.prototype.getCell = function (x, y) {
            if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
                return null;
            }
            return this.data[x + y * this.cols];
        };
        /**
         * Returns the cell by testing a point in global coordinates,
         * returns null if no cell was found.
         * @method getCellByPoint
         * @param x {number}
         * @param y {number}
         * @returns Cell
         */
        TileMap.prototype.getCellByPoint = function (x, y) {
            var x = Math.floor((x - this.x) / this.cellWidth); // - Math.floor(this.x/this.cellWidth);
            var y = Math.floor((y - this.y) / this.cellHeight);
            var cell = this.getCell(x, y);
            if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
                return cell;
            }
            return null;
        };
        TileMap.prototype.update = function (engine, delta) {
            var worldCoordsUpperLeft = engine.screenToWorldCoordinates(new ex.Point(0, 0));
            var worldCoordsLowerRight = engine.screenToWorldCoordinates(new ex.Point(engine.width, engine.height));
            this._onScreenXStart = Math.max(Math.floor(worldCoordsUpperLeft.x / this.cellWidth) - 2, 0);
            this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
            this._onScreenXEnd = Math.max(Math.floor(worldCoordsLowerRight.x / this.cellWidth) + 2, 0);
            this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
        };
        /**
         * Draws the collision map to the screen. Called by the Scene.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         * @param delta {number} The number of milliseconds since the last draw
         */
        TileMap.prototype.draw = function (ctx, delta) {
            var _this = this;
            ctx.save();
            ctx.translate(this.x, this.y);
            for (var x = this._onScreenXStart; x < Math.min(this._onScreenXEnd, this.cols); x++) {
                for (var y = this._onScreenYStart; y < Math.min(this._onScreenYEnd, this.rows); y++) {
                    this.getCell(x, y).sprites.filter(function (s) {
                        return s.spriteId > -1;
                    }).forEach(function (ts) {
                        var ss = _this._spriteSheets[ts.spriteSheetKey];
                        if (ss) {
                            var sprite = ss.getSprite(ts.spriteId);
                            if (sprite) {
                                sprite.draw(ctx, x * _this.cellWidth, y * _this.cellHeight);
                            }
                            else {
                                _this.logger.warn("Sprite does not exist for id", ts.spriteId, "in sprite sheet", ts.spriteSheetKey, sprite, ss);
                            }
                        }
                        else {
                            _this.logger.warn("Sprite sheet", ts.spriteSheetKey, "does not exist", ss);
                        }
                    });
                }
            }
            ctx.restore();
        };
        /**
         * Draws all the collision map's debug info. Called by the Scene.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         */
        TileMap.prototype.debugDraw = function (ctx) {
            var width = this.cols * this.cellWidth;
            var height = this.rows * this.cellHeight;
            ctx.save();
            ctx.strokeStyle = ex.Color.Red.toString();
            for (var x = 0; x < this.cols + 1; x++) {
                ctx.beginPath();
                ctx.moveTo(this.x + x * this.cellWidth, this.y);
                ctx.lineTo(this.x + x * this.cellWidth, this.y + height);
                ctx.stroke();
            }
            for (var y = 0; y < this.rows + 1; y++) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + y * this.cellHeight);
                ctx.lineTo(this.x + width, this.y + y * this.cellHeight);
                ctx.stroke();
            }
            var solid = ex.Color.Red.clone();
            solid.a = .3;
            this.data.filter(function (cell) {
                return cell.solid;
            }).forEach(function (cell) {
                ctx.fillStyle = solid.toString();
                ctx.fillRect(cell.x, cell.y, cell.width, cell.height);
            });
            if (this._collidingY > -1 && this._collidingX > -1) {
                ctx.fillStyle = ex.Color.Cyan.toString();
                ctx.fillRect(this.x + this._collidingX * this.cellWidth, this.y + this._collidingY * this.cellHeight, this.cellWidth, this.cellHeight);
            }
            ctx.restore();
        };
        return TileMap;
    })();
    ex.TileMap = TileMap;
})(ex || (ex = {}));
/// <reference path="../Algebra.ts" />
var ex;
(function (ex) {
    (function (CollisionStrategy) {
        CollisionStrategy[CollisionStrategy["Naive"] = 0] = "Naive";
        CollisionStrategy[CollisionStrategy["DynamicAABBTree"] = 1] = "DynamicAABBTree";
        CollisionStrategy[CollisionStrategy["SeparatingAxis"] = 2] = "SeparatingAxis";
    })(ex.CollisionStrategy || (ex.CollisionStrategy = {}));
    var CollisionStrategy = ex.CollisionStrategy;
    /**
     * Axis Aligned collision primitive for Excalibur.
     * @class BoundingBox
     * @constructor
     * @param left {number} x coordinate of the left edge
     * @param top {number} y coordinate of the top edge
     * @param right {number} x coordinate of the right edge
     * @param bottom {number} y coordinate of the bottom edge
     */
    var BoundingBox = (function () {
        function BoundingBox(left, top, right, bottom) {
            if (left === void 0) { left = 0; }
            if (top === void 0) { top = 0; }
            if (right === void 0) { right = 0; }
            if (bottom === void 0) { bottom = 0; }
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        /**
         * Returns the calculated width of the bounding box
         * @method getWidth
         * @returns number
         */
        BoundingBox.prototype.getWidth = function () {
            return this.right - this.left;
        };
        /**
         * Returns the calculated height of the bounding box
         * @method getHeight
         * @returns number
         */
        BoundingBox.prototype.getHeight = function () {
            return this.bottom - this.top;
        };
        /**
         * Returns the perimeter of the bounding box
         * @method getPerimeter
         * @returns number
         */
        BoundingBox.prototype.getPerimeter = function () {
            var wx = this.getWidth();
            var wy = this.getHeight();
            return 2 * (wx + wy);
        };
        BoundingBox.prototype.contains = function (val) {
            if (val instanceof ex.Point) {
                return (this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x);
            }
            else if (val instanceof BoundingBox) {
                if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {
                    return true;
                }
                return false;
            }
            return false;
        };
        /**
         * Combines this bounding box and another together returning a new bounding box
         * @method combine
         * @param other {BoundingBox} The bounding box to combine
         * @returns BoundingBox
         */
        BoundingBox.prototype.combine = function (other) {
            var compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
            return compositeBB;
        };
        /**
         * Test wether this bounding box collides with another returning,
         * the intersection vector that can be used to resovle the collision. If there
         * is no collision null is returned.
         * @method collides
         * @param collidable {ICollidable} Other collidable to test
         * @returns Vector
         */
        BoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof BoundingBox) {
                var other = collidable;
                var totalBoundingBox = this.combine(other);
                // If the total bounding box is less than the sum of the 2 bounds then there is collision
                if (totalBoundingBox.getWidth() < other.getWidth() + this.getWidth() && totalBoundingBox.getHeight() < other.getHeight() + this.getHeight()) {
                    // collision
                    var overlapX = 0;
                    if (this.right >= other.left && this.right <= other.right) {
                        overlapX = other.left - this.right;
                    }
                    else {
                        overlapX = other.right - this.left;
                    }
                    var overlapY = 0;
                    if (this.top <= other.bottom && this.top >= other.top) {
                        overlapY = other.bottom - this.top;
                    }
                    else {
                        overlapY = other.top - this.bottom;
                    }
                    if (Math.abs(overlapX) < Math.abs(overlapY)) {
                        return new ex.Vector(overlapX, 0);
                    }
                    else {
                        return new ex.Vector(0, overlapY);
                    }
                }
                else {
                    return null;
                }
            }
            return null;
        };
        BoundingBox.prototype.debugDraw = function (ctx) {
            ctx.lineWidth = 2;
            ctx.strokeRect(this.left, this.top, this.getWidth(), this.getHeight());
        };
        return BoundingBox;
    })();
    ex.BoundingBox = BoundingBox;
    var SATBoundingBox = (function () {
        function SATBoundingBox(points) {
            this._points = points.map(function (p) { return p.toVector(); });
        }
        SATBoundingBox.prototype.getSides = function () {
            var lines = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                lines.push(new ex.Line(this._points[i], this._points[(i + 1) % len]));
            }
            return lines;
        };
        SATBoundingBox.prototype.getAxes = function () {
            var axes = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                axes.push(this._points[i].minus(this._points[(i + 1) % len]).normal());
            }
            return axes;
        };
        SATBoundingBox.prototype.project = function (axis) {
            var scalars = [];
            var len = this._points.length;
            for (var i = 0; i < len; i++) {
                scalars.push(this._points[i].dot(axis));
            }
            return new ex.Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
        };
        /**
         * Returns the calculated width of the bounding box, by generating an axis aligned box around the current
         * @method getWidth
         * @returns number
         */
        SATBoundingBox.prototype.getWidth = function () {
            var left = this._points.reduce(function (accum, p, i, arr) {
                return Math.min(accum, p.x);
            }, Infinity);
            var right = this._points.reduce(function (accum, p, i, arr) {
                return Math.max(accum, p.x);
            }, -Infinity);
            return right - left;
        };
        /**
         * Returns the calculated height of the bounding box, by generating an axis aligned box around the current
         * @method getHeight
         * @returns number
         */
        SATBoundingBox.prototype.getHeight = function () {
            var top = this._points.reduce(function (accum, p, i, arr) {
                return Math.min(accum, p.y);
            }, Infinity);
            var bottom = this._points.reduce(function (accum, p, i, arr) {
                return Math.max(accum, p.y);
            }, -Infinity);
            return top - bottom;
        };
        /**
         * Tests wether a point is contained within the bounding box, using the PIP algorithm
         * http://en.wikipedia.org/wiki/Point_in_polygon
         * @method contains
         * @param p {Point} The point to test
         * @returns boolean
         */
        SATBoundingBox.prototype.contains = function (p) {
            // Always cast to the right, as long as we cast in a consitent fixed direction we
            // will be fine
            var testRay = new ex.Ray(p, new ex.Vector(1, 0));
            var intersectCount = this.getSides().reduce(function (accum, side, i, arr) {
                if (testRay.intersect(side) >= 0) {
                    return accum + 1;
                }
                return accum;
            }, 0);
            if (intersectCount % 2 === 0) {
                return false;
            }
            return true;
        };
        SATBoundingBox.prototype.collides = function (collidable) {
            if (collidable instanceof SATBoundingBox) {
                var other = collidable;
                var axes = this.getAxes();
                axes = other.getAxes().concat(axes);
                var minOverlap = 99999;
                var minAxis = null;
                for (var i = 0; i < axes.length; i++) {
                    var proj1 = this.project(axes[i]);
                    var proj2 = other.project(axes[i]);
                    var overlap = proj1.getOverlap(proj2);
                    if (overlap === 0) {
                        return null;
                    }
                    else {
                        if (overlap <= minOverlap) {
                            minOverlap = overlap;
                            minAxis = axes[i];
                        }
                    }
                }
                if (minAxis) {
                    return minAxis.normalize().scale(minOverlap);
                }
                else {
                    return null;
                }
            }
            return null;
        };
        SATBoundingBox.prototype.debugDraw = function (ctx) {
            ctx.beginPath();
            ctx.lineWidth = 2;
            // Iterate through the supplied points and contruct a 'polygon'
            var firstPoint = this._points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this._points.forEach(function (point) {
                ctx.lineTo(point.x, point.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            ctx.strokeStyle = ex.Color.Blue.toString();
            ctx.stroke();
        };
        return SATBoundingBox;
    })();
    ex.SATBoundingBox = SATBoundingBox;
})(ex || (ex = {}));
/// <reference path="Events.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur base class
     * @class Class
     * @constructor
     */
    var Class = (function () {
        function Class() {
            this.eventDispatcher = new ex.EventDispatcher(this);
        }
        /**
         * Add an event listener. You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method addEventListener
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Class.prototype.addEventListener = function (eventName, handler) {
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * Removes an event listener. If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified just that handler will be removed.
         *
         * @method removeEventListener
         * @param eventName {string} Name of the event to listen for
         * @param [handler=undefined] {event=>void} Event handler for the thrown event
         */
        Class.prototype.removeEventListener = function (eventName, handler) {
            this.eventDispatcher.unsubscribe(eventName, handler);
        };
        /**
         * Alias for "addEventListener". You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method on
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Class.prototype.on = function (eventName, handler) {
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * Alias for "removeEventListener". If only the eventName is specified
         * it will remove all handlers registered for that specific event. If the eventName
         * and the handler instance are specified only that handler will be removed.
         *
         * @method off
         * @param eventName {string} Name of the event to listen for
         * @param [handler=undefined] {event=>void} Event handler for the thrown event
         */
        Class.prototype.off = function (eventName, handler) {
            this.eventDispatcher.unsubscribe(eventName, handler);
        };
        /**
         * You may wish to extend native Excalibur functionality. Any method on
         * actor may be extended to support additional functionaliy. In the
         * example below we create a new type called "MyActor"
         * <br/><b>Example</b><pre>var MyActor = Actor.extend({
     constructor : function(){
        this.newprop = 'something';
        Actor.apply(this, arguments);
     },
     update : function(engine, delta){
        // Implement custom update
  
           // Call super constructor update
           Actor.prototype.update.call(this, engine, delta);
           console.log("Something cool!");
     }
  });
  var myActor = new MyActor(100, 100, 100, 100, Color.Azure);</pre>
         * @method extend
         * @static
         * @param methods {any}
         */
        Class.extend = function (methods) {
            var parent = this;
            var child;
            if (methods && methods.hasOwnProperty('constructor')) {
                child = methods.constructor;
            }
            else {
                child = function () {
                    return parent.apply(this, arguments);
                };
            }
            // Using constructor allows JS to lazily instantiate super classes
            var Super = function () {
                this.constructor = child;
            };
            Super.prototype = parent.prototype;
            child.prototype = new Super;
            if (methods) {
                for (var prop in methods) {
                    if (methods.hasOwnProperty(prop)) {
                        child.prototype[prop] = methods[prop];
                    }
                }
            }
            // Make subclasses extendable
            child.extend = Class.extend;
            return child;
        };
        return Class;
    })();
    ex.Class = Class;
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Timer = (function () {
        /**
         * The Excalibur timer hooks into the internal timer and fires callbacks, after a certain interval, optionally repeating.
         *
         * @class Timer
         * @constructor
         * @param callback {callback} The callback to be fired after the interval is complete.
         * @param [repeats=false] {boolean} Indicates whether this call back should be fired only once, or repeat after every interval as completed.
         */
        function Timer(fcn, interval, repeats) {
            this.id = 0;
            this.interval = 10;
            this.fcn = function () {
            };
            this.repeats = false;
            this.elapsedTime = 0;
            this._totalTimeAlive = 0;
            this.complete = false;
            this.scene = null;
            this.id = Timer.id++;
            this.interval = interval || this.interval;
            this.fcn = fcn || this.fcn;
            this.repeats = repeats || this.repeats;
        }
        /**
         * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
         * @method update
         * @param delta {number} Number of elapsed milliseconds since the last update.
         */
        Timer.prototype.update = function (delta) {
            this._totalTimeAlive += delta;
            this.elapsedTime += delta;
            if (this.elapsedTime > this.interval) {
                this.fcn.call(this);
                if (this.repeats) {
                    this.elapsedTime = 0;
                }
                else {
                    this.complete = true;
                }
            }
        };
        Timer.prototype.getTimeRunning = function () {
            return this._totalTimeAlive;
        };
        /**
         * Cancels the timer, preventing any further executions.
         * @method cancel
         */
        Timer.prototype.cancel = function () {
            if (this.scene) {
                this.scene.cancelTimer(this);
            }
        };
        Timer.id = 0;
        return Timer;
    })();
    ex.Timer = Timer;
})(ex || (ex = {}));
/// <reference path="../Actor.ts"/>
/// <reference path="Side.ts"/>
/// <reference path="ICollisionResolver.ts"/> 
var ex;
(function (ex) {
    var NaiveCollisionResolver = (function () {
        function NaiveCollisionResolver() {
        }
        NaiveCollisionResolver.prototype.register = function (target) {
            // pass
        };
        NaiveCollisionResolver.prototype.remove = function (tartet) {
            // pass
        };
        NaiveCollisionResolver.prototype.evaluate = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== 0 /* PreventCollision */;
            });
            var actor1;
            var actor2;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor1 = potentialColliders[j];
                for (var i = j + 1; i < l; i++) {
                    actor2 = potentialColliders[i];
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor1.collides(actor2)) {
                        var side = actor1.getSideFromIntersect(minimumTranslationVector);
                        var collisionPair = new ex.CollisionPair(actor1, actor2, minimumTranslationVector, side);
                        if (!collisionPairs.some(function (cp) {
                            return cp.equals(collisionPair);
                        })) {
                            collisionPairs.push(collisionPair);
                        }
                    }
                }
            }
            collisionPairs.forEach(function (p) { return p.evaluate(); });
            return collisionPairs;
        };
        NaiveCollisionResolver.prototype.update = function (targets) {
            return 0;
        };
        NaiveCollisionResolver.prototype.debugDraw = function (ctx, delta) {
        };
        return NaiveCollisionResolver;
    })();
    ex.NaiveCollisionResolver = NaiveCollisionResolver;
})(ex || (ex = {}));
/// <reference path="BoundingBox.ts"/>
var ex;
(function (ex) {
    var TreeNode = (function () {
        function TreeNode(parent) {
            this.parent = parent;
            this.parent = parent || null;
            this.actor = null;
            this.bounds = new ex.BoundingBox();
            this.left = null;
            this.right = null;
            this.height = 0;
        }
        TreeNode.prototype.isLeaf = function () {
            return (!this.left && !this.right);
        };
        return TreeNode;
    })();
    ex.TreeNode = TreeNode;
    var DynamicTree = (function () {
        function DynamicTree() {
            this.root = null;
            this.nodes = {};
        }
        DynamicTree.prototype.insert = function (leaf) {
            // If there are no nodes in the tree, make this the root leaf
            if (this.root === null) {
                this.root = leaf;
                this.root.parent = null;
                return;
            }
            // Search the tree for a node that is not a leaf and find the best place to insert
            var leafAABB = leaf.bounds;
            var currentRoot = this.root;
            while (!currentRoot.isLeaf()) {
                var left = currentRoot.left;
                var right = currentRoot.right;
                var area = currentRoot.bounds.getPerimeter();
                var combinedAABB = currentRoot.bounds.combine(leafAABB);
                var combinedArea = combinedAABB.getPerimeter();
                // Calculate cost heuristic for creating a new parent and leaf
                var cost = 2 * combinedArea;
                // Minimum cost of pushing the leaf down the tree
                var inheritanceCost = 2 * (combinedArea - area);
                // Cost of descending
                var leftCost = 0;
                var leftCombined = leafAABB.combine(left.bounds);
                var newArea;
                var oldArea;
                if (left.isLeaf()) {
                    leftCost = leftCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = left.bounds.getPerimeter();
                    newArea = leftCombined.getPerimeter();
                    leftCost = (newArea - oldArea) + inheritanceCost;
                }
                var rightCost = 0;
                var rightCombined = leafAABB.combine(right.bounds);
                if (right.isLeaf()) {
                    rightCost = rightCombined.getPerimeter() + inheritanceCost;
                }
                else {
                    oldArea = right.bounds.getPerimeter();
                    newArea = rightCombined.getPerimeter();
                    rightCost = (newArea - oldArea) + inheritanceCost;
                }
                // cost is acceptable
                if (cost < leftCost && cost < rightCost) {
                    break;
                }
                // Descend to the depths
                if (leftCost < rightCost) {
                    currentRoot = left;
                }
                else {
                    currentRoot = right;
                }
            }
            // Create the new parent node and insert into the tree
            var oldParent = currentRoot.parent;
            var newParent = new TreeNode(oldParent);
            newParent.bounds = leafAABB.combine(currentRoot.bounds);
            newParent.height = currentRoot.height + 1;
            if (oldParent !== null) {
                // The sibling node was not the root
                if (oldParent.left === currentRoot) {
                    oldParent.left = newParent;
                }
                else {
                    oldParent.right = newParent;
                }
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
            }
            else {
                // The sibling node was the root
                newParent.left = currentRoot;
                newParent.right = leaf;
                currentRoot.parent = newParent;
                leaf.parent = newParent;
                this.root = newParent;
            }
            // Walk up the tree fixing heights and AABBs
            var currentNode = leaf.parent;
            while (currentNode) {
                currentNode = this.balance(currentNode);
                if (!currentNode.left) {
                    throw new Error("Parent of current leaf cannot have a null left child" + currentNode);
                }
                if (!currentNode.right) {
                    throw new Error("Parent of current leaf cannot have a null right child" + currentNode);
                }
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode = currentNode.parent;
            }
        };
        DynamicTree.prototype.remove = function (leaf) {
            if (leaf === this.root) {
                this.root = null;
                return;
            }
            var parent = leaf.parent;
            var grandParent = parent.parent;
            var sibling;
            if (parent.left === leaf) {
                sibling = parent.right;
            }
            else {
                sibling = parent.left;
            }
            if (grandParent) {
                if (grandParent.left === parent) {
                    grandParent.left = sibling;
                }
                else {
                    grandParent.right = sibling;
                }
                sibling.parent = grandParent;
                var currentNode = grandParent;
                while (currentNode) {
                    currentNode = this.balance(currentNode);
                    currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                    currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                    currentNode = currentNode.parent;
                }
            }
            else {
                this.root = sibling;
                sibling.parent = null;
            }
        };
        DynamicTree.prototype.registerActor = function (actor) {
            var node = new TreeNode();
            node.actor = actor;
            node.bounds = actor.getBounds();
            node.bounds.left -= 2;
            node.bounds.top -= 2;
            node.bounds.right += 2;
            node.bounds.bottom += 2;
            this.nodes[actor.id] = node;
            this.insert(node);
        };
        DynamicTree.prototype.updateActor = function (actor) {
            var node = this.nodes[actor.id];
            if (!node)
                return;
            var b = actor.getBounds();
            if (node.bounds.contains(b)) {
                return false;
            }
            this.remove(node);
            b.left -= 5;
            b.top -= 5;
            b.right += 5;
            b.bottom += 5;
            var multdx = actor.dx * 2;
            var multdy = actor.dy * 2;
            if (multdx < 0) {
                b.left += multdx;
            }
            else {
                b.right += multdx;
            }
            if (multdy < 0) {
                b.top += multdy;
            }
            else {
                b.bottom += multdy;
            }
            node.bounds = b;
            this.insert(node);
            return true;
        };
        DynamicTree.prototype.removeActor = function (actor) {
            var node = this.nodes[actor.id];
            if (!node)
                return;
            this.remove(node);
            this.nodes[actor.id] = null;
            delete this.nodes[actor.id];
        };
        DynamicTree.prototype.balance = function (node) {
            if (node === null) {
                throw new Error("Cannot balance at null node");
            }
            if (node.isLeaf() || node.height < 2) {
                return node;
            }
            var left = node.left;
            var right = node.right;
            var a = node;
            var b = left;
            var c = right;
            var d = left.left;
            var e = left.right;
            var f = right.left;
            var g = right.right;
            var balance = c.height - b.height;
            // Rotate c node up
            if (balance > 1) {
                // Swap the right node with it's parent
                c.left = a;
                c.parent = a.parent;
                a.parent = c;
                // The original node's old parent should point to the right node
                // this is mega confusing
                if (c.parent) {
                    if (c.parent.left === a) {
                        c.parent.left = c;
                    }
                    else {
                        c.parent.right = c;
                    }
                }
                else {
                    this.root = c;
                }
                // Rotate
                if (f.height > g.height) {
                    c.right = f;
                    a.right = g;
                    g.parent = a;
                    a.bounds = b.bounds.combine(g.bounds);
                    c.bounds = a.bounds.combine(f.bounds);
                    a.height = 1 + Math.max(b.height, g.height);
                    c.height = 1 + Math.max(a.height, f.height);
                }
                else {
                    c.right = g;
                    a.right = f;
                    f.parent = a;
                    a.bounds = b.bounds.combine(f.bounds);
                    c.bounds = a.bounds.combine(g.bounds);
                    a.height = 1 + Math.max(b.height, f.height);
                    c.height = 1 + Math.max(a.height, g.height);
                }
                return c;
            }
            // Rotate left node up
            if (balance < -1) {
                // swap
                b.left = a;
                b.parent = a.parent;
                a.parent = b;
                // node's old parent should point to b
                if (b.parent) {
                    if (b.parent.left === a) {
                        b.parent.left = b;
                    }
                    else {
                        if (b.parent.right !== a)
                            throw "Error rotating Dynamic Tree";
                        b.parent.right = b;
                    }
                }
                else {
                    this.root = b;
                }
                // rotate
                if (d.height > e.height) {
                    b.right = d;
                    a.left = e;
                    e.parent = a;
                    a.bounds = c.bounds.combine(e.bounds);
                    b.bounds = a.bounds.combine(d.bounds);
                    a.height = 1 + Math.max(c.height, e.height);
                    b.height = 1 + Math.max(a.height, d.height);
                }
                else {
                    b.right = e;
                    a.left = d;
                    d.parent = a;
                    a.bounds = c.bounds.combine(d.bounds);
                    b.bounds = a.bounds.combine(e.bounds);
                    a.height = 1 + Math.max(c.height, d.height);
                    b.height = 1 + Math.max(a.height, e.height);
                }
                return b;
            }
            return node;
        };
        DynamicTree.prototype.getHeight = function () {
            if (this.root === null) {
                return 0;
            }
            return this.root.height;
        };
        DynamicTree.prototype.query = function (actor, callback) {
            var bounds = actor.getBounds();
            var helper = function (currentNode) {
                if (currentNode && currentNode.bounds.collides(bounds)) {
                    if (currentNode.isLeaf() && currentNode.actor !== actor) {
                        if (callback.call(actor, currentNode.actor)) {
                            return true;
                        }
                    }
                    else {
                        return helper(currentNode.left) || helper(currentNode.right);
                    }
                }
                else {
                    return null;
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.rayCast = function (ray, max) {
            // todo implement
            return null;
        };
        DynamicTree.prototype.getNodes = function () {
            var helper = function (currentNode) {
                if (currentNode) {
                    return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
                }
                else {
                    return [];
                }
            };
            return helper(this.root);
        };
        DynamicTree.prototype.debugDraw = function (ctx, delta) {
            // draw all the nodes in the Dynamic Tree
            var helper = function (currentNode) {
                if (currentNode) {
                    if (currentNode.isLeaf()) {
                        ctx.strokeStyle = 'green';
                    }
                    else {
                        ctx.strokeStyle = 'white';
                    }
                    currentNode.bounds.debugDraw(ctx);
                    if (currentNode.left)
                        helper(currentNode.left);
                    if (currentNode.right)
                        helper(currentNode.right);
                }
            };
            helper(this.root);
        };
        return DynamicTree;
    })();
    ex.DynamicTree = DynamicTree;
})(ex || (ex = {}));
/// <reference path="ICollisionResolver.ts"/>
/// <reference path="DynamicTree.ts"/>
var ex;
(function (ex) {
    var DynamicTreeCollisionResolver = (function () {
        function DynamicTreeCollisionResolver() {
            this._dynamicCollisionTree = new ex.DynamicTree();
        }
        DynamicTreeCollisionResolver.prototype.register = function (target) {
            this._dynamicCollisionTree.registerActor(target);
        };
        DynamicTreeCollisionResolver.prototype.remove = function (target) {
            this._dynamicCollisionTree.removeActor(target);
        };
        DynamicTreeCollisionResolver.prototype.evaluate = function (targets) {
            // Retrieve the list of potential colliders, exclude killed, prevented, and self
            var potentialColliders = targets.filter(function (other) {
                return !other.isKilled() && other.collisionType !== 0 /* PreventCollision */;
            });
            var actor;
            var collisionPairs = [];
            for (var j = 0, l = potentialColliders.length; j < l; j++) {
                actor = potentialColliders[j];
                this._dynamicCollisionTree.query(actor, function (other) {
                    if (other.collisionType === 0 /* PreventCollision */ || other.isKilled())
                        return false;
                    var minimumTranslationVector;
                    if (minimumTranslationVector = actor.collides(other)) {
                        var side = actor.getSideFromIntersect(minimumTranslationVector);
                        var collisionPair = new ex.CollisionPair(actor, other, minimumTranslationVector, side);
                        if (!collisionPairs.some(function (cp) {
                            return cp.equals(collisionPair);
                        })) {
                            collisionPairs.push(collisionPair);
                        }
                        return true;
                    }
                    return false;
                });
            }
            collisionPairs.forEach(function (p) { return p.evaluate(); });
            return collisionPairs;
        };
        DynamicTreeCollisionResolver.prototype.update = function (targets) {
            var _this = this;
            var updated = 0;
            targets.forEach(function (a) {
                if (_this._dynamicCollisionTree.updateActor(a)) {
                    updated++;
                }
            });
            return updated;
        };
        DynamicTreeCollisionResolver.prototype.debugDraw = function (ctx, delta) {
            this._dynamicCollisionTree.debugDraw(ctx, delta);
        };
        return DynamicTreeCollisionResolver;
    })();
    ex.DynamicTreeCollisionResolver = DynamicTreeCollisionResolver;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Collision pairs are used internally by Excalibur to resolve collision between actors. The
     * Pair prevents collisions from being evaluated more than one time
     * @class CollisionPair
     * @constructor
     * @param left {Actor} The first actor in the collision pair
     * @param right {Actor} The second actor in the collision pair
     * @param intersect {Vector} The minimum translation vector to separate the actors from the perspective of the left actor
     * @param side {Side} The side on which the collision occured from the perspective of the left actor
     */
    var CollisionPair = (function () {
        function CollisionPair(left, right, intersect, side) {
            this.left = left;
            this.right = right;
            this.intersect = intersect;
            this.side = side;
        }
        /**
         * Determines if this collision pair and another are equivalent.
         * @method equals
         * @param collisionPair {CollisionPair}
         * @returns boolean
         */
        CollisionPair.prototype.equals = function (collisionPair) {
            return (collisionPair.left === this.left && collisionPair.right === this.right) || (collisionPair.right === this.left && collisionPair.left === this.right);
        };
        /**
         * Evaluates the collision pair, performing collision resolution and event publishing appropriate to each collision type.
         * @method evaluate
         */
        CollisionPair.prototype.evaluate = function () {
            // todo fire collision events on left and right actor
            // todo resolve collisions                  
            // Publish collision events on both participants
            this.left.eventDispatcher.publish('collision', new ex.CollisionEvent(this.left, this.right, this.side, this.intersect));
            this.right.eventDispatcher.publish('collision', new ex.CollisionEvent(this.right, this.left, ex.Util.getOppositeSide(this.side), this.intersect.scale(-1.0)));
            // If the actor is active push the actor out if its not passive
            var leftSide = this.side;
            if ((this.left.collisionType === 2 /* Active */ || this.left.collisionType === 3 /* Elastic */) && this.right.collisionType !== 1 /* Passive */) {
                this.left.y += this.intersect.y;
                this.left.x += this.intersect.x;
                // Naive elastic bounce
                if (this.left.collisionType === 3 /* Elastic */) {
                    if (leftSide === 3 /* Left */) {
                        this.left.dx = Math.abs(this.left.dx);
                    }
                    else if (leftSide === 4 /* Right */) {
                        this.left.dx = -Math.abs(this.left.dx);
                    }
                    else if (leftSide === 1 /* Top */) {
                        this.left.dy = Math.abs(this.left.dy);
                    }
                    else if (leftSide === 2 /* Bottom */) {
                        this.left.dy = -Math.abs(this.left.dy);
                    }
                }
            }
            var rightSide = ex.Util.getOppositeSide(this.side);
            var rightIntersect = this.intersect.scale(-1.0);
            if ((this.right.collisionType === 2 /* Active */ || this.right.collisionType === 3 /* Elastic */) && this.left.collisionType !== 1 /* Passive */) {
                this.right.y += rightIntersect.y;
                this.right.x += rightIntersect.x;
                // Naive elastic bounce
                if (this.right.collisionType === 3 /* Elastic */) {
                    if (rightSide === 3 /* Left */) {
                        this.right.dx = Math.abs(this.right.dx);
                    }
                    else if (rightSide === 4 /* Right */) {
                        this.right.dx = -Math.abs(this.right.dx);
                    }
                    else if (rightSide === 1 /* Top */) {
                        this.right.dy = Math.abs(this.right.dy);
                    }
                    else if (rightSide === 2 /* Bottom */) {
                        this.right.dy = -Math.abs(this.right.dy);
                    }
                }
            }
        };
        return CollisionPair;
    })();
    ex.CollisionPair = CollisionPair;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Algebra.ts" />
var ex;
(function (ex) {
    /**
    * A base implementation of a camera. This class is meant to be extended.
    * @class Camera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var BaseCamera = (function () {
        function BaseCamera() {
            this.focus = new ex.Point(0, 0);
            this.lerp = false;
            this._cameraMoving = false;
            this._currentLerpTime = 0;
            this._lerpDuration = 1 * 1000; // 5 seconds
            this._totalLerpTime = 0;
            this._lerpStart = null;
            this._lerpEnd = null;
            //camera effects
            this.isShaking = false;
            this.shakeMagnitudeX = 0;
            this.shakeMagnitudeY = 0;
            this.shakeDuration = 0;
            this.elapsedShakeTime = 0;
            this.isZooming = false;
            this.currentZoomScale = 1;
            this.maxZoomScale = 1;
            this.zoomDuration = 0;
            this.elapsedZoomTime = 0;
            this.zoomIncrement = 0.01;
        }
        BaseCamera.prototype.easeInOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime * currentTime + startValue;
            currentTime -= 2;
            return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
        };
        /**
        * Sets the {{#crossLink Actor}}{{/crossLink}} to follow with the camera
        * @method setActorToFollow
        * @param actor {Actor} The actor to follow
        */
        BaseCamera.prototype.setActorToFollow = function (actor) {
            this.follow = actor;
        };
        /**
        * Returns the focal point of the camera
        * @method getFocus
        * @returns Point
        */
        BaseCamera.prototype.getFocus = function () {
            return this.focus;
        };
        /**
        * Sets the focal point of the camera. This value can only be set if there is no actor to be followed.
        * @method setFocus
        * @param x {number} The x coordinate of the focal point
        * @param y {number} The y coordinate of the focal point
        */
        BaseCamera.prototype.setFocus = function (x, y) {
            if (!this.follow && !this.lerp) {
                this.focus.x = x;
                this.focus.y = y;
            }
            if (this.lerp) {
                this._lerpStart = this.focus.clone();
                this._lerpEnd = new ex.Point(x, y);
                this._currentLerpTime = 0;
                this._cameraMoving = true;
            }
        };
        /**
        * Sets the camera to shake at the specified magnitudes for the specified duration
        * @method shake
        * @param magnitudeX {number} the x magnitude of the shake
        * @param magnitudeY {number} the y magnitude of the shake
        * @param duration {number} the duration of the shake
        */
        BaseCamera.prototype.shake = function (magnitudeX, magnitudeY, duration) {
            this.isShaking = true;
            this.shakeMagnitudeX = magnitudeX;
            this.shakeMagnitudeY = magnitudeY;
            this.shakeDuration = duration;
        };
        /**
        * Zooms the camera in or out by the specified scale over the specified duration.
        * If no duration is specified, it will zoom by a set amount until the scale is reached.
        * @method zoom
        * @param scale {number} the scale of the zoom
        * @param [duration] {number} the duration of the zoom
        */
        BaseCamera.prototype.zoom = function (scale, duration) {
            this.isZooming = true;
            this.maxZoomScale = scale;
            this.zoomDuration = duration | 0;
            if (duration) {
                this.zoomIncrement = Math.abs(this.maxZoomScale - this.currentZoomScale) / duration * 1000;
            }
            if (this.maxZoomScale < 1) {
                if (duration) {
                    this.zoomIncrement = -1 * this.zoomIncrement;
                }
                else {
                    this.isZooming = false;
                    this.setCurrentZoomScale(this.maxZoomScale);
                }
            }
            else {
                if (!duration) {
                    this.isZooming = false;
                    this.setCurrentZoomScale(this.maxZoomScale);
                }
            }
            // console.log("zoom increment: " + this.zoomIncrement);
        };
        /**
        * gets the current zoom scale
        * @method getZoom
        * @returns {Number} the current zoom scale
        */
        BaseCamera.prototype.getZoom = function () {
            return this.currentZoomScale;
        };
        BaseCamera.prototype.setCurrentZoomScale = function (zoomScale) {
            this.currentZoomScale = zoomScale;
        };
        /**
        * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
        * @method update
        * @param delta {number} The number of milliseconds since the last update
        */
        BaseCamera.prototype.update = function (ctx, delta) {
            var focus = this.getFocus();
            var xShake = 0;
            var yShake = 0;
            var canvasWidth = ctx.canvas.width;
            var canvasHeight = ctx.canvas.height;
            var newCanvasWidth = canvasWidth * this.getZoom();
            var newCanvasHeight = canvasHeight * this.getZoom();
            if (this.lerp) {
                if (this._currentLerpTime < this._lerpDuration && this._cameraMoving) {
                    if (this._lerpEnd.x < this._lerpStart.x) {
                        this.focus.x = this._lerpStart.x - (this.easeInOutCubic(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                    }
                    else {
                        this.focus.x = this.easeInOutCubic(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                    }
                    if (this._lerpEnd.y < this._lerpStart.y) {
                        this.focus.y = this._lerpStart.y - (this.easeInOutCubic(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                    }
                    else {
                        this.focus.y = this.easeInOutCubic(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                    }
                    this._currentLerpTime += delta;
                }
                else {
                    this._lerpStart = null;
                    this._lerpEnd = null;
                    this._currentLerpTime = 0;
                    this._cameraMoving = false;
                }
            }
            if (this.isDoneShaking()) {
                this.isShaking = false;
                this.elapsedShakeTime = 0;
                this.shakeMagnitudeX = 0;
                this.shakeMagnitudeY = 0;
                this.shakeDuration = 0;
            }
            else {
                this.elapsedShakeTime += delta;
                xShake = (Math.random() * this.shakeMagnitudeX | 0) + 1;
                yShake = (Math.random() * this.shakeMagnitudeY | 0) + 1;
            }
            ctx.translate(-focus.x + xShake + (newCanvasWidth / 2), -focus.y + yShake + (newCanvasHeight / 2));
            if (this.isDoneZooming()) {
                this.isZooming = false;
                this.elapsedZoomTime = 0;
                this.zoomDuration = 0;
                this.setCurrentZoomScale(this.maxZoomScale);
            }
            else {
                this.elapsedZoomTime += delta;
                this.setCurrentZoomScale(this.getZoom() + this.zoomIncrement * delta / 1000);
            }
            ctx.scale(this.getZoom(), this.getZoom());
        };
        BaseCamera.prototype.debugDraw = function (ctx) {
            var focus = this.getFocus();
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        BaseCamera.prototype.isDoneShaking = function () {
            return !(this.isShaking) || (this.elapsedShakeTime >= this.shakeDuration);
        };
        BaseCamera.prototype.isDoneZooming = function () {
            if (this.zoomDuration != 0) {
                return (this.elapsedZoomTime >= this.zoomDuration);
            }
            else {
                if (this.maxZoomScale < 1) {
                    return (this.currentZoomScale <= this.maxZoomScale);
                }
                else {
                    return (this.currentZoomScale >= this.maxZoomScale);
                }
            }
        };
        return BaseCamera;
    })();
    ex.BaseCamera = BaseCamera;
    /**
    * An extension of BaseCamera that is locked vertically; it will only move side to side.
    * @class SideCamera
    * @extends BaseCamera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var SideCamera = (function (_super) {
        __extends(SideCamera, _super);
        function SideCamera() {
            _super.apply(this, arguments);
        }
        SideCamera.prototype.getFocus = function () {
            if (this.follow) {
                return new ex.Point(this.follow.x + this.follow.getWidth() / 2, this.focus.y);
            }
            else {
                return this.focus;
            }
        };
        return SideCamera;
    })(BaseCamera);
    ex.SideCamera = SideCamera;
    /**
    * An extension of BaseCamera that is locked to an actor or focal point; the actor will appear in the center of the screen.
    * @class TopCamera
    * @extends BaseCamera
    * @constructor
    * @param engine {Engine} Reference to the current engine
    */
    var TopCamera = (function (_super) {
        __extends(TopCamera, _super);
        function TopCamera() {
            _super.apply(this, arguments);
        }
        TopCamera.prototype.getFocus = function () {
            if (this.follow) {
                return new ex.Point(this.follow.x + this.follow.getWidth() / 2, this.follow.y + this.follow.getHeight() / 2);
            }
            else {
                return this.focus;
            }
        };
        return TopCamera;
    })(BaseCamera);
    ex.TopCamera = TopCamera;
})(ex || (ex = {}));
/// <reference path="Class.ts" />
/// <reference path="Timer.ts" />
/// <reference path="Collision/NaiveCollisionResolver.ts"/>
/// <reference path="Collision/DynamicTreeCollisionResolver.ts"/>
/// <reference path="CollisionPair.ts" />
/// <reference path="Camera.ts" />
var ex;
(function (ex) {
    /**
     * Actors are composed together into groupings called Scenes in
     * Excalibur. The metaphor models the same idea behind real world
     * actors in a scene. Only actors in scenes will be updated and drawn.
     * @class Scene
     * @constructor
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(engine) {
            _super.call(this);
            /**
             * The actors in the current scene
             * @property children {Actor[]}
             */
            this.children = [];
            this.tileMaps = [];
            this.uiActors = [];
            this._collisionResolver = new ex.DynamicTreeCollisionResolver();
            this._killQueue = [];
            this._timers = [];
            this._cancelQueue = [];
            this._isInitialized = false;
            this.camera = new ex.BaseCamera();
            if (engine) {
                this.camera.setFocus(engine.width / 2, engine.height / 2);
            }
        }
        /**
         * This is called when the scene is made active and started. It is meant to be overriden,
         * this is where you should setup any DOM UI or event handlers needed for the scene.
         * @method onActivate
         */
        Scene.prototype.onActivate = function () {
            // will be overridden
        };
        /**
         * This is called when the scene is made transitioned away from and stopped. It is meant to be overriden,
         * this is where you should cleanup any DOM UI or event handlers needed for the scene.
         * @method onDeactivate
         */
        Scene.prototype.onDeactivate = function () {
            // will be overridden
        };
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         * @method onInitialize
         * @param engine {Engine}
         */
        Scene.prototype.onInitialize = function (engine) {
            // will be overridden
        };
        /**
         * Publish an event to all actors in the scene
         * @method publish
         * @param eventType {string} The name of the event to publish
         * @param event {GameEvent} The event object to send
         */
        Scene.prototype.publish = function (eventType, event) {
            this.children.forEach(function (actor) {
                actor.triggerEvent(eventType, event);
            });
        };
        /**
         * Updates all the actors and timers in the Scene. Called by the Engine.
         * @method update
         * @param engine {Engine} Reference to the current Engine
         * @param delta {number} The number of milliseconds since the last update
         */
        Scene.prototype.update = function (engine, delta) {
            if (!this._isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.publish('initialize', new ex.InitializeEvent(engine));
                this._isInitialized = true;
            }
            this.uiActors.forEach(function (ui) {
                ui.update(engine, delta);
            });
            this.tileMaps.forEach(function (cm) {
                cm.update(engine, delta);
            });
            var len = 0;
            for (var i = 0, len = this.children.length; i < len; i++) {
                this.children[i].update(engine, delta);
            }
            // Run collision resolution strategy
            if (this._collisionResolver) {
                this._collisionResolver.update(this.children);
                this._collisionResolver.evaluate(this.children);
            }
            // Remove actors from scene graph after being killed
            var actorIndex = 0;
            for (var i = 0, len = this._killQueue.length; i < len; i++) {
                actorIndex = this.children.indexOf(this._killQueue[i]);
                if (actorIndex > -1) {
                    this.children.splice(actorIndex, 1);
                }
            }
            this._killQueue.length = 0;
            // Remove timers in the cancel queue before updating them
            var timerIndex = 0;
            for (var i = 0, len = this._cancelQueue.length; i < len; i++) {
                this.removeTimer(this._cancelQueue[i]);
            }
            this._cancelQueue.length = 0;
            // Cycle through timers updating timers
            var that = this;
            this._timers = this._timers.filter(function (timer) {
                timer.update(delta);
                return !timer.complete;
            });
        };
        /**
         * Draws all the actors in the Scene. Called by the Engine.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         * @param delta {number} The number of milliseconds since the last draw
         */
        Scene.prototype.draw = function (ctx, delta) {
            ctx.save();
            if (this.camera) {
                this.camera.update(ctx, delta);
            }
            this.tileMaps.forEach(function (cm) {
                cm.draw(ctx, delta);
            });
            var len = 0;
            var start = 0;
            var end = 0;
            var actor;
            for (var i = 0, len = this.children.length; i < len; i++) {
                actor = this.children[i];
                // only draw actors that are visible
                if (actor.visible) {
                    this.children[i].draw(ctx, delta);
                }
            }
            if (this.engine && this.engine.isDebug) {
                ctx.strokeStyle = 'yellow';
                this.debugDraw(ctx);
            }
            ctx.restore();
            this.uiActors.forEach(function (ui) {
                if (ui.visible) {
                    ui.draw(ctx, delta);
                }
            });
            if (this.engine && this.engine.isDebug) {
                this.uiActors.forEach(function (ui) {
                    ui.debugDraw(ctx);
                });
            }
        };
        /**
         * Draws all the actors' debug information in the Scene. Called by the Engine.
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The current rendering context
         */
        Scene.prototype.debugDraw = function (ctx) {
            this.tileMaps.forEach(function (map) {
                map.debugDraw(ctx);
            });
            this.children.forEach(function (actor) {
                actor.debugDraw(ctx);
            });
            // todo possibly enable this with excalibur flags features?
            //this._collisionResolver.debugDraw(ctx, 20);
            //this.camera.debugDraw(ctx);
        };
        Scene.prototype.add = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.addUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.addChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.addTileMap(entity);
            }
        };
        Scene.prototype.remove = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.removeUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this._collisionResolver.remove(entity);
                this.removeChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.removeTileMap(entity);
            }
        };
        /**
         * Adds an actor to act as a piece of UI, meaning it is always positioned
         * in screen coordinates. UI actors do not participate in collisions
         * @method addUIActor
         * @param actor {Actor}
         */
        Scene.prototype.addUIActor = function (actor) {
            this.uiActors.push(actor);
        };
        /**
         * Removes an actor as a piec of UI
         * @method removeUIActor
         * @param actor {Actor}
         */
        Scene.prototype.removeUIActor = function (actor) {
            var index = this.uiActors.indexOf(actor);
            if (index > -1) {
                this.uiActors.splice(index, 1);
            }
        };
        /**
         * Adds an actor to the Scene, once this is done the actor will be drawn and updated.
         * @method addChild
         * @param actor {Actor}
         */
        Scene.prototype.addChild = function (actor) {
            this._collisionResolver.register(actor);
            actor.scene = this;
            this.children.push(actor);
            actor.parent = this.actor;
        };
        /**
         * Adds a TileMap to the Scene, once this is done the TileMap will be drawn and updated.
         * @method addTileMap
         * @param tileMap {TileMap}
         */
        Scene.prototype.addTileMap = function (tileMap) {
            this.tileMaps.push(tileMap);
        };
        /**
         * Removes a TileMap from the Scene, it willno longer be drawn or updated.
         * @method removeTileMap
         * @param tileMap {TileMap}
         */
        Scene.prototype.removeTileMap = function (tileMap) {
            var index = this.tileMaps.indexOf(tileMap);
            if (index > -1) {
                this.tileMaps.splice(index, 1);
            }
        };
        /**
         * Removes an actor from the Scene, it will no longer be drawn or updated.
         * @method removeChild
         * @param actor {Actor} The actor to remove
         */
        Scene.prototype.removeChild = function (actor) {
            this._collisionResolver.remove(actor);
            this._killQueue.push(actor);
            actor.parent = null;
        };
        /**
         * Adds a timer to the Scene
         * @method addTimer
         * @param timer {Timer} The timer to add
         * @returns Timer
         */
        Scene.prototype.addTimer = function (timer) {
            this._timers.push(timer);
            timer.scene = this;
            return timer;
        };
        /**
         * Removes a timer to the Scene, can be dangerous
         * @method removeTimer
         * @private
         * @param timer {Timer} The timer to remove
         * @returns Timer
         */
        Scene.prototype.removeTimer = function (timer) {
            var i = this._timers.indexOf(timer);
            if (i !== -1) {
                this._timers.splice(i, 1);
            }
            return timer;
        };
        /**
         * Cancels a timer, removing it from the scene nicely
         * @method cancelTimer
         * @param timer {Timer} The timer to cancel
         * @returns Timer
         */
        Scene.prototype.cancelTimer = function (timer) {
            this._cancelQueue.push(timer);
            return timer;
        };
        /**
         * Tests whether a timer is active in the scene
         * @method isTimerActive
         * @param timer {Timer}
         * @returns boolean
         */
        Scene.prototype.isTimerActive = function (timer) {
            return (this._timers.indexOf(timer) > -1);
        };
        return Scene;
    })(ex.Class);
    ex.Scene = Scene;
})(ex || (ex = {}));
/// <reference path="Algebra.ts" />
/// <reference path="Engine.ts" />
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    var Internal;
    (function (Internal) {
        var Actions;
        (function (Actions) {
            var EaseTo = (function () {
                function EaseTo(actor, x, y, duration, easingFcn) {
                    this.actor = actor;
                    this.easingFcn = easingFcn;
                    this._currentLerpTime = 0;
                    this._lerpDuration = 1 * 1000; // 5 seconds
                    this._lerpStart = new ex.Point(0, 0);
                    this._lerpEnd = new ex.Point(0, 0);
                    this._initialized = false;
                    this._stopped = false;
                    this._distance = 0;
                    this._lerpDuration = duration;
                    this._lerpEnd = new ex.Point(x, y);
                }
                EaseTo.prototype._initialize = function () {
                    this._lerpStart = new ex.Point(this.actor.x, this.actor.y);
                    this._currentLerpTime = 0;
                    this._distance = this._lerpStart.toVector().distance(this._lerpEnd.toVector());
                };
                EaseTo.prototype.update = function (delta) {
                    if (!this._initialized) {
                        this._initialize();
                        this._initialized = true;
                    }
                    var newX = this.actor.x;
                    var newY = this.actor.y;
                    if (this._currentLerpTime < this._lerpDuration) {
                        if (this._lerpEnd.x < this._lerpStart.x) {
                            newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
                        }
                        else {
                            newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
                        }
                        if (this._lerpEnd.y < this._lerpStart.y) {
                            newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
                        }
                        else {
                            newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
                        }
                        this.actor.x = newX;
                        this.actor.y = newY;
                        this._currentLerpTime += delta;
                    }
                    else {
                        this.actor.x = this._lerpEnd.x;
                        this.actor.y = this._lerpEnd.y;
                    }
                };
                EaseTo.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this._lerpStart.toVector()) >= this._distance;
                };
                EaseTo.prototype.reset = function () {
                    this._initialized = false;
                };
                EaseTo.prototype.stop = function () {
                    this._stopped = true;
                };
                return EaseTo;
            })();
            Actions.EaseTo = EaseTo;
            var MoveTo = (function () {
                function MoveTo(actor, destx, desty, speed) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = new ex.Vector(destx, desty);
                    this.speed = speed;
                }
                MoveTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = new ex.Vector(this.actor.x, this.actor.y);
                        this.distance = this.start.distance(this.end);
                        this.dir = this.end.minus(this.start).normalize();
                    }
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                MoveTo.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this.start) >= this.distance;
                };
                MoveTo.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                MoveTo.prototype.reset = function () {
                    this._started = false;
                };
                return MoveTo;
            })();
            Actions.MoveTo = MoveTo;
            var MoveBy = (function () {
                function MoveBy(actor, destx, desty, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = new ex.Vector(destx, desty);
                    if (time <= 0) {
                        ex.Logger.getInstance().error("Attempted to moveBy time less than or equal to zero : " + time);
                        throw new Error("Cannot move in time <= 0");
                    }
                    this.time = time;
                }
                MoveBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = new ex.Vector(this.actor.x, this.actor.y);
                        this.distance = this.start.distance(this.end);
                        this.dir = this.end.minus(this.start).normalize();
                        this.speed = this.distance / (this.time / 1000);
                    }
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                MoveBy.prototype.isComplete = function (actor) {
                    return this._stopped || (new ex.Vector(actor.x, actor.y)).distance(this.start) >= this.distance;
                };
                MoveBy.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                MoveBy.prototype.reset = function () {
                    this._started = false;
                };
                return MoveBy;
            })();
            Actions.MoveBy = MoveBy;
            var Follow = (function () {
                function Follow(actor, actorToFollow, followDistance) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.actorToFollow = actorToFollow;
                    this.current = new ex.Vector(this.actor.x, this.actor.y);
                    this.end = new ex.Vector(actorToFollow.x, actorToFollow.y);
                    this.maximumDistance = (followDistance != undefined) ? followDistance : this.current.distance(this.end);
                    this.speed = 0;
                }
                Follow.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.distanceBetween = this.current.distance(this.end);
                        this.dir = this.end.minus(this.current).normalize();
                    }
                    var actorToFollowSpeed = Math.sqrt(Math.pow(this.actorToFollow.dx, 2) + Math.pow(this.actorToFollow.dy, 2));
                    if (actorToFollowSpeed != 0) {
                        this.speed = actorToFollowSpeed;
                    }
                    this.current.x = this.actor.x;
                    this.current.y = this.actor.y;
                    this.end.x = this.actorToFollow.x;
                    this.end.y = this.actorToFollow.y;
                    this.distanceBetween = this.current.distance(this.end);
                    this.dir = this.end.minus(this.current).normalize();
                    if (this.distanceBetween >= this.maximumDistance) {
                        var m = this.dir.scale(this.speed);
                        this.actor.dx = m.x;
                        this.actor.dy = m.y;
                    }
                    else {
                        this.actor.dx = 0;
                        this.actor.dy = 0;
                    }
                    if (this.isComplete(this.actor)) {
                        // TODO this should never occur
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                Follow.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                Follow.prototype.isComplete = function (actor) {
                    // the actor following should never stop unless specified to do so
                    return this._stopped;
                };
                Follow.prototype.reset = function () {
                    this._started = false;
                };
                return Follow;
            })();
            Actions.Follow = Follow;
            var Meet = (function () {
                function Meet(actor, actorToMeet, speed) {
                    this._started = false;
                    this._stopped = false;
                    this._speedWasSpecified = false;
                    this.actor = actor;
                    this.actorToMeet = actorToMeet;
                    this.current = new ex.Vector(this.actor.x, this.actor.y);
                    this.end = new ex.Vector(actorToMeet.x, actorToMeet.y);
                    this.speed = speed || 0;
                    if (speed != undefined) {
                        this._speedWasSpecified = true;
                    }
                }
                Meet.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.distanceBetween = this.current.distance(this.end);
                        this.dir = this.end.minus(this.current).normalize();
                    }
                    var actorToMeetSpeed = Math.sqrt(Math.pow(this.actorToMeet.dx, 2) + Math.pow(this.actorToMeet.dy, 2));
                    if ((actorToMeetSpeed != 0) && (!this._speedWasSpecified)) {
                        this.speed = actorToMeetSpeed;
                    }
                    this.current.x = this.actor.x;
                    this.current.y = this.actor.y;
                    this.end.x = this.actorToMeet.x;
                    this.end.y = this.actorToMeet.y;
                    this.distanceBetween = this.current.distance(this.end);
                    this.dir = this.end.minus(this.current).normalize();
                    var m = this.dir.scale(this.speed);
                    this.actor.dx = m.x;
                    this.actor.dy = m.y;
                    if (this.isComplete(this.actor)) {
                        // console.log("meeting is complete")
                        this.actor.x = this.end.x;
                        this.actor.y = this.end.y;
                        this.actor.dy = 0;
                        this.actor.dx = 0;
                    }
                };
                Meet.prototype.isComplete = function (actor) {
                    return this._stopped || (this.distanceBetween <= 1);
                };
                Meet.prototype.stop = function () {
                    this.actor.dy = 0;
                    this.actor.dx = 0;
                    this._stopped = true;
                };
                Meet.prototype.reset = function () {
                    this._started = false;
                };
                return Meet;
            })();
            Actions.Meet = Meet;
            var RotateTo = (function () {
                function RotateTo(actor, angleRadians, speed) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = angleRadians;
                    this.speed = speed;
                }
                RotateTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = this.actor.rotation;
                        this.distance = Math.abs(this.end - this.start);
                    }
                    this.actor.rx = this.speed;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.rotation = this.end;
                        this.actor.rx = 0;
                    }
                };
                RotateTo.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.rotation - this.start) >= this.distance);
                };
                RotateTo.prototype.stop = function () {
                    this.actor.rx = 0;
                    this._stopped = true;
                };
                RotateTo.prototype.reset = function () {
                    this._started = false;
                };
                return RotateTo;
            })();
            Actions.RotateTo = RotateTo;
            var RotateBy = (function () {
                function RotateBy(actor, angleRadians, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.end = angleRadians;
                    this.time = time;
                    this.speed = (this.end - this.actor.rotation) / time * 1000;
                }
                RotateBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.start = this.actor.rotation;
                        this.distance = Math.abs(this.end - this.start);
                    }
                    this.actor.rx = this.speed;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.rotation = this.end;
                        this.actor.rx = 0;
                    }
                };
                RotateBy.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.rotation - this.start) >= this.distance);
                };
                RotateBy.prototype.stop = function () {
                    this.actor.rx = 0;
                    this._stopped = true;
                };
                RotateBy.prototype.reset = function () {
                    this._started = false;
                };
                return RotateBy;
            })();
            Actions.RotateBy = RotateBy;
            var ScaleTo = (function () {
                function ScaleTo(actor, scaleX, scaleY, speedX, speedY) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endX = scaleX;
                    this.endY = scaleY;
                    this.speedX = speedX;
                    this.speedY = speedY;
                }
                ScaleTo.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.startX = this.actor.scale.x;
                        this.startY = this.actor.scale.y;
                        this.distanceX = Math.abs(this.endX - this.startX);
                        this.distanceY = Math.abs(this.endY - this.startY);
                    }
                    if (!(Math.abs(this.actor.scale.x - this.startX) >= this.distanceX)) {
                        var directionX = this.endY < this.startY ? -1 : 1;
                        this.actor.sx = this.speedX * directionX;
                    }
                    else {
                        this.actor.sx = 0;
                    }
                    if (!(Math.abs(this.actor.scale.y - this.startY) >= this.distanceY)) {
                        var directionY = this.endY < this.startY ? -1 : 1;
                        this.actor.sy = this.speedY * directionY;
                    }
                    else {
                        this.actor.sy = 0;
                    }
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.scale.x = this.endX;
                        this.actor.scale.y = this.endY;
                        this.actor.sx = 0;
                        this.actor.sy = 0;
                    }
                };
                ScaleTo.prototype.isComplete = function (actor) {
                    return this._stopped || ((Math.abs(this.actor.scale.y - this.startX) >= this.distanceX) && (Math.abs(this.actor.scale.y - this.startY) >= this.distanceY));
                };
                ScaleTo.prototype.stop = function () {
                    this.actor.sx = 0;
                    this.actor.sy = 0;
                    this._stopped = true;
                };
                ScaleTo.prototype.reset = function () {
                    this._started = false;
                };
                return ScaleTo;
            })();
            Actions.ScaleTo = ScaleTo;
            var ScaleBy = (function () {
                function ScaleBy(actor, scaleX, scaleY, time) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endX = scaleX;
                    this.endY = scaleY;
                    this.time = time;
                    this.speedX = (this.endX - this.actor.scale.x) / time * 1000;
                    this.speedY = (this.endY - this.actor.scale.y) / time * 1000;
                }
                ScaleBy.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                        this.startX = this.actor.scale.x;
                        this.startY = this.actor.scale.y;
                        this.distanceX = Math.abs(this.endX - this.startX);
                        this.distanceY = Math.abs(this.endY - this.startY);
                    }
                    var directionX = this.endX < this.startX ? -1 : 1;
                    var directionY = this.endY < this.startY ? -1 : 1;
                    this.actor.sx = this.speedX * directionX;
                    this.actor.sy = this.speedY * directionY;
                    //Logger.getInstance().log("Pos x: " + this.actor.x +"  y:" + this.actor.y, Log.DEBUG);
                    if (this.isComplete(this.actor)) {
                        this.actor.scale.x = this.endX;
                        this.actor.scale.y = this.endY;
                        this.actor.sx = 0;
                        this.actor.sy = 0;
                    }
                };
                ScaleBy.prototype.isComplete = function (actor) {
                    return this._stopped || ((Math.abs(this.actor.scale.x - this.startX) >= this.distanceX) && (Math.abs(this.actor.scale.y - this.startY) >= this.distanceY));
                };
                ScaleBy.prototype.stop = function () {
                    this.actor.sx = 0;
                    this.actor.sy = 0;
                    this._stopped = true;
                };
                ScaleBy.prototype.reset = function () {
                    this._started = false;
                };
                return ScaleBy;
            })();
            Actions.ScaleBy = ScaleBy;
            var Delay = (function () {
                function Delay(actor, delay) {
                    this.elapsedTime = 0;
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.delay = delay;
                }
                Delay.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    this.elapsedTime += delta;
                };
                Delay.prototype.isComplete = function (actor) {
                    return this._stopped || (this.elapsedTime >= this.delay);
                };
                Delay.prototype.stop = function () {
                    this._stopped = true;
                };
                Delay.prototype.reset = function () {
                    this.elapsedTime = 0;
                    this._started = false;
                };
                return Delay;
            })();
            Actions.Delay = Delay;
            var Blink = (function () {
                function Blink(actor, timeVisible, timeNotVisible, numBlinks) {
                    if (numBlinks === void 0) { numBlinks = 1; }
                    this.timeVisible = 0;
                    this.timeNotVisible = 0;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                    this._stopped = false;
                    this._started = false;
                    this.actor = actor;
                    this.timeVisible = timeVisible;
                    this.timeNotVisible = timeNotVisible;
                    this.duration = (timeVisible + timeNotVisible) * numBlinks;
                }
                Blink.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    this.elapsedTime += delta;
                    this.totalTime += delta;
                    if (this.actor.visible && this.elapsedTime >= this.timeVisible) {
                        this.actor.visible = false;
                        this.elapsedTime = 0;
                    }
                    if (!this.actor.visible && this.elapsedTime >= this.timeNotVisible) {
                        this.actor.visible = true;
                        this.elapsedTime = 0;
                    }
                    if (this.isComplete(this.actor)) {
                        this.actor.visible = true;
                    }
                };
                Blink.prototype.isComplete = function (actor) {
                    return this._stopped || (this.totalTime >= this.duration);
                };
                Blink.prototype.stop = function () {
                    this.actor.visible = true;
                    this._stopped = true;
                };
                Blink.prototype.reset = function () {
                    this._started = false;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                };
                return Blink;
            })();
            Actions.Blink = Blink;
            var Fade = (function () {
                function Fade(actor, endOpacity, speed) {
                    this.multiplyer = 1;
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                    this.endOpacity = endOpacity;
                    this.speed = speed;
                    if (endOpacity < actor.opacity) {
                        this.multiplyer = -1;
                    }
                }
                Fade.prototype.update = function (delta) {
                    if (!this._started) {
                        this._started = true;
                    }
                    if (this.speed > 0) {
                        this.actor.opacity += this.multiplyer * (Math.abs(this.actor.opacity - this.endOpacity) * delta) / this.speed;
                    }
                    this.speed -= delta;
                    ex.Logger.getInstance().debug("actor opacity: " + this.actor.opacity);
                    if (this.isComplete(this.actor)) {
                        this.actor.opacity = this.endOpacity;
                    }
                };
                Fade.prototype.isComplete = function (actor) {
                    return this._stopped || (Math.abs(this.actor.opacity - this.endOpacity) < 0.05);
                };
                Fade.prototype.stop = function () {
                    this._stopped = true;
                };
                Fade.prototype.reset = function () {
                    this._started = false;
                };
                return Fade;
            })();
            Actions.Fade = Fade;
            var Die = (function () {
                function Die(actor) {
                    this._started = false;
                    this._stopped = false;
                    this.actor = actor;
                }
                Die.prototype.update = function (delta) {
                    this.actor.actionQueue.clearActions();
                    this.actor.kill();
                    this._stopped = true;
                };
                Die.prototype.isComplete = function () {
                    return this._stopped;
                };
                Die.prototype.stop = function () {
                };
                Die.prototype.reset = function () {
                };
                return Die;
            })();
            Actions.Die = Die;
            var CallMethod = (function () {
                function CallMethod(actor, method) {
                    this._method = null;
                    this._actor = null;
                    this._hasBeenCalled = false;
                    this._actor = actor;
                    this._method = method;
                }
                CallMethod.prototype.update = function (delta) {
                    this._method.call(this._actor);
                    this._hasBeenCalled = true;
                };
                CallMethod.prototype.isComplete = function (actor) {
                    return this._hasBeenCalled;
                };
                CallMethod.prototype.reset = function () {
                    this._hasBeenCalled = false;
                };
                CallMethod.prototype.stop = function () {
                    this._hasBeenCalled = true;
                };
                return CallMethod;
            })();
            Actions.CallMethod = CallMethod;
            var Repeat = (function () {
                function Repeat(actor, repeat, actions) {
                    var _this = this;
                    this._stopped = false;
                    this.actor = actor;
                    this.actionQueue = new ActionQueue(actor);
                    this.repeat = repeat;
                    this.originalRepeat = repeat;
                    actions.forEach(function (action) {
                        action.reset();
                        _this.actionQueue.add(action);
                    });
                }
                Repeat.prototype.update = function (delta) {
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    if (!this.actionQueue.hasNext()) {
                        this.actionQueue.reset();
                        this.repeat--;
                    }
                    this.actionQueue.update(delta);
                };
                Repeat.prototype.isComplete = function () {
                    return this._stopped || (this.repeat <= 0);
                };
                Repeat.prototype.stop = function () {
                    this._stopped = true;
                };
                Repeat.prototype.reset = function () {
                    this.repeat = this.originalRepeat;
                };
                return Repeat;
            })();
            Actions.Repeat = Repeat;
            var RepeatForever = (function () {
                function RepeatForever(actor, actions) {
                    var _this = this;
                    this._stopped = false;
                    this.actor = actor;
                    this.actionQueue = new ActionQueue(actor);
                    actions.forEach(function (action) {
                        action.reset();
                        _this.actionQueue.add(action);
                    });
                }
                RepeatForever.prototype.update = function (delta) {
                    this.x = this.actor.x;
                    this.y = this.actor.y;
                    if (this._stopped) {
                        return;
                    }
                    if (!this.actionQueue.hasNext()) {
                        this.actionQueue.reset();
                    }
                    this.actionQueue.update(delta);
                };
                RepeatForever.prototype.isComplete = function () {
                    return this._stopped;
                };
                RepeatForever.prototype.stop = function () {
                    this._stopped = true;
                    this.actionQueue.clearActions();
                };
                RepeatForever.prototype.reset = function () {
                };
                return RepeatForever;
            })();
            Actions.RepeatForever = RepeatForever;
            var ActionQueue = (function () {
                function ActionQueue(actor) {
                    this._actions = [];
                    this._completedActions = [];
                    this.actor = actor;
                }
                ActionQueue.prototype.add = function (action) {
                    this._actions.push(action);
                };
                ActionQueue.prototype.remove = function (action) {
                    var index = this._actions.indexOf(action);
                    this._actions.splice(index, 1);
                };
                ActionQueue.prototype.clearActions = function () {
                    this._actions.length = 0;
                    this._completedActions.length = 0;
                    this._currentAction.stop();
                };
                ActionQueue.prototype.getActions = function () {
                    return this._actions.concat(this._completedActions);
                };
                ActionQueue.prototype.hasNext = function () {
                    return this._actions.length > 0;
                };
                ActionQueue.prototype.reset = function () {
                    this._actions = this.getActions();
                    this._actions.forEach(function (action) {
                        action.reset();
                    });
                    this._completedActions = [];
                };
                ActionQueue.prototype.update = function (delta) {
                    if (this._actions.length > 0) {
                        this._currentAction = this._actions[0];
                        this._currentAction.update(delta);
                        if (this._currentAction.isComplete(this.actor)) {
                            //Logger.getInstance().log("Action complete!", Log.DEBUG);
                            this._completedActions.push(this._actions.shift());
                        }
                    }
                };
                return ActionQueue;
            })();
            Actions.ActionQueue = ActionQueue;
        })(Actions = Internal.Actions || (Internal.Actions = {}));
    })(Internal = ex.Internal || (ex.Internal = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var EasingFunctions = (function () {
        function EasingFunctions() {
        }
        /*
       easeInQuad: function (t) { return t * t },
       // decelerating to zero velocity
       easeOutQuad: function (t) { return t * (2 - t) },
       // acceleration until halfway, then deceleration
       easeInOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
       // accelerating from zero velocity
       easeInCubic: function (t) { return t * t * t },
       // decelerating to zero velocity
       easeOutCubic: function (t) { return (--t) * t * t + 1 },
       // acceleration until halfway, then deceleration
       easeInOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
       // accelerating from zero velocity
       easeInQuart: function (t) { return t * t * t * t },
       // decelerating to zero velocity
       easeOutQuart: function (t) { return 1 - (--t) * t * t * t },
       // acceleration until halfway, then deceleration
       easeInOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
       // accelerating from zero velocity
       easeInQuint: function (t) { return t * t * t * t * t },
       // decelerating to zero velocity
       easeOutQuint: function (t) { return 1 + (--t) * t * t * t * t },
       // acceleration until halfway, then deceleration
       easeInOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t }
        */
        EasingFunctions.Linear = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            return endValue * currentTime / duration + startValue;
        };
        EasingFunctions.EaseInQuad = function (currentTime, startValue, endValue, duration) {
            //endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * currentTime * currentTime + startValue;
        };
        EasingFunctions.EaseOutQuad = function (currentTime, startValue, endValue, duration) {
            //endValue = (endValue - startValue);
            currentTime /= duration;
            return -endValue * currentTime * (currentTime - 2) + startValue;
        };
        EasingFunctions.EaseInOutQuad = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime + startValue;
            currentTime--;
            return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
        };
        EasingFunctions.EaseInCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * currentTime * currentTime * currentTime + startValue;
        };
        EasingFunctions.EaseOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration;
            return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
        };
        EasingFunctions.EaseInOutCubic = function (currentTime, startValue, endValue, duration) {
            endValue = (endValue - startValue);
            currentTime /= duration / 2;
            if (currentTime < 1)
                return endValue / 2 * currentTime * currentTime * currentTime + startValue;
            currentTime -= 2;
            return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
        };
        return EasingFunctions;
    })();
    ex.EasingFunctions = EasingFunctions;
})(ex || (ex = {}));
/// <reference path="Interfaces/IDrawable.ts" />
/// <reference path="Modules/MovementModule.ts" />
/// <reference path="Modules/OffscreenCullingModule.ts" />
/// <reference path="Modules/CapturePointerModule.ts" />
/// <reference path="Modules/CollisionDetectionModule.ts" />
/// <reference path="Collision/Side.ts" />
/// <reference path="Algebra.ts" />
/// <reference path="Util.ts" />
/// <reference path="TileMap.ts" />
/// <reference path="Collision/BoundingBox.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Action.ts" />
/// <reference path="EasingFunctions.ts"/>
var ex;
(function (ex) {
    /**
     * An enum that describes the types of collisions actors can participate in
     * @class CollisionType
     */
    (function (CollisionType) {
        /**
         * Actors with the PreventCollision setting do not participate in any
         * collisions and do not raise collision events.
         * @property PreventCollision {CollisionType}
         * @static
         */
        CollisionType[CollisionType["PreventCollision"] = 0] = "PreventCollision";
        /**
         * Actors with the Passive setting only raise collision events, but are not
         * influenced or moved by other actors and do not influence or move other actors.
         * @property Passive {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Passive"] = 1] = "Passive";
        /**
         * Actors with the Active setting raise collision events and participate
         * in collisions with other actors and will be push or moved by actors sharing
         * the Active or Fixed setting.
         * @property Active {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Active"] = 2] = "Active";
        /**
         * Actors with the Elastic setting will behave the same as Active, except that they will
         * "bounce" in the opposite direction given their velocity dx/dy. This is a naive implementation meant for
         * prototyping, for a more robust elastic collision listen to the "collision" event and perform your custom logic.
         * @property Elastic {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Elastic"] = 3] = "Elastic";
        /**
         * Actors with the Fixed setting raise collision events and participate in
         * collisions with other actors. Actors with the Fixed setting will not be
         * pushed or moved by other actors sharing the Fixed or Actors. Think of Fixed
         * actors as "immovable/onstoppable" objects. If two Fixed actors meet they will
         * not be pushed or moved by each other, they will not interact except to throw
         * collision events.
         * @property Fixed {CollisionType}
         * @static
         */
        CollisionType[CollisionType["Fixed"] = 4] = "Fixed";
    })(ex.CollisionType || (ex.CollisionType = {}));
    var CollisionType = ex.CollisionType;
    /**
     * The most important primitive in Excalibur is an "Actor." Anything that
     * can move on the screen, collide with another Actor, respond to events,
     * or interact with the current scene, must be an actor. An Actor <b>must</b>
     * be part of a {{#crossLink "Scene"}}{{/crossLink}} for it to be drawn to the screen.
     * @class Actor
     * @extends Class
     * @constructor
     * @param [x=0.0] {number} The starting x coordinate of the actor
     * @param [y=0.0] {number} The starting y coordinate of the actor
     * @param [width=0.0] {number} The starting width of the actor
     * @param [height=0.0] {number} The starting height of the actor
     * @param [color=undefined] {Color} The starting color of the actor
     */
    var Actor = (function (_super) {
        __extends(Actor, _super);
        function Actor(x, y, width, height, color) {
            _super.call(this);
            /**
             * The unique identifier for the actor
             */
            this.id = Actor.maxId++;
            /**
             * The x coordinate of the actor (left edge)
             * @property x {number}
             */
            this.x = 0;
            /**
             * The y coordinate of the actor (top edge)
             * @property y {number}
             */
            this.y = 0;
            this.height = 0;
            this.width = 0;
            /**
             * The rotation of the actor in radians
             * @property rotation {number}
             */
            this.rotation = 0; // radians
            /**
             * The rotational velocity of the actor in radians/second
             * @property rx {number}
             */
            this.rx = 0; //radions/sec
            /**
             * The scale vector of the actor
             * @property scale
             */
            this.scale = new ex.Vector(1, 1);
            /**
             * The x scalar velocity of the actor in scale/second
             * @property sx {number}
             */
            this.sx = 0; //scale/sec
            /**
             * The y scalar velocity of the actor in scale/second
             * @property sy {number}
             */
            this.sy = 0; //scale/sec
            /**
             * The x velocity of the actor in pixels/second
             * @property dx {number}
             */
            this.dx = 0; // pixels/sec
            /**
             * The x velocity of the actor in pixels/second
             * @property dx {number}
             */
            this.dy = 0;
            /**
             * The x acceleration of the actor in pixels/second^2
             * @property ax {number}
             */
            this.ax = 0; // pixels/sec/sec
            /**
             * The y acceleration of the actor in pixels/second^2
             * @property ay {number}
             */
            this.ay = 0;
            /**
             * Indicates wether the actor is physically in the viewport
             * @property isOffScreen {boolean}
             */
            this.isOffScreen = false;
            /**
             * The visibility of an actor
             * @property visible {boolean}
             */
            this.visible = true;
            /**
             * The opacity of an actor
             * @property opacity {number}
             */
            this.opacity = 1;
            this.previousOpacity = 1;
            /**
             * Convenience reference to the global logger
             * @property logger {Logger}
             */
            this.logger = ex.Logger.getInstance();
            /**
            * The scene that the actor is in
            * @property scene {Scene}
            */
            this.scene = null; //formerly "parent"
            /**
            * The parent of this actor
            * @property parent {Actor}
            */
            this.parent = null;
            /**
             * Gets or sets the current collision type of this actor. By
             * default all actors participate in Active collisions.
             * @property collisionType {CollisionType}
             */
            this.collisionType = 0 /* PreventCollision */;
            this.collisionGroups = [];
            this._collisionHandlers = {};
            this._isInitialized = false;
            this.frames = {};
            /**
             * Access to the current drawing on for the actor, this can be an {{#crossLink "Animation"}}{{/crossLink}},
             * {{#crossLink "Sprite"}}{{/crossLink}}, or {{#crossLink "Polygon"}}{{/crossLink}}.
             * Set drawings with the {{#crossLink "Actor/setDrawing:method"}}{{/crossLink}}.
             * @property currentDrawing {IDrawable}
             */
            this.currentDrawing = null;
            this.centerDrawingX = false;
            this.centerDrawingY = false;
            /**
             * Modify the current actor update pipeline.
             *
             *
             */
            this.pipeline = [];
            /**
             * Whether or not to enable the CapturePointer trait that propogates pointer events to this actor
             * @property [enableCapturePointer=false] {boolean}
             */
            this.enableCapturePointer = false;
            /**
             * Configuration for CapturePointer trait
             * @property capturePointer {ICapturePointerConfig}
             */
            this.capturePointer = {
                captureMoveEvents: false
            };
            this._isKilled = false;
            this.x = x || 0;
            this.y = y || 0;
            this.width = width || 0;
            this.height = height || 0;
            if (color) {
                this.color = color.clone();
                // set default opacity of an actor to the color
                this.opacity = color.a;
            }
            // Build default pipeline
            this.pipeline.push(new ex.MovementModule());
            //this.pipeline.push(new ex.CollisionDetectionModule());
            this.pipeline.push(new ex.OffscreenCullingModule());
            this.pipeline.push(new ex.CapturePointerModule());
            this.actionQueue = new ex.Internal.Actions.ActionQueue(this);
            this.sceneNode = new ex.Scene();
            this.sceneNode.actor = this;
            this.anchor = new ex.Point(.5, .5);
        }
        /**
         * This is called before the first update of the actor. This method is meant to be
         * overridden. This is where initialization of child actors should take place.
         * @method onInitialize
         * @param engine {Engine}
         */
        Actor.prototype.onInitialize = function (engine) {
        };
        Actor.prototype._checkForPointerOptIn = function (eventName) {
            if (eventName && (eventName.toLowerCase() === 'pointerdown' || eventName.toLowerCase() === 'pointerdown' || eventName.toLowerCase() === 'pointermove')) {
                this.enableCapturePointer = true;
                if (eventName.toLowerCase() === 'pointermove') {
                    this.capturePointer.captureMoveEvents = true;
                }
            }
        };
        /**
        * Add an event listener. You can listen for a variety of
        * events off of the engine; see the events section below for a complete list.
        * @method addEventListener
        * @param eventName {string} Name of the event to listen for
        * @param handler {event=>void} Event handler for the thrown event
        */
        Actor.prototype.addEventListener = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            _super.prototype.addEventListener.call(this, eventName, handler);
        };
        /**
         * Alias for "addEventListener". You can listen for a variety of
         * events off of the engine; see the events section below for a complete list.
         * @method on
         * @param eventName {string} Name of the event to listen for
         * @param handler {event=>void} Event handler for the thrown event
         */
        Actor.prototype.on = function (eventName, handler) {
            this._checkForPointerOptIn(eventName);
            this.eventDispatcher.subscribe(eventName, handler);
        };
        /**
         * If the current actors is a member of the scene. This will remove
         * it from the scene graph. It will no longer be drawn or updated.
         * @method kill
         */
        Actor.prototype.kill = function () {
            if (this.scene) {
                this.scene.removeChild(this);
                this._isKilled = true;
            }
            else {
                this.logger.warn("Cannot kill actor, it was never added to the Scene");
            }
        };
        /**
         * Indicates wether the actor has been killed.
         * @method isKilled
         * @returns boolean
         */
        Actor.prototype.isKilled = function () {
            return this._isKilled;
        };
        /**
         * Adds a child actor to this actor. All movement of the child actor will be
         * relative to the parent actor. Meaning if the parent moves the child will
         * move with
         * @method addChild
         * @param actor {Actor} The child actor to add
         */
        Actor.prototype.addChild = function (actor) {
            actor.collisionType = 0 /* PreventCollision */;
            this.sceneNode.addChild(actor);
        };
        /**
         * Removes a child actor from this actor.
         * @method removeChild
         * @param actor {Actor} The child actor to remove
         */
        Actor.prototype.removeChild = function (actor) {
            this.sceneNode.removeChild(actor);
        };
        /**
         * Sets the current drawing of the actor to the drawing correspoding to
         * the key.
         * @method setDrawing
         * @param key {string} The key of the drawing
         */
        Actor.prototype.setDrawing = function (key) {
            if (this.currentDrawing != this.frames[key]) {
                this.frames[key].reset();
            }
            this.currentDrawing = this.frames[key];
        };
        Actor.prototype.addDrawing = function (args) {
            if (arguments.length === 2) {
                this.frames[arguments[0]] = arguments[1];
                if (!this.currentDrawing) {
                    this.currentDrawing = arguments[1];
                }
            }
            else {
                if (arguments[0] instanceof ex.Sprite) {
                    this.addDrawing("default", arguments[0]);
                }
                if (arguments[0] instanceof ex.Texture) {
                    this.addDrawing("default", arguments[0].asSprite());
                }
            }
        };
        /**
         * Artificially trigger an event on an actor, useful when creating custom events.
         * @method triggerEvent
         * @param eventName {string} The name of the event to trigger
         * @param [event=undefined] {GameEvent} The event object to pass to the callback
         */
        Actor.prototype.triggerEvent = function (eventName, event) {
            this.eventDispatcher.publish(eventName, event);
        };
        /**
         * Adds an actor to a collision group. Actors with no named collision group are
         * considered to be in every collision group.
         *
         * Once in a collision group(s) actors will only collide with other actors in
         * that group.
         *
         * @method addCollisionGroup
         * @param name {string} The name of the collision group
         */
        Actor.prototype.addCollisionGroup = function (name) {
            this.collisionGroups.push(name);
        };
        /**
         * Remove an actor from a collision group.
         * @method removeCollisionGroup
         * @param name {string} The name of the collision group
         */
        Actor.prototype.removeCollisionGroup = function (name) {
            var index = this.collisionGroups.indexOf(name);
            if (index !== -1) {
                this.collisionGroups.splice(index, 1);
            }
        };
        /**
         * Get the center point of an actor
         * @method getCenter
         * @returns Vector
         */
        Actor.prototype.getCenter = function () {
            var anchor = this._getCalculatedAnchor();
            return new ex.Vector(this.x + this.getWidth() / 2, this.y + this.getHeight() / 2);
        };
        /**
         * Gets the calculated width of an actor
         * @method getWidth
         * @returns number
         */
        Actor.prototype.getWidth = function () {
            return this.width * this.scale.x;
        };
        /**
         * Sets the width of an actor, factoring in the current scale
         * @method setWidth
         */
        Actor.prototype.setWidth = function (width) {
            this.width = width / this.scale.x;
        };
        /**
         * Gets the calculated height of an actor
         * @method getHeight
         * @returns number
         */
        Actor.prototype.getHeight = function () {
            return this.height * this.scale.y;
        };
        /**
         * Sets the height of an actor, factoring in the current scale
         * @method setHeight
         */
        Actor.prototype.setHeight = function (height) {
            this.height = height / this.scale.y;
        };
        /**
         * Centers the actor's drawing around the center of the actor's bounding box
         * @method setCenterDrawing
         * @param center {boolean} Indicates to center the drawing around the actor
         */
        Actor.prototype.setCenterDrawing = function (center) {
            this.centerDrawingY = center;
            this.centerDrawingX = center;
        };
        /**
         * Gets the left edge of the actor
         * @method getLeft
         * @returns number
         */
        Actor.prototype.getLeft = function () {
            return this.x;
        };
        /**
         * Gets the right edge of the actor
         * @method getRight
         * @returns number
         */
        Actor.prototype.getRight = function () {
            return this.x + this.getWidth();
        };
        /**
         * Gets the top edge of the actor
         * @method getTop
         * @returns number
         */
        Actor.prototype.getTop = function () {
            return this.y;
        };
        /**
         * Gets the bottom edge of the actor
         * @method getBottom
         * @returns number
         */
        Actor.prototype.getBottom = function () {
            return this.y + this.getHeight();
        };
        /**
        * Gets the x value of the Actor in global coordinates
        * @method getGlobalX
        * @returns number
        */
        Actor.prototype.getGlobalX = function () {
            if (!this.parent)
                return this.x;
            return this.x * this.parent.scale.y + this.parent.getGlobalX();
        };
        /**
        * Gets the y value of the Actor in global coordinates
        * @method getGlobalY
        * @returns number
        */
        Actor.prototype.getGlobalY = function () {
            if (!this.parent)
                return this.y;
            return this.y * this.parent.scale.y + this.parent.getGlobalY();
        };
        /**
         * Gets the global scale of the Actor
         * @method getGlobalScale
         * @returns Point
         */
        Actor.prototype.getGlobalScale = function () {
            if (!this.parent)
                return new ex.Point(this.scale.x, this.scale.y);
            var parentScale = this.parent.getGlobalScale();
            return new ex.Point(this.scale.x * parentScale.x, this.scale.y * parentScale.y);
        };
        /**
         * Returns the actor's bounding box calculated for this instant.
         * @method getBounds
         * @returns BoundingBox
         */
        Actor.prototype.getBounds = function () {
            var anchor = this._getCalculatedAnchor();
            return new ex.BoundingBox(this.getGlobalX() - anchor.x, this.getGlobalY() - anchor.y, this.getGlobalX() + this.getWidth() - anchor.x, this.getGlobalY() + this.getHeight() - anchor.y);
        };
        /**
         * Tests whether the x/y specified are contained in the actor
         * @method contains
         * @param x {number} X coordinate to test (in world coordinates)
         * @param y {number} Y coordinate to test (in world coordinates)
         */
        Actor.prototype.contains = function (x, y) {
            return this.getBounds().contains(new ex.Point(x, y));
        };
        /**
         * Returns the side of the collision based on the intersection
         * @method getSideFromIntersect
         * @param intersect {Vector} The displacement vector returned by a collision
         * @returns Side
        */
        Actor.prototype.getSideFromIntersect = function (intersect) {
            if (intersect) {
                if (Math.abs(intersect.x) > Math.abs(intersect.y)) {
                    if (intersect.x < 0) {
                        return 4 /* Right */;
                    }
                    return 3 /* Left */;
                }
                else {
                    if (intersect.y < 0) {
                        return 2 /* Bottom */;
                    }
                    return 1 /* Top */;
                }
            }
            return 0 /* None */;
        };
        /**
         * Test whether the actor has collided with another actor, returns the side of the current actor that collided.
         * @method collides
         * @param actor {Actor} The other actor to test
         * @returns Side
         */
        Actor.prototype.collidesWithSide = function (actor) {
            var separationVector = this.collides(actor);
            if (!separationVector) {
                return 0 /* None */;
            }
            if (Math.abs(separationVector.x) > Math.abs(separationVector.y)) {
                if (this.x < actor.x) {
                    return 4 /* Right */;
                }
                else {
                    return 3 /* Left */;
                }
            }
            else {
                if (this.y < actor.y) {
                    return 2 /* Bottom */;
                }
                else {
                    return 1 /* Top */;
                }
            }
            return 0 /* None */;
        };
        /**
         * Test whether the actor has collided with another actor, returns the intersection vector on collision. Returns
         * null when there is no collision;
         * @method collides
         * @param actor {Actor} The other actor to test
         * @returns Vector
         */
        Actor.prototype.collides = function (actor) {
            var bounds = this.getBounds();
            var otherBounds = actor.getBounds();
            var intersect = bounds.collides(otherBounds);
            return intersect;
        };
        /**
         * Register a handler to fire when this actor collides with another in a specified group
         * @method onCollidesWith
         * @param group {string} The group name to listen for
         * @param func {callback} The callback to fire on collision with another actor from the group. The callback is passed the other actor.
         */
        Actor.prototype.onCollidesWith = function (group, func) {
            if (!this._collisionHandlers[group]) {
                this._collisionHandlers[group] = [];
            }
            this._collisionHandlers[group].push(func);
        };
        Actor.prototype.getCollisionHandlers = function () {
            return this._collisionHandlers;
        };
        /**
         * Removes all collision handlers for this group on this actor
         * @method removeCollidesWith
         * @param group {string} Group to remove all handlers for on this actor.
         */
        Actor.prototype.removeCollidesWith = function (group) {
            this._collisionHandlers[group] = [];
        };
        /**
         * Returns true if the two actors are less than or equal to the distance specified from each other
         * @method within
         * @param actor {Actor} Actor to test
         * @param distance {number} Distance in pixels to test
         * @returns boolean
         */
        Actor.prototype.within = function (actor, distance) {
            return Math.sqrt(Math.pow(this.x - actor.x, 2) + Math.pow(this.y - actor.y, 2)) <= distance;
        };
        /**
         * Clears all queued actions from the Actor
         * @method clearActions
         */
        Actor.prototype.clearActions = function () {
            this.actionQueue.clearActions();
        };
        Actor.prototype.easeTo = function (x, y, duration, easingFcn) {
            if (easingFcn === void 0) { easingFcn = ex.EasingFunctions.Linear; }
            this.actionQueue.add(new ex.Internal.Actions.EaseTo(this, x, y, duration, easingFcn));
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position at the
         * speed specified (in pixels per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @method moveTo
         * @param x {number} The x location to move the actor to
         * @param y {number} The y location to move the actor to
         * @param speed {number} The speed in pixels per second to move
         * @returns Actor
         */
        Actor.prototype.moveTo = function (x, y, speed) {
            this.actionQueue.add(new ex.Internal.Actions.MoveTo(this, x, y, speed));
            return this;
        };
        /**
         * This method will move an actor to the specified x and y position by a
         * certain time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @method moveBy
         * @param x {number} The x location to move the actor to
         * @param y {number} The y location to move the actor to
         * @param time {number} The time it should take the actor to move to the new location in milliseconds
         * @returns Actor
         */
        Actor.prototype.moveBy = function (x, y, time) {
            this.actionQueue.add(new ex.Internal.Actions.MoveBy(this, x, y, time));
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle at the speed
         * specified (in radians per second) and return back the actor. This
         * method is part of the actor 'Action' fluent API allowing action chaining.
         * @method rotateTo
         * @param angleRadians {number} The angle to rotate to in radians
         * @param speed {number} The angular velocity of the rotation specified in radians per second
         * @returns Actor
         */
        Actor.prototype.rotateTo = function (angleRadians, speed) {
            this.actionQueue.add(new ex.Internal.Actions.RotateTo(this, angleRadians, speed));
            return this;
        };
        /**
         * This method will rotate an actor to the specified angle by a certain
         * time (in milliseconds) and return back the actor. This method is part
         * of the actor 'Action' fluent API allowing action chaining.
         * @method rotateBy
         * @param angleRadians {number} The angle to rotate to in radians
         * @param time {number} The time it should take the actor to complete the rotation in milliseconds
         * @returns Actor
         */
        Actor.prototype.rotateBy = function (angleRadians, time) {
            this.actionQueue.add(new ex.Internal.Actions.RotateBy(this, angleRadians, time));
            return this;
        };
        /**
         * This method will scale an actor to the specified size at the speed
         * specified (in magnitude increase per second) and return back the
         * actor. This method is part of the actor 'Action' fluent API allowing
         * action chaining.
         * @method scaleTo
         * @param size {number} The scaling factor to apply
         * @param speed {number} The speed of scaling specified in magnitude increase per second
         * @returns Actor
         */
        Actor.prototype.scaleTo = function (sizeX, sizeY, speedX, speedY) {
            this.actionQueue.add(new ex.Internal.Actions.ScaleTo(this, sizeX, sizeY, speedX, speedY));
            return this;
        };
        /**
         * This method will scale an actor to the specified size by a certain time
         * (in milliseconds) and return back the actor. This method is part of the
         * actor 'Action' fluent API allowing action chaining.
         * @method scaleBy
         * @param size {number} The scaling factor to apply
         * @param time {number} The time it should take to complete the scaling in milliseconds
         * @returns Actor
         */
        Actor.prototype.scaleBy = function (sizeX, sizeY, time) {
            this.actionQueue.add(new ex.Internal.Actions.ScaleBy(this, sizeX, sizeY, time));
            return this;
        };
        /**
         * This method will cause an actor to blink (become visible and not
         * visible). Optionally, you may specify the number of blinks. Specify the amount of time
         * the actor should be visible per blink, and the amount of time not visible.
         * This method is part of the actor 'Action' fluent API allowing action chaining.
         * @method blink
         * @param timeVisible {number} The amount of time to stay visible per blink in milliseconds
         * @param timeNotVisible {number} The amount of time to stay not visible per blink in milliseconds
         * @param [numBlinks] {number} The number of times to blink
         * @returns Actor
         */
        Actor.prototype.blink = function (timeVisible, timeNotVisible, numBlinks) {
            if (numBlinks === void 0) { numBlinks = 1; }
            this.actionQueue.add(new ex.Internal.Actions.Blink(this, timeVisible, timeNotVisible, numBlinks));
            return this;
        };
        /**
         * This method will cause an actor's opacity to change from its current value
         * to the provided value by a specified time (in milliseconds). This method is
         * part of the actor 'Action' fluent API allowing action chaining.
         * @method fade
         * @param opacity {number} The ending opacity
         * @param time {number} The time it should take to fade the actor (in milliseconds)
         * @returns Actor
         */
        Actor.prototype.fade = function (opacity, time) {
            this.actionQueue.add(new ex.Internal.Actions.Fade(this, opacity, time));
            return this;
        };
        /**
         * This method will delay the next action from executing for a certain
         * amount of time (in milliseconds). This method is part of the actor
         * 'Action' fluent API allowing action chaining.
         * @method delay
         * @param time {number} The amount of time to delay the next action in the queue from executing in milliseconds
         * @returns Actor
         */
        Actor.prototype.delay = function (time) {
            this.actionQueue.add(new ex.Internal.Actions.Delay(this, time));
            return this;
        };
        /**
         * This method will add an action to the queue that will remove the actor from the
         * scene once it has completed its previous actions. Any actions on the
         * action queue after this action will not be executed.
         * @method die
         * @returns Actor
         */
        Actor.prototype.die = function () {
            this.actionQueue.add(new ex.Internal.Actions.Die(this));
            return this;
        };
        /**
         * This method allows you to call an arbitrary method as the next action in the
         * action queue. This is useful if you want to execute code in after a specific
         * action, i.e An actor arrives at a destinatino after traversing a path
         * @method callMethod
         * @returns Actor
         */
        Actor.prototype.callMethod = function (method) {
            this.actionQueue.add(new ex.Internal.Actions.CallMethod(this, method));
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions a certain number of times. If the number of repeats
         * is not specified it will repeat forever. This method is part of
         * the actor 'Action' fluent API allowing action chaining
         * @method repeat
         * @param [times=undefined] {number} The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions will repeat forever
         * @returns Actor
         */
        Actor.prototype.repeat = function (times) {
            if (!times) {
                this.repeatForever();
                return this;
            }
            this.actionQueue.add(new ex.Internal.Actions.Repeat(this, times, this.actionQueue.getActions()));
            return this;
        };
        /**
         * This method will cause the actor to repeat all of the previously
         * called actions forever. This method is part of the actor 'Action'
         * fluent API allowing action chaining.
         * @method repeatForever
         * @returns Actor
         */
        Actor.prototype.repeatForever = function () {
            this.actionQueue.add(new ex.Internal.Actions.RepeatForever(this, this.actionQueue.getActions()));
            return this;
        };
        /**
         * This method will cause the actor to follow another at a specified distance
         * @method follow
         * @param actor {Actor} The actor to follow
         * @param [followDistance=currentDistance] {number} The distance to maintain when following, if not specified the actor will follow at the current distance.
         * @returns Actor
         */
        Actor.prototype.follow = function (actor, followDistance) {
            if (followDistance == undefined) {
                this.actionQueue.add(new ex.Internal.Actions.Follow(this, actor));
            }
            else {
                this.actionQueue.add(new ex.Internal.Actions.Follow(this, actor, followDistance));
            }
            return this;
        };
        /**
         * This method will cause the actor to move towards another until they
         * collide "meet" at a specified speed.
         * @method meet
         * @param actor {Actor} The actor to meet
         * @param [speed=0] {number} The speed in pixels per second to move, if not specified it will match the speed of the other actor
         * @returns Actor
         */
        Actor.prototype.meet = function (actor, speed) {
            if (speed == undefined) {
                this.actionQueue.add(new ex.Internal.Actions.Meet(this, actor));
            }
            else {
                this.actionQueue.add(new ex.Internal.Actions.Meet(this, actor, speed));
            }
            return this;
        };
        /**
         * Returns a promise that resolves when the current action queue up to now
         * is finished.
         * @method asPromise
         * @returns Promise
         */
        Actor.prototype.asPromise = function () {
            var complete = new ex.Promise();
            this.callMethod(function () {
                complete.resolve();
            });
            return complete;
        };
        Actor.prototype._getCalculatedAnchor = function () {
            return new ex.Point(this.getWidth() * this.anchor.x, this.getHeight() * this.anchor.y);
        };
        /**
         * Called by the Engine, updates the state of the actor
         * @method update
         * @param engine {Engine} The reference to the current game engine
         * @param delta {number} The time elapsed since the last update in milliseconds
         */
        Actor.prototype.update = function (engine, delta) {
            if (!this._isInitialized) {
                this.onInitialize(engine);
                this.eventDispatcher.publish('initialize', new ex.InitializeEvent(engine));
                this._isInitialized = true;
            }
            var eventDispatcher = this.eventDispatcher;
            // Update action queue
            this.actionQueue.update(delta);
            for (var i = 0; i < this.pipeline.length; i++) {
                this.pipeline[i].update(this, engine, delta);
            }
            eventDispatcher.publish(ex.EventType[5 /* Update */], new ex.UpdateEvent(delta));
        };
        /**
         * Called by the Engine, draws the actor to the screen
         * @method draw
         * @param ctx {CanvasRenderingContext2D} The rendering context
         * @param delta {number} The time since the last draw in milliseconds
         */
        Actor.prototype.draw = function (ctx, delta) {
            if (this.isOffScreen) {
                return;
            }
            var anchorPoint = this._getCalculatedAnchor();
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.scale(this.scale.x, this.scale.y);
            // calculate changing opacity
            if (this.previousOpacity != this.opacity) {
                for (var drawing in this.frames) {
                    this.frames[drawing].addEffect(new ex.Effects.Opacity(this.opacity));
                }
                this.previousOpacity = this.opacity;
            }
            if (this.currentDrawing) {
                var xDiff = 0;
                var yDiff = 0;
                if (this.centerDrawingX) {
                    xDiff = (this.currentDrawing.width * this.currentDrawing.getScaleX() - this.getWidth()) / 2;
                }
                if (this.centerDrawingY) {
                    yDiff = (this.currentDrawing.height * this.currentDrawing.getScaleY() - this.getHeight()) / 2;
                }
                this.currentDrawing.draw(ctx, -xDiff - anchorPoint.x, -yDiff - anchorPoint.y);
            }
            else {
                if (this.color) {
                    ctx.fillStyle = this.color.toString();
                    ctx.fillRect(-anchorPoint.x, -anchorPoint.y, this.width, this.height);
                }
            }
            this.sceneNode.draw(ctx, delta);
            ctx.restore();
        };
        /**
         * Called by the Engine, draws the actors debugging to the screen
         * @method debugDraw
         * @param ctx {CanvasRenderingContext2D} The rendering context
         */
        Actor.prototype.debugDraw = function (ctx) {
            var bb = this.getBounds();
            bb.debugDraw(ctx);
            ctx.fillStyle = ex.Color.Yellow.toString();
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        };
        /**
         * Indicates the next id to be set
         */
        Actor.maxId = 0;
        return Actor;
    })(ex.Class);
    ex.Actor = Actor;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Logging level that Excalibur will tag
     * @class LogLevel
     */
    (function (LogLevel) {
        /**
         @property Debug {LogLevel}
         @static
         @final
         */
        /**
        @property Info {LogLevel}
        @static
        @final
        */
        /**
        @property Warn {LogLevel}
        @static
        @final
        */
        /**
        @property Error {LogLevel}
        @static
        @final
        */
        /**
        @property Fatal {LogLevel}
        @static
        @final
        */
        LogLevel[LogLevel["Debug"] = 0] = "Debug";
        LogLevel[LogLevel["Info"] = 1] = "Info";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Error"] = 3] = "Error";
        LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
    })(ex.LogLevel || (ex.LogLevel = {}));
    var LogLevel = ex.LogLevel;
    /**
     * Static singleton that represents the logging facility for Excalibur.
     * Excalibur comes built-in with a ConsoleAppender and ScreenAppender.
     * Derive from IAppender to create your own logging appenders.
     * @class Logger
     * @static
     */
    var Logger = (function () {
        function Logger() {
            this.appenders = [];
            /**
             * Gets or sets the default logging level. Excalibur will only log
             * messages if equal to or above this level.
             * @property defaultLevel {LogLevel}
             */
            this.defaultLevel = 1 /* Info */;
            if (Logger._instance) {
                throw new Error("Logger is a singleton");
            }
            Logger._instance = this;
            // Default console appender
            Logger._instance.addAppender(new ConsoleAppender());
            return Logger._instance;
        }
        /**
         * Gets the current static instance of Logger
         * @method getInstance
         * @static
         * @returns Logger
         */
        Logger.getInstance = function () {
            if (Logger._instance == null) {
                Logger._instance = new Logger();
            }
            return Logger._instance;
        };
        /**
         * Adds a new IAppender to the list of appenders to write to
         * @method addAppender
         * @param appender {IAppender} Appender to add
         */
        Logger.prototype.addAppender = function (appender) {
            this.appenders.push(appender);
        };
        /**
         * Clears all appenders from the logger
         * @method clearAppenders
         */
        Logger.prototype.clearAppenders = function () {
            this.appenders.length = 0;
        };
        /**
         * Logs a message at a given LogLevel
         * @method _log
         * @private
         * @param level {LogLevel}The LogLevel`to log the message at
         * @param args An array of arguments to write to an appender
         */
        Logger.prototype._log = function (level, args) {
            var _this = this;
            if (level == null) {
                level = this.defaultLevel;
            }
            this.appenders.forEach(function (appender) {
                if (level >= _this.defaultLevel) {
                    appender.log(level, args);
                }
            });
        };
        /**
         * Writes a log message at the LogLevel.Debug level
         * @method debug
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(0 /* Debug */, args);
        };
        /**
         * Writes a log message at the LogLevel.Info level
         * @method info
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(1 /* Info */, args);
        };
        /**
         * Writes a log message at the LogLevel.Warn level
         * @method warn
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(2 /* Warn */, args);
        };
        /**
         * Writes a log message at the LogLevel.Error level
         * @method error
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(3 /* Error */, args);
        };
        /**
         * Writes a log message at the LogLevel.Fatal level
         * @method fatal
         * @param ...args Accepts any number of arguments
         */
        Logger.prototype.fatal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._log(4 /* Fatal */, args);
        };
        Logger._instance = null;
        return Logger;
    })();
    ex.Logger = Logger;
    /**
     * Console appender for browsers (i.e. console.log)
     * @class ConsoleAppender
     * @constructor
     * @extends IAppender
     */
    var ConsoleAppender = (function () {
        function ConsoleAppender() {
        }
        ConsoleAppender.prototype.log = function (level, args) {
            // Check for console support
            if (!console && !console.log && console.warn && console.error) {
                // todo maybe do something better than nothing
                return;
            }
            // Create a new console args array
            var consoleArgs = [];
            consoleArgs.unshift.apply(consoleArgs, args);
            consoleArgs.unshift("[" + LogLevel[level] + "] : ");
            if (level < 2 /* Warn */) {
                // Call .log for Debug/Info
                if (console.log.apply) {
                    // this is required on some older browsers that don't support apply on console.log :(
                    console.log.apply(console, consoleArgs);
                }
                else {
                    console.log(consoleArgs.join(' '));
                }
            }
            else if (level < 3 /* Error */) {
                // Call .warn for Warn
                if (console.warn.apply) {
                    console.warn.apply(console, consoleArgs);
                }
                else {
                    console.warn(consoleArgs.join(' '));
                }
            }
            else {
                // Call .error for Error/Fatal
                if (console.error.apply) {
                    console.error.apply(console, consoleArgs);
                }
                else {
                    console.error(consoleArgs.join(' '));
                }
            }
        };
        return ConsoleAppender;
    })();
    ex.ConsoleAppender = ConsoleAppender;
    /**
     * On-screen (canvas) appender
     * @todo Clean this up
     * @class ScreenAppender
     * @extends IAppender
     * @constructor
     * @param width {number} Width of the screen appender in pixels
     * @param height {number} Height of the screen appender in pixels
     */
    var ScreenAppender = (function () {
        function ScreenAppender(width, height) {
            this._messages = [];
            this.canvas = document.createElement('canvas');
            this.canvas.width = width || window.innerWidth;
            this.canvas.height = height || window.innerHeight;
            this.canvas.style.position = 'absolute';
            this.ctx = this.canvas.getContext('2d');
            document.body.appendChild(this.canvas);
        }
        ScreenAppender.prototype.log = function (level, args) {
            var message = args.join(",");
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this._messages.unshift("[" + LogLevel[level] + "] : " + message);
            var pos = 10;
            var opacity = 1.0;
            for (var i = 0; i < this._messages.length; i++) {
                this.ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
                this.ctx.fillText(this._messages[i], 200, pos);
                pos += 10;
                opacity = opacity > 0 ? opacity - .05 : 0;
            }
        };
        return ScreenAppender;
    })();
    ex.ScreenAppender = ScreenAppender;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Actor.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    /**
     * An enum representing all of the built in event types for Excalibur
     * @class EventType
     */
    (function (EventType) {
        /**
        @property UserEvent {EventType}
        @static
        @final
        */
        /**
        @property Blur {EventType}
        @static
        @final
        */
        /**
        @property Focus {EventType}
        @static
        @final
        */
        /**
        @property Update {EventType}
        @static
        @final
        */
        /**
        @property EnterViewPort {EventType}
        @static
        @final
        */
        /**
        @property ExitViewPort {EventType}
        @static
        @final
        */
        /**
        @property Activate {EventType}
        @static
        @final
        */
        /**
        @property Deactivate {EventType}
        @static
        @final
        */
        /**
        @property Initialize {EventType}
        @static
        @final
        */
        EventType[EventType["Collision"] = 0] = "Collision";
        EventType[EventType["EnterViewPort"] = 1] = "EnterViewPort";
        EventType[EventType["ExitViewPort"] = 2] = "ExitViewPort";
        EventType[EventType["Blur"] = 3] = "Blur";
        EventType[EventType["Focus"] = 4] = "Focus";
        EventType[EventType["Update"] = 5] = "Update";
        EventType[EventType["Activate"] = 6] = "Activate";
        EventType[EventType["Deactivate"] = 7] = "Deactivate";
        EventType[EventType["Initialize"] = 8] = "Initialize";
    })(ex.EventType || (ex.EventType = {}));
    var EventType = ex.EventType;
    /**
     * Base event type in Excalibur that all other event types derive from.
     *
     * @class GameEvent
     * @constructor
     * @param target {any} Events can have target game object, like the Engine, or an Actor.
     */
    var GameEvent = (function () {
        function GameEvent() {
        }
        return GameEvent;
    })();
    ex.GameEvent = GameEvent;
    /**
     * Event received by the Engine when the browser window is visible
     *
     * @class VisibleEvent
     * @extends GameEvent
     * @constructor
     */
    var VisibleEvent = (function (_super) {
        __extends(VisibleEvent, _super);
        function VisibleEvent() {
            _super.call(this);
        }
        return VisibleEvent;
    })(GameEvent);
    ex.VisibleEvent = VisibleEvent;
    /**
     * Event received by the Engine when the browser window is hidden
     *
     * @class HiddenEvent
     * @extends GameEvent
     * @constructor
     */
    var HiddenEvent = (function (_super) {
        __extends(HiddenEvent, _super);
        function HiddenEvent() {
            _super.call(this);
        }
        return HiddenEvent;
    })(GameEvent);
    ex.HiddenEvent = HiddenEvent;
    /**
     * Event thrown on an actor when a collision has occured
     *
     * @class CollisionEvent
     * @extends GameEvent
     * @constructor
     * @param actor {Actor} The actor the event was thrown on
     * @param other {Actor} The actor that was collided with
     * @param side {Side} The side that was collided with
     */
    var CollisionEvent = (function (_super) {
        __extends(CollisionEvent, _super);
        function CollisionEvent(actor, other, side, intersection) {
            _super.call(this);
            this.actor = actor;
            this.other = other;
            this.side = side;
            this.intersection = intersection;
        }
        return CollisionEvent;
    })(GameEvent);
    ex.CollisionEvent = CollisionEvent;
    /**
     * Event thrown on a game object on Excalibur update
     *
     * @class UpdateEvent
     * @extends GameEvent
     * @constructor
     * @param delta {number} The number of milliseconds since the last update
     */
    var UpdateEvent = (function (_super) {
        __extends(UpdateEvent, _super);
        function UpdateEvent(delta) {
            _super.call(this);
            this.delta = delta;
        }
        return UpdateEvent;
    })(GameEvent);
    ex.UpdateEvent = UpdateEvent;
    /**
     * Event thrown on an Actor only once before the first update call
     *
     * @class InitializeEvent
     * @extends GameEvent
     * @constructor
     * @param engine {Engine} The reference to the current engine
     */
    var InitializeEvent = (function (_super) {
        __extends(InitializeEvent, _super);
        function InitializeEvent(engine) {
            _super.call(this);
            this.engine = engine;
        }
        return InitializeEvent;
    })(GameEvent);
    ex.InitializeEvent = InitializeEvent;
    /**
     * Event thrown on a Scene on activation
     *
     * @class ActivateEvent
     * @extends GameEvent
     * @constructor
     * @param oldScene {Scene} The reference to the old scene
     */
    var ActivateEvent = (function (_super) {
        __extends(ActivateEvent, _super);
        function ActivateEvent(oldScene) {
            _super.call(this);
            this.oldScene = oldScene;
        }
        return ActivateEvent;
    })(GameEvent);
    ex.ActivateEvent = ActivateEvent;
    /**
     * Event thrown on a Scene on deactivation
     *
     * @class DeactivateEvent
     * @extends GameEvent
     * @constructor
     * @param newScene {Scene} The reference to the new scene
     */
    var DeactivateEvent = (function (_super) {
        __extends(DeactivateEvent, _super);
        function DeactivateEvent(newScene) {
            _super.call(this);
            this.newScene = newScene;
        }
        return DeactivateEvent;
    })(GameEvent);
    ex.DeactivateEvent = DeactivateEvent;
    /**
     * Event thrown on an Actor when it completely leaves the screen.
     * @class ExitViewPortEvent
     * @constructor
     */
    var ExitViewPortEvent = (function (_super) {
        __extends(ExitViewPortEvent, _super);
        function ExitViewPortEvent() {
            _super.call(this);
        }
        return ExitViewPortEvent;
    })(GameEvent);
    ex.ExitViewPortEvent = ExitViewPortEvent;
    /**
     * Event thrown on an Actor when it completely leaves the screen.
     * @class EnterViewPortEvent
     * @constructor
     */
    var EnterViewPortEvent = (function (_super) {
        __extends(EnterViewPortEvent, _super);
        function EnterViewPortEvent() {
            _super.call(this);
        }
        return EnterViewPortEvent;
    })(GameEvent);
    ex.EnterViewPortEvent = EnterViewPortEvent;
    /**
     * Enum representing the different mouse buttons
     * @class MouseButton
     */
    (function (MouseButton) {
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Left"] = 0] = "Left";
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Middle"] = 1] = "Middle";
        /**
         * @property Left
         * @static
         */
        MouseButton[MouseButton["Right"] = 2] = "Right";
    })(ex.MouseButton || (ex.MouseButton = {}));
    var MouseButton = ex.MouseButton;
})(ex || (ex = {}));
/// <reference path="Events.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur's internal event dispatcher implementation. Callbacks are fired immediately after an event is published
     * @class EventDispatcher
     * @constructor
     * @param target {any} The object that will be the recipient of events from this event dispatcher
     */
    var EventDispatcher = (function () {
        function EventDispatcher(target) {
            this._handlers = {};
            this.log = ex.Logger.getInstance();
            this.target = target;
        }
        /**
         * Publish an event for target
         * @method publish
         * @param eventName {string} The name of the event to publish
         * @param [event=undefined] {GameEvent} Optionally pass an event data object to the handler
         */
        EventDispatcher.prototype.publish = function (eventName, event) {
            if (!eventName) {
                // key not mapped
                return;
            }
            eventName = eventName.toLowerCase();
            var target = this.target;
            if (!event) {
                event = new ex.GameEvent();
            }
            event.target = target;
            if (this._handlers[eventName]) {
                this._handlers[eventName].forEach(function (callback) {
                    callback.call(target, event);
                });
            }
        };
        /**
         * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
         * @method subscribe
         * @param eventName {string} The name of the event to subscribe to
         * @param handler {GameEvent=>void} The handler callback to fire on this event
         */
        EventDispatcher.prototype.subscribe = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            if (!this._handlers[eventName]) {
                this._handlers[eventName] = [];
            }
            this._handlers[eventName].push(handler);
        };
        /**
         * Unsubscribe a event handler(s) from an event. If a specific handler
         * is specified for an event, only that handler will be unsubscribed.
         * Otherwise all handlers will be unsubscribed for that event.
         * @method unsubscribe
         * @param eventName {string} The name of the event to unsubscribe
         * @param [handler=undefined] Optionally the specific handler to unsubscribe
         *
         */
        EventDispatcher.prototype.unsubscribe = function (eventName, handler) {
            eventName = eventName.toLowerCase();
            var eventHandlers = this._handlers[eventName];
            if (eventHandlers) {
                // if no explicit handler is give with the event name clear all handlers
                if (!handler) {
                    this._handlers[eventName].length = 0;
                }
                else {
                    var index = eventHandlers.indexOf(handler);
                    if (index < 0)
                        return;
                    this._handlers[eventName].splice(index, 1);
                }
            }
        };
        return EventDispatcher;
    })();
    ex.EventDispatcher = EventDispatcher;
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Color = (function () {
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @class Color
         * @constructor
         * @param r {number} The red component of color (0-255)
         * @param g {number} The green component of color (0-255)
         * @param b {number} The blue component of color (0-255)
         * @param [a=1] {number} The alpha component of color (0-1.0)
         */
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            this.a = (a != null ? a : 1);
        }
        /**
         * Creates a new instance of Color from an r, g, b, a
         *
         * @method fromRGB
         * @static
         * @param r {number} The red component of color (0-255)
         * @param g {number} The green component of color (0-255)
         * @param b {number} The blue component of color (0-255)
         * @param [a=1] {number} The alpha component of color (0-1.0)
         */
        Color.fromRGB = function (r, g, b, a) {
            return new Color(r, g, b, a);
        };
        /**
         * Creates a new inscance of Color from a hex string
         *
         * @method fromHex
         * @static
         * @param hex {string} CSS color string of the form #ffffff, the alpha component is optional
         */
        Color.fromHex = function (hex) {
            var hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
            var match = null;
            if (match = hex.match(hexRegEx)) {
                var r = parseInt(match[1], 16);
                var g = parseInt(match[2], 16);
                var b = parseInt(match[3], 16);
                var a = 1;
                if (match[4]) {
                    a = parseInt(match[4], 16) / 255;
                }
                return new Color(r, g, b, a);
            }
            else {
                throw new Error("Invalid hex string: " + hex);
            }
        };
        /**
         * Returns a CSS string representation of a color.
         * @method toString
         * @returns string
         */
        Color.prototype.toString = function () {
            var result = String(this.r.toFixed(0)) + ", " + String(this.g.toFixed(0)) + ", " + String(this.b.toFixed(0));
            if (this.a !== undefined || this.a !== null) {
                return "rgba(" + result + ", " + String(this.a) + ")";
            }
            return "rgb(" + result + ")";
        };
        /**
         * Returns a CSS string representation of a color.
         * @method fillStyle
         * @returns string
         */
        Color.prototype.fillStyle = function () {
            return this.toString();
        };
        /**
         * Returns a clone of the current color.
         * @method clone
         * @returns Color
         */
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        /**
         * Color constant
         * @property Black {ex.Color}
         * @static
         * @final
         */
        Color.Black = Color.fromHex('#000000');
        /**
         * Color constant
         * @property White {ex.Color}
         * @static
         * @final
         */
        Color.White = Color.fromHex('#FFFFFF');
        /**
         * Color constant
         * @property Gray {ex.Color}
         * @static
         * @final
         */
        Color.Gray = Color.fromHex('#808080');
        /**
         * Color constant
         * @property LightGray {ex.Color}
         * @static
         * @final
         */
        Color.LightGray = Color.fromHex('#D3D3D3');
        /**
         * Color constant
         * @property DarkGray {ex.Color}
         * @static
         * @final
         */
        Color.DarkGray = Color.fromHex('#A9A9A9');
        /**
         * Color constant
         * @property Yellow {ex.Color}
         * @static
         * @final
         */
        Color.Yellow = Color.fromHex('#FFFF00');
        /**
         * Color constant
         * @property Orange {ex.Color}
         * @static
         * @final
         */
        Color.Orange = Color.fromHex('#FFA500');
        /**
         * Color constant
         * @property Red {ex.Color}
         * @static
         * @final
         */
        Color.Red = Color.fromHex('#FF0000');
        /**
         * Color constant
         * @property Vermillion {ex.Color}
         * @static
         * @final
         */
        Color.Vermillion = Color.fromHex('#FF5B31');
        /**
         * Color constant
         * @property Rose {ex.Color}
         * @static
         * @final
         */
        Color.Rose = Color.fromHex('#FF007F');
        /**
         * Color constant
         * @property Magenta {ex.Color}
         * @static
         * @final
         */
        Color.Magenta = Color.fromHex('#FF00FF');
        /**
         * Color constant
         * @property Violet {ex.Color}
         * @static
         * @final
         */
        Color.Violet = Color.fromHex('#7F00FF');
        /**
         * Color constant
         * @property Blue {ex.Color}
         * @static
         * @final
         */
        Color.Blue = Color.fromHex('#0000FF');
        /**
         * Color constant
         * @property Azure {ex.Color}
         * @static
         * @final
         */
        Color.Azure = Color.fromHex('#007FFF');
        /**
         * Color constant
         * @property Cyan {ex.Color}
         * @static
         * @final
         */
        Color.Cyan = Color.fromHex('#00FFFF');
        /**
         * Color constant
         * @property Viridian {ex.Color}
         * @static
         * @final
         */
        Color.Viridian = Color.fromHex('#59978F');
        /**
         * Color constant
         * @property Green {ex.Color}
         * @static
         * @final
         */
        Color.Green = Color.fromHex('#00FF00');
        /**
         * Color constant
         * @property Chartreuse {ex.Color}
         * @static
         * @final
         */
        Color.Chartreuse = Color.fromHex('#7FFF00');
        /**
         * Color constant
         * @property Transparent {ex.Color}
         * @static
         * @final
         */
        Color.Transparent = Color.fromHex('#FFFFFF00');
        return Color;
    })();
    ex.Color = Color;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * Helper Actor primitive for drawing UI's, optimized for UI drawing. Does
     * not participate in collisions.
     * @class UIActor
     * @extends Actor
     * @constructor
     * @param [x=0.0] {number} The starting x coordinate of the actor
     * @param [y=0.0] {number} The starting y coordinate of the actor
     * @param [width=0.0] {number} The starting width of the actor
     * @param [height=0.0] {number} The starting height of the actor
     */
    var UIActor = (function (_super) {
        __extends(UIActor, _super);
        function UIActor(x, y, width, height) {
            _super.call(this, x, y, width, height);
            this.pipeline = [];
            this.pipeline.push(new ex.MovementModule());
            this.pipeline.push(new ex.CapturePointerModule());
            this.anchor.setTo(0, 0);
            this.collisionType = 0 /* PreventCollision */;
            this.enableCapturePointer = true;
        }
        UIActor.prototype.onInitialize = function (engine) {
            this._engine = engine;
        };
        UIActor.prototype.contains = function (x, y, useWorld) {
            if (useWorld === void 0) { useWorld = true; }
            if (useWorld)
                return _super.prototype.contains.call(this, x, y);
            var coords = this._engine.worldToScreenCoordinates(new ex.Point(x, y));
            return _super.prototype.contains.call(this, coords.x, coords.y);
        };
        return UIActor;
    })(ex.Actor);
    ex.UIActor = UIActor;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
/// <reference path="Engine.ts" />
var ex;
(function (ex) {
    /**
     * Triggers a method of firing arbitrary code on collision. These are useful
     * as 'buttons', 'switches', or to trigger effects in a game. By defualt triggers
     * are invisible, and can only be seen with debug mode enabled on the Engine.
     * @class Trigger
     * @constructor
     * @param [x=0] {number} The x position of the trigger
     * @param [y=0] {number} The y position of the trigger
     * @param [width=0] {number} The width of the trigger
     * @param [height=0] {number} The height of the trigger
     * @param [action=null] {()=>void} Callback to fire when trigger is activated
     * @param [repeats=1] {number} The number of times that this trigger should fire, by default it is 1, if -1 is supplied it will fire indefinitely
     */
    var Trigger = (function (_super) {
        __extends(Trigger, _super);
        function Trigger(x, y, width, height, action, repeats) {
            _super.call(this, x, y, width, height);
            this.action = function () {
            };
            this.repeats = 1;
            this.target = null;
            this.repeats = repeats || this.repeats;
            this.action = action || this.action;
            this.collisionType = 0 /* PreventCollision */;
            this.eventDispatcher = new ex.EventDispatcher(this);
            this.actionQueue = new ex.Internal.Actions.ActionQueue(this);
        }
        Trigger.prototype.update = function (engine, delta) {
            // Update action queue
            this.actionQueue.update(delta);
            // Update placements based on linear algebra
            this.x += this.dx * delta / 1000;
            this.y += this.dy * delta / 1000;
            this.rotation += this.rx * delta / 1000;
            this.scale.x += this.sx * delta / 1000;
            this.scale.y += this.sy * delta / 1000;
            // check for trigger collisions
            if (this.target) {
                if (this.collides(this.target)) {
                    this.dispatchAction();
                }
            }
            else {
                for (var i = 0; i < engine.currentScene.children.length; i++) {
                    var other = engine.currentScene.children[i];
                    if (other !== this && other.collisionType !== 0 /* PreventCollision */ && this.collides(other)) {
                        this.dispatchAction();
                    }
                }
            }
            // remove trigger if its done, -1 repeat forever
            if (this.repeats === 0) {
                this.kill();
            }
        };
        Trigger.prototype.dispatchAction = function () {
            this.action.call(this);
            this.repeats--;
        };
        Trigger.prototype.draw = function (ctx, delta) {
            // does not draw
            return;
        };
        Trigger.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            // Meant to draw debug information about actors
            ctx.save();
            ctx.translate(this.x, this.y);
            var bb = this.getBounds();
            bb.left = bb.left - this.getGlobalX();
            bb.right = bb.right - this.getGlobalX();
            bb.top = bb.top - this.getGlobalY();
            bb.bottom = bb.bottom - this.getGlobalY();
            // Currently collision primitives cannot rotate 
            // ctx.rotate(this.rotation);
            ctx.fillStyle = ex.Color.Violet.toString();
            ctx.strokeStyle = ex.Color.Violet.toString();
            ctx.fillText('Trigger', 10, 10);
            bb.debugDraw(ctx);
            ctx.restore();
        };
        return Trigger;
    })(ex.Actor);
    ex.Trigger = Trigger;
})(ex || (ex = {}));
/// <reference path="Engine.ts" />
/// <reference path="Algebra.ts" />
/// <reference path="Util.ts" />
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * An enum that represents the types of emitter nozzles
     * @class EmitterType
     */
    (function (EmitterType) {
        /**
         * Constant for the circular emitter type
         * @property Circle {EmitterType}
         */
        EmitterType[EmitterType["Circle"] = 0] = "Circle";
        /**
         * Constant for the rectangular emitter type
         * @property Rectangle {EmitterType}
         */
        EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
    })(ex.EmitterType || (ex.EmitterType = {}));
    var EmitterType = ex.EmitterType;
    var Particle = (function () {
        function Particle(emitter, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
            this.position = new ex.Vector(0, 0);
            this.velocity = new ex.Vector(0, 0);
            this.acceleration = new ex.Vector(0, 0);
            this.particleRotationalVelocity = 0;
            this.currentRotation = 0;
            this.focus = null;
            this.focusAccel = 0;
            this.opacity = 1;
            this.beginColor = ex.Color.White.clone();
            this.endColor = ex.Color.White.clone();
            // Life is counted in ms
            this.life = 300;
            this.fadeFlag = false;
            // Color transitions
            this.rRate = 1;
            this.gRate = 1;
            this.bRate = 1;
            this.aRate = 0;
            this.currentColor = ex.Color.White.clone();
            this.emitter = null;
            this.particleSize = 5;
            this.particleSprite = null;
            this.sizeRate = 0;
            this.elapsedMultiplier = 0;
            this.emitter = emitter;
            this.life = life || this.life;
            this.opacity = opacity || this.opacity;
            this.endColor = endColor || this.endColor.clone();
            this.beginColor = beginColor || this.beginColor.clone();
            this.currentColor = this.beginColor.clone();
            this.position = position || this.position;
            this.velocity = velocity || this.velocity;
            this.acceleration = acceleration || this.acceleration;
            this.rRate = (this.endColor.r - this.beginColor.r) / this.life;
            this.gRate = (this.endColor.g - this.beginColor.g) / this.life;
            this.bRate = (this.endColor.b - this.beginColor.b) / this.life;
            this.aRate = this.opacity / this.life;
            this.startSize = startSize || 0;
            this.endSize = endSize || 0;
            if ((this.endSize > 0) && (this.startSize > 0)) {
                this.sizeRate = (this.endSize - this.startSize) / this.life;
                this.particleSize = this.startSize;
            }
        }
        Particle.prototype.kill = function () {
            this.emitter.removeParticle(this);
        };
        Particle.prototype.update = function (delta) {
            this.life = this.life - delta;
            this.elapsedMultiplier = this.elapsedMultiplier + delta;
            if (this.life < 0) {
                this.kill();
            }
            if (this.fadeFlag) {
                this.opacity = ex.Util.clamp(this.aRate * this.life, 0.0001, 1);
            }
            if ((this.startSize > 0) && (this.endSize > 0)) {
                this.particleSize = ex.Util.clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
            }
            this.currentColor.r = ex.Util.clamp(this.currentColor.r + this.rRate * delta, 0, 255);
            this.currentColor.g = ex.Util.clamp(this.currentColor.g + this.gRate * delta, 0, 255);
            this.currentColor.b = ex.Util.clamp(this.currentColor.b + this.bRate * delta, 0, 255);
            this.currentColor.a = ex.Util.clamp(this.opacity, 0.0001, 1);
            if (this.focus) {
                var accel = this.focus.minus(this.position).normalize().scale(this.focusAccel).scale(delta / 1000);
                this.velocity = this.velocity.add(accel);
            }
            else {
                this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
            }
            this.position = this.position.add(this.velocity.scale(delta / 1000));
            if (this.particleRotationalVelocity) {
                this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1000) % (2 * Math.PI);
            }
        };
        Particle.prototype.draw = function (ctx) {
            if (this.particleSprite) {
                this.particleSprite.setRotation(this.currentRotation);
                this.particleSprite.setScaleX(this.particleSize);
                this.particleSprite.setScaleY(this.particleSize);
                this.particleSprite.draw(ctx, this.position.x, this.position.y);
                return;
            }
            this.currentColor.a = ex.Util.clamp(this.opacity, 0.0001, 1);
            ctx.fillStyle = this.currentColor.toString();
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        };
        return Particle;
    })();
    ex.Particle = Particle;
    /**
     * Using a particle emitter is a great way to create interesting effects
     * in your game, like smoke, fire, water, explosions, etc. Particle Emitters
     * extend Actor allowing you to use all of the features that come with Actor
     * @class ParticleEmitter
     * @constructor
     * @param [x=0] {number} The x position of the emitter
     * @param [y=0] {number} The y position of the emitter
     * @param [width=0] {number} The width of the emitter
     * @param [height=0] {number} The height of the emitter
     */
    var ParticleEmitter = (function (_super) {
        __extends(ParticleEmitter, _super);
        function ParticleEmitter(x, y, width, height) {
            _super.call(this, x, y, width, height, ex.Color.White);
            this._particlesToEmit = 0;
            this.numParticles = 0;
            /**
             * Gets or sets the isEmitting flag
             * @property isEmitting {boolean}
             */
            this.isEmitting = true;
            /**
             * Gets or sets the backing particle collection
             * @property particles {Util.Collection&lt;Particle&gt;}
             */
            this.particles = null;
            /**
             * Gets or sets the backing deadParticle collection
             * @property particles {Util.Collection&lt;Particle&gt;}
             */
            this.deadParticles = null;
            /**
             * Gets or sets the minimum partical velocity
             * @property [minVel=0] {number}
             */
            this.minVel = 0;
            /**
             * Gets or sets the maximum partical velocity
             * @property [maxVel=0] {number}
             */
            this.maxVel = 0;
            /**
             * Gets or sets the acceleration vector for all particles
             * @property [acceleration=new Vector(0,0)] {Vector}
             */
            this.acceleration = new ex.Vector(0, 0);
            /**
             * Gets or sets the minimum angle in radians
             * @property [minAngle=0] {number}
             */
            this.minAngle = 0;
            /**
             * Gets or sets the maximum angle in radians
             * @property [maxAngle=0] {number}
             */
            this.maxAngle = 0;
            /**
             * Gets or sets the emission rate for particles (particles/sec)
             * @property [emitRate=1] {number}
             */
            this.emitRate = 1; //particles/sec
            /**
             * Gets or sets the life of each particle in milliseconds
             * @property [particleLife=2000] {number}
             */
            this.particleLife = 2000;
            /**
             * Gets or sets the opacity of each particle from 0 to 1.0
             * @property [opacity=1.0] {number}
             */
            this.opacity = 1;
            /**
             * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
             * @property [fade=false] {boolean}
             */
            this.fadeFlag = false;
            /**
             * Gets or sets the optional focus where all particles should accelerate towards
             * @property [focus=null] {Vector}
             */
            this.focus = null;
            /**
             * Gets or sets the acceleration for focusing particles if a focus has been specified
             * @property [focusAccel=1] {number}
             */
            this.focusAccel = 1;
            /*
             * Gets or sets the optional starting size for the particles
             * @property [startSize=null] {number}
             */
            this.startSize = null;
            /*
             * Gets or sets the optional ending size for the particles
             * @property [endSize=null] {number}
             */
            this.endSize = null;
            /**
             * Gets or sets the minimum size of all particles
             * @property [minSize=5] {number}
             */
            this.minSize = 5;
            /**
             * Gets or sets the maximum size of all particles
             * @property [maxSize=5] {number}
             */
            this.maxSize = 5;
            /**
             * Gets or sets the beginning color of all particles
             * @property [beginColor=Color.White] {Color}
             */
            this.beginColor = ex.Color.White;
            /**
             * Gets or sets the ending color of all particles
             * @property [endColor=Color.White] {Color}
             */
            this.endColor = ex.Color.White;
            /**
             * Gets or sets the sprite that a particle should use
             * @property [particleSprite=null] {Sprite}
             */
            this.particleSprite = null;
            /**
             * Gets or sets the emitter type for the particle emitter
             * @property [emitterType=EmitterType.Rectangle] {EmitterType}
             */
            this.emitterType = 1 /* Rectangle */;
            /**
             * Gets or sets the emitter radius, only takes effect when the emitterType is Circle
             * @property [radius=0] {number}
             */
            this.radius = 0;
            /**
             * Gets or sets the particle rotational speed velocity
             * @property [particleRotationalVelocity=0] {number}
             */
            this.particleRotationalVelocity = 0;
            /**
             * Indicates whether particles should start with a random rotation
             * @property [randomRotation=false] {boolean}
             */
            this.randomRotation = false;
            this.collisionType = 0 /* PreventCollision */;
            this.particles = new ex.Util.Collection();
            this.deadParticles = new ex.Util.Collection();
        }
        ParticleEmitter.prototype.removeParticle = function (particle) {
            this.deadParticles.push(particle);
        };
        /**
         * Causes the emitter to emit particles
         * @method emit
         * @param particleCount {number} Number of particles to emit right now
         */
        ParticleEmitter.prototype.emit = function (particleCount) {
            for (var i = 0; i < particleCount; i++) {
                this.particles.push(this.createParticle());
            }
        };
        ParticleEmitter.prototype.clearParticles = function () {
            this.particles.clear();
        };
        // Creates a new particle given the contraints of the emitter
        ParticleEmitter.prototype.createParticle = function () {
            // todo implement emitter contraints;
            var ranX = 0;
            var ranY = 0;
            var angle = ex.Util.randomInRange(this.minAngle, this.maxAngle);
            var vel = ex.Util.randomInRange(this.minVel, this.maxVel);
            var size = this.startSize || ex.Util.randomInRange(this.minSize, this.maxSize);
            var dx = vel * Math.cos(angle);
            var dy = vel * Math.sin(angle);
            if (this.emitterType === 1 /* Rectangle */) {
                ranX = ex.Util.randomInRange(this.x, this.x + this.getWidth());
                ranY = ex.Util.randomInRange(this.y, this.y + this.getHeight());
            }
            else if (this.emitterType === 0 /* Circle */) {
                var radius = ex.Util.randomInRange(0, this.radius);
                ranX = radius * Math.cos(angle) + this.x;
                ranY = radius * Math.sin(angle) + this.y;
            }
            var p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new ex.Vector(ranX, ranY), new ex.Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
            p.fadeFlag = this.fadeFlag;
            p.particleSize = size;
            if (this.particleSprite) {
                p.particleSprite = this.particleSprite;
            }
            p.particleRotationalVelocity = this.particleRotationalVelocity;
            if (this.randomRotation) {
                p.currentRotation = ex.Util.randomInRange(0, Math.PI * 2);
            }
            if (this.focus) {
                p.focus = this.focus.add(new ex.Vector(this.x, this.y));
                p.focusAccel = this.focusAccel;
            }
            return p;
        };
        ParticleEmitter.prototype.update = function (engine, delta) {
            var _this = this;
            _super.prototype.update.call(this, engine, delta);
            if (this.isEmitting) {
                this._particlesToEmit += this.emitRate * (delta / 1000);
                var numParticles = Math.ceil(this.emitRate * delta / 1000);
                if (this._particlesToEmit > 1.0) {
                    this.emit(Math.floor(this._particlesToEmit));
                    this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
                }
            }
            this.particles.forEach(function (particle, index) {
                particle.update(delta);
            });
            this.deadParticles.forEach(function (particle, index) {
                _this.particles.removeElement(particle);
            });
            this.deadParticles.clear();
        };
        ParticleEmitter.prototype.draw = function (ctx, delta) {
            this.particles.forEach(function (particle, index) {
                // todo is there a more efficient to draw 
                // possibly use a webgl offscreen canvas and shaders to do particles?
                particle.draw(ctx);
            });
        };
        ParticleEmitter.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
            ctx.fillStyle = ex.Color.Black.toString();
            ctx.fillText("Particles: " + this.particles.count(), this.x, this.y + 20);
            if (this.focus) {
                ctx.fillRect(this.focus.x + this.x, this.focus.y + this.y, 3, 3);
                ex.Util.drawLine(ctx, "yellow", this.focus.x + this.x, this.focus.y + this.y, _super.prototype.getCenter.call(this).x, _super.prototype.getCenter.call(this).y);
                ctx.fillText("Focus", this.focus.x + this.x, this.focus.y + this.y);
            }
        };
        return ParticleEmitter;
    })(ex.Actor);
    ex.ParticleEmitter = ParticleEmitter;
})(ex || (ex = {}));
var ex;
(function (ex) {
    /**
     * Animations allow you to display a series of images one after another,
     * creating the illusion of change. Generally these images will come from a sprite sheet source.
     * @class Animation
     * @extends IDrawable
     * @constructor
     * @param engine {Engine} Reference to the current game engine
     * @param images {Sprite[]} An array of sprites to create the frames for the animation
     * @param speed {number} The number in milliseconds to display each frame in the animation
     * @param [loop=false] {boolean} Indicates whether the animation should loop after it is completed
     */
    var Animation = (function () {
        function Animation(engine, images, speed, loop) {
            this.currIndex = 0;
            this.oldTime = Date.now();
            this.rotation = 0.0;
            this.scaleX = 1.0;
            this.scaleY = 1.0;
            /**
             * Indicates whether the animation should loop after it is completed
             * @property [loop=false] {boolean}
             */
            this.loop = false;
            this.freezeFrame = -1;
            this.flipVertical = false;
            this.flipHorizontal = false;
            this.width = 0;
            this.height = 0;
            this.sprites = images;
            this.speed = speed;
            this.engine = engine;
            if (loop != null) {
                this.loop = loop;
            }
            this.height = images[0] ? images[0].height : 0;
            this.width = images[0] ? images[0].width : 0;
        }
        Animation.prototype.addEffect = function (effect) {
            for (var i in this.sprites) {
                this.sprites[i].addEffect(effect);
            }
        };
        Animation.prototype.removeEffect = function (param) {
            for (var i in this.sprites) {
                this.sprites[i].removeEffect(param);
            }
        };
        Animation.prototype.clearEffects = function () {
            for (var i in this.sprites) {
                this.sprites[i].clearEffects();
            }
        };
        Animation.prototype.transformAboutPoint = function (point) {
            for (var i in this.sprites) {
                this.sprites[i].transformAboutPoint(point);
            }
        };
        Animation.prototype.setRotation = function (radians) {
            this.rotation = radians;
            for (var i in this.sprites) {
                this.sprites[i].setRotation(radians);
            }
        };
        Animation.prototype.getRotation = function () {
            return this.rotation;
        };
        Animation.prototype.setScaleX = function (scaleX) {
            this.scaleX = scaleX;
            for (var i in this.sprites) {
                this.sprites[i].setScaleX(scaleX);
            }
        };
        Animation.prototype.setScaleY = function (scaleY) {
            this.scaleY = scaleY;
            for (var i in this.sprites) {
                this.sprites[i].setScaleY(scaleY);
            }
        };
        Animation.prototype.getScaleX = function () {
            return this.scaleX;
        };
        Animation.prototype.getScaleY = function () {
            return this.scaleY;
        };
        /**
         * Resets the animation to first frame.
         * @method reset
         */
        Animation.prototype.reset = function () {
            this.currIndex = 0;
        };
        /**
         * Indicates whether the animation is complete, animations that loop are never complete.
         * @method isDone
         * @returns boolean
         */
        Animation.prototype.isDone = function () {
            return (!this.loop && this.currIndex >= this.sprites.length);
        };
        /**
         * Not meant to be called by game developers. Ticks the animation forward internally an
         * calculates whether to change to teh frame.
         * @method tick
         */
        Animation.prototype.tick = function () {
            var time = Date.now();
            if ((time - this.oldTime) > this.speed) {
                this.currIndex = (this.loop ? (this.currIndex + 1) % this.sprites.length : this.currIndex + 1);
                this.oldTime = time;
            }
        };
        /**
         * Skips ahead a specified number of frames in the animation
         * @method skip
         * @param frames {number} Frames to skip ahead
         */
        Animation.prototype.skip = function (frames) {
            this.currIndex = (this.currIndex + frames) % this.sprites.length;
        };
        Animation.prototype.draw = function (ctx, x, y) {
            this.tick();
            if (this.currIndex < this.sprites.length) {
                var currSprite = this.sprites[this.currIndex];
                if (this.flipVertical) {
                    currSprite.flipVertical = this.flipVertical;
                }
                if (this.flipHorizontal) {
                    currSprite.flipHorizontal = this.flipHorizontal;
                }
                currSprite.draw(ctx, x, y);
            }
            if (this.freezeFrame !== -1 && this.currIndex >= this.sprites.length) {
                var currSprite = this.sprites[ex.Util.clamp(this.freezeFrame, 0, this.sprites.length - 1)];
                currSprite.draw(ctx, x, y);
            }
        };
        /**
         * Plays an animation at an arbitrary location in the game.
         * @method play
         * @param x {number} The x position in the game to play
         * @param y {number} The y position in the game to play
         */
        Animation.prototype.play = function (x, y) {
            this.reset();
            this.engine.playAnimation(this, x, y);
        };
        return Animation;
    })();
    ex.Animation = Animation;
})(ex || (ex = {}));
/// <reference path="MonkeyPatch.ts" />
/// <reference path="Util.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    var Internal;
    (function (Internal) {
        var FallbackAudio = (function () {
            function FallbackAudio(path, volume) {
                this.log = ex.Logger.getInstance();
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                if (window.AudioContext) {
                    this.log.debug("Using new Web Audio Api for " + path);
                    this.soundImpl = new WebAudio(path, volume);
                }
                else {
                    this.log.debug("Falling back to Audio Element for " + path);
                    this.soundImpl = new AudioTag(path, volume);
                }
            }
            FallbackAudio.prototype.setVolume = function (volume) {
                this.soundImpl.setVolume(volume);
            };
            FallbackAudio.prototype.setLoop = function (loop) {
                this.soundImpl.setLoop(loop);
            };
            FallbackAudio.prototype.load = function () {
                this.soundImpl.onload = this.onload;
                this.soundImpl.onprogress = this.onprogress;
                this.soundImpl.onerror = this.onerror;
                this.soundImpl.load();
            };
            FallbackAudio.prototype.isPlaying = function () {
                return this.soundImpl.isPlaying();
            };
            FallbackAudio.prototype.play = function () {
                return this.soundImpl.play();
            };
            FallbackAudio.prototype.pause = function () {
                this.soundImpl.pause();
            };
            FallbackAudio.prototype.stop = function () {
                this.soundImpl.stop();
            };
            return FallbackAudio;
        })();
        Internal.FallbackAudio = FallbackAudio;
        var AudioTag = (function () {
            function AudioTag(path, volume) {
                var _this = this;
                this.path = path;
                this.audioElements = new Array(5);
                this._loadedAudio = null;
                this.isLoaded = false;
                this.index = 0;
                this.log = ex.Logger.getInstance();
                this._isPlaying = false;
                this._currentOffset = 0;
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                for (var i = 0; i < this.audioElements.length; i++) {
                    (function (i) {
                        _this.audioElements[i] = new Audio();
                    })(i);
                }
                if (volume) {
                    this.setVolume(ex.Util.clamp(volume, 0, 1.0));
                }
                else {
                    this.setVolume(1.0);
                }
            }
            AudioTag.prototype.isPlaying = function () {
                return this._isPlaying;
            };
            AudioTag.prototype.audioLoaded = function () {
                this.isLoaded = true;
            };
            AudioTag.prototype.setVolume = function (volume) {
                this.audioElements.forEach(function (a) {
                    a.volume = volume;
                });
            };
            AudioTag.prototype.setLoop = function (loop) {
                this.audioElements.forEach(function (a) {
                    a.loop = loop;
                });
            };
            AudioTag.prototype.getLoop = function () {
                this.audioElements.some(function (a) { return a.loop; });
            };
            AudioTag.prototype.load = function () {
                var _this = this;
                var request = new XMLHttpRequest();
                request.open("GET", this.path, true);
                request.responseType = 'blob';
                request.onprogress = this.onprogress;
                request.onerror = this.onerror;
                request.onload = function (e) {
                    if (request.status !== 200) {
                        _this.log.error("Failed to load audio resource ", _this.path, " server responded with error code", request.status);
                        _this.onerror(request.response);
                        _this.isLoaded = false;
                        return;
                    }
                    _this._loadedAudio = URL.createObjectURL(request.response);
                    _this.audioElements.forEach(function (a) {
                        a.src = _this._loadedAudio;
                    });
                    _this.onload(e);
                };
                request.send();
            };
            AudioTag.prototype.play = function () {
                var _this = this;
                this.audioElements[this.index].load();
                //this.audioElements[this.index].currentTime = this._currentOffset;
                this.audioElements[this.index].play();
                this._currentOffset = 0;
                var done = new ex.Promise();
                this._isPlaying = true;
                if (!this.getLoop()) {
                    this.audioElements[this.index].addEventListener('ended', function () {
                        _this._isPlaying = false;
                        done.resolve(true);
                    });
                }
                this.index = (this.index + 1) % this.audioElements.length;
                return done;
            };
            AudioTag.prototype.pause = function () {
                this.index = (this.index - 1 + this.audioElements.length) % this.audioElements.length;
                this._currentOffset = this.audioElements[this.index].currentTime;
                this.audioElements.forEach(function (a) {
                    a.pause();
                });
                this._isPlaying = false;
            };
            AudioTag.prototype.stop = function () {
                this.audioElements.forEach(function (a) {
                    a.pause();
                    //a.currentTime = 0;
                });
                this._isPlaying = false;
            };
            return AudioTag;
        })();
        Internal.AudioTag = AudioTag;
        if (window.AudioContext) {
            var audioContext = new window.AudioContext();
        }
        var WebAudio = (function () {
            function WebAudio(soundPath, volume) {
                this.context = audioContext;
                this.volume = this.context.createGain();
                this.buffer = null;
                this.sound = null;
                this.path = "";
                this.isLoaded = false;
                this.loop = false;
                this._isPlaying = false;
                this._isPaused = false;
                this._currentOffset = 0;
                this.logger = ex.Logger.getInstance();
                this.onload = function () {
                };
                this.onprogress = function () {
                };
                this.onerror = function () {
                };
                this.path = soundPath;
                if (volume) {
                    this.volume.gain.value = ex.Util.clamp(volume, 0, 1.0);
                }
                else {
                    this.volume.gain.value = 1.0; // max volume
                }
            }
            WebAudio.prototype.setVolume = function (volume) {
                this.volume.gain.value = volume;
            };
            WebAudio.prototype.load = function () {
                var _this = this;
                var request = new XMLHttpRequest();
                request.open('GET', this.path);
                request.responseType = 'arraybuffer';
                request.onprogress = this.onprogress;
                request.onerror = this.onerror;
                request.onload = function () {
                    if (request.status !== 200) {
                        _this.logger.error("Failed to load audio resource ", _this.path, " server responded with error code", request.status);
                        _this.onerror(request.response);
                        _this.isLoaded = false;
                        return;
                    }
                    _this.context.decodeAudioData(request.response, function (buffer) {
                        _this.buffer = buffer;
                        _this.isLoaded = true;
                        _this.onload(_this);
                    }, function (e) {
                        _this.logger.error("Unable to decode " + _this.path + " this browser may not fully support this format, or the file may be corrupt, " + "if this is an mp3 try removing id3 tags and album art from the file.");
                        _this.isLoaded = false;
                        _this.onload(_this);
                    });
                };
                try {
                    request.send();
                }
                catch (e) {
                    console.error("Error loading sound! If this is a cross origin error, you must host your sound with your html and javascript.");
                }
            };
            WebAudio.prototype.setLoop = function (loop) {
                this.loop = loop;
            };
            WebAudio.prototype.isPlaying = function () {
                return this._isPlaying;
            };
            WebAudio.prototype.play = function () {
                var _this = this;
                if (this.isLoaded) {
                    this.sound = this.context.createBufferSource();
                    this.sound.buffer = this.buffer;
                    this.sound.loop = this.loop;
                    this.sound.connect(this.volume);
                    this.volume.connect(this.context.destination);
                    this.sound.start(0, this._currentOffset % this.buffer.duration);
                    this._currentOffset = 0;
                    var done;
                    if (!this._isPaused || !this._playPromise) {
                        done = new ex.Promise();
                    }
                    else {
                        done = this._playPromise;
                    }
                    this._isPaused = false;
                    this._isPlaying = true;
                    if (!this.loop) {
                        this.sound.onended = (function () {
                            _this._isPlaying = false;
                            if (!_this._isPaused) {
                                done.resolve(true);
                            }
                        }).bind(this);
                    }
                    this._playPromise = done;
                    return done;
                }
                else {
                    return ex.Promise.wrap(true);
                }
            };
            WebAudio.prototype.pause = function () {
                if (this._isPlaying) {
                    try {
                        window.clearTimeout(this._playingTimer);
                        this.sound.stop(0);
                        this._currentOffset = this.context.currentTime;
                        this._isPlaying = false;
                        this._isPaused = true;
                    }
                    catch (e) {
                        this.logger.warn("The sound clip", this.path, "has already been paused!");
                    }
                }
            };
            WebAudio.prototype.stop = function () {
                if (this.sound) {
                    try {
                        window.clearTimeout(this._playingTimer);
                        this._currentOffset = 0;
                        this.sound.stop(0);
                        this._isPlaying = false;
                        this._isPaused = false;
                    }
                    catch (e) {
                        this.logger.warn("The sound clip", this.path, "has already been stopped!");
                    }
                }
            };
            return WebAudio;
        })();
        Internal.WebAudio = WebAudio;
    })(Internal = ex.Internal || (ex.Internal = {}));
})(ex || (ex = {}));
/// <reference path="Log.ts" />
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
var ex;
(function (ex) {
    /**
     * Valid states for a promise to be in
     * @class PromiseState
     */
    (function (PromiseState) {
        /**
        @property Resolved {PromiseState}
        */
        PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
        /**
        @property Rejected {PromiseState}
        */
        PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
        /**
        @property Pending {PromiseState}
        */
        PromiseState[PromiseState["Pending"] = 2] = "Pending";
    })(ex.PromiseState || (ex.PromiseState = {}));
    var PromiseState = ex.PromiseState;
    /**
     * Promises/A+ spec implementation of promises
     * @class Promise
     * @constructor
     */
    var Promise = (function () {
        function Promise() {
            this._state = 2 /* Pending */;
            this.successCallbacks = [];
            this.rejectCallback = function () {
            };
            this.logger = ex.Logger.getInstance();
        }
        /**
         * Wrap a value in a resolved promise
         * @method wrap<T>
         * @param [value=undefined] {T} An optional value to wrap in a resolved promise
         * @returns Promise&lt;T&gt;
         */
        Promise.wrap = function (value) {
            var promise = (new Promise()).resolve(value);
            return promise;
        };
        /**
         * Returns a new promise that resolves when all the promises passed to it resolve, or rejects
         * when at least 1 promise rejects.
         * @param promises {Promise[]}
         * @returns Promise
         */
        Promise.join = function () {
            var promises = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                promises[_i - 0] = arguments[_i];
            }
            var joinedPromise = new Promise();
            if (!promises) {
                return joinedPromise.resolve();
            }
            var total = promises.length;
            var successes = 0;
            var rejects = 0;
            var errors = [];
            promises.forEach(function (p) {
                p.then(function () {
                    successes += 1;
                    if (successes === total) {
                        joinedPromise.resolve();
                    }
                    else if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }, function () {
                    rejects += 1;
                    if (successes + rejects + errors.length === total) {
                        joinedPromise.reject(errors);
                    }
                }).error(function (e) {
                    errors.push(e);
                    if ((errors.length + successes + rejects) === total) {
                        joinedPromise.reject(errors);
                    }
                });
            });
            return joinedPromise;
        };
        /**
         * Chain success and reject callbacks after the promise is resovled
         * @method then
         * @param successCallback {T=>any} Call on resolution of promise
         * @param rejectCallback {any=>any} Call on rejection of promise
         * @returns Promise&lt;T&gt;
         */
        Promise.prototype.then = function (successCallback, rejectCallback) {
            if (successCallback) {
                this.successCallbacks.push(successCallback);
                // If the promise is already resovled call immediately
                if (this.state() === 0 /* Resolved */) {
                    try {
                        successCallback.call(this, this.value);
                    }
                    catch (e) {
                        this.handleError(e);
                    }
                }
            }
            if (rejectCallback) {
                this.rejectCallback = rejectCallback;
                // If the promise is already rejected call immediately
                if (this.state() === 1 /* Rejected */) {
                    try {
                        rejectCallback.call(this, this.value);
                    }
                    catch (e) {
                        this.handleError(e);
                    }
                }
            }
            return this;
        };
        /**
         * Add an error callback to the promise
         * @method error
         * @param errorCallback {any=>any} Call if there was an error in a callback
         * @returns Promise&lt;T&gt;
         */
        Promise.prototype.error = function (errorCallback) {
            if (errorCallback) {
                this.errorCallback = errorCallback;
            }
            return this;
        };
        /**
         * Resolve the promise and pass an option value to the success callbacks
         * @method resolve
         * @param [value=undefined] {T} Value to pass to the success callbacks
         */
        Promise.prototype.resolve = function (value) {
            var _this = this;
            if (this._state === 2 /* Pending */) {
                this.value = value;
                try {
                    this._state = 0 /* Resolved */;
                    this.successCallbacks.forEach(function (cb) {
                        cb.call(_this, _this.value);
                    });
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            else {
                throw new Error('Cannot resolve a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Reject the promise and pass an option value to the reject callbacks
         * @method reject
         * @param [value=undefined] {T} Value to pass to the reject callbacks
         */
        Promise.prototype.reject = function (value) {
            if (this._state === 2 /* Pending */) {
                this.value = value;
                try {
                    this._state = 1 /* Rejected */;
                    this.rejectCallback.call(this, this.value);
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            else {
                throw new Error('Cannot reject a promise that is not in a pending state!');
            }
            return this;
        };
        /**
         * Inpect the current state of a promise
         * @method state
         * @returns PromiseState
         */
        Promise.prototype.state = function () {
            return this._state;
        };
        Promise.prototype.handleError = function (e) {
            if (this.errorCallback) {
                this.errorCallback.call(this, e);
            }
            else {
                throw e;
            }
        };
        return Promise;
    })();
    ex.Promise = Promise;
})(ex || (ex = {}));
/// <reference path="Interfaces/ILoadable.ts" />
var ex;
(function (ex) {
    /**
     * The Resource type allows games built in Excalibur to load generic resources.
     * For any type of remote resource it is recome
     * @class Resource
     * @extend ILoadable
     * @constructor
     * @param path {string} Path to the remote resource
     */
    var Resource = (function () {
        function Resource(path, responseType, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            this.path = path;
            this.responseType = responseType;
            this.bustCache = bustCache;
            this.data = null;
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
        }
        /**
         * Returns true if the Resource is completely loaded and is ready
         * to be drawn.
         * @method isLoaded
         * @returns boolean
         */
        Resource.prototype.isLoaded = function () {
            return !!this.data;
        };
        Resource.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        Resource.prototype.cacheBust = function (uri) {
            var query = /\?\w*=\w*/;
            if (query.test(uri)) {
                uri += ("&__=" + Date.now());
            }
            else {
                uri += ("?__=" + Date.now());
            }
            return uri;
        };
        Resource.prototype._start = function (e) {
            this.logger.debug("Started loading resource " + this.path);
        };
        /**
         * Begin loading the resource and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;any&gt;
         */
        Resource.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var request = new XMLHttpRequest();
            request.open("GET", this.bustCache ? this.cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.onloadstart = function (e) {
                _this._start(e);
            };
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function (e) {
                if (request.status !== 200) {
                    _this.logger.error("Failed to load resource ", _this.path, " server responded with error code", request.status);
                    _this.onerror(request.response);
                    complete.resolve(request.response);
                    return;
                }
                _this.data = _this.processDownload(request.response);
                _this.oncomplete();
                _this.logger.debug("Completed loading resource", _this.path);
                complete.resolve(_this.data);
            };
            request.send();
            return complete;
        };
        /**
         * Returns the loaded data once the resource is loaded
         * @method GetData
         * @returns any
         */
        Resource.prototype.getData = function () {
            return this.data;
        };
        /**
         * This method is meant to be overriden to handle any additional
         * processing. Such as decoding downloaded audio bits.
         * @method ProcessDownload
         */
        Resource.prototype.processDownload = function (data) {
            // Handle any additional loading after the xhr has completed.
            return URL.createObjectURL(data);
        };
        return Resource;
    })();
    ex.Resource = Resource;
})(ex || (ex = {}));
/// <reference path="Sound.ts" />
/// <reference path="Util.ts" />
/// <reference path="Promises.ts" />
/// <reference path="Resource.ts" />
/// <reference path="Interfaces/ILoadable.ts" />
var ex;
(function (ex) {
    /**
     * The Texture object allows games built in Excalibur to load image resources.
     * It is generally recommended to preload images using the "Texture" object.
     * @class Texture
     * @extend Resource
     * @constructor
     * @param path {string} Path to the image resource
     * @param [bustCache=true] {boolean} Optionally load texture with cache busting
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture(path, bustCache) {
            if (bustCache === void 0) { bustCache = true; }
            _super.call(this, path, 'blob', bustCache);
            this.path = path;
            this.bustCache = bustCache;
            this.loaded = new ex.Promise();
            this._isLoaded = false;
            this._sprite = null;
            this._sprite = new ex.Sprite(this, 0, 0, 0, 0);
        }
        /**
         * Returns true if the Texture is completely loaded and is ready
         * to be drawn.
         * @method isLoaded
         * @returns boolean
         */
        Texture.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the texture and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;HTMLImageElement&gt;
         */
        Texture.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var loaded = _super.prototype.load.call(this);
            loaded.then(function () {
                _this.image = new Image();
                _this.image.addEventListener("load", function () {
                    _this._isLoaded = true;
                    _this.width = _this._sprite.swidth = _this._sprite.width = _this.image.naturalWidth;
                    _this.height = _this._sprite.sheight = _this._sprite.height = _this.image.naturalHeight;
                    _this.loaded.resolve(_this.image);
                    complete.resolve(_this.image);
                });
                _this.image.src = _super.prototype.getData.call(_this);
            }, function () {
                complete.reject("Error loading texture.");
            });
            return complete;
        };
        Texture.prototype.asSprite = function () {
            return this._sprite;
        };
        return Texture;
    })(ex.Resource);
    ex.Texture = Texture;
    /**
     * The Sound object allows games built in Excalibur to load audio
     * components, from soundtracks to sound effects. It is generally
     * recommended to load sound resources when using Excalibur
     * @class Sound
     * @extend Resource
     * @constructor
     * @param ...paths {string[]} A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    var Sound = (function () {
        function Sound() {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i - 0] = arguments[_i];
            }
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            this.onload = function () {
            };
            this._isLoaded = false;
            this._selectedFile = "";
            this._wasPlayingOnHidden = false;
            /* Chrome : MP3, WAV, Ogg
             * Firefox : WAV, Ogg,
             * IE : MP3, WAV coming soon
             * Safari MP3, WAV, Ogg
             */
            this._selectedFile = "";
            for (var i = 0; i < paths.length; i++) {
                if (Sound.canPlayFile(paths[i])) {
                    this._selectedFile = paths[i];
                    break;
                }
            }
            if (!this._selectedFile) {
                this.logger.warn("This browser does not support any of the files specified");
                this._selectedFile = paths[0]; // select the first specified
            }
            this.sound = new ex.Internal.FallbackAudio(this._selectedFile, 1.0);
        }
        Sound.canPlayFile = function (file) {
            try {
                var a = new Audio();
                var filetype = /.*\.([A-Za-z0-9]+)$/;
                var type = file.match(filetype)[1];
                if (a.canPlayType('audio/' + type)) {
                    return true;
                }
                {
                    return false;
                }
            }
            catch (e) {
                ex.Logger.getInstance().warn("Cannot determine audio support, assuming no support for the Audio Tag", e);
                return false;
            }
        };
        Sound.prototype.wireEngine = function (engine) {
            var _this = this;
            if (engine) {
                this._engine = engine;
                this._engine.on('hidden', function () {
                    if (engine.pauseAudioWhenHidden && _this.isPlaying()) {
                        _this._wasPlayingOnHidden = true;
                        _this.pause();
                    }
                });
                this._engine.on('visible', function () {
                    if (engine.pauseAudioWhenHidden && _this._wasPlayingOnHidden) {
                        _this.play();
                        _this._wasPlayingOnHidden = false;
                    }
                });
            }
        };
        /**
         * Sets the volume of the sound clip
         * @method setVolume
         * @param volume {number} A volume value between 0-1.0
         */
        Sound.prototype.setVolume = function (volume) {
            if (this.sound)
                this.sound.setVolume(volume);
        };
        /**
         * Indicates whether the clip should loop when complete
         * @method setLoop
         * @param loop {boolean} Set the looping flag
         */
        Sound.prototype.setLoop = function (loop) {
            if (this.sound)
                this.sound.setLoop(loop);
        };
        Sound.prototype.isPlaying = function () {
            if (this.sound)
                return this.sound.isPlaying();
        };
        /**
         * Play the sound, returns a promise that resolves when the sound is done playing
         * @method play
         * @return ex.Promise
         */
        Sound.prototype.play = function () {
            if (this.sound)
                return this.sound.play();
        };
        /**
         * Stop the sound, and do not rewind
         * @method pause
         */
        Sound.prototype.pause = function () {
            if (this.sound)
                this.sound.pause();
        };
        /**
         * Stop the sound and rewind
         * @method stop
         */
        Sound.prototype.stop = function () {
            if (this.sound)
                this.sound.stop();
        };
        /**
         * Returns true if the sound is loaded
         * @method isLoaded
         */
        Sound.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        /**
         * Begins loading the sound and returns a promise to be resolved on completion
         * @method load
         * @returns Promise&lt;Sound&gt;
         */
        Sound.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            this.logger.debug("Started loading sound", this._selectedFile);
            this.sound.onprogress = this.onprogress;
            this.sound.onload = function () {
                _this.oncomplete();
                _this._isLoaded = true;
                _this.logger.debug("Completed loading sound", _this._selectedFile);
                complete.resolve(_this.sound);
            };
            this.sound.onerror = function (e) {
                _this.onerror(e);
                complete.resolve(e);
            };
            this.sound.load();
            return complete;
        };
        return Sound;
    })();
    ex.Sound = Sound;
    /**
     * The loader provides a mechanism to preload multiple resources at
     * one time. The loader must be passed to the engine in order to
     * trigger the loading progress bar
     * @class Loader
     * @extend ILoadable
     * @constructor
     * @param [loadables=undefined] {ILoadable[]} Optionally provide the list of resources you want to load at constructor time
     */
    var Loader = (function () {
        function Loader(loadables) {
            this.resourceList = [];
            this.index = 0;
            this.resourceCount = 0;
            this.numLoaded = 0;
            this.progressCounts = {};
            this.totalCounts = {};
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            if (loadables) {
                this.addResources(loadables);
            }
        }
        Loader.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Add a resource to the loader to load
         * @method addResource
         * @param loadable {ILoadable} Resource to add
         */
        Loader.prototype.addResource = function (loadable) {
            var key = this.index++;
            this.resourceList.push(loadable);
            this.progressCounts[key] = 0;
            this.totalCounts[key] = 1;
            this.resourceCount++;
        };
        /**
         * Add a list of resources to the loader to load
         * @method addResources
         * @param loadables {ILoadable[]} The list of resources to load
         */
        Loader.prototype.addResources = function (loadables) {
            var _this = this;
            loadables.forEach(function (l) {
                _this.addResource(l);
            });
        };
        Loader.prototype.sumCounts = function (obj) {
            var sum = 0;
            var prev = 0;
            for (var i in obj) {
                sum += obj[i] | 0;
            }
            return sum;
        };
        /**
         * Returns true if the loader has completely loaded all resources
         * @method isLoaded
         */
        Loader.prototype.isLoaded = function () {
            return this.numLoaded === this.resourceCount;
        };
        /**
         * Begin loading all of the supplied resources, returning a promise that resolves when loading of all is complete
         * @method load
         * @returns Promsie&lt;any&gt;
         */
        Loader.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var me = this;
            if (this.resourceList.length === 0) {
                me.oncomplete.call(me);
                return complete;
            }
            var progressArray = new Array(this.resourceList.length);
            var progressChunks = this.resourceList.length;
            this.resourceList.forEach(function (r, i) {
                if (_this._engine) {
                    r.wireEngine(_this._engine);
                }
                r.onprogress = function (e) {
                    var total = e.total;
                    var loaded = e.loaded;
                    progressArray[i] = { loaded: ((loaded / total) * (100 / progressChunks)), total: 100 };
                    var progressResult = progressArray.reduce(function (accum, next) {
                        return { loaded: (accum.loaded + next.loaded), total: 100 };
                    }, { loaded: 0, total: 100 });
                    me.onprogress.call(me, progressResult);
                };
                r.oncomplete = r.onerror = function () {
                    me.numLoaded++;
                    if (me.numLoaded === me.resourceCount) {
                        me.onprogress.call(me, { loaded: 100, total: 100 });
                        me.oncomplete.call(me);
                        complete.resolve();
                    }
                };
            });
            function loadNext(list, index) {
                if (!list[index])
                    return;
                list[index].load().then(function () {
                    loadNext(list, index + 1);
                });
            }
            loadNext(this.resourceList, 0);
            return complete;
        };
        return Loader;
    })();
    ex.Loader = Loader;
})(ex || (ex = {}));
/// <reference path="Promises.ts" />
/// <reference path="Loader.ts" />
/// <reference path="Log.ts" />
var ex;
(function (ex) {
    /**
     * Excalibur's built in templating class, it is a loadable that will load
     * and html fragment from a url. Excalibur templating is very basic only
     * allowing bindings of the type data-text="this.obj.someprop",
     * data-style="color:this.obj.color.toString()". Bindings allow all valid
     * javascript expressions.
     * @class Template
     * @extends ILoadable
     * @constructor
     * @param path {string} Location of the html template
     */
    var Template = (function () {
        function Template(path) {
            this.path = path;
            this._isLoaded = false;
            this.logger = ex.Logger.getInstance();
            this.onprogress = function () {
            };
            this.oncomplete = function () {
            };
            this.onerror = function () {
            };
            this._innerElement = document.createElement('div');
            this._innerElement.className = "excalibur-template";
        }
        Template.prototype.wireEngine = function (engine) {
            this._engine = engine;
        };
        /**
         * Returns the full html template string once loaded.
         * @method getTemplateString
         * @returns string
         */
        Template.prototype.getTemplateString = function () {
            if (!this._isLoaded)
                return "";
            return this._htmlString;
        };
        Template.prototype._compile = function () {
            this._innerElement.innerHTML = this._htmlString;
            this._styleElements = this._innerElement.querySelectorAll('[data-style]');
            this._textElements = this._innerElement.querySelectorAll('[data-text]');
        };
        Template.prototype._evaluateExpresion = function (expression, ctx) {
            var func = new Function("return " + expression + ";");
            var val = func.call(ctx);
            return val;
        };
        /**
         * Applies any ctx object you wish and evaluates the template.
         * Overload this method to include your favorite template library.
         * You may return either an HTML string or a Dom node.
         * @method apply
         * @param ctx {any} Any object you wish to apply to the template
         * @returns any
         */
        Template.prototype.apply = function (ctx) {
            var _this = this;
            for (var j = 0; j < this._styleElements.length; j++) {
                (function () {
                    // poor man's json parse for things that aren't exactly json :(
                    // Extract style expressions
                    var styles = {};
                    _this._styleElements[j].dataset["style"].split(";").forEach(function (s) {
                        if (s) {
                            var vals = s.split(":");
                            styles[vals[0].trim()] = vals[1].trim();
                        }
                    });
                    for (var style in styles) {
                        (function () {
                            var expression = styles[style];
                            _this._styleElements[j].style[style] = _this._evaluateExpresion(expression, ctx);
                        })();
                    }
                })();
            }
            for (var i = 0; i < this._textElements.length; i++) {
                (function () {
                    // Evaluate text expressions
                    var expression = _this._textElements[i].dataset["text"];
                    _this._textElements[i].innerText = _this._evaluateExpresion(expression, ctx);
                })();
            }
            // If the template HTML has a root element return that, otherwise use constructed root
            if (this._innerElement.children.length === 1) {
                this._innerElement = this._innerElement.firstChild;
            }
            return this._innerElement;
        };
        /**
         * Begins loading the template. Returns a promise that resolves with the template string when loaded.
         * @method load
         * @returns {Promise}
         */
        Template.prototype.load = function () {
            var _this = this;
            var complete = new ex.Promise();
            var request = new XMLHttpRequest();
            request.open("GET", this.path, true);
            request.responseType = "text";
            request.onprogress = this.onprogress;
            request.onerror = this.onerror;
            request.onload = function (e) {
                if (request.status !== 200) {
                    _this.logger.error("Failed to load html template resource ", _this.path, " server responded with error code", request.status);
                    _this.onerror(request.response);
                    _this._isLoaded = false;
                    complete.resolve("error");
                    return;
                }
                _this._htmlString = request.response;
                _this.oncomplete();
                _this.logger.debug("Completed loading template", _this.path);
                _this._compile();
                _this._isLoaded = true;
                complete.resolve(_this._htmlString);
            };
            if (request.overrideMimeType) {
                request.overrideMimeType('text/plain; charset=x-user-defined');
            }
            request.send();
            return complete;
        };
        /**
         * Indicates whether the template has been loaded
         * @method isLoaded
         * @returns {boolean}
         */
        Template.prototype.isLoaded = function () {
            return this._isLoaded;
        };
        return Template;
    })();
    ex.Template = Template;
    /**
     * Excalibur's binding library that allows you to bind an html
     * template to the dom given a certain context. Excalibur bindings are only updated
     * when the update() method is called
     * @class Binding
     * @constructor
     * @param parentElementId {string} The id of the element in the dom to attach the template binding
     * @param template {Template} The template you wish to bind
     * @param ctx {any} The context of the binding, which can be any object
     */
    var Binding = (function () {
        function Binding(parentElementId, template, ctx) {
            this.parent = document.getElementById(parentElementId);
            this.template = template;
            this._ctx = ctx;
            this.update();
        }
        /**
         * Listen to any arbitrary object's events to update this binding
         * @method listen
         * @param obj {any} Any object that supports addEventListener
         * @param events {string[]} A list of events to listen for
         * @param [hander=defaultHandler] {callback} A optional handler to fire on any event
         */
        Binding.prototype.listen = function (obj, events, handler) {
            var _this = this;
            // todo
            if (!handler) {
                handler = function () {
                    _this.update();
                };
            }
            if (obj.addEventListener) {
                events.forEach(function (e) {
                    obj.addEventListener(e, handler);
                });
            }
        };
        /**
         * Update this template binding with the latest values from the ctx reference passed to the constructor
         * @method update
         */
        Binding.prototype.update = function () {
            var html = this._applyTemplate(this.template, this._ctx);
            if (html instanceof String) {
                this.parent.innerHTML = html;
            }
            if (html instanceof Node) {
                if (this.parent.lastChild !== html) {
                    this.parent.appendChild(html);
                }
            }
        };
        Binding.prototype._applyTemplate = function (template, ctx) {
            if (template.isLoaded()) {
                return template.apply(ctx);
            }
        };
        return Binding;
    })();
    ex.Binding = Binding;
})(ex || (ex = {}));
/// <reference path="Actor.ts" />
var ex;
(function (ex) {
    /**
     * Enum representing the different horizontal text alignments
     * @class TextAlign
     */
    (function (TextAlign) {
        /**
         * The text is left-aligned.
         * @property Left
         * @static
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * The text is right-aligned.
         * @property Right
         * @static
         */
        TextAlign[TextAlign["Right"] = 1] = "Right";
        /**
         * The text is centered.
         * @property Center
         * @static
         */
        TextAlign[TextAlign["Center"] = 2] = "Center";
        /**
         * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).
         * @property Start
         * @static
         */
        TextAlign[TextAlign["Start"] = 3] = "Start";
        /**
         * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).
         * @property End
         * @static
         */
        TextAlign[TextAlign["End"] = 4] = "End";
    })(ex.TextAlign || (ex.TextAlign = {}));
    var TextAlign = ex.TextAlign;
    /**
     * Enum representing the different baseline text alignments
     * @class BaseAlign
     */
    (function (BaseAlign) {
        /**
         * The text baseline is the top of the em square.
         * @property Top
         * @static
         */
        BaseAlign[BaseAlign["Top"] = 0] = "Top";
        /**
         * The text baseline is the hanging baseline.  Currently unsupported; this will act like alphabetic.
         * @property Hanging
         * @static
         */
        BaseAlign[BaseAlign["Hanging"] = 1] = "Hanging";
        /**
         * The text baseline is the middle of the em square.
         * @property Middle
         * @static
         */
        BaseAlign[BaseAlign["Middle"] = 2] = "Middle";
        /**
         * The text baseline is the normal alphabetic baseline.
         * @property Alphabetic
         * @static
         */
        BaseAlign[BaseAlign["Alphabetic"] = 3] = "Alphabetic";
        /**
         * The text baseline is the ideographic baseline; this is the bottom of
         * the body of the characters, if the main body of characters protrudes
         * beneath the alphabetic baseline.  Currently unsupported; this will
         * act like alphabetic.
         * @property Ideographic
         * @static
         */
        BaseAlign[BaseAlign["Ideographic"] = 4] = "Ideographic";
        /**
         * The text baseline is the bottom of the bounding box.  This differs
         * from the ideographic baseline in that the ideographic baseline
         * doesn't consider descenders.
         * @property Bottom
         * @static
         */
        BaseAlign[BaseAlign["Bottom"] = 5] = "Bottom";
    })(ex.BaseAlign || (ex.BaseAlign = {}));
    var BaseAlign = ex.BaseAlign;
    /**
     * Labels are the way to draw small amounts of text to the screen in Excalibur. They are
     * actors and inherit all of the benifits and capabilities.
     * @class Label
     * @extends Actor
     * @constructor
     * @param [text=empty] {string} The text of the label
     * @param [x=0] {number} The x position of the label
     * @param [y=0] {number} The y position of the label
     * @param [font=sans-serif] {string} Use any valid css font string for the label's font. Default is "10px sans-serif".
     * @param [spriteFont=undefined] {SpriteFont} Use an Excalibur sprite font for the label's font, if a SpriteFont is provided it will take precendence over a css font.
     *
     */
    var Label = (function (_super) {
        __extends(Label, _super);
        function Label(text, x, y, font, spriteFont) {
            _super.call(this, x, y);
            /**
             * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
             * @property [letterSpacing=0] {number}
             */
            this.letterSpacing = 0; //px
            this.caseInsensitive = true;
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = ex.Color.Black.clone();
            this._shadowColorDirty = false;
            this._textSprites = {};
            this._shadowSprites = {};
            this._color = ex.Color.Black.clone();
            this.text = text || "";
            this.color = ex.Color.Black.clone();
            this.spriteFont = spriteFont;
            this.collisionType = 0 /* PreventCollision */;
            this.font = font || "10px sans-serif"; // coallesce to default canvas font
            if (spriteFont) {
                this._textSprites = spriteFont.getTextSprites();
            }
        }
        /**
         * Returns the width of the text in the label (in pixels);
         * @method getTextWidth {number}
         * @param ctx {CanvasRenderingContext2D} Rending context to measure the string with
         */
        Label.prototype.getTextWidth = function (ctx) {
            var oldFont = ctx.font;
            ctx.font = this.font;
            var width = ctx.measureText(this.text).width;
            ctx.font = oldFont;
            return width;
        };
        // TypeScript doesn't support string enums :(
        Label.prototype._lookupTextAlign = function (textAlign) {
            switch (textAlign) {
                case 0 /* Left */:
                    return "left";
                    break;
                case 1 /* Right */:
                    return "right";
                    break;
                case 2 /* Center */:
                    return "center";
                    break;
                case 4 /* End */:
                    return "end";
                    break;
                case 3 /* Start */:
                    return "start";
                    break;
                default:
                    return "start";
                    break;
            }
        };
        Label.prototype._lookupBaseAlign = function (baseAlign) {
            switch (baseAlign) {
                case 3 /* Alphabetic */:
                    return "alphabetic";
                    break;
                case 5 /* Bottom */:
                    return "bottom";
                    break;
                case 1 /* Hanging */:
                    return "hangin";
                    break;
                case 4 /* Ideographic */:
                    return "ideographic";
                    break;
                case 2 /* Middle */:
                    return "middle";
                    break;
                case 0 /* Top */:
                    return "top";
                    break;
                default:
                    return "alphabetic";
                    break;
            }
        };
        /**
         * Sets the text shadow for sprite fonts
         * @method setTextShadow
         * @param offsetX {number} The x offset in pixels to place the shadow
         * @param offsetY {number} The y offset in pixles to place the shadow
         * @param shadowColor {Color} The color of the text shadow
         */
        Label.prototype.setTextShadow = function (offsetX, offsetY, shadowColor) {
            this._textShadowOn = true;
            this._shadowOffsetX = offsetX;
            this._shadowOffsetY = offsetY;
            this._shadowColor = shadowColor.clone();
            this._shadowColorDirty = true;
            for (var character in this._textSprites) {
                this._shadowSprites[character] = this._textSprites[character].clone();
            }
        };
        /**
         * Clears the current text shadow
         * @method clearTextShadow
         */
        Label.prototype.clearTextShadow = function () {
            this._textShadowOn = false;
            this._shadowOffsetX = 0;
            this._shadowOffsetY = 0;
            this._shadowColor = ex.Color.Black.clone();
        };
        Label.prototype.update = function (engine, delta) {
            _super.prototype.update.call(this, engine, delta);
            if (this.spriteFont && this._color !== this.color) {
                for (var character in this._textSprites) {
                    this._textSprites[character].clearEffects();
                    this._textSprites[character].addEffect(new ex.Effects.Fill(this.color.clone()));
                    this._color = this.color;
                }
            }
            if (this.spriteFont && this._textShadowOn && this._shadowColorDirty && this._shadowColor) {
                for (var character in this._shadowSprites) {
                    this._shadowSprites[character].clearEffects();
                    this._shadowSprites[character].addEffect(new ex.Effects.Fill(this._shadowColor.clone()));
                }
                this._shadowColorDirty = false;
            }
        };
        Label.prototype.draw = function (ctx, delta) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.scale.x, this.scale.y);
            ctx.rotate(this.rotation);
            if (this._textShadowOn) {
                ctx.save();
                ctx.translate(this._shadowOffsetX, this._shadowOffsetY);
                this._fontDraw(ctx, delta, this._shadowSprites);
                ctx.restore();
            }
            this._fontDraw(ctx, delta, this._textSprites);
            _super.prototype.draw.call(this, ctx, delta);
            ctx.restore();
        };
        Label.prototype._fontDraw = function (ctx, delta, sprites) {
            if (this.spriteFont) {
                var currX = 0;
                for (var i = 0; i < this.text.length; i++) {
                    var character = this.text[i];
                    if (this.caseInsensitive) {
                        character = character.toLowerCase();
                    }
                    try {
                        var charSprite = sprites[character];
                        if (this.previousOpacity !== this.opacity) {
                            charSprite.clearEffects();
                            charSprite.addEffect(new ex.Effects.Opacity(this.opacity));
                        }
                        charSprite.draw(ctx, currX, 0);
                        currX += (charSprite.swidth + this.letterSpacing);
                    }
                    catch (e) {
                        ex.Logger.getInstance().error("SpriteFont Error drawing char " + character);
                    }
                }
                if (this.previousOpacity !== this.opacity) {
                    this.previousOpacity = this.opacity;
                }
            }
            else {
                var oldAlign = ctx.textAlign;
                var oldTextBaseline = ctx.textBaseline;
                ctx.textAlign = this._lookupTextAlign(this.textAlign);
                ctx.textBaseline = this._lookupBaseAlign(this.baseAlign);
                if (this.color) {
                    this.color.a = this.opacity;
                }
                ctx.fillStyle = this.color.toString();
                ctx.font = this.font;
                if (this.maxWidth) {
                    ctx.fillText(this.text, 0, 0, this.maxWidth);
                }
                else {
                    ctx.fillText(this.text, 0, 0);
                }
                ctx.textAlign = oldAlign;
                ctx.textBaseline = oldTextBaseline;
            }
        };
        Label.prototype.debugDraw = function (ctx) {
            _super.prototype.debugDraw.call(this, ctx);
        };
        return Label;
    })(ex.Actor);
    ex.Label = Label;
})(ex || (ex = {}));
/// <reference path="../Events.ts"/>
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        (function (PointerType) {
            PointerType[PointerType["Touch"] = 0] = "Touch";
            PointerType[PointerType["Mouse"] = 1] = "Mouse";
            PointerType[PointerType["Pen"] = 2] = "Pen";
            PointerType[PointerType["Unknown"] = 3] = "Unknown";
        })(Input.PointerType || (Input.PointerType = {}));
        var PointerType = Input.PointerType;
        (function (PointerButton) {
            PointerButton[PointerButton["Left"] = 0] = "Left";
            PointerButton[PointerButton["Middle"] = 1] = "Middle";
            PointerButton[PointerButton["Right"] = 2] = "Right";
            PointerButton[PointerButton["Unknown"] = 3] = "Unknown";
        })(Input.PointerButton || (Input.PointerButton = {}));
        var PointerButton = Input.PointerButton;
        var PointerEvent = (function (_super) {
            __extends(PointerEvent, _super);
            function PointerEvent(x, y, index, pointerType, button, ev) {
                _super.call(this);
                this.x = x;
                this.y = y;
                this.index = index;
                this.pointerType = pointerType;
                this.button = button;
                this.ev = ev;
            }
            return PointerEvent;
        })(ex.GameEvent);
        Input.PointerEvent = PointerEvent;
        ;
        /**
         * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to W3C Pointer Events.
         * There is always at least one pointer available (primary).
         *
         * @class Pointers
         * @extends Class
         * @constructor
         */
        var Pointers = (function (_super) {
            __extends(Pointers, _super);
            function Pointers(engine) {
                _super.call(this);
                this._pointerDown = [];
                this._pointerUp = [];
                this._pointerMove = [];
                this._pointerCancel = [];
                this._pointers = [];
                this._activePointers = [];
                this._engine = engine;
                this._pointers.push(new Pointer());
                this._activePointers = [-1];
                this.primary = this._pointers[0];
            }
            /**
             * Initializes pointer event listeners
             */
            Pointers.prototype.init = function () {
                // Touch Events
                document.addEventListener('touchstart', this._handleTouchEvent("down", this._pointerDown));
                document.addEventListener('touchend', this._handleTouchEvent("up", this._pointerUp));
                document.addEventListener('touchmove', this._handleTouchEvent("move", this._pointerMove));
                document.addEventListener('touchcancel', this._handleTouchEvent("cancel", this._pointerCancel));
                // W3C Pointer Events
                // Current: IE11, IE10
                if (window.PointerEvent) {
                    // IE11
                    this._engine.canvas.style.touchAction = "none";
                    document.addEventListener('pointerdown', this._handlePointerEvent("down", this._pointerDown));
                    document.addEventListener('pointerup', this._handlePointerEvent("up", this._pointerUp));
                    document.addEventListener('pointermove', this._handlePointerEvent("move", this._pointerMove));
                    document.addEventListener('pointercancel', this._handlePointerEvent("cancel", this._pointerMove));
                }
                else if (window.MSPointerEvent) {
                    // IE10
                    this._engine.canvas.style.msTouchAction = "none";
                    document.addEventListener('MSPointerDown', this._handlePointerEvent("down", this._pointerDown));
                    document.addEventListener('MSPointerUp', this._handlePointerEvent("up", this._pointerUp));
                    document.addEventListener('MSPointerMove', this._handlePointerEvent("move", this._pointerMove));
                    document.addEventListener('MSPointerCancel', this._handlePointerEvent("cancel", this._pointerMove));
                }
                else {
                    // Mouse Events
                    document.addEventListener('mousedown', this._handleMouseEvent("down", this._pointerDown));
                    document.addEventListener('mouseup', this._handleMouseEvent("up", this._pointerUp));
                    document.addEventListener('mousemove', this._handleMouseEvent("move", this._pointerMove));
                }
            };
            Pointers.prototype.update = function (delta) {
                this._pointerUp.length = 0;
                this._pointerDown.length = 0;
                this._pointerMove.length = 0;
                this._pointerCancel.length = 0;
            };
            /**
             * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
             * @param index {number} The pointer index to retrieve
             */
            Pointers.prototype.at = function (index) {
                if (index >= this._pointers.length) {
                    for (var i = this._pointers.length - 1, max = index; i < max; i++) {
                        this._pointers.push(new Pointer());
                        this._activePointers.push(-1);
                    }
                }
                return this._pointers[index];
            };
            /**
             * Get number of pointers being watched
             */
            Pointers.prototype.count = function () {
                return this._pointers.length;
            };
            /**
             * Propogates events to actor if necessary
             */
            Pointers.prototype.propogate = function (actor) {
                var isUIActor = actor instanceof ex.UIActor;
                this._pointerUp.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointerup", e);
                    }
                });
                this._pointerDown.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointerdown", e);
                    }
                });
                if (actor.capturePointer.captureMoveEvents) {
                    this._pointerMove.forEach(function (e) {
                        if (actor.contains(e.x, e.y, !isUIActor)) {
                            actor.eventDispatcher.publish("pointermove", e);
                        }
                    });
                }
                this._pointerCancel.forEach(function (e) {
                    if (actor.contains(e.x, e.y, !isUIActor)) {
                        actor.eventDispatcher.publish("pointercancel", e);
                    }
                });
            };
            Pointers.prototype._handleMouseEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    var x = e.pageX - ex.Util.getPosition(_this._engine.canvas).x;
                    var y = e.pageY - ex.Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, 0, 1 /* Mouse */, e.button, e);
                    eventArr.push(pe);
                    _this.at(0).eventDispatcher.publish(eventName, pe);
                };
            };
            Pointers.prototype._handleTouchEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                        var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                        if (index === -1)
                            continue;
                        var x = e.changedTouches[i].pageX - ex.Util.getPosition(_this._engine.canvas).x;
                        var y = e.changedTouches[i].pageY - ex.Util.getPosition(_this._engine.canvas).y;
                        var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                        var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, index, 0 /* Touch */, 3 /* Unknown */, e);
                        eventArr.push(pe);
                        _this.at(index).eventDispatcher.publish(eventName, pe);
                        // only with multi-pointer
                        if (_this._pointers.length > 1) {
                            if (eventName === "up") {
                                // remove pointer ID from pool when pointer is lifted
                                _this._activePointers[index] = -1;
                            }
                            else if (eventName === "down") {
                                // set pointer ID to given index
                                _this._activePointers[index] = e.changedTouches[i].identifier;
                            }
                        }
                    }
                };
            };
            Pointers.prototype._handlePointerEvent = function (eventName, eventArr) {
                var _this = this;
                return function (e) {
                    e.preventDefault();
                    // get the index for this pointer ID if multi-pointer is asked for
                    var index = _this._pointers.length > 1 ? _this._getPointerIndex(e.pointerId) : 0;
                    if (index === -1)
                        return;
                    var x = e.pageX - ex.Util.getPosition(_this._engine.canvas).x;
                    var y = e.pageY - ex.Util.getPosition(_this._engine.canvas).y;
                    var transformedPoint = _this._engine.screenToWorldCoordinates(new ex.Point(x, y));
                    var pe = new PointerEvent(transformedPoint.x, transformedPoint.y, index, _this._stringToPointerType(e.pointerType), e.button, e);
                    eventArr.push(pe);
                    _this.at(index).eventDispatcher.publish(eventName, pe);
                    // only with multi-pointer
                    if (_this._pointers.length > 1) {
                        if (eventName === "up") {
                            // remove pointer ID from pool when pointer is lifted
                            _this._activePointers[index] = -1;
                        }
                        else if (eventName === "down") {
                            // set pointer ID to given index
                            _this._activePointers[index] = e.pointerId;
                        }
                    }
                };
            };
            /**
             * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
             * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
             * @private
             */
            Pointers.prototype._getPointerIndex = function (pointerId) {
                var idx;
                if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
                    return idx;
                }
                for (var i = 0; i < this._activePointers.length; i++) {
                    if (this._activePointers[i] === -1)
                        return i;
                }
                // ignore pointer because game isn't watching
                return -1;
            };
            Pointers.prototype._stringToPointerType = function (s) {
                switch (s) {
                    case "touch":
                        return 0 /* Touch */;
                    case "mouse":
                        return 1 /* Mouse */;
                    case "pen":
                        return 2 /* Pen */;
                    default:
                        return 3 /* Unknown */;
                }
            };
            return Pointers;
        })(ex.Class);
        Input.Pointers = Pointers;
        /**
         * Captures and dispatches PointerEvents
         * @class Pointer
         * @constructor
         * @extends Class
         */
        var Pointer = (function (_super) {
            __extends(Pointer, _super);
            function Pointer() {
                _super.apply(this, arguments);
            }
            return Pointer;
        })(ex.Class);
        Input.Pointer = Pointer;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        /**
        * Enum representing input key codes
        * @class Keys
        *
        */
        (function (Keys) {
            /**
            @property Num1 {Keys}
            */
            /**
            @property Num2 {Keys}
            */
            /**
            @property Num3 {Keys}
            */
            /**
            @property Num4 {Keys}
            */
            /**
            @property Num5 {Keys}
            */
            /**
            @property Num6 {Keys}
            */
            /**
            @property Num7 {Keys}
            */
            /**
            @property Num8 {Keys}
            */
            /**
            @property Num9 {Keys}
            */
            /**
            @property Num0 {Keys}
            */
            Keys[Keys["Num1"] = 97] = "Num1";
            Keys[Keys["Num2"] = 98] = "Num2";
            Keys[Keys["Num3"] = 99] = "Num3";
            Keys[Keys["Num4"] = 100] = "Num4";
            Keys[Keys["Num5"] = 101] = "Num5";
            Keys[Keys["Num6"] = 102] = "Num6";
            Keys[Keys["Num7"] = 103] = "Num7";
            Keys[Keys["Num8"] = 104] = "Num8";
            Keys[Keys["Num9"] = 105] = "Num9";
            Keys[Keys["Num0"] = 96] = "Num0";
            /**
            @property Numlock {Keys}
            */
            Keys[Keys["Numlock"] = 144] = "Numlock";
            /**
            @property Semicolon {Keys}
            */
            Keys[Keys["Semicolon"] = 186] = "Semicolon";
            /**
            @property A {Keys}
            */
            /**
            @property B {Keys}
            */
            /**
            @property C {Keys}
            */
            /**
            @property D {Keys}
            */
            /**
            @property E {Keys}
            */
            /**
            @property F {Keys}
            */
            /**
            @property G {Keys}
            */
            /**
            @property H {Keys}
            */
            /**
            @property I {Keys}
            */
            /**
            @property J {Keys}
            */
            /**
            @property K {Keys}
            */
            /**
            @property L {Keys}
            */
            /**
            @property M {Keys}
            */
            /**
            @property N {Keys}
            */
            /**
            @property O {Keys}
            */
            /**
            @property P {Keys}
            */
            /**
            @property Q {Keys}
            */
            /**
            @property R {Keys}
            */
            /**
            @property S {Keys}
            */
            /**
            @property T {Keys}
            */
            /**
            @property U {Keys}
            */
            /**
            @property V {Keys}
            */
            /**
            @property W {Keys}
            */
            /**
            @property X {Keys}
            */
            /**
            @property Y {Keys}
            */
            /**
            @property Z {Keys}
            */
            Keys[Keys["A"] = 65] = "A";
            Keys[Keys["B"] = 66] = "B";
            Keys[Keys["C"] = 67] = "C";
            Keys[Keys["D"] = 68] = "D";
            Keys[Keys["E"] = 69] = "E";
            Keys[Keys["F"] = 70] = "F";
            Keys[Keys["G"] = 71] = "G";
            Keys[Keys["H"] = 72] = "H";
            Keys[Keys["I"] = 73] = "I";
            Keys[Keys["J"] = 74] = "J";
            Keys[Keys["K"] = 75] = "K";
            Keys[Keys["L"] = 76] = "L";
            Keys[Keys["M"] = 77] = "M";
            Keys[Keys["N"] = 78] = "N";
            Keys[Keys["O"] = 79] = "O";
            Keys[Keys["P"] = 80] = "P";
            Keys[Keys["Q"] = 81] = "Q";
            Keys[Keys["R"] = 82] = "R";
            Keys[Keys["S"] = 83] = "S";
            Keys[Keys["T"] = 84] = "T";
            Keys[Keys["U"] = 85] = "U";
            Keys[Keys["V"] = 86] = "V";
            Keys[Keys["W"] = 87] = "W";
            Keys[Keys["X"] = 88] = "X";
            Keys[Keys["Y"] = 89] = "Y";
            Keys[Keys["Z"] = 90] = "Z";
            /**
            @property Shift {Keys}
            */
            /**
            @property Alt {Keys}
            */
            /**
            @property Up {Keys}
            */
            /**
            @property Down {Keys}
            */
            /**
            @property Left {Keys}
            */
            /**
            @property Right {Keys}
            */
            /**
            @property Space {Keys}
            */
            /**
            @property Esc {Keys}
            */
            Keys[Keys["Shift"] = 16] = "Shift";
            Keys[Keys["Alt"] = 18] = "Alt";
            Keys[Keys["Up"] = 38] = "Up";
            Keys[Keys["Down"] = 40] = "Down";
            Keys[Keys["Left"] = 37] = "Left";
            Keys[Keys["Right"] = 39] = "Right";
            Keys[Keys["Space"] = 32] = "Space";
            Keys[Keys["Esc"] = 27] = "Esc";
        })(Input.Keys || (Input.Keys = {}));
        var Keys = Input.Keys;
        ;
        /**
         * Event thrown on a game object for a key event
         *
         * @class KeyEvent
         * @extends GameEvent
         * @constructor
         * @param key {InputKey} The key responsible for throwing the event
         */
        var KeyEvent = (function (_super) {
            __extends(KeyEvent, _super);
            function KeyEvent(key) {
                _super.call(this);
                this.key = key;
            }
            return KeyEvent;
        })(ex.GameEvent);
        Input.KeyEvent = KeyEvent;
        /**
         * Manages Keyboard input events that you can query or listen for events on
         *
         * @class Keyboard
         * @extends Class
         * @constructor
         *
         */
        var Keyboard = (function (_super) {
            __extends(Keyboard, _super);
            function Keyboard(engine) {
                _super.call(this);
                this._keys = [];
                this._keysUp = [];
                this._keysDown = [];
                this._engine = engine;
            }
            /**
             * Initialize Keyboard event listeners
             */
            Keyboard.prototype.init = function () {
                var _this = this;
                window.addEventListener('blur', function (ev) {
                    _this._keys.length = 0; // empties array efficiently
                });
                // key up is on window because canvas cannot have focus
                window.addEventListener('keyup', function (ev) {
                    var key = _this._keys.indexOf(ev.keyCode);
                    _this._keys.splice(key, 1);
                    _this._keysUp.push(ev.keyCode);
                    var keyEvent = new KeyEvent(ev.keyCode);
                    _this.eventDispatcher.publish("up", keyEvent);
                });
                // key down is on window because canvas cannot have focus
                window.addEventListener('keydown', function (ev) {
                    if (_this._keys.indexOf(ev.keyCode) === -1) {
                        _this._keys.push(ev.keyCode);
                        _this._keysDown.push(ev.keyCode);
                        var keyEvent = new KeyEvent(ev.keyCode);
                        _this.eventDispatcher.publish("down", keyEvent);
                    }
                });
            };
            Keyboard.prototype.update = function (delta) {
                // Reset keysDown and keysUp after update is complete
                this._keysDown.length = 0;
                this._keysUp.length = 0;
            };
            /**
             * Gets list of keys being pressed down
             */
            Keyboard.prototype.getKeys = function () {
                return this._keys;
            };
            /**
             *  Tests if a certain key is down.
             * @method isKeyDown
             * @param key {Keys} Test wether a key is down
             * @returns boolean
             */
            Keyboard.prototype.isKeyDown = function (key) {
                return this._keysDown.indexOf(key) > -1;
            };
            /**
             *  Tests if a certain key is pressed.
             * @method isKeyPressed
             * @param key {Keys} Test wether a key is pressed
             * @returns boolean
             */
            Keyboard.prototype.isKeyPressed = function (key) {
                return this._keys.indexOf(key) > -1;
            };
            /**
             *  Tests if a certain key is up.
             * @method isKeyUp
             * @param key {Keys} Test wether a key is up
             * @returns boolean
             */
            Keyboard.prototype.isKeyUp = function (key) {
                return this._keysUp.indexOf(key) > -1;
            };
            return Keyboard;
        })(ex.Class);
        Input.Keyboard = Keyboard;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
var ex;
(function (ex) {
    var Input;
    (function (Input) {
        /**
         * Manages Gamepad API input. You can query the gamepads that are connected
         * or listen to events ("button" and "axis").
         * @class Gamepads
         * @extends Class
         * @param pads {Gamepad[]} The connected gamepads.
         * @param supported {boolean} Whether or not the Gamepad API is present
         */
        var Gamepads = (function (_super) {
            __extends(Gamepads, _super);
            function Gamepads(engine) {
                _super.call(this);
                /**
                 * Whether or not to poll for Gamepad input (default: false)
                 * @property enabled {boolean}
                 */
                this.enabled = false;
                /**
                 * Whether or not Gamepad API is supported
                 * @property supported {boolean}
                 */
                this.supported = !!navigator.getGamepads;
                this._gamePadTimeStamps = [0, 0, 0, 0];
                this._oldPads = [];
                this._pads = [];
                this._initSuccess = false;
                this._navigator = navigator;
                this._engine = engine;
            }
            Gamepads.prototype.init = function () {
                if (!this.supported)
                    return;
                if (this._initSuccess)
                    return;
                // In Chrome, this will return 4 undefined items until a button is pressed
                // In FF, this will not return any items until a button is pressed
                this._oldPads = this._clonePads(this._navigator.getGamepads());
                if (this._oldPads.length && this._oldPads[0]) {
                    this._initSuccess = true;
                }
            };
            /**
             * Updates Gamepad state and publishes Gamepad events
             */
            Gamepads.prototype.update = function (delta) {
                if (!this.enabled || !this.supported)
                    return;
                this.init();
                var gamepads = this._navigator.getGamepads();
                for (var i = 0; i < gamepads.length; i++) {
                    if (!gamepads[i]) {
                        // Reset connection status
                        this.at(i).connected = false;
                        continue;
                    }
                    else {
                        // Set connection status
                        this.at(i).connected = true;
                    }
                    ;
                    // Only supported in Chrome
                    if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                        continue;
                    }
                    this._gamePadTimeStamps[i] = gamepads[i].timestamp;
                    // Buttons
                    var b, a, value, buttonIndex, axesIndex;
                    for (b in Buttons) {
                        if (typeof Buttons[b] !== "number")
                            continue;
                        buttonIndex = Buttons[b];
                        value = gamepads[i].buttons[buttonIndex].value;
                        if (value !== this._oldPads[i].getButton(buttonIndex)) {
                            if (gamepads[i].buttons[buttonIndex].pressed) {
                                this.at(i).updateButton(buttonIndex, value);
                                this.at(i).eventDispatcher.publish("button", new GamepadButtonEvent(buttonIndex, value));
                            }
                            else {
                                this.at(i).updateButton(buttonIndex, 0);
                            }
                        }
                    }
                    for (a in Axes) {
                        if (typeof Axes[a] !== "number")
                            continue;
                        axesIndex = Axes[a];
                        value = gamepads[i].axes[axesIndex];
                        if (value !== this._oldPads[i].getAxes(axesIndex)) {
                            this.at(i).updateAxes(axesIndex, value);
                            this.at(i).eventDispatcher.publish("axis", new GamepadAxisEvent(axesIndex, value));
                        }
                    }
                    this._oldPads[i] = this._clonePad(gamepads[i]);
                }
            };
            /**
             * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
             */
            Gamepads.prototype.at = function (index) {
                if (index >= this._pads.length) {
                    for (var i = this._pads.length - 1, max = index; i < max; i++) {
                        this._pads.push(new Gamepad());
                        this._oldPads.push(new Gamepad());
                    }
                }
                return this._pads[index];
            };
            /**
             * Gets the number of connected gamepads
             */
            Gamepads.prototype.count = function () {
                return this._pads.filter(function (p) { return p.connected; }).length;
            };
            Gamepads.prototype._clonePads = function (pads) {
                var arr = [];
                for (var i = 0, len = pads.length; i < len; i++) {
                    arr.push(this._clonePad(pads[i]));
                }
                return arr;
            };
            /**
             * Fastest way to clone a known object is to do it yourself
             */
            Gamepads.prototype._clonePad = function (pad) {
                var i, len;
                var clonedPad = new Gamepad();
                if (!pad)
                    return clonedPad;
                for (i = 0, len = pad.buttons.length; i < len; i++) {
                    clonedPad.updateButton(i, pad.buttons[i].value);
                }
                for (i = 0, len = pad.axes.length; i < len; i++) {
                    clonedPad.updateAxes(i, pad.axes[i]);
                }
                return clonedPad;
            };
            /**
             * The minimum value an axis has to move before considering it a change
             * @property MinAxisMoveThreshold {number}
             * @static
             */
            Gamepads.MinAxisMoveThreshold = 0.05;
            return Gamepads;
        })(ex.Class);
        Input.Gamepads = Gamepads;
        /**
         * Individual state for a Gamepad
         * @class Gamepad
         * @extends Class
         */
        var Gamepad = (function (_super) {
            __extends(Gamepad, _super);
            function Gamepad() {
                _super.call(this);
                this.connected = false;
                this._buttons = new Array(16);
                this._axes = new Array(4);
                var i;
                for (i = 0; i < this._buttons.length; i++) {
                    this._buttons[i] = 0;
                }
                for (i = 0; i < this._axes.length; i++) {
                    this._axes[i] = 0;
                }
            }
            /**
             * Whether or not the given button is pressed
             * @param button {Buttons}
             * @param [threshold=1] {number} The threshold over which the button is considered to be pressed
             */
            Gamepad.prototype.isButtonPressed = function (button, threshold) {
                if (threshold === void 0) { threshold = 1; }
                return this._buttons[button] >= threshold;
            };
            /**
             * Gets the given button value
             * @param button {Buttons}
             */
            Gamepad.prototype.getButton = function (button) {
                return this._buttons[button];
            };
            /**
             * Gets the given axis value
             * @param axes {Axes}
             */
            Gamepad.prototype.getAxes = function (axes) {
                var value = this._axes[axes];
                if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
                    return 0;
                }
                else {
                    return value;
                }
            };
            Gamepad.prototype.updateButton = function (buttonIndex, value) {
                this._buttons[buttonIndex] = value;
            };
            Gamepad.prototype.updateAxes = function (axesIndex, value) {
                this._axes[axesIndex] = value;
            };
            return Gamepad;
        })(ex.Class);
        Input.Gamepad = Gamepad;
        /**
         * Gamepad Buttons enumeration
         * @class Buttons
         */
        (function (Buttons) {
            /**
             * Face 1 button (e.g. A)
             * @property Face1 {Buttons}
             * @static
             */
            /**
             * Face 2 button (e.g. B)
             * @property Face2 {Buttons}
             * @static
             */
            /**
             * Face 3 button (e.g. X)
             * @property Face3 {Buttons}
             * @static
             */
            /**
             * Face 4 button (e.g. Y)
             * @property Face4 {Buttons}
             * @static
             */
            Buttons[Buttons["Face1"] = 0] = "Face1";
            Buttons[Buttons["Face2"] = 1] = "Face2";
            Buttons[Buttons["Face3"] = 2] = "Face3";
            Buttons[Buttons["Face4"] = 3] = "Face4";
            /**
             * Left bumper button
             * @property LeftBumper {Buttons}
             * @static
             */
            /**
             * Right bumper button
             * @property RightBumper {Buttons}
             * @static
             */
            Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
            Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
            /**
             * Left trigger button
             * @property LeftTrigger {Buttons}
             * @static
             */
            /**
             * Right trigger button
             * @property RightTrigger {Buttons}
             * @static
             */
            Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
            Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
            /**
             * Select button
             * @property Select {Buttons}
             * @static
             */
            /**
             * Start button
             * @property Start {Buttons}
             * @static
             */
            Buttons[Buttons["Select"] = 8] = "Select";
            Buttons[Buttons["Start"] = 9] = "Start";
            /**
             * Left analog stick press (e.g. L3)
             * @property LeftStick {Buttons}
             * @static
             */
            /**
             * Right analog stick press (e.g. R3)
             * @property Start {Buttons}
             * @static
             */
            Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
            Buttons[Buttons["RightStick"] = 11] = "RightStick";
            /**
             * D-pad up
             * @property DpadUp {Buttons}
             * @static
             */
            /**
             * D-pad down
             * @property DpadDown {Buttons}
             * @static
             */
            /**
             * D-pad left
             * @property DpadLeft {Buttons}
             * @static
             */
            /**
             * D-pad right
             * @property DpadRight {Buttons}
             * @static
             */
            Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
            Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
            Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
            Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
        })(Input.Buttons || (Input.Buttons = {}));
        var Buttons = Input.Buttons;
        /**
         * Gamepad Axes enumeration
         * @class Axes
         */
        (function (Axes) {
            /**
             * Left analogue stick X direction
             * @property LeftStickX {Axes}
             * @static
             */
            /**
             * Left analogue stick Y direction
             * @property LeftStickY {Axes}
             * @static
             */
            /**
             * Right analogue stick X direction
             * @property RightStickX {Axes}
             * @static
             */
            /**
             * Right analogue stick Y direction
             * @property RightStickY {Axes}
             * @static
             */
            Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
            Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
            Axes[Axes["RightStickX"] = 2] = "RightStickX";
            Axes[Axes["RightStickY"] = 3] = "RightStickY";
        })(Input.Axes || (Input.Axes = {}));
        var Axes = Input.Axes;
        var GamepadButtonEvent = (function (_super) {
            __extends(GamepadButtonEvent, _super);
            function GamepadButtonEvent(button, value) {
                _super.call(this);
                this.button = button;
                this.value = value;
            }
            return GamepadButtonEvent;
        })(ex.GameEvent);
        Input.GamepadButtonEvent = GamepadButtonEvent;
        var GamepadAxisEvent = (function (_super) {
            __extends(GamepadAxisEvent, _super);
            function GamepadAxisEvent(axis, value) {
                _super.call(this);
                this.axis = axis;
                this.value = value;
            }
            return GamepadAxisEvent;
        })(ex.GameEvent);
        Input.GamepadAxisEvent = GamepadAxisEvent;
    })(Input = ex.Input || (ex.Input = {}));
})(ex || (ex = {}));
/// <reference path="MonkeyPatch.ts" />
/// <reference path="Events.ts" />
/// <reference path="EventDispatcher.ts" />
/// <reference path="Class.ts" />
/// <reference path="Color.ts" />
/// <reference path="Log.ts" />
/// <reference path="Collision/Side.ts" />
/// <reference path="Scene.ts" />
/// <reference path="Actor.ts" />
/// <reference path="UIActor.ts" />
/// <reference path="Trigger.ts" />
/// <reference path="Particles.ts" />
/// <reference path="Animation.ts" />
/// <reference path="Camera.ts" />
/// <reference path="Sound.ts" />
/// <reference path="Loader.ts" />
/// <reference path="Promises.ts" />
/// <reference path="Util.ts" />
/// <reference path="Binding.ts" />
/// <reference path="TileMap.ts" />
/// <reference path="Label.ts" />
/// <reference path="PostProcessing/IPostProcessor.ts"/>
/// <reference path="Input/IEngineInput.ts"/>
/// <reference path="Input/Pointer.ts"/>
/// <reference path="Input/Keyboard.ts"/>
/// <reference path="Input/Gamepad.ts"/>
var ex;
(function (ex) {
    /**
     * Enum representing the different display modes available to Excalibur
     * @class DisplayMode
     */
    (function (DisplayMode) {
        /**
         * Show the game as full screen
         * @property FullScreen {DisplayMode}
         */
        DisplayMode[DisplayMode["FullScreen"] = 0] = "FullScreen";
        /**
         * Scale the game to the parent DOM container
         * @property Container {DisplayMode}
         */
        DisplayMode[DisplayMode["Container"] = 1] = "Container";
        /**
         * Show the game as a fixed size
         * @Property Fixed {DisplayMode}
         */
        DisplayMode[DisplayMode["Fixed"] = 2] = "Fixed";
    })(ex.DisplayMode || (ex.DisplayMode = {}));
    var DisplayMode = ex.DisplayMode;
    // internal
    var AnimationNode = (function () {
        function AnimationNode(animation, x, y) {
            this.animation = animation;
            this.x = x;
            this.y = y;
        }
        return AnimationNode;
    })();
    /**
     * The 'Engine' is the main driver for a game. It is responsible for
     * starting/stopping the game, maintaining state, transmitting events,
     * loading resources, and managing the scene.
     *
     * @class Engine
     * @constructor
     * @param [width] {number} The width in pixels of the Excalibur game viewport
     * @param [height] {number} The height in pixels of the Excalibur game viewport
     * @param [canvasElementId] {string} If this is not specified, then a new canvas will be created and inserted into the body.
     * @param [displayMode] {DisplayMode} If this is not specified, then it will fall back to fixed if a height and width are specified, else the display mode will be FullScreen.
     */
    var Engine = (function (_super) {
        __extends(Engine, _super);
        function Engine(width, height, canvasElementId, displayMode) {
            _super.call(this);
            /**
             * Sets or gets the collision strategy for Excalibur
             * @property collisionStrategy {CollisionStrategy}
             */
            this.collisionStrategy = 1 /* DynamicAABBTree */;
            this.hasStarted = false;
            this.fps = 0;
            this.postProcessors = [];
            this.sceneHash = {};
            this.animations = [];
            /**
             * Indicates whether the engine is set to fullscreen or not
             * @property isFullscreen {boolean}
             */
            this.isFullscreen = false;
            /**
             * Indicates the current DisplayMode of the engine.
             * @property [displayMode=FullScreen] {DisplayMode}
             */
            this.displayMode = 0 /* FullScreen */;
            /**
             * Indicates whether audio should be paused when the game is no longer visible.
             * @property [pauseAudioWhenHidden=true] {boolean}
             */
            this.pauseAudioWhenHidden = true;
            /**
             * Indicates whether the engine should draw with debug information
             * @property [isDebug=false] {boolean}
             */
            this.isDebug = false;
            this.debugColor = new ex.Color(255, 255, 255);
            /**
             * Sets the background color for the engine.
             * @property [backgroundColor=new Color(0, 0, 100)] {Color}
             */
            this.backgroundColor = new ex.Color(0, 0, 100);
            this.isSmoothingEnabled = true;
            this.isLoading = false;
            this.progress = 0;
            this.total = 1;
            this.logger = ex.Logger.getInstance();
            this.logger.info("Powered by Excalibur.js visit", "http://excaliburjs.com", "for more information.");
            this.logger.debug("Building engine...");
            this.canvasElementId = canvasElementId;
            if (canvasElementId) {
                this.logger.debug("Using Canvas element specified: " + canvasElementId);
                this.canvas = document.getElementById(canvasElementId);
            }
            else {
                this.logger.debug("Using generated canvas element");
                this.canvas = document.createElement('canvas');
            }
            if (width && height) {
                if (displayMode == undefined) {
                    this.displayMode = 2 /* Fixed */;
                }
                this.logger.debug("Engine viewport is size " + width + " x " + height);
                this.width = width;
                this.canvas.width = width;
                this.height = height;
                this.canvas.height = height;
            }
            else if (!displayMode) {
                this.logger.debug("Engine viewport is fullscreen");
                this.displayMode = 0 /* FullScreen */;
            }
            this.loader = new ex.Loader();
            this.initialize();
            this.rootScene = this.currentScene = new ex.Scene(this);
            this.addScene('root', this.rootScene);
        }
        /**
         * Plays a sprite animation on the screen at the specified x and y
         * (in game coordinates, not screen pixels). These animations play
         * independent of actors, and will be cleaned up internally as soon
         * as they are complete. Note animations that loop will never be
         * cleaned up.
         * @method playAnimation
         * @param animation {Animation} Animation to play
         * @param x {number} x game coordinate to play the animation
         * @param y {number} y game coordinate to play the animation
         */
        Engine.prototype.playAnimation = function (animation, x, y) {
            this.animations.push(new AnimationNode(animation, x, y));
        };
        /**
         * Adds an actor to the current scene of the game. This is synonymous
         * to calling engine.currentScene.addChild(actor : Actor).
         *
         * Actors can only be drawn if they are a member of a scene, and only
         * the 'currentScene' may be drawn or updated.
         * @method addChild
         * @param actor {Actor} The actor to add to the current scene
         */
        Engine.prototype.addChild = function (actor) {
            this.currentScene.addChild(actor);
        };
        /**
         * Removes an actor from the currentScene of the game. This is synonymous
         * to calling engine.currentScene.removeChild(actor : Actor).
         * Actors that are removed from a scene will no longer be drawn or updated.
         *
         * @method removeChild
         * @param actor {Actor} The actor to remove from the current scene.
         */
        Engine.prototype.removeChild = function (actor) {
            this.currentScene.removeChild(actor);
        };
        /**
         * Adds a TileMap to the Scene, once this is done the TileMap will be drawn and updated.
         * @method addTileMap
         * @param tileMap {TileMap}
         */
        Engine.prototype.addTileMap = function (tileMap) {
            this.currentScene.addTileMap(tileMap);
        };
        /**
         * Removes a TileMap from the Scene, it willno longer be drawn or updated.
         * @method removeTileMap
         * @param tileMap {TileMap}
         */
        Engine.prototype.removeTileMap = function (tileMap) {
            this.currentScene.removeTileMap(tileMap);
        };
        /**
         * Adds an excalibur timer to the current scene.
         * @param timer {Timer} The timer to add to the current scene.
         * @method addTimer
         */
        Engine.prototype.addTimer = function (timer) {
            return this.currentScene.addTimer(timer);
        };
        /**
         * Removes an excalibur timer from the current scene.
         * @method removeTimer
         * @param timer {Timer} The timer to remove to the current scene.
         */
        Engine.prototype.removeTimer = function (timer) {
            return this.currentScene.removeTimer(timer);
        };
        /**
         * Adds a scene to the engine, think of scenes in excalibur as you
         * would scenes in a play.
         * @method addScene
         * @param name {string} The name of the scene, must be unique
         * @param scene {Scene} The scene to add to the engine
         */
        Engine.prototype.addScene = function (name, scene) {
            if (this.sceneHash[name]) {
                this.logger.warn("Scene", name, "already exists overwriting");
            }
            this.sceneHash[name] = scene;
            scene.engine = this;
        };
        Engine.prototype.removeScene = function (entity) {
            if (entity instanceof ex.Scene) {
                for (var key in this.sceneHash) {
                    if (this.sceneHash.hasOwnProperty(key)) {
                        if (this.sceneHash[key] === entity) {
                            delete this.sceneHash[key];
                        }
                    }
                }
            }
            if (typeof entity === "string") {
                // remove scene
                delete this.sceneHash[entity];
            }
        };
        Engine.prototype.add = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.currentScene.addUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.addChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.addTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.addTileMap(entity);
            }
            if (arguments.length === 2) {
                this.addScene(arguments[0], arguments[1]);
            }
        };
        Engine.prototype.remove = function (entity) {
            if (entity instanceof ex.UIActor) {
                this.currentScene.removeUIActor(entity);
                return;
            }
            if (entity instanceof ex.Actor) {
                this.removeChild(entity);
            }
            if (entity instanceof ex.Timer) {
                this.removeTimer(entity);
            }
            if (entity instanceof ex.TileMap) {
                this.removeTileMap(entity);
            }
            if (entity instanceof ex.Scene) {
                this.removeScene(entity);
            }
            if (typeof entity === "string") {
                this.removeScene(entity);
            }
        };
        /**
         * Changes the currently updating and drawing scene to a different,
         * named scene.
         * @method goToScene
         * @param name {string} The name of the scene to trasition to.
         */
        Engine.prototype.goToScene = function (name) {
            if (this.sceneHash[name]) {
                this.currentScene.onDeactivate.call(this.currentScene);
                var oldScene = this.currentScene;
                this.currentScene = this.sceneHash[name];
                oldScene.eventDispatcher.publish('deactivate', new ex.DeactivateEvent(this.currentScene));
                this.currentScene.onActivate.call(this.currentScene);
                this.currentScene.eventDispatcher.publish('activate', new ex.ActivateEvent(oldScene));
            }
            else {
                this.logger.error("Scene", name, "does not exist!");
            }
        };
        /**
         * Returns the width of the engines drawing surface in pixels.
         * @method getWidth
         * @returns number The width of the drawing surface in pixels.
         */
        Engine.prototype.getWidth = function () {
            if (this.currentScene && this.currentScene.camera) {
                return this.width / this.currentScene.camera.getZoom();
            }
            return this.width;
        };
        /**
         * Returns the height of the engines drawing surface in pixels.
         * @method getHeight
         * @returns number The height of the drawing surface in pixels.
         */
        Engine.prototype.getHeight = function () {
            if (this.currentScene && this.currentScene.camera) {
                return this.height / this.currentScene.camera.getZoom();
            }
            return this.height;
        };
        /**
         * Transforms the current x, y from screen coordinates to world coordinates
         * @method screenToWorldCoordinates
         * @param point {Point} screen coordinate to convert
         */
        Engine.prototype.screenToWorldCoordinates = function (point) {
            // todo set these back this.canvas.clientWidth
            var newX = point.x;
            var newY = point.y;
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                newX = focus.x + (point.x - (this.getWidth() / 2));
                newY = focus.y + (point.y - (this.getHeight() / 2));
            }
            newX = Math.floor((newX / this.canvas.clientWidth) * this.getWidth());
            newY = Math.floor((newY / this.canvas.clientHeight) * this.getHeight());
            return new ex.Point(newX, newY);
        };
        /**
         * Transforms a world coordinate, to a screen coordinate
         * @method worldToScreenCoordinates
         * @param point {Point} world coordinate to convert
         *
         */
        Engine.prototype.worldToScreenCoordinates = function (point) {
            // todo set these back this.canvas.clientWidth
            // this isn't correct on zoom
            var screenX = point.x;
            var screenY = point.y;
            if (this.currentScene && this.currentScene.camera) {
                var focus = this.currentScene.camera.getFocus();
                screenX = (point.x - focus.x) + (this.getWidth() / 2); //(this.getWidth() / this.canvas.clientWidth);
                screenY = (point.y - focus.y) + (this.getHeight() / 2); // (this.getHeight() / this.canvas.clientHeight);
            }
            screenX = Math.floor((screenX / this.getWidth()) * this.canvas.clientWidth);
            screenY = Math.floor((screenY / this.getHeight()) * this.canvas.clientHeight);
            return new ex.Point(screenX, screenY);
        };
        /**
         * Sets the internal canvas height based on the selected display mode.
         * @method setHeightByDisplayMode
         * @private
         */
        Engine.prototype.setHeightByDisplayMode = function (parent) {
            if (this.displayMode === 1 /* Container */) {
                this.width = this.canvas.width = parent.clientWidth;
                this.height = this.canvas.height = parent.clientHeight;
            }
            if (this.displayMode === 0 /* FullScreen */) {
                document.body.style.margin = '0px';
                document.body.style.overflow = 'hidden';
                this.width = this.canvas.width = parent.innerWidth;
                this.height = this.canvas.height = parent.innerHeight;
            }
        };
        /**
         * Initializes the internal canvas, rendering context, displaymode, and native event listeners
         * @method initialize
         * @private
         */
        Engine.prototype.initialize = function () {
            var _this = this;
            if (this.displayMode === 0 /* FullScreen */ || this.displayMode === 1 /* Container */) {
                var parent = (this.displayMode === 1 /* Container */ ? (this.canvas.parentElement || document.body) : window);
                this.setHeightByDisplayMode(parent);
                window.addEventListener('resize', function (ev) {
                    _this.logger.debug("View port resized");
                    _this.setHeightByDisplayMode(parent);
                    _this.logger.info("parent.clientHeight " + parent.clientHeight);
                    _this.setAntialiasing(_this.isSmoothingEnabled);
                });
            }
            // initialize inputs
            this.input = {
                keyboard: new ex.Input.Keyboard(this),
                pointers: new ex.Input.Pointers(this),
                gamepads: new ex.Input.Gamepads(this)
            };
            this.input.keyboard.init();
            this.input.pointers.init();
            this.input.gamepads.init();
            // Issue #385 make use of the visibility api
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
            document.addEventListener("visibilitychange", function () {
                if (document.hidden || document.msHidden) {
                    _this.eventDispatcher.publish('hidden', new ex.HiddenEvent());
                    _this.logger.debug("Window hidden");
                }
                else {
                    _this.eventDispatcher.publish('visible', new ex.VisibleEvent());
                    _this.logger.debug("Window visible");
                }
            });
            /*
            // DEPRECATED in favor of visibility api
            window.addEventListener('blur', () => {
               this.eventDispatcher.publish(EventType[EventType.Blur], new BlurEvent());
            });
   
            window.addEventListener('focus', () => {
               this.eventDispatcher.publish(EventType[EventType.Focus], new FocusEvent());
            });*/
            this.ctx = this.canvas.getContext('2d');
            if (!this.canvasElementId) {
                document.body.appendChild(this.canvas);
            }
        };
        /**
         * If supported by the browser, this will set the antialiasing flag on the
         * canvas. Set this to false if you want a 'jagged' pixel art look to your
         * image resources.
         * @method setAntialiasing
         * @param isSmooth {boolean} Set smoothing to true or false
         */
        Engine.prototype.setAntialiasing = function (isSmooth) {
            this.isSmoothingEnabled = isSmooth;
            this.ctx.imageSmoothingEnabled = isSmooth;
            this.ctx.webkitImageSmoothingEnabled = isSmooth;
            this.ctx.mozImageSmoothingEnabled = isSmooth;
            this.ctx.msImageSmoothingEnabled = isSmooth;
        };
        /**
         *  Return the current smoothing status of the canvas
         * @method getAntialiasing
         * @returns boolean
         */
        Engine.prototype.getAntialiasing = function () {
            return this.ctx.imageSmoothingEnabled || this.ctx.webkitImageSmoothingEnabled || this.ctx.mozImageSmoothingEnabled || this.ctx.msImageSmoothingEnabled;
        };
        /**
         * Updates the entire state of the game
         * @method update
         * @private
         * @param delta {number} Number of milliseconds elapsed since the last update.
         */
        Engine.prototype.update = function (delta) {
            if (this.isLoading) {
                // suspend updates untill loading is finished
                return;
            }
            // process engine level events
            this.currentScene.update(this, delta);
            // update animations
            this.animations = this.animations.filter(function (a) {
                return !a.animation.isDone();
            });
            // Update input listeners
            this.input.keyboard.update(delta);
            this.input.pointers.update(delta);
            this.input.gamepads.update(delta);
            // Publish update event
            this.eventDispatcher.publish(ex.EventType[5 /* Update */], new ex.UpdateEvent(delta));
        };
        /**
         * Draws the entire game
         * @method draw
         * @private
         * @param draw {number} Number of milliseconds elapsed since the last draw.
         */
        Engine.prototype.draw = function (delta) {
            var ctx = this.ctx;
            if (this.isLoading) {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, this.width, this.height);
                this.drawLoadingBar(ctx, this.progress, this.total);
                // Drawing nothing else while loading
                return;
            }
            ctx.clearRect(0, 0, this.width, this.height);
            ctx.fillStyle = this.backgroundColor.toString();
            ctx.fillRect(0, 0, this.width, this.height);
            this.currentScene.draw(this.ctx, delta);
            // todo needs to be a better way of doing this
            this.animations.forEach(function (a) {
                a.animation.draw(ctx, a.x, a.y);
            });
            this.fps = 1.0 / (delta / 1000);
            // Draw debug information
            if (this.isDebug) {
                this.ctx.font = "Consolas";
                this.ctx.fillStyle = this.debugColor.toString();
                var keys = this.input.keyboard.getKeys();
                for (var j = 0; j < keys.length; j++) {
                    this.ctx.fillText(keys[j].toString() + " : " + (ex.Input.Keys[keys[j]] ? ex.Input.Keys[keys[j]] : "Not Mapped"), 100, 10 * j + 10);
                }
                this.ctx.fillText("FPS:" + this.fps.toFixed(2).toString(), 10, 10);
            }
            for (var i = 0; i < this.postProcessors.length; i++) {
                this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.width, this.height), this.ctx);
            }
            //ctx.drawImage(currentImage, 0, 0, this.width, this.height);
        };
        /**
         * Starts the internal game loop for Excalibur after loading
         * any provided assets.
         * @method start
         * @param [loader=undefined] {ILoadable} Optional resources to load before
         * starting the mainloop. Some loadable such as a Loader collection, Sound, or Texture.
         * @returns Promise
         */
        Engine.prototype.start = function (loader) {
            var loadingComplete;
            if (loader) {
                loader.wireEngine(this);
                loadingComplete = this.load(loader);
            }
            else {
                loadingComplete = ex.Promise.wrap();
            }
            if (!this.hasStarted) {
                this.hasStarted = true;
                this.logger.debug("Starting game...");
                // Mainloop
                var lastTime = Date.now();
                var game = this;
                (function mainloop() {
                    if (!game.hasStarted) {
                        return;
                    }
                    window.requestAnimationFrame(mainloop);
                    // Get the time to calculate time-elapsed
                    var now = Date.now();
                    var elapsed = Math.floor(now - lastTime) || 1;
                    // Resolves issue #138 if the game has been paused, or blurred for 
                    // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability 
                    // and provides more expected behavior when the engine comes back
                    // into focus
                    if (elapsed > 200) {
                        elapsed = 1;
                    }
                    game.update(elapsed);
                    game.draw(elapsed);
                    lastTime = now;
                })();
                this.logger.debug("Game started");
            }
            else {
            }
            return loadingComplete;
        };
        /**
         * Stops Excalibur's mainloop, useful for pausing the game.
         * @method stop
         */
        Engine.prototype.stop = function () {
            if (this.hasStarted) {
                this.hasStarted = false;
                this.logger.debug("Game stopped");
            }
        };
        /**
         * Takes a screen shot of the current viewport and returns it as an
         * HTML Image Element.
         * @method screenshot
         * @returns HTMLImageElement
         */
        Engine.prototype.screenshot = function () {
            var result = new Image();
            var raw = this.canvas.toDataURL("image/png");
            result.src = raw;
            return result;
        };
        /**
         * Draws the Excalibur loading bar
         * @method drawLoadingBar
         * @private
         * @param ctx {CanvasRenderingContext2D} The canvas rendering context
         * @param loaded {number} Number of bytes loaded
         * @param total {number} Total number of bytes to load
         */
        Engine.prototype.drawLoadingBar = function (ctx, loaded, total) {
            if (this.loadingDraw) {
                this.loadingDraw(ctx, loaded, total);
                return;
            }
            var y = this.canvas.height / 2;
            var width = this.canvas.width / 3;
            var x = width;
            // loading image
            var image = new Image();
            // 64 bit string encoding of the excalibur logo
            image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAEsCAYAAAA7Ldc6AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjenhJ3MAAA6Y0lEQVR4Xu3dUagkWZ3ncUEEQYSiRXBdmi2KdRUZxgJZhmV9qOdmkWJYlmYYhkKWcWcfpEDQFx9K2O4Fm6UaVhoahi4GF2wWh1pnYawHoXzxpVu6Gimatqni0kpTiGLhgy++3Pn9Mk6kkXlPZp4TGSfiROT3A39aq25EnMi6GfH/ZcSJ/BAAAAAAAAAAAAAAYAw/+9nPLqluqO6rroc/BgAAAIDhhNBxV3Ue6mn4KwAAAAA4nkLGddUdh40QOrp1J/wYAAAAAPSjYHHV4UIVCx3duhoWAQAAAIB0DhOq26qzEC4O1VlYFAAAAAAOU4i4rLrpMBFCxYV66623zt99993z999///ydd97p/t3tsBoAAAAAiFNwaEPHgxAkotWGjt/85jer+vWvf739M9x+BQAAAOAihYX2sbndJ1hdKF/hODs7W4WNNni09fjx4+7PPgirBgAAAICGgsLB0PHzn/98Z+joln+us9zNsAkAAAAAp0zhYN9jc1flMOErGk+ePImGje3yz22t43LYHAAAAIBTo0Bw8LG5b7/99vl7772XHDq6xe1XAAAAwIlTEDj42Nw2dHzwwQfRYJFaXk9nvTfCEAAAAAAsmZr/rMfmxsJEbjm8bG3jUhgOAAAAgKVRw9/rsblDla+gdLZzNwwLAAAAwFKo0T/6sblDFbdfAQAAAAvlBl81yGNzh6hf/epX3W17gju3XwEAAABzpqZ+8MfmDlW+raszjjthyAAAAADmRM180cfmDlWe0N4Z0/UwfAAAAAC1UwM/2mNzhyhPaO+M7WnYDQAAAAC1UwPvuR3dhn5dQz82d6ji9isAAABghtS8R8NHjaGjLU9w3xrv1bA7AAAAAGqlxn0jfPhqx1hPsDqmPMbOuM/C7gAAAAColRr3C+GjhrkdKeXvF+mM/XbYJQAAAAA1UtM+2/DB7VcAAADAjKhhn234cPn7RjrjfxB2CwAAAEBt1LDPOny4/KWHnX24GXYNAAAAQE3UrM8+fPhLD7v7oLocdg8AAABALdSozz58uB49etQNH9x+BQAAANRGjfpG+PAtTHMMHy5/E3tnX26EXQQAAABQAzfpnYZ9FT5q/46PXeXQ1N0X1aWwmwAAAACmpgZ9MeHD9d5773XDx92wmwAAAACmpgZ9UeHDxe1XAAAAQIXcnHca9UWEj/fff78bPp6quP0KAAAAmJoa88WFD9e7777bDSB3wu4CAAAAmIoa80WGD5cfG9zZt+thlwEAAABMQU35YsPH9u1XYZcBAAAATEFN+WLDh+udd97pBpDbYbcBAAAAjE0N+aLDh/elu3+qq2HXAQAAAIxJzfiiw4fr7OysGz7Owq4DAAAAGJOa8cWHDxe3XwEAAAATUyN+EuHjyZMn3fDhuhxeAgAAAABjUBN+EuHD9fjx4274eBBeAgAAAABjUBN+MuHD5f3r7O/N8DIAAAAAKE0N+EmFD26/AgAAACai5vukwofr0aNH3fBxP7wUAAAAAEpS831y4cP19ttvdwPIjfByAAAAACjFjXenCT+Z8PHBBx90w4frUnhJAAAAAJSgpvskw4frvffe64aPu+ElAQAAAFCCmu6TDR8ubr8CAAAARuKGu9N8n1z4eP/997vh42l4WQAAAAAMTQ33SYcP17vvvtsNIHfCSwMAAABgSGq2Tz58uN56661uALkeXh4AAAAAQ1GjTfhQPX78uBs+uP0KAAAAGJoabcKH6uzsrBs+XLfDSwQAAABgCGqyCR+qSPh4oOK7PwAAAIChqMEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qAgfAAAAQGFqsAkfKsIHAAAAUJgabMKHivABAAAAFKYGm/ChInwAAAAAhanBvt1puAkffyrCBwAAADAkNdh3Og034eNPRfgAAAAAhqQGm/ChInwAAAAAhanBJnyoCB8AAABAYWqwCR8qwgcAAABQmBpswoeK8AEAAAAUpgab8KEifAAAAACFqcEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qAgfAAAAQGFqsAkfKsIHAAAAUJgabMKHivABAAAAFKYGm/ChInwAAAAAhanBJnyoCB8AAABAYWqwCR8qwgcAAABQmBpswoeK8AEAAAAUpgab8KEifAAAAACFqcEmfKgIHwAAAEBharAJHyrCBwAAAFCYGmzCh4rwAQAAABSmBpvwoSJ8AAAAAIWpwSZ8qB49etQNHi7CBwAAADAkNdiED9W7777bDR4uwgcAAAAwJDXYhA8V4QMAAAAoTA024UNF+AAAAAAKU4NN+FARPgAAAIDC1GATPlSEDwAAAKAwNdiEDxXhAwAAAChMDTbhQ0X4AAAAAApTg034UBE+AAAAgMLUYBM+VIQPAAAAoDA12IQPFeEDAAAAKEwNNuFDRfgAAAAAClODTfhQET4AAACAwtRgEz5UhA8AAACgMDXYhA8V4QMAAAAoTA024UNF+AAAAAAKU4NN+FARPgAAAIDC1GATPlSEDwAAAKAwNdiEDxXhAwAAAChMDTbhQ0X4AAAAAApTg034UBE+AAAAgMLUYBM+VIQPAAAAoDA12IQPFeEDAAAAKEwNNuFDRfgAMHfn5+ffUCULixWh1b/QbCXJm2GxIrT+e81mktwLiwEASlCDTfhQET4ALIGa5yoCiFb9pWYLWV4Iiw9O6yaAAEAN1GBvhI+HDx8SPpoaLXz4RNec7xbhG2G3AEzE78Pm7ZgmLDY4rfrNZgvZroRVDErrJYAAwNTUYG+EDzfhseZ86TX1lQ+f6Jrz3SIQQICJ+X3YvB3ThMUGpdVeadbey1fDagal9RJAAGBKarAJH6oabrvyia453y0CAQSYmN+HzdsxTVhsUFptn9uvWq+E1QxK6yWAAMBU1GATPlQ1hA/zia453y0CAQSYmN+HzdsxTVhsUFrtMQGkSPPv9TarT0IAAYChqMEmfKhqCR/mE11zvlsEAggwMb8Pm7djmrDYoLRaroAAAAgfbdUUPswnuuZ8twgEEGBifh82b8c0YbFBabXMAQGAU6cGm/Chqi18mE90zfluEQggwMT8PmzejmnCYoPTqh81W8jGU7AAYO7UYBM+VDWGD/OJrjnfLQIBBJiY34fN2zFNWGxwWvVzzRayFDuGaN0EEAAYgxpswoeq1vBhPtE157tFIIAAE/P7sHk7pgmLFaHVv9JsJQnfhA4Ac6cGm/Chqjl8mE90zfluEQggwMT8PmzejmnCYsVoEynjcVD5RFikCK2fAAIAJanBJnyoag8f5hNdc75bBAIIMDG/D5u3Y5qwWFHajCelv6Dqfju654g4eHwp/FhR2g4BBABKUYNN+FDNIXyYT3TN+S5NWAwAonSYqC6A1EC7SgABgBLUYBM+VHMJH+YTXXO+SxMWA4AoHSYIIBHaVQIIAAxNDTbhQzWn8GE+0TXnuzRhMQCI0mGCABKhXSWAAMCQ1GATPlRzCx/mE11zvksTFgOAKB0mCCAR2lUCCAAMRQ024UM1x/BhPtE157s0YTEAiNJhggASoV0lgADAENRgEz5Ucw0f5hNdc75LExYDgCgdJgggEdpVAggAHEsNNuFDNefwYT7RNee7NGExAIjSYYIAEqFdJYAAwDHUYBM+VHMPH+YTXXO+SxMWA4AoHSYIIBHaVQIIAPSlBpvwoVpC+DCf6JrzXZqwGABE6TBBAInQrhJAAKAPNdiED9VSwof5RNec79KExQAgSocJAkiEdpUAAgC51GATPlRLCh/mE11zvksTFgOAKB0mCCAR2lUCCADkUINN+FBFwsd91WzDh/lE15zv0oTFACBKhwkCSIR2lQACAKnUYBM+VJHwcSe8RLPmE11zvksTFgOAKB0mCCAR2lUCCIDy/unvPnRZdS2hbiXUHdX9Tt0ImynKTXa36SZ8LCt8mE90zfkuTVgMAKJ0mCCARGhXCSAALlJT7zCw3ejvqvOJ61YYdjFusrtNN+FjeeHDfKJrzndpwmIAEKXDBAEkQruac6wlgACnwk39VpNfc90Nwy7CTXa36SZ8LDN8mE90zfkuTVgMAKJ0mCCARGhXc461BBDgVKipHzSA/OhrHz7/6bc+drAevvTM+S9e/uTeevzdT62qs/77YdiDc5PdbboJH8sNH+YTXXO+SxMWAwajX6svqZ5XuXH176PrkWoX/137c17Gy34hrK56Gqv396th7O1+vKna5Xeq2exvGGOysNjiaVf975dqkACi9XxB5d+XF7zOULvM5ncM86LfpSsqH/NeV8WOde0x7hWVf+5KWPQ0qKlfB5AHL146/+33Lu+sP/7ws+fn//z5UesPP/jMamxthWEPyk12t+kmfCw7fFh40ycLiwG96dfITVHbfA/N66zmBKZxfEL1nMon1n0how+ftL3e58LmqqDxEEAitKs5v++9A4iWdcD178W+EJ/K66judwzzoN8b/y72Oc6f1hVANfXrAOKrDrEQMHW14wt1OQx9EG6yu0034WP54cP8Rm/e72nCYrOnXfEnMm7gcj0fVjEpjcONbe74Jzuoa9t+vf0p7BBNUSo3/P4k9xNhGKPw9sJ2/WnfWPy6uvEfdV9jwjiShcWK0Opzjm9F3x9ef7OZJNlj0TL+nSv5/vK6He5r+B2b9XlLQ8p6j8iXwqKD07oH/73Uz/lDpqx/oy0EkNrKt2y1Y1RdD0M/mpvsbtNN+DiN8GF+ozfv9zRhsUXQ7vhkmutRWHxSGoeb+RwOK6NfFdA2/QnYmI14jPf9G2FIxWgbDln+tLhPsB2Ktz1pSNb2CSARXn+zmSTJY9HPlg4e22r4HZv1eUtDWmwA0c/0Oa9uO7kA4idgnbs83yIWAKYu3xrWjlE1yJOw3GR3m27Cx+mED/MbvXm/pwmLLYZ2KWv/g+LN7D7avj9dyvXVsPgotD03431e22LC0AanVfe9zaAkj2eST6q1XQJIhNffbCZJSqM39XvMVxgnmSei7Wbtd1isGhrSIgOI/t4fwAzh5ALI+vG6nucRCwBT1y9f/fRqfKGOnojuJrvbdBM+Tit8mN/ozfs9TVhsMbRLfZp5fwI42W0I2nbWv5mMdjDXtnz7Ue7VmVGEIQ5Gq2yveNTKv6ejN4jaJgEkwutvNpPkUKPneUVTXmlrTXI1RNuc9XlLQ1pcANHfDXksJIDUVr9//cpqfKGehqH34ia723QTPk4vfJjf6M37PU1YbFG0W7knA3slLD4qbde3W+RwgzDKrVfajsPcmLeCZAnDHIRW1+d3ZgqjhxBtjwAS4fU3m0myr9HLPQaMYdSrwtrerM9bGtKiAoj+fOgPYgggNZYf79uOU3U1DD+Lm+xu0034OM3wYX6jN+/3NGGxxdGu9XlC0diNXZ+J56PceqXt1NgUbQhDPZpW5Vuu5mS0EGraFgEkwutvNpNkrEZvSKN9KKNtzfq8pSEtJoDoz4aY87GNAFJjvfHtj6/GGOpmGH4SNdiXVPc7DTfh4091cuHD/EZv3u9pwmKLo13r01SOepDU9nJvbRplfNpOzU3RWhju0bSquQUQezMMvzhtiwAS4fU3m0kSa/Rym9YpvBCGW5S2M+vzloa0iACi/9/nFuYUo55bJ6dmfhYBpO8XEqrBdvh40Gm4CR9/qpMMH+Y3evN+TxMWWyTtXp+5C6M8H1/byT3Qj/Kpt7Yxi/BhYchH06rmGEBslNtkvJ1mc2nCYkVo9TnHt2oDiP5/9VcYO4rPCdE2Zn3e0pCWEkCG/m6jFgGkxtr+QkLVpbALO6nBJnyEInxs8hu9eb+nCYstknbPtzjlzmEY5bG82k7Wv5MUv/VK2xgyfDgw+XG9PjG7wY+ecPXnDmL+e1/29/aT/73CKo6mVR0bQDzmdl89mdjru/BQA/9Z+Dvvq38+9/a7mDFCKQEkwutvNpNkPRb97z6fMvt3zB+oOLj4d+jCv7v/LPxd+14a4verVfT2VK1/1uctDWn2AUT/u8StVy0CSK31469/ZDXOUDfCLkSpwSZ8hCJ8XOQ3evN+TxMWWyztohvCXEWbfa0/d0zFD97axlDhw+s56iqSlncj5ZPh3jASfvxoWlWfAOIA4WawdwDQsu0XHOaG5K7i9+lrGwSQCK+/2UyS1Vj035wPRRwg/Nof8zvmY80Q39vjMRd7UqDWPevzloY06wCi/+bMR/Tvk4/PF/ZBf9Z+yOLjWvcDJQJIrfXwpWdW4wx1N+zCBWqwCR+hCB9xfqM37/c0YbFF027mnoB9IC5ysvV6VTkNp8dS9FNurT/35BnjdQz+mmmdPplFf6fDjxxNq0oNIP5384l30P30+lTHBMCqfj/CYkVo9TnHtxoDSMqxaBU8VhsZiNbnqy5Z54aIYvNBtO5Zn7c0pLkHkJTx+xiVfazRMg7Bo8wlqkanoV/d5hRr/GuprcfxuqK3YanJvtttugkfhI9teqPfUyULiy2adjPn051WkQOm1pt7oqrtasw2N1RFG2DTNi4EkfBXR9OqDgUQ3xc9xn3wfecFFD25a/0EkAivv9lMEv9synvN76eSVxqOvc2myK1YWu+sz1sa0twDyL4Pxfx3o3//0Kx1G/pY019bpdyGpUb7Vrfx/vWvfx1t0JdchI/9dKC4tzpkJAqLLZ52tU9zN2hj7fU1q01WuoHqE8xaXm6KLyzzv+NqzOGPjqZV7QogPvGOuo/aXm4jY78Lixeh9RNAIrz+ZjNJHGIPXfkc6xHbvhrS931f5DX1epvVpwmLVUNDmm0AUe0Lxv77YoF4sTrNfLThr622bsOKPg1LzbZvwXraNt+PHj2KNulLLcLHYeGAkSwsdhK0u1mvjQx6svX6mtUmcYNQ+taa3Nej5bFN9omYtu3gNNi/jdYVCyBuKCY58Wq7ff5dSjY0BJAIr7/ZzCDGDrrHhJDBf9e0zqzXMixWDQ1pzgFk122Br4dVIlenmY82/LVV5GlYl8OubFDTvb4K8tZbb53MVRDCRxodNO41x440YbGToN31FYjck+4gJwqtJ/dWp1pvvfInucVvuRqT9qcbQCa/3cDbX40kT7FH8nrdzSbShMWK0Opzjm9zCSCjX0k0bbfP75kN/rp6nc2q04TFqqEhzTWA7Loq5+M8Vz766jbzsYa/xvrptz62HrPqdtiVDWq8T+4qCOEjnQ4a91aHj/kq+t0GXn+zmWRHP5ZX68ideF66cep761XxqzJT0D61AaTo/fc5NI7cSenFfme0bgJIhNffbOYok4SPlrbfd07I0LenZr2WYbFqaEhzDSAxizzOj6rTyEeb/Rrrl69+ej1m1VPVrsnoG3NBnjx5Em3cl1CEjzw6cNxbHULmq/iXq2kbuV+2dFSToOVzTk7FD/5af+7J0jyuRU5E1H45gIxy/30qjSf7ClVYdHBaNQEkwutvNtNb8Ucop9A4+uzHoA8+0PqyxhAWq4aGtKQAMsqX8S5ap5GPNvu11tZk9Jthdy5QI37WNuXvvPNOtHmfexE+8ungca85hszWGAEk99YDN9+9PhnXcrkTz0vfetX36gcnpZHpNc/9dyr1hCICSITX32ymF18RreVqW59bUwd98IHWl/VahsWqoSEtJYAUfc+cjE4TH230a61fvPzJ9bhVZ2F3LlAzfr3bnP/qV7+KNvFzLcJHPz6ANMeR2SoeQMzbaTaXrNe4tFzOv0fxg7+2kbvfdlrPcK+EXvfc27CKNDVaLwEkwutvNtNLsQa0D42nz3FhsA8ltK6s1zIsVg0NaSkBhFuvjqXG/VKniY82+rXWH3/42fMffe3D67Grdn4zupry+22D/vbbby9mQjrhoz8dQO41x5HZGiuA5M7LsKyDs34+5zYafwJZ/OCvbeTuczWf1J4ave659+cXee94vc3q04TFitDqc45vtQaQ6j5l1ph8PMw12AcTWlfWaxkWq4aGtIQAUsUtgbOnpv1a28B7Ynes0a+5Mq6CXFatJ6S/99570YZ+TkX4OI4OIn0PPrUYJYCYtrXr+x92SX4soX42N+AUn4OgbfR58tWkk2RPmV773N9PAsimWgNIVVc/WhpX7hW3ox/Q0dK6sl7LsFg1NKQlBBC+bHAIatpnHUAiV0FuhV27QA36xoT0Od+KRfg4ng4ifQ8+tRgtgJi2V+Q2F/1czglplE9EtZ1dz3vfZbAGA/n0+ud+Kl3Ft/eHxYrQ6nOObzUGkOqufrQ0tj6P5R3kqq3Wk/VahsWqoSHNPYC8GRbHsdSwzzqAuLaugux8IpapUX/QNu1z/W4QwscwdCDpc/CpydgBJHdS9sEDtX4mZ1LnWLde9bnFgqsfEwv/DqmKNLdaLwEkwutvNpOl6veUxpd7i+Yg80C0nqzXMixWDQ1p7gGkqqcAzpqa9dkHkMhVkOj3gpia9auq9a1Yc3sqFuFjODqQ9Dn41GTUAGLaZu6tSXubCP19zpWGUQ782s7zzeaScfWjAvp3yAnHBJBNNQaQqudTaXy5V4QHOV5rPVmvZVisGhrS3AMIt18NRc367AOI6/F3P7Xah05dDbt4gZr2m90mfi5fUEj4GJYOJPea48lsjR5ATNvNCQ07J2brz3Pu2x/tdgxtK7ex4MlXFdC/Q877mQCyqbYAMtr7vS+NMfeDikH2yetpVpcmLFYNDWnOAYQPm4akRn0RAcT1k29+dLUfoe6HXYxS836328zXPh+E8DE8HUxyDz61mSqA5D4LPzpO/XnqLQyj3HrV0rZyb63gE7EK6N8h5/1MANlUWwCZ5NiWQ2PM/d6iQZpXrSfrtQyLVUNDmnMASX64ChKoUV9MAPnt9y6v9qNT+76c8JJqYz7IBx98EG3+py7CRxk6mNxrjilpwmIQvRw5jz11gNi4CqL/n3MSGu2eW21rkqYC6fSa+8qZbwX075CvVvl9nBOIjQCyqbYAUqzpHFIYa7Kw2FG0mlmftzSkOQeQ6oPxrKhJX0wAcT148dJqX0J5QvrlsKsXqJHfmA/y85//vKpJ6R6L56i04wtF+BiIDiZZB5+wGAK9JDmv3/q56frfOVdQijZG27S93DkuPA++AL2uQ4SMfQggm2oLILP4Ph2NM3e/jr6Sq3VkbTMsVg0Nac4BZBbBeDbUoN9oG/Y3vv3xaFM/p4pMSD90K9bGt6TXEkI8Bo+lOzYV4WNAOphkHXzCYgj0kuQ+inJ18tV/U+eQjHrrlWl7uSdHnn7Vk1670iFjHwLIpqoCSFisehpq7uO6j25gtY5Zv5Ya0pwDyKjno8VTg36rbdb9ONtYUz+3evLas6v96dTO7wYxNfY3uo3+w4cPo6FgrCJ8jEMHk3vNMSVNWAwdellyTiZuMnMmno/+uENtM7ehYP7HAX6NVL5l7wWV33NjhYx9CCCbagogs/meBY119GZa65j1eUtDmm0ACYthKG7O20Z9KQHE9fClZ1b71KlrYZej3OB3G37Pu4iFg9JF+BiPjif3msNKmrAYtuilebN5hZKkNp+TNCHaLr8TR9LL4u9R8ROCHOZqCBsxBJBNNQWQomMZksZKAMmkIRFA0FBjvsgA4luxtp6KtfcLCs2NfrfxHzuEED7GpeMJB58B6KXJuaqRapIrC2HbqZiA3qHXw7dT5V5BmgoBZBMBpAeNNbeZPnoSs9Yx6/OWhjTXADKb38vZUFO+yADi+v3rV7bngzwIu72TG/5uAHAIGWNOCOFjfD6gNMeVNGExROjl8e01Q5nsSSNh+6k4IYleB1/tyH108dQIIJsIID1orASQTBoSAQQNNeWLDSCuX7766dW+depgU+/GvxsEHAxKhhDCxzR8QGmOK2nCYojQy+PbboZoQie7/1vb9j7kOOkTkvbfV77mFjxaBJBNBJAeNFYCSCYNiQCChhryRQcQV2Q+yN5J6eYA0A0EpUII4WM6PqA0x5U0YTHsoJco9xG2MZNN6ta2c28lO8lvQNd+O6gNecVrCgSQTQSQHjRWAkgmDYkAgoab8bYxX2oAcfkRw+1+hroRXoKdHAS6wWDoLyskfEzLB5TmuJImLIY99DIdMwdgsluvTNvPDSCTjncK2meHj5yHDpTg961/z9zI+PYv/7t5XDnvZwLIJgJIDxorASSThkQAQUON+DqA+IsI/W3if/jBZ6JN/JwrMindlRJCbnUDgkPI2dlZNFDkFOFjej6gNMeVNGEx7KGXKfc2pq5Jv3xM2yeA7KH99eN0x3iqlbfh96Yf27wRMsJQovT3Oe9nAsgmAkgPGisBJJOGRABBQ0343a2mfF0OJL59yd+r4QY+1tjPqbwPP/76R7b3MyWEbHxPiOuYJ2QRPurgA0pzXEkTFsMeepn8fQ99TXpLk7ZPANlB++pgOXT48JWUNmT49r2jGg0tn/N+JoBsIoD0oLGO3kxrHbM+b2lIBBA01IDf32rId5avILSBJNbgz6EiT8ZypYSQq6qnncCwChG5t2QRPurhA0pzXEkTFsMOeolyvxk9ptjJ5hBvuxlCslMKIEPcduV1uPko8m+s9ea8nwkgmwggPWisBJBMGhIBBA0131dV11W+FeuOKjmQeF6FnzI1t6sjR4SQS6oHneCwuiXr8ePH0bCxXYSPuviA0hxX0oTFsINeoiGaVD9VaZJbsbTd3AByEick7ecxE8797+mG40pYXTHaRs77mQCyiQDSg8aaO+eNAEIAwSFqyB1Mbqhuqx6ozvfVgxcvzerKSN8QYgoNt7dCxPnDhw/Pnzx5Eg0eLsJHfXxAaY4racJiiNDLk3tS2WeSW7G0XQLIFu1j36tavl3r+bCaUWh7Oe9nAsgmAkgPHmsz5GRHB3GtY9bnLQ2JAII8as4vqXylxFdJzlTnsfIcCz9Naw5XRXaEkKRQoPBwTXXWCROrevTo0SpsED7q5wNKc1xJExbDFr00uY17imInnV20zdwJ9KcQQLLeI4E/FR79Kpa2mTNWAsgmAkgPGmvW9+CExY6i1cz6vKUhEUBwHDXqvkLiqyPRMOLG3ldFan+i1o6nY/k2tEthV3dSiPAtWRuP6nW9/fbb5++//z7ho3I+oDTHlTRhMXToZXHTXuLL6Ca5FavZdLqw2CJp9/pc/XglLD46bTvn/UwA2UQA6SGMN9XvwmJH0Xpmfd7SkAggGI6a9WsqXxk5j1XtQWRHCPFtZ1fDLu6lQBG9GuLbsggf9fIBpTmupAmLoUMvi59ilMonnpywMvqtWNpm7pOeJn10cEnat5x/W5v0BO3tN8NIQgDZRADJpHFOcsum1pM1JyssVg0NiQCC4alh921aN1XRqyK1BxGPb2vMT1Wp80J8NcTfGbLxpKytInxUxAeU5riSJiyGQC9JzjefvxmW8Xc65Bj1VixtL+t3Qka/VWws2rfcMFZ8ovk+2n7OeAkgmwggmTTO3EeOD/KBitZTze9YHxoSAQRluXFXXZi87luzap4j8vi7n9oYbyh/V8rBW7JMIeOyg0YndBA+KuUDSnNcSRMWg+jlyP1eiC+ERb1sztOyRr0VS9vK/dR/kY/i1X7lfro72a1XrTCOVASQTTUFkEdhsappnLnHiq+GRY+i9cw9gOQ+VY8Agn7UuPv2rAtXRDxZvdanZvnb4COT070P18JuHaTA4e8NuU/4qJcPKM1xJU1YDKKXI+fxkxuf/On/5za3o92KpW3lfjq3yJOS9iv3dXguLDoJbf9KM4xkBJBNNQWQWRxrNczcuW/rD2GOofXkvjerukqr8WT9LggBBMdR8+4rIheCiL9LpMarIR6Tvwl+e7wqz3VJuhpiDiLhf6IyPqA0x5U0YbGTp5ci59YDXyW5cAVDf5b76eEoJ1Fvp9lclsXNA9E+Zb03ZNLXQNuf5H78bVovASTC6282k2yQZr0Uj68ZZrqw6NG0qrkHkNxbOwkgGIaad3/hoedWnLflqw21Xg3xLVmRqyHJc0NQLx9QmuNKmrDYSdPL4E+ac04g0e+C0J/nrme0W7GazWUZ9fsuxqB9yvl0d/JbZjSG3KaMALKptgAyyO1KpWh8ubcRDfb6al25v+vV3CaqseReqTQCCIaj5v2y6sI3rtd6NcQT53dcDfEcl+TbslAXH1Ca40qasNhJ08uQM39j7wFbfz/JJM5DtJ2s3wtZ3Ikp7FeqyfffY2iGkqzImLVeAkiE199sJtnrYdEqaXy5t18NFqi0rtnNz2ppLLkPITECCNL8q+f+x+XwPw9S8+4vNty4GuK5If6CwFgQmLp2XA1xOUwRRGbGB5TmuJImLHay9BLkfvJ28KlI+pmcQGPFbyfQNnKDkVV9y0gO7cusvpBR288drxFANtUWQKzKWxs1rj63aQ52fNC6cre/egJhDTSWnLmDLQIIDlP4uKU6D/9Nmiehxt2P7r1wNeSXr346GgKmLl+hiTyuty2CyIz4gNIcV9KExU6Sdj/3nueky/76udyTafFbsbT+PrcJVPMp47G0L1XMp0il7fcJjASQTTUGkCpvbdS4cpvoQW9R1Pr6BO7Jw5zH0AwlGwEE+ylwXA/ho62nqpvhrw9S4+7vD3ETvy43+rEQUEP5Ks2O27JcDiLXw66hUj6gNMeVNGGxk6Nd94mj2KNz9bO5E9KL34qlbeRembFFXAXRfswtgOTeDmMEkE01BpDqHserMfX5cGLwORhaZ+5E7snDnMaQewW9RQDBbgoaV0Pg6AaQth6okp4Epab9qmrjSVlu8mv9zhCXH9m7J4h4XzzpPvm2NIzHB5TmuJImLHZytOtFn9uun3fAqebJKKb197lXeREnKO3HbAKItt3n38kIIJtqDCBW1VUQjafPfgz+BZ1aZ+44Jp1To+33Oca3CCCIU7i4FELGKnD86//0P1fV/v9O3VYdvC1Lzbpvydr4AsOffPOjVYcQ14Eg4vJVET+KOPkRvijLB5TmuJImLHZStNu5zWivE52Wy72NpuitWF63qs8Js+qn96TQPuTebjfJJ9Xarv+N+lz9MALIploDiN+DVcwF0TieW40oT6nfs9wPhWzwIJRK2+579cMIIIhTqLjbCRnnX/zK98//w3/7f+efe/7VbvhoK+dqiL9vw437qjz5u9bJ6d3yE7N869iOyeptOYz4ljOujEzIB5TmuJImLHYytMu5Tbh/tvdJTsvm3vZU9FYsrb/vSXP2t2KF/cgxenOjbfZpwloEkE21BhCb/IlYGkPfDySKNM9ab58wNMnjeLVd37bW57VrEUBwkcJEO+l8VX/216+d/8f//v/X5TDyb67/r24AaetWWMVeoUl3w76quYQQl6/YeCK9r9509yFSvk3LYctXR/jSwhH5gNIcV9KExU6Gdjl3suVRn/5r+dyrLVby5NS36fAysw4hzW5kGbW50fb6/K50EUA21RxAbNJbsbT9Pk9vKvaaat0+NuU66gOivrTNPvPpuggg2KQQsTHp/N/9l1c2wke3Pv9Xf98NH23dV6XckuXG3I36quYUQtryVZGHLz2zesRwd1/2lK+Q3FZ5/sg1FcGkAB9QmuNKmrDYSdDu5n7CNsijHrWe3E+1S9+K1fcqiMc12S0Px9LYs94b4uZmlFtltB3fInbMJ6pGANlUewCx58LqRqXt5j4ko1WscTatv09jP+rVJG2v72vXRQDBnyg4bEw691UO33YVCx9t/fv/+n/Pn/3yd7ZDyJnqYHOtBnz2IaQthxF/n8iB+SLRCi8HBuIDSnNcSRMWWzztap9L5oN84q/19LnqUOxWLK3b4+k7z8D7MemVEG9flf36eBlVrjGeTjZE+DACyKY5BBD/uxdt6rdpe30b6OLNqrbR5/HTNsrVJG2n7/i2EUDQUGC4MOn8L/72H6OhY7scUnylpF02lIPMjbD6ndSAXwghtU9MTylPXv/Fy59cBZID80YIIAPzAaU5rqQJiy2edjXrdZFBG0+tr7Zvyz3mdh83TZPcPqLtts1w9olTy/S5x9yK7avWPVT4MALIpjkEkNZYDfQxn94X/+BB2/AHRX0VfQ21/r5XjmMIIGgoLFyYdB4LG/vKc0W66wh18DtD1IRvhJA5PB0rt3yF5Mlrz65CyRvf/vh6X1X3w8uAgfiA0hxX0oTFFk27mfuplRvCwW+90Tqz/m2k9K1Yx0x4Nt9DPtYtSg5w3as2fQJIn3vMW4M3N16nal/48N/lhBMCyKY5BRDz+7HI+0nrdWN/zHhHmw+lbfWZm9Iq8T71cePQmHI/RCCA4PCk85zyLVmRx/XeCZvaSY34hRASa+SXUL460tlXAsjAfEBpjiuL0vsgqWX7fMJc5L5srddjyVX6qVjHTqb0a+sGtURg84l/O3i0ev1OaLljPgEepAnTelKbQb+uOe9nAsimmgKIf4dTjkP+ucGaaK3L7yH/++UeA7sGmQuXSts79mEMg30wovX4qmns+NPlv896jwgB5NQpHCRPOk8t37oVeUpWSgjZeDpWzd+YfkwRQMryAaU5rizKMQEkt8Eu3bT0uepQ8mTVZ27MLm7ujw5vXkdY175x9fp30nLHNje9G0Qt522nBqBV06f/5ryfi/zuar0EkAivv9lMEv9szuu4+j1T9WqktZzf18cGD/PyUzxl6tjzmMft/e81di3n1z51DH5fE0CQTqEge9J5ank9PUPIxveE+JG3sSZ+zkUAKcsHlOa4sih9m83ck4IVPdlq/f5EMrcpcDNS7FYnrXvIeQjmdfn30K+/w4RP0BfG7z8Lf+ef8c/m/O72PnF62WYVR/E+Oky4UbnQTOjP2n3z3/vnDn2Kum11v73+O8prso/Wm/U+CosVodVP/nq0vP5mM0lWY9F/+1xx9Hb8b+DfpwvzMPRn3d81f8Bx7FXNrqme0tXnavEufj3aY9G+18+36vrqSc6xcHWFWv/Neo8IAeRUKQz0nnSeWjsmp6eEED+u9rytuT4Za1cRQMryAaU5rixK9kFSy/iEkmuU+5y1HTcKuUrfijV0CCmt94lTyw7Z3JSw/u4Z/e+c93ORZkLrJYBEeP3NZpKsxqL/DnnFsbSik7oP0faPnaNWmoPN6oMV/ZcAgjQKAkdPOk+t3BCipvySyl/kd+7y92wsaVI6AaQsH1Ca48qiZB0k9fP+RCv3E+dHYfFRaHt9/p2KnbRM659TCDnqxKnlcxuGsbwShrii/5/ze1KkmdB6CSARXn+zmSTrseh/+5P42k0aPloax5BXc4bk4+T6aor+NwEEhykADDbpPLV6hJCrnSZ99eSoWDM/xyKAlOUDSnNcWZSsg6R+vqp5FjHanj8JzVX0VizT+h1CcsPbFI4+cWodxzxtp4QL++Q/a/4qSZFmQuslgER4/c1mkmyMRf+/z1XQsVQRPkxj8YdJNX4osnG+0P8ngGA/Nf6DTzpPrUgI2fuIXjXnG5PS/UV/sYZ+bkUAKcsHlOa4sijJB0n9bJ9PFzc+dR6LttvnU/gxvhjPJ/3af4+OPnFqHd7PWj5h9esdmyeT8+9QpJnQegkgEV5/s5kkF8aiP6sthLjRryZ8tDSm2q7MXniN9GcEEOymhr/YpPOU2jExfe+XFapBv9s26/5CP3+fRqypn1M5SLX7pDo4JwZ5fEBpjiuLknSQ1M/1+bTMP1/0qsIu3q6qz9WGUa7WaDuelFnjp482yIlT66khhOwMwPq7nPdzkWZC6yWARHj9zWaSRMeiP68lhPg9UPyLBvvy2FRTX5n1sTD6GunPCSCIU6NffNJ5SkVCiAPR1TDMC9Sgez7I07Zh9zeLx5r6OZW/jLDdH9WtsKsYiA8ozXFlUZIOkvq5PrfUrCf8TkHb73PFpvitWC1tx7eK1fY75fEM+rQyrW+KCa9uaPb+/unvc157Asim6gOI6e+mbq5H+5LBY2icU16ZdUDbeczR3xFAEKcmf7RJ54fKwWfrywrPVJfCUC9Qk36907CvvlE81tjPpQggZfmA0hxXFuXgQVI/k/tt51bFwdfjaIaTpfitWF3anp8qNvXvlrdf8sTtMDhWI+h9ORiiws+lKvL7rPUSQCK8/mYzSfaORX/v5nrsEOzHQxd97HgJGrOvGo11ZdbbORjQ/DOrn05HADkFau5Hn3R+qPyN6d0xqfbOhVCjvr4Va+5PxSKAlOUDSnNcWZRDJ+++j7as4pYDjaPPhHQb5VasLm3Tn9Ye+pLAITkQuDEbrVHSttxMlAoifn8m/7uFn09FANk0mwDS0s/5WJD6ZZV9+H07y+DRpfE7sPn3stRxKOt10s8RQLBJjf1kk84P1Z//zT90A4hrZzOuRv2yan0rlpv4WHM/hyKAAMugk5evGPgkPXSz7tsdHDomDYjavvcv94vJYtpmptp77FEX/a44iAwVhNvfv+ommA9B+9Ueh4YIIz72+Gr6JPMCsRBq6CeddJ5SkSdj7ZsPcqvTuM92QjoBBFgenbDdMLkRcNPkpv2eat/kbjdW/hmXl/FJf/QrOqk8tjBGNzr79q3dL/+cf57QgaPod8jvLd925FC+73fPDXj3PeVlTur3z/ur8vuufa1cu3RfKx+7CB04nhr5KiadHyoHome//J1uADk0H2T9BYUPXrwUbfBrLwIIAAAAFkdNfDWTzg9VZD7I7bAbF6hh35iQPserIAQQAAAALIoa+OomnR+qz//V33cDiGvfrVj32wZ+jldBHr70DAEEAAAAy6DGvdpJ54dq6/tBHoRdukBN+7VOAz+7qyD+LpPO+K+F3QIAAADmRU179ZPO91XkVqybYdcuUOM+26sgBBAAAADMnpr1C5PO3dDHGv2aK/It6dEJ6WrcZzsXhAACAACA2VOjvjHp/OqN/xNt8GstX6m58pcvd8OHywHkctjFC9S8r5+INafvBSGAAAAAYNbUpG9MOveE7liTX2v5Ss3Wo3hdvpqzM3yYmvcbbSPvb0ePNfs1FgEEAAAAs6UmfWPS+b/9z/872uTXWv42dN8u1t0H1R3Vzu8Caal5v6Rafzv6k9eejTb8tRUBBAAAALOkJn3Wk84/9/yr28HDtXPieYwa+DttM//Gtz8ebfhrKwIIAAAAZkeN+mwnne+Z77Hzuz92UQN/tdPMn//xh5+NNv01FQEEAAAAs6NmfZaTzvfM9zh4y9UuauLXk9F/+eqno01/TfWjr324G0D2znMBAAAAJqdmfZaTznfN9wi71Zua+NttQz+H27DasbrCLgAAAAB1UsM+y0nn/kb27rhD3Qi7dRQ18rO6Das71rALAAAAQH3UsM9u0rnHt/Xlgq5e8z32UTO/vg2r9qdhteN0heEDAAAAdVHDPrtJ5x5f5Jaro+Z77KJmfn0b1oMXL0Ub/1qqHacrDB8AAACoi5r2WU0693yP7nhDHT3fYxc189fbpr72LyVsx+kKwwcAAADqocZ9VpPOS8732Kfb2P/hB5+JNv81VHecYegAAABAHdS4z2bS+Y75HmeqQed77KKG/n7b2Nf8ON52jK4wdAAAAGB6btxVs5h0vmO+x33V4PM9dlFDf6tt7B++9Ey0+Z+6/ISudoyuMHQAAABgWm7cVbOYdL5jvsftsCujUUO/ngfibxuPBYCp67ffu9wNIPfD0AEAAIBpqYGvftK5r8ZE5nv4ik3x+R4xaugvd5r7aACYugggAAAAqI4a+Judhr7KSed/8bf/OOl8j13U1D9tG/zfv34lGgKmLAIIAAAAqqIG/lqnoa9y0vkXv/L9yed77OKmvm3wa/xCQgIIAAAAqqEG/rKq6knnf/bXr20HD9fo8z12UVO/8YWEbvgP1ePvfur8Fy9/8mB5Xsmh+sk3P9oNGIeKAAIAAIBpqImvetJ5bfM9dlFTv34S1gyKAAIAAIBpqJG/02nsq5p0Xut8jxg19de2mvxay3NVqrlyBAAAgBOiRr7aSec1z/eIUVPfDSBu8j0n5FDdUfnKyaHyY369/r0VhgIAAADUR418tZPOd8z3uBWGDgAAAGBO1MxXOel8z3yP62HoAAAAAOZEzXyVk853zPfwOKub7wEAAAAgkRr66iadewyR+R7+RvYq53sAAAAASKCGvrpJ5x5Dd0yhmO8BAAAAzJma+qomnXu+h8fQHZOK+R4AAADA3Kmpr2rSueecMN8DAAAAWCA19RuTzl3+jo1YMBijmO8BAAAALJga+41J5y4HAM+9GPsqCPM9AAAAgIVTg++5Hw4h61uw2nr2y98Z5SlYe+Z78O3dAAAAwBKp2fetWH4K1plqIwz4y/9KXQ3ZM9/jchgaAAAAgKVS4+8gcku1cUXEIWHoLyTcMd/DV2OY7wEAAACcEoUAPxnrfggFqxryW9E/9/yr3dDR1s2weQAAAACnSKHAV0PWIeHYEOJbua785cvd0OFivgcAAAAwV//0dx+6prquutWpmyr/efbcCoWDGyEkHBVCvIwntrfrCcV8DwAAAGBOHCpCwLivOk+op6o7quRvFVdIuKraCCE5E9P//G/+gfkeAAAAwJwpQDh4OEjEQkZqnaluhFXupbDgELIOEJ6YHgsb28V8DwAAAGDGFBguqW6HAHGhfvz1j5z/9FsfO3/40jPnv3j5k6t68OKl1Z/Ffj6Ug8jBeRgKDr4dax0k/OWBsdDhYr4HAAAAMHMKCVdVD0JoWNdPvvnR88ff/dT5H37wmfPzf/783nry2rOrQPKjr314Yx2hbodN7aQAcbsTKKLzQZjvAQAAAMycwoHDh+dvrAODr3b89nuXo0HjUP3xh59dXR3pri+U55LsnJuhEOHvCll/YaGvcnTDx675HmFxAAAAALVTILgQPhweYsEit3zVxFdQuutW+SrLvhByrRswvviV76/Cx475HklzTAAAAABUQEFgI3z41qm+Vz32lW/LarcRau9VCwULP8VqFTJ8FcST0tv/H8rzPa6GHwcAAABQO4UATzhfz/lw+Pj961eiAWKIioSQnU+rUrjwt6Vvh462PN+DR+wCAAAAc6IAsPG0qxJXPrbrjW9/vBtAXDsnjitkrK+CdIr5HgAAAMDcuPHvBoGh5nwcKk9O9+T2zrbvhyFdoLCxMRdExXwPAAAAYI7U+K+/ZNCTxGNhoVT5Sku77VA7v7tDocNPxGK+BwAAADBXavg3rn6McevVdm19ceHO26oUPK6rmO8BAAAAzJUa/ptt8z/21Y+2IldBCBkAAADAEqnZXz/5yt9wHgsIY9TWXBDmdwAAAABL1Gn6V18UGAsHY9TDl57pBpDbYXgAAAAAlkKN/rW26fcViFgwGKuevPZsN4DsfBoWAAAAgJlSo3+jbfo9ETwWDMYqX31px+IKQwQAAACwFGr0b7UN/1jf/bGv2rG4whABAAAALIUafQIIAAAAgHGo0SeAAAAAABiHGv11APFTqGKhYMxqx+IKQwQAAACwFGr010/BmnoS+taXEZ6FIQIAAABYCjX6V9um/0df+3A0GIxVv3z1090AwmN4AQAAgCVSs/+0bfx///qVaDgYo9749se7AeRWGB4AAACAJVGzf7dt/KeaB/LHH352dQWmHYfqahgeAAAAgCVRs7/+MkKHAIeBWEgoWVu3XzH/AwAAAFgyNf3r27DGfhyvA8+Pv/6RbgDh9isAAABgydz0twHAV0H+8IPPRMNCiXLgabetchC6FIYFAAAAYInc9KvOQggY7ZG8nvTebjMUVz8AAACAU6Dm/3o3DDx48VI0NAxVvsqyNfH8QRgKAAAAgFOgEHCnEwiKhRCHj59886Pd8OFbr3jyFQAAAHBqFAQedILBKoQM+WQs33a1deXDdSNsHgAAAMApURjwfJCNEOKrFb/93uVooMiprQnnbRE+AAAAgFOmUOAQcr8TElblqyG535buqyf+no+tR+22RfgAAAAA0FBAWD+et1u+IuKrGb4qErs9yyHFocOBJXK7lctP3GLOBwAAAIBNDgqqC1dDepYnmzvU8F0fAAAAAHZTaLimuquKBYtDRfAAAAAAkM8hQnVD5Uf2bkxW75QDh6+aOHRcC4sCAAAAAAAAAAAAAAAAAAAAAAAg1Yc+9C+CyYFQsnpjxgAAAABJRU5ErkJggg==';
            var imageHeight = width * 3 / 8;
            var oldAntialias = this.getAntialiasing();
            this.setAntialiasing(true);
            ctx.drawImage(image, 0, 0, 800, 300, x, y - imageHeight - 20, width, imageHeight);
            // loading box
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, 20);
            var progress = width * (loaded / total);
            ctx.fillStyle = 'white';
            var margin = 5;
            var width = progress - margin * 2;
            var height = 20 - margin * 2;
            ctx.fillRect(x + margin, y + margin, width > 0 ? width : 0, height);
            this.setAntialiasing(oldAntialias);
        };
        /**
         * Sets the loading screen draw function if you want to customize the draw
         * @method setLoadingDrawFunction
         * @param fcn {ctx: CanvasRenderingContext2D, loaded: number, total: number) => void}
         * Callback to draw the loading screen which is passed a rendering context, the number of bytes loaded, and the total number of bytes to load.
         */
        Engine.prototype.setLoadingDrawFunction = function (fcn) {
            this.loadingDraw = fcn;
        };
        /**
         * Another option available to you to load resources into the game.
         * Immediately after calling this the game will pause and the loading screen
         * will appear.
         * @method load
         * @param loader {ILoadable} Some loadable such as a Loader collection, Sound, or Texture.
         */
        Engine.prototype.load = function (loader) {
            var _this = this;
            var complete = new ex.Promise();
            this.isLoading = true;
            loader.onprogress = function (e) {
                _this.progress = e.loaded;
                _this.total = e.total;
                _this.logger.debug('Loading ' + (100 * _this.progress / _this.total).toFixed(0));
            };
            loader.oncomplete = function () {
                setTimeout(function () {
                    _this.isLoading = false;
                    complete.resolve();
                }, 500);
            };
            loader.load();
            return complete;
        };
        return Engine;
    })(ex.Class);
    ex.Engine = Engine;
    ;
})(ex || (ex = {}));
//# sourceMappingURL=excalibur-0.2.5.js.map
;
// Concatenated onto excalibur after build
// Exports the excalibur module so it can be used with browserify
// https://github.com/excaliburjs/Excalibur/issues/312
if (typeof module !== 'undefined') {module.exports = ex;}
},{}],"/home/a/snake/lib/food.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
var _ = require('underscore');

module.exports = function (opts) {
    'use strict';
    var
        parts = opts.parts,
        ex = opts.ex,
        game = opts.game,
        color = opts.color,
        w = game.width,
        h = game.height,
        size = opts.size,
        findX = function () {
            var x = size * _.random(2, Math.floor(w / size) - 2);
            return _.pluck(parts, 'x').indexOf(x) === -1 ? x : findX();
        },
        findY = function () {
            var y = size * _.random(2, Math.floor(h / size) - 2);
            return _.pluck(parts, 'y').indexOf(y) === -1 ? y : findY();
        },
        actor = new ex.Actor(findX(), findY(), size, size, color);
    this.eat = function () {
        actor.kill();
    };
    this.actor = actor;
    game.add(actor);
};

},{"underscore":"/home/a/snake/node_modules/underscore/underscore.js"}],"/home/a/snake/lib/mobile.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
/*global window*/
module.exports = function (snake) {
    'use strict';
    var handleOrientation = function (event) {
        var y = event.beta,
            x = event.gamma,
            maxX = 30,
            maxY = 20;
        if (y > maxY) {
            snake.down();
        } else if (y < -maxY) {
            snake.up();
        } else if (x > maxX) {
            snake.right();
        } else if (x < -maxX) {
            snake.left();
        }
    };
    window.addEventListener('deviceorientation', handleOrientation);
};

},{}],"/home/a/snake/lib/score.js":[function(require,module,exports){
/*jslint node:true*/
/*global window*/
module.exports = function () {
    'use strict';
    var ls = window.localStorage,
        score = 0,
        record = ls.getItem('record') || 0;
    this.inc = function () {
        score += 1;
        if (score > record) {
            record = score;
            ls.setItem('record', record);
        }
        document.title = 'Score: ' + score + ' Record: ' + record;
    };
    document.title = 'Score: ' + score + ' Record: ' + record;
};
},{}],"/home/a/snake/lib/snake.js":[function(require,module,exports){
/*jslint node:true,nomen:true*/
var Food = require('./food'),
    _ = require('underscore'),
    Score = require('./score');

module.exports = function (opts) {
    'use strict';
    var
        self = this,
        v = {},
        running = false,
        speed = 150,
        score = new Score(),
        game = opts.game,
        size = Math.floor(Math.min(game.width, game.height) / 22),
        ex = opts.ex,
        color = opts.color,
        part = function (x, y, color) {
            var actor = new ex.Actor(x, y, size, size, color);
            game.add(actor);
            return actor;
        },
        startPlaceRandX = _.random(2, Math.floor(game.width / size) - 2),
        startPlaceRandY = _.random(2, Math.floor(game.height / size) - 2),
        parts = [
            part((startPlaceRandX + 1) * size, startPlaceRandY * size, color.body),
            part(startPlaceRandX * size, startPlaceRandY * size, color.body)
        ],
        food = new Food({
            ex: ex,
            game: game,
            color: color.food,
            parts: parts,
            size: size
        }),
        cutTail = function () {
            var last = parts.pop(),
                prelast = parts[parts.length - 1];
            last.moveTo(
                prelast.x,
                prelast.y,
                2 * speed
            );
            return last;
        },
        addNeck = function (time) {
            var firstPart = parts[0],
                x = firstPart.x,
                y =  firstPart.y,
                newPart = part(x, y, color.body);
            parts.unshift(newPart);
            newPart.moveTo(
                x + v.x * size,
                y + v.y * size,
                speed
            );
            newPart.on('exitviewport', function () {
                self.onLose();
            });
            return newPart;
        },
        hiTail = function (actor) {
            var i;
            for (i = 2; i < parts.length - 2; i += 1) {
                if (parts[i] && actor.within(parts[i], size / 2)) {
                    return true;
                }
            }
        },
        step = function () {
            addNeck().callMethod(function () {
                if (this.within(food.actor, size / 2)) {
                    speed += 50;
                    food.eat();
                    score.inc();
                    food = new Food({
                        ex: ex,
                        game: game,
                        color: color.food,
                        parts: parts,
                        size: size
                    });
                    step();
                } else if (hiTail(this)) {
                    self.onLose();
                } else {
                    cutTail().callMethod(function () {
                        this.kill();
                        step();
                    });
                }
            });
        };
    this.right = function () {
        v.x = 1;
        v.y = 0;
    };
    this.left = function () {
        v.x = -1;
        v.y = 0;
    };
    this.up = function () {
        v.x = 0;
        v.y = -1;
    };
    this.down = function () {
        v.x = 0;
        v.y = 1;
    };
    this.run = function (obj) {
        v.x = obj.x || 0;
        v.y = obj.y || 0;
        step();
    };
};

},{"./food":"/home/a/snake/lib/food.js","./score":"/home/a/snake/lib/score.js","underscore":"/home/a/snake/node_modules/underscore/underscore.js"}],"/home/a/snake/node_modules/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/home/a/snake/node_modules/screenfull/dist/screenfull.js":[function(require,module,exports){
/*!
* screenfull
* v2.0.0 - 2014-12-22
* (c) Sindre Sorhus; MIT License
*/
(function () {
	'use strict';

	var isCommonjs = typeof module !== 'undefined' && module.exports;
	var keyboardAllowed = typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element;

	var fn = (function () {
		var val;
		var valLength;

		var fnMap = [
			[
				'requestFullscreen',
				'exitFullscreen',
				'fullscreenElement',
				'fullscreenEnabled',
				'fullscreenchange',
				'fullscreenerror'
			],
			// new WebKit
			[
				'webkitRequestFullscreen',
				'webkitExitFullscreen',
				'webkitFullscreenElement',
				'webkitFullscreenEnabled',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			// old WebKit (Safari 5.1)
			[
				'webkitRequestFullScreen',
				'webkitCancelFullScreen',
				'webkitCurrentFullScreenElement',
				'webkitCancelFullScreen',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			[
				'mozRequestFullScreen',
				'mozCancelFullScreen',
				'mozFullScreenElement',
				'mozFullScreenEnabled',
				'mozfullscreenchange',
				'mozfullscreenerror'
			],
			[
				'msRequestFullscreen',
				'msExitFullscreen',
				'msFullscreenElement',
				'msFullscreenEnabled',
				'MSFullscreenChange',
				'MSFullscreenError'
			]
		];

		var i = 0;
		var l = fnMap.length;
		var ret = {};

		for (; i < l; i++) {
			val = fnMap[i];
			if (val && val[1] in document) {
				for (i = 0, valLength = val.length; i < valLength; i++) {
					ret[fnMap[0][i]] = val[i];
				}
				return ret;
			}
		}

		return false;
	})();

	var screenfull = {
		request: function (elem) {
			var request = fn.requestFullscreen;

			elem = elem || document.documentElement;

			// Work around Safari 5.1 bug: reports support for
			// keyboard in fullscreen even though it doesn't.
			// Browser sniffing, since the alternative with
			// setTimeout is even worse.
			if (/5\.1[\.\d]* Safari/.test(navigator.userAgent)) {
				elem[request]();
			} else {
				elem[request](keyboardAllowed && Element.ALLOW_KEYBOARD_INPUT);
			}
		},
		exit: function () {
			document[fn.exitFullscreen]();
		},
		toggle: function (elem) {
			if (this.isFullscreen) {
				this.exit();
			} else {
				this.request(elem);
			}
		},
		raw: fn
	};

	if (!fn) {
		if (isCommonjs) {
			module.exports = false;
		} else {
			window.screenfull = false;
		}

		return;
	}

	Object.defineProperties(screenfull, {
		isFullscreen: {
			get: function () {
				return !!document[fn.fullscreenElement];
			}
		},
		element: {
			enumerable: true,
			get: function () {
				return document[fn.fullscreenElement];
			}
		},
		enabled: {
			enumerable: true,
			get: function () {
				// Coerce to boolean in case of old WebKit
				return !!document[fn.fullscreenEnabled];
			}
		}
	});

	if (isCommonjs) {
		module.exports = screenfull;
	} else {
		window.screenfull = screenfull;
	}
})();

},{}],"/home/a/snake/node_modules/underscore/underscore.js":[function(require,module,exports){
//     Underscore.js 1.7.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.7.0';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var createCallback = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  _.iteratee = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return createCallback(value, context, argCount);
    if (_.isObject(value)) return _.matches(value);
    return _.property(value);
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    if (obj == null) return obj;
    iteratee = createCallback(iteratee, context);
    var i, length = obj.length;
    if (length === +length) {
      for (i = 0; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    if (obj == null) return [];
    iteratee = _.iteratee(iteratee, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length),
        currentKey;
    for (var index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index = 0, currentKey;
    if (arguments.length < 3) {
      if (!length) throw new TypeError(reduceError);
      memo = obj[keys ? keys[index++] : index++];
    }
    for (; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== + obj.length && _.keys(obj),
        index = (keys || obj).length,
        currentKey;
    if (arguments.length < 3) {
      if (!index) throw new TypeError(reduceError);
      memo = obj[keys ? keys[--index] : --index];
    }
    while (index--) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    predicate = _.iteratee(predicate, context);
    _.some(obj, function(value, index, list) {
      if (predicate(value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    predicate = _.iteratee(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(_.iteratee(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    if (obj == null) return true;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    if (obj == null) return false;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (obj.length !== +obj.length) obj = _.values(obj);
    return _.indexOf(obj, target) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = obj && obj.length === +obj.length ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = _.iteratee(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = _.iteratee(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = _.iteratee(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    for (var i = 0, length = input.length; i < length; i++) {
      var value = input[i];
      if (!_.isArray(value) && !_.isArguments(value)) {
        if (!strict) output.push(value);
      } else if (shallow) {
        push.apply(output, value);
      } else {
        flatten(value, shallow, strict, output);
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = _.iteratee(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i];
      if (isSorted) {
        if (!i || seen !== value) result.push(value);
        seen = value;
      } else if (iteratee) {
        var computed = iteratee(value, i, array);
        if (_.indexOf(seen, computed) < 0) {
          seen.push(computed);
          result.push(value);
        }
      } else if (_.indexOf(result, value) < 0) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true, []));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(slice.call(arguments, 1), true, true, []);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function(array) {
    if (array == null) return [];
    var length = _.max(arguments, 'length').length;
    var results = Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var idx = array.length;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var Ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    args = slice.call(arguments, 2);
    bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      Ctor.prototype = func.prototype;
      var self = new Ctor;
      Ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (_.isObject(result)) return result;
      return self;
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = hasher ? hasher.apply(this, arguments) : key;
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last > 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed before being called N times.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      } else {
        func = null;
      }
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    if (!_.isObject(obj)) return obj;
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (hasOwnProperty.call(source, prop)) {
            obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj, iteratee, context) {
    var result = {}, key;
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      iteratee = createCallback(iteratee, context);
      for (key in obj) {
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
    } else {
      var keys = concat.apply([], slice.call(arguments, 1));
      obj = new Object(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (key in obj) result[key] = obj[key];
      }
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    if (!_.isObject(obj)) return obj;
    for (var i = 1, length = arguments.length; i < length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (
      aCtor !== bCtor &&
      // Handle Object.create(x) cases
      'constructor' in a && 'constructor' in b &&
      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
        _.isFunction(bCtor) && bCtor instanceof bCtor)
    ) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size, result;
    // Recursively compare objects and arrays.
    if (className === '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size === b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      size = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      result = _.keys(b).length === size;
      if (result) {
        while (size--) {
          // Deep compare each member
          key = keys[size];
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
  if (typeof /./ !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    var pairs = _.pairs(attrs), length = pairs.length;
    return function(obj) {
      if (obj == null) return !length;
      obj = new Object(obj);
      for (var i = 0; i < length; i++) {
        var pair = pairs[i], key = pair[0];
        if (pair[1] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = createCallback(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? object[property]() : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}]},{},["/home/a/snake/index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiaW5kZXguanMiLCJsaWIvZXhjYWxpYnVyLmpzIiwibGliL2Zvb2QuanMiLCJsaWIvbW9iaWxlLmpzIiwibGliL3Njb3JlLmpzIiwibGliL3NuYWtlLmpzIiwibm9kZV9tb2R1bGVzL2RvbXJlYWR5L3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL3NjcmVlbmZ1bGwvZGlzdC9zY3JlZW5mdWxsLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5dVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qanNsaW50IG5vZGU6dHJ1ZSovXG4vKmdsb2JhbCB3aW5kb3cqL1xudmFyIGRvbXJlYWR5ID0gcmVxdWlyZSgnZG9tcmVhZHknKSxcbiAgICBleCA9IHJlcXVpcmUoJy4vbGliL2V4Y2FsaWJ1cicpLFxuICAgIFNuYWtlID0gcmVxdWlyZSgnLi9saWIvc25ha2UnKSxcbiAgICBtb2JpbGUgPSByZXF1aXJlKCcuL2xpYi9tb2JpbGUnKSxcbiAgICBzY3JlZW5mdWxsID0gcmVxdWlyZSgnc2NyZWVuZnVsbCcpO1xuXG5kb21yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBnYW1lID0gbmV3IGV4LkVuZ2luZSgpLFxuICAgICAgICBzbmFrZSA9IG5ldyBTbmFrZSh7XG4gICAgICAgICAgICBleDogZXgsXG4gICAgICAgICAgICBnYW1lOiBnYW1lLFxuICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICBoZWFkOiBleC5Db2xvci5SZWQsXG4gICAgICAgICAgICAgICAgYm9keTogZXguQ29sb3IuWWVsbG93LFxuICAgICAgICAgICAgICAgIGZvb2Q6IGV4LkNvbG9yLkdyZWVuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICByZXBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnYW1lLnJvb3RTY2VuZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgIGFjdG9yLmtpbGwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQudGl0bGUgPSAnJztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNuYWtlID0gbmV3IFNuYWtlKHtcbiAgICAgICAgICAgICAgICAgICAgZXg6IGV4LFxuICAgICAgICAgICAgICAgICAgICBnYW1lOiBnYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZDogZXguQ29sb3IuUmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZXguQ29sb3IuWWVsbG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9vZDogZXguQ29sb3IuR3JlZW5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNuYWtlLm9uTG9zZSA9IHJlcGxheTtcbiAgICAgICAgICAgICAgICBzbmFrZS5ydW4oe3g6IDF9KTtcbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGdhbWUuaW5wdXQua2V5Ym9hcmQub24oJ2Rvd24nLCBmdW5jdGlvbiAoaykge1xuICAgICAgICBrID0gay5rZXk7XG4gICAgICAgIGlmIChrID09PSAzNykge1xuICAgICAgICAgICAgc25ha2UubGVmdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IDM4KSB7XG4gICAgICAgICAgICBzbmFrZS51cCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IDM5KSB7XG4gICAgICAgICAgICBzbmFrZS5yaWdodCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT09IDQwKSB7XG4gICAgICAgICAgICBzbmFrZS5kb3duKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoayA9PT0gMzIpIHtcbiAgICAgICAgICAgIGlmIChwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBnYW1lLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdhbWUuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVwbGF5KCk7XG4gICAgfSk7XG4gICAgbW9iaWxlKHNuYWtlKTtcbiAgICBpZiAoc2NyZWVuZnVsbC5lbmFibGVkKSB7XG4gICAgICAgIHNjcmVlbmZ1bGwucmVxdWVzdCgpO1xuICAgIH1cbiAgICBnYW1lLnN0YXJ0KCk7XG4gICAgc25ha2Uub25Mb3NlID0gcmVwbGF5O1xuICAgIHNuYWtlLnJ1bih7eDogMX0pO1xufSk7XG4iLCIvKiEgZXhjYWxpYnVyIC0gdjAuMi41IC0gMjAxNS0wMi0wNFxuKiBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyXG4qIENvcHlyaWdodCAoYykgMjAxNSA7IExpY2Vuc2VkIEJTRCovXG5pZiAodHlwZW9mIHdpbmRvdyA9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdyA9IHsgYXVkaW9Db250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgfSB9O1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB3aW5kb3cuc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgfTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmICF3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCB8fCB3aW5kb3cubW96QXVkaW9Db250ZXh0IHx8IHdpbmRvdy5tc0F1ZGlvQ29udGV4dCB8fCB3aW5kb3cub0F1ZGlvQ29udGV4dDtcbn1cbi8vIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaFxuLy8gUHJvZHVjdGlvbiBzdGVwcyBvZiBFQ01BLTI2MiwgRWRpdGlvbiA1LCAxNS40LjQuMThcbi8vIFJlZmVyZW5jZTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMThcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgVCwgaztcbiAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignIHRoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCBwYXNzaW5nIHRoZSB8dGhpc3wgdmFsdWUgYXMgdGhlIGFyZ3VtZW50LlxuICAgICAgICB2YXIgTyA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgLy8gMi4gTGV0IGxlblZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgR2V0IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggdGhlIGFyZ3VtZW50IFwibGVuZ3RoXCIuXG4gICAgICAgIC8vIDMuIExldCBsZW4gYmUgVG9VaW50MzIobGVuVmFsdWUpLlxuICAgICAgICB2YXIgbGVuID0gTy5sZW5ndGggPj4+IDA7XG4gICAgICAgIC8vIDQuIElmIElzQ2FsbGFibGUoY2FsbGJhY2spIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIC8vIFNlZTogaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS4xMVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIFQgPSB0aGlzQXJnO1xuICAgICAgICB9XG4gICAgICAgIC8vIDYuIExldCBrIGJlIDBcbiAgICAgICAgayA9IDA7XG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgICAgICB2YXIga1ZhbHVlO1xuICAgICAgICAgICAgLy8gYS4gTGV0IFBrIGJlIFRvU3RyaW5nKGspLlxuICAgICAgICAgICAgLy8gICBUaGlzIGlzIGltcGxpY2l0IGZvciBMSFMgb3BlcmFuZHMgb2YgdGhlIGluIG9wZXJhdG9yXG4gICAgICAgICAgICAvLyBiLiBMZXQga1ByZXNlbnQgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBIYXNQcm9wZXJ0eSBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgICAgICAgLy8gICBUaGlzIHN0ZXAgY2FuIGJlIGNvbWJpbmVkIHdpdGggY1xuICAgICAgICAgICAgLy8gYy4gSWYga1ByZXNlbnQgaXMgdHJ1ZSwgdGhlblxuICAgICAgICAgICAgaWYgKGsgaW4gTykge1xuICAgICAgICAgICAgICAgIC8vIGkuIExldCBrVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBHZXQgaW50ZXJuYWwgbWV0aG9kIG9mIE8gd2l0aCBhcmd1bWVudCBQay5cbiAgICAgICAgICAgICAgICBrVmFsdWUgPSBPW2tdO1xuICAgICAgICAgICAgICAgIC8vIGlpLiBDYWxsIHRoZSBDYWxsIGludGVybmFsIG1ldGhvZCBvZiBjYWxsYmFjayB3aXRoIFQgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gYXJndW1lbnQgbGlzdCBjb250YWluaW5nIGtWYWx1ZSwgaywgYW5kIE8uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChULCBrVmFsdWUsIGssIE8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZC4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIC8vIDguIHJldHVybiB1bmRlZmluZWRcbiAgICB9O1xufVxuLy8gUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXG5pZiAoIUFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoZnVuIC8qLCB0aGlzQXJnICovKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgICAgICBpZiAodHlwZW9mIGZ1biAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG4vLyBQb2x5ZmlsbCBmcm9tICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kI1BvbHlmaWxsXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZUb0JpbmQgPSB0aGlzLCBmTk9QID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB9LCBmQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpcyA/IHRoaXMgOiBvVGhpcywgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG4gICAgICAgIHJldHVybiBmQm91bmQ7XG4gICAgfTtcbn1cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgRWZmZWN0cztcbiAgICAoZnVuY3Rpb24gKEVmZmVjdHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGxpZXMgdGhlIFwiR3JheXNjYWxlXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCByZW1vdmluZyBjb2xvciBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQGNsYXNzIEVmZmVjdHMuR3JheXNjYWxlXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyBJU3ByaXRlRWZmZWN0XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgR3JheXNjYWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdyYXlzY2FsZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdyYXlzY2FsZS5wcm90b3R5cGUudXBkYXRlUGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSwgaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgYXZnID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSArIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSArIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSkgLyAzO1xuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGF2ZztcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBhdmc7XG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gYXZnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBHcmF5c2NhbGU7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEVmZmVjdHMuR3JheXNjYWxlID0gR3JheXNjYWxlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgXCJJbnZlcnRcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGludmVydGluZyB0aGUgcGl4ZWwgY29sb3JzLlxuICAgICAgICAgKiBAY2xhc3MgRWZmZWN0cy5JbnZlcnRcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBleHRlbmRzIElTcHJpdGVFZmZlY3RcbiAgICAgICAgICovXG4gICAgICAgIHZhciBJbnZlcnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gSW52ZXJ0KCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSW52ZXJ0LnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXTtcbiAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMV07XG4gICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDJdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBJbnZlcnQ7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEVmZmVjdHMuSW52ZXJ0ID0gSW52ZXJ0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgXCJPcGFjaXR5XCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBzZXR0aW5nIHRoZSBhbHBoYSBvZiBhbGwgcGl4ZWxzIHRvIGEgZ2l2ZW4gdmFsdWUuXG4gICAgICAgICAqIEBjbGFzcyBFZmZlY3RzLk9wYWNpdHlcbiAgICAgICAgICogQGV4dGVuZHMgSVNwcml0ZUVmZmVjdFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIG9wYWNpdHkge251bWJlcn0gVGhlIG5ldyBvcGFjaXR5IG9mIHRoZSBzcHJpdGUgZnJvbSAwLTEuMFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIE9wYWNpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZVBpeGVsID0gZnVuY3Rpb24gKHgsIHksIGltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBNYXRoLnJvdW5kKHRoaXMub3BhY2l0eSAqIDI1NSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBPcGFjaXR5O1xuICAgICAgICB9KSgpO1xuICAgICAgICBFZmZlY3RzLk9wYWNpdHkgPSBPcGFjaXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyB0aGUgXCJDb2xvcml6ZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCB0aGUgcGl4ZWxzIHRvIGFuXG4gICAgICAgICAqIGF2ZXJhZ2Ugb2YgdGhlIG9yaWdpbmFsIGNvbG9yIGFuZCB0aGUgcHJvdmlkZWQgY29sb3JcbiAgICAgICAgICogQGNsYXNzIEVmZmVjdHMuQ29sb3JpemVcbiAgICAgICAgICogQGV4dGVuZHMgSVNwcml0ZUVmZmVjdFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIGNvbG9yIHtDb2xvcn0gVGhlIGNvbG9yIHRvIGFwcGx5IHRvIHRoZSBzcHJpdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBDb2xvcml6ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBDb2xvcml6ZShjb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENvbG9yaXplLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChwaXhlbFtmaXJzdFBpeGVsICsgM10gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSArIHRoaXMuY29sb3IucikgLyAyO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDFdICsgdGhpcy5jb2xvci5nKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMl0gKyB0aGlzLmNvbG9yLmIpIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIENvbG9yaXplO1xuICAgICAgICB9KSgpO1xuICAgICAgICBFZmZlY3RzLkNvbG9yaXplID0gQ29sb3JpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBcIkZpbGxcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgbm9uLXRyYW5zcGFyZW50IHBpeGVscyB0byBtYXRjaFxuICAgICAgICAgKiBhIGdpdmVuIGNvbG9yXG4gICAgICAgICAqIEBjbGFzcyBFZmZlY3RzLkZpbGxcbiAgICAgICAgICogQGV4dGVuZHMgSVNwcml0ZUVmZmVjdFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIGNvbG9yIHtDb2xvcn0gVGhlIGNvbG9yIHRvIGFwcGx5IHRvIHRoZSBzcHJpdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBGaWxsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZpbGwoY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBGaWxsLnByb3RvdHlwZS51cGRhdGVQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCBpbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChwaXhlbFtmaXJzdFBpeGVsICsgM10gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gdGhpcy5jb2xvci5yO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSB0aGlzLmNvbG9yLmc7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IHRoaXMuY29sb3IuYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEZpbGw7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEVmZmVjdHMuRmlsbCA9IEZpbGw7XG4gICAgfSkoRWZmZWN0cyA9IGV4LkVmZmVjdHMgfHwgKGV4LkVmZmVjdHMgPSB7fSkpO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9TcHJpdGVFZmZlY3RzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9JbnRlcmZhY2VzL0lQaXBlbGluZU1vZHVsZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIE1vdmVtZW50TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTW92ZW1lbnRNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTW92ZW1lbnRNb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcbiAgICAgICAgICAgIGFjdG9yLnggKz0gYWN0b3IuZHggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICBhY3Rvci55ICs9IGFjdG9yLmR5ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgYWN0b3IuZHggKz0gYWN0b3IuYXggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICBhY3Rvci5keSArPSBhY3Rvci5heSAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIGFjdG9yLnJvdGF0aW9uICs9IGFjdG9yLnJ4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgYWN0b3Iuc2NhbGUueCArPSBhY3Rvci5zeCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIGFjdG9yLnNjYWxlLnkgKz0gYWN0b3Iuc3kgKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNb3ZlbWVudE1vZHVsZTtcbiAgICB9KSgpO1xuICAgIGV4Lk1vdmVtZW50TW9kdWxlID0gTW92ZW1lbnRNb2R1bGU7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0ludGVyZmFjZXMvSVBpcGVsaW5lTW9kdWxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9mZnNjcmVlbkN1bGxpbmdNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnREaXNwYXRjaGVyID0gYWN0b3IuZXZlbnREaXNwYXRjaGVyO1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGFjdG9yLmFuY2hvcjtcbiAgICAgICAgICAgIHZhciBnbG9iYWxTY2FsZSA9IGFjdG9yLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBnbG9iYWxTY2FsZS54ICogYWN0b3IuZ2V0V2lkdGgoKSAvIGFjdG9yLnNjYWxlLng7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZ2xvYmFsU2NhbGUueSAqIGFjdG9yLmdldEhlaWdodCgpIC8gYWN0b3Iuc2NhbGUueTtcbiAgICAgICAgICAgIHZhciBhY3RvclNjcmVlbkNvb3JkcyA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KGFjdG9yLmdldEdsb2JhbFgoKSAtIGFuY2hvci54ICogd2lkdGgsIGFjdG9yLmdldEdsb2JhbFkoKSAtIGFuY2hvci55ICogaGVpZ2h0KSk7XG4gICAgICAgICAgICB2YXIgem9vbSA9IDEuMDtcbiAgICAgICAgICAgIGlmIChhY3Rvci5zY2VuZSAmJiBhY3Rvci5zY2VuZS5jYW1lcmEpIHtcbiAgICAgICAgICAgICAgICB6b29tID0gYWN0b3Iuc2NlbmUuY2FtZXJhLmdldFpvb20oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWN0b3IuaXNPZmZTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3JTY3JlZW5Db29yZHMueCArIHdpZHRoICogem9vbSA8IDAgfHwgYWN0b3JTY3JlZW5Db29yZHMueSArIGhlaWdodCAqIHpvb20gPCAwIHx8IGFjdG9yU2NyZWVuQ29vcmRzLnggPiBlbmdpbmUud2lkdGggfHwgYWN0b3JTY3JlZW5Db29yZHMueSA+IGVuZ2luZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2V4aXR2aWV3cG9ydCcsIG5ldyBleC5FeGl0Vmlld1BvcnRFdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IuaXNPZmZTY3JlZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhY3RvclNjcmVlbkNvb3Jkcy54ICsgd2lkdGggKiB6b29tID4gMCAmJiBhY3RvclNjcmVlbkNvb3Jkcy55ICsgaGVpZ2h0ICogem9vbSA+IDAgJiYgYWN0b3JTY3JlZW5Db29yZHMueCA8IGVuZ2luZS53aWR0aCAmJiBhY3RvclNjcmVlbkNvb3Jkcy55IDwgZW5naW5lLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudERpc3BhdGNoZXIucHVibGlzaCgnZW50ZXJ2aWV3cG9ydCcsIG5ldyBleC5FbnRlclZpZXdQb3J0RXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdG9yLmlzT2ZmU2NyZWVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZTtcbiAgICB9KSgpO1xuICAgIGV4Lk9mZnNjcmVlbkN1bGxpbmdNb2R1bGUgPSBPZmZzY3JlZW5DdWxsaW5nTW9kdWxlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9JbnRlcmZhY2VzL0lQaXBlbGluZU1vZHVsZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogUHJvcG9nYXRlcyBwb2ludGVyIGV2ZW50cyB0byB0aGUgYWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ2FwdHVyZVBvaW50ZXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYXB0dXJlUG9pbnRlck1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBDYXB0dXJlUG9pbnRlck1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGFjdG9yLCBlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAoIWFjdG9yLmVuYWJsZUNhcHR1cmVQb2ludGVyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChhY3Rvci5pc0tpbGxlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVuZ2luZS5pbnB1dC5wb2ludGVycy5wcm9wb2dhdGUoYWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2FwdHVyZVBvaW50ZXJNb2R1bGU7XG4gICAgfSkoKTtcbiAgICBleC5DYXB0dXJlUG9pbnRlck1vZHVsZSA9IENhcHR1cmVQb2ludGVyTW9kdWxlO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9JbnRlcmZhY2VzL0lQaXBlbGluZU1vZHVsZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIENvbGxpc2lvbkRldGVjdGlvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbGxpc2lvbkRldGVjdGlvbk1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBDb2xsaXNpb25EZXRlY3Rpb25Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChhY3RvciwgZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50RGlzcGF0Y2hlciA9IGFjdG9yLmV2ZW50RGlzcGF0Y2hlcjtcbiAgICAgICAgICAgIGlmIChhY3Rvci5jb2xsaXNpb25UeXBlICE9PSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVuZ2luZS5jdXJyZW50U2NlbmUudGlsZU1hcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IGVuZ2luZS5jdXJyZW50U2NlbmUudGlsZU1hcHNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3RNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlID0gMCAvKiBOb25lICovO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0JvdW5jZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGludGVyc2VjdE1hcCA9IG1hcC5jb2xsaWRlcyhhY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXgtLSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSBhY3Rvci5nZXRTaWRlRnJvbUludGVyc2VjdChpbnRlcnNlY3RNYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2NvbGxpc2lvbicsIG5ldyBleC5Db2xsaXNpb25FdmVudChhY3RvciwgbnVsbCwgc2lkZSwgaW50ZXJzZWN0TWFwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGFjdG9yLmNvbGxpc2lvblR5cGUgPT09IDIgLyogQWN0aXZlICovIHx8IGFjdG9yLmNvbGxpc2lvblR5cGUgPT09IDMgLyogRWxhc3RpYyAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci55ICs9IGludGVyc2VjdE1hcC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLnggKz0gaW50ZXJzZWN0TWFwLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmFpdmUgZWxhc3RpYyBib3VuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY29sbGlzaW9uVHlwZSA9PT0gMyAvKiBFbGFzdGljICovICYmICFoYXNCb3VuY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0JvdW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA9PT0gMyAvKiBMZWZ0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5keCA9IE1hdGguYWJzKGFjdG9yLmR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWRlID09PSA0IC8qIFJpZ2h0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5keCA9IC1NYXRoLmFicyhhY3Rvci5keCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lkZSA9PT0gMSAvKiBUb3AgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmR5ID0gTWF0aC5hYnMoYWN0b3IuZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPT09IDIgLyogQm90dG9tICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rvci5keSA9IC1NYXRoLmFicyhhY3Rvci5keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25EZXRlY3Rpb25Nb2R1bGU7XG4gICAgfSkoKTtcbiAgICBleC5Db2xsaXNpb25EZXRlY3Rpb25Nb2R1bGUgPSBDb2xsaXNpb25EZXRlY3Rpb25Nb2R1bGU7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHNpZGVzIG9mIGFuIEFjdG9yIGZvciBjb2xsaXNpb25cbiAgICAgKiBAY2xhc3MgU2lkZVxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoU2lkZSkge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IE5vbmUge1NpZGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIFNpZGVbU2lkZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFRvcCB7U2lkZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgU2lkZVtTaWRlW1wiVG9wXCJdID0gMV0gPSBcIlRvcFwiO1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEJvdHRvbSB7U2lkZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgU2lkZVtTaWRlW1wiQm90dG9tXCJdID0gMl0gPSBcIkJvdHRvbVwiO1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IExlZnQge1NpZGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIFNpZGVbU2lkZVtcIkxlZnRcIl0gPSAzXSA9IFwiTGVmdFwiO1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFJpZ2h0IHtTaWRlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBTaWRlW1NpZGVbXCJSaWdodFwiXSA9IDRdID0gXCJSaWdodFwiO1xuICAgIH0pKGV4LlNpZGUgfHwgKGV4LlNpZGUgPSB7fSkpO1xuICAgIHZhciBTaWRlID0gZXguU2lkZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgX19leHRlbmRzID0gdGhpcy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgICBkLnByb3RvdHlwZSA9IG5ldyBfXygpO1xufTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSAyRCBwb2ludCBvbiBhIHBsYW5lXG4gICAgICogQGNsYXNzIFBvaW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHgge251bWJlcn0gWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBQb2ludCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBYIENvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSB4IHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogWSBDb29yZGluYXRlIG9mIHRoZSBwb2ludFxuICAgICAgICAgKiBAcHJvcGVydHkgeSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgdGhpcyBwb2ludCB0byBhIHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIHRvVmVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgUG9pbnQucHJvdG90eXBlLnRvVmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUm90YXRlcyB0aGUgY3VycmVudCBwb2ludCBhcm91bmQgYW5vdGhlciBieSBhIGNlcnRhaW4gbnVtYmVyIG9mXG4gICAgICAgICAqIGRlZ3JlZXMgaW4gcmFkaWFuc1xuICAgICAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgUG9pbnQucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSwgYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBleC5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciB4ID0gY29zQW5nbGUgKiAodGhpcy54IC0gYW5jaG9yLngpIC0gc2luQW5nbGUgKiAodGhpcy55IC0gYW5jaG9yLnkpICsgYW5jaG9yLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNpbkFuZ2xlICogKHRoaXMueCAtIGFuY2hvci54KSArIGNvc0FuZ2xlICogKHRoaXMueSAtIGFuY2hvci55KSArIGFuY2hvci55O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zbGF0ZXMgdGhlIGN1cnJlbnQgcG9pbnQgYnkgYSB2ZWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBhZGRcbiAgICAgICAgICogQHJldHVybnMgUG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIFBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHZlY3Rvci54LCB0aGlzLnkgKyB2ZWN0b3IueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB4IGFuZCB5IGNvbXBvbmVudHMgYXQgb25jZVxuICAgICAgICAgKiBAbWV0aG9kIHNldFRvXG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9XG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBQb2ludC5wcm90b3R5cGUuc2V0VG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9uZXMgYSBuZXcgcG9pbnQgdGhhdCBpcyBhIGNvcHkgb2YgdGhpcyBvbmUuXG4gICAgICAgICAqIEBtZXRob2QgY2xvbmVcbiAgICAgICAgICogQHJldHVybnMgUG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIFBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUG9pbnQ7XG4gICAgfSkoKTtcbiAgICBleC5Qb2ludCA9IFBvaW50O1xuICAgIC8qKlxuICAgICAqIEEgMkQgdmVjdG9yIG9uIGEgcGxhbmUuXG4gICAgICogQGNsYXNzIFZlY3RvclxuICAgICAqIEBleHRlbmRzIFBvaW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHgge251bWJlcn0gWCBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxuICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFkgY29tcG9uZW50IG9mIHRoZSBWZWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVmVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFZlY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVmVjdG9yKHgsIHkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSB2ZWN0b3Igb2YgdW5pdCBsZW5ndGggaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGFuZ2xlLlxuICAgICAgICAgKiBAbWV0aG9kIGZyb21BbmdsZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSBhbmdsZSB7bnVtYmVyfSBUaGUgYW5nbGUgdG8gZ2VuZXJhdGUgdGhlIHZlY3RvclxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5mcm9tQW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXN0YW5jZSB0byBhbm90aGVyIHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGRpc3RhbmNlXG4gICAgICAgICAqIEBwYXJhbSB2IHtWZWN0b3J9IFRoZSBvdGhlciB2ZWN0b3JcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgIHYgPSBuZXcgVmVjdG9yKDAuMCwgMC4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0gdi54LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHYueSwgMikpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTm9ybWFsaXplcyBhIHZlY3RvciB0byBoYXZlIGEgbWFnbml0dWRlIG9mIDEuXG4gICAgICAgICAqIEBtZXRob2Qgbm9ybWFsaXplXG4gICAgICAgICAqIEByZXR1cm4gVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kaXN0YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54IC8gZCwgdGhpcy55IC8gZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlcyBhIHZlY3RvcidzIGJ5IGEgZmFjdG9yIG9mIHNpemVcbiAgICAgICAgICogQG1ldGhvZCBzY2FsZVxuICAgICAgICAgKiBAcGFyYW0gc2l6ZSB7bnVtYmVyfSBUaGUgZmFjdG9yIHRvIHNjYWxlIHRoZSBtYWduaXR1ZGUgYnlcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAqIHNpemUsIHRoaXMueSAqIHNpemUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBvbmUgdmVjdG9yIHRvIGFub3RoZXJcbiAgICAgICAgICogQG1ldGhvZCBhZGRcbiAgICAgICAgICogQHBhcmFtIHYge1ZlY3Rvcn0gVGhlIHZlY3RvciB0byBhZGRcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggKyB2LngsIHRoaXMueSArIHYueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSB0aGUgY3VycmVudCB2ZWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBtaW51c1xuICAgICAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0XG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5taW51cyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggLSB2LngsIHRoaXMueSAtIHYueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIGRvdCBwcm9kdWN0IHdpdGggYW5vdGhlciB2ZWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBkb3RcbiAgICAgICAgICogQHBhcmFtIHYge1ZlY3Rvcn0gVGhlIHZlY3RvciB0byBkb3RcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSAyRCBjcm9zcyBwcm9kdWN0IHdpdGggYW5vdGhlciB2ZWN0b3IuIDJEIGNyb3NzIHByb2R1Y3RzIHJldHVybiBhIHNjYWxhciB2YWx1ZSBub3QgYSB2ZWN0b3IuXG4gICAgICAgICAqIEBtZXRob2QgY3Jvc3NcbiAgICAgICAgICogQHBhcmFtIHYge1ZlY3Rvcn0gVGhlIHZlY3RvciB0byBjcm9zc1xuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuY3Jvc3MgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBlcnBlbmRpY3VsYXIgdmVjdG9yIHRvIHRoaXMgb25lXG4gICAgICAgICAqIEBtZXRob2QgcGVycGVuZGljdWxhclxuICAgICAgICAgKiBAcmV0dXJuIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVmVjdG9yLnByb3RvdHlwZS5wZXJwZW5kaWN1bGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy55LCAtdGhpcy54KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG5vcm1hbCB2ZWN0b3IgdG8gdGhpcyBvbmVcbiAgICAgICAgICogQG1ldGhvZCBub3JtYWxcbiAgICAgICAgICogQHJldHVybiBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUubm9ybWFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVycGVuZGljdWxhcigpLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgYW5nbGUgb2YgdGhpcyB2ZWN0b3IuXG4gICAgICAgICAqIEBtZXRob2QgdG9BbmdsZVxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUudG9BbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBvaW50IHJlcHJlc2VudGlvbiBvZiB0aGlzIHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIHRvUG9pbnRcbiAgICAgICAgICogQHJldHVybnMgUG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUudG9Qb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUm90YXRlcyB0aGUgY3VycmVudCB2ZWN0b3IgYXJvdW5kIGEgcG9pbnQgYnkgYSBjZXJ0YWluIG51bWJlciBvZlxuICAgICAgICAgKiBkZWdyZWVzIGluIHJhZGlhbnNcbiAgICAgICAgICogQG1ldGhvZCByb3RhdGVcbiAgICAgICAgICogQHJldHVybnMgVmVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSwgYW5jaG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5yb3RhdGUuY2FsbCh0aGlzLCBhbmdsZSwgYW5jaG9yKS50b1ZlY3RvcigpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmVjdG9yO1xuICAgIH0pKFBvaW50KTtcbiAgICBleC5WZWN0b3IgPSBWZWN0b3I7XG4gICAgLyoqXG4gICAgICogQSAyRCByYXkgdGhhdCBjYW4gYmUgY2FzdCBpbnRvIHRoZSBzY2VuZSB0byBkbyBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICogQGNsYXNzIFJheVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBwb3Mge1BvaW50fSBUaGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoZSByYXlcbiAgICAgKiBAcGFyYW0gZGlyIHtWZWN0b3J9IFRoZSB2ZWN0b3IgaW5kaWNhdGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByYXlcbiAgICAgKi9cbiAgICB2YXIgUmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmF5KHBvcywgZGlyKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgICAgIHRoaXMuZGlyID0gZGlyLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyBhIHdoZXRoZXIgdGhpcyByYXkgaW50ZXJzZWN0cyB3aXRoIGEgbGluZSBzZWdtZW50LiBSZXR1cm5zIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAqIFRoaXMgbnVtYmVyIGluZGljYXRlcyB0aGUgbWF0aGVtYXRpY2FsIGludGVyc2VjdGlvbiB0aW1lLlxuICAgICAgICAgKiBAbWV0aG9kIGludGVyc2VjdFxuICAgICAgICAgKiBAcGFyYW0gbGluZSB7TGluZX0gVGhlIGxpbmUgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBsaW5lLmJlZ2luLnRvVmVjdG9yKCkubWludXModGhpcy5wb3MudG9WZWN0b3IoKSk7XG4gICAgICAgICAgICAvLyBUZXN0IGlzIGxpbmUgYW5kIHJheSBhcmUgcGFyYWxsZWwgYW5kIG5vbiBpbnRlcnNlY3RpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmRpci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpID09PSAwICYmIG51bWVyYXRvci5jcm9zcyh0aGlzLmRpcikgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgcGFyYWxsZWxcbiAgICAgICAgICAgIHZhciBkaXZpc29yID0gKHRoaXMuZGlyLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkpO1xuICAgICAgICAgICAgaWYgKGRpdmlzb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdCA9IG51bWVyYXRvci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpIC8gZGl2aXNvcjtcbiAgICAgICAgICAgIGlmICh0ID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IChudW1lcmF0b3IuY3Jvc3ModGhpcy5kaXIpIC8gZGl2aXNvcikgLyBsaW5lLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGlmICh1ID49IDAgJiYgdSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBnaXZlbiB0aGUgaW50ZXJzZWN0aW9uIHRpbWVcbiAgICAgICAgICogQG1ldGhvZCBnZXRQb2ludFxuICAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgUmF5LnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MudG9WZWN0b3IoKS5hZGQodGhpcy5kaXIuc2NhbGUodGltZSkpLnRvUG9pbnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJheTtcbiAgICB9KSgpO1xuICAgIGV4LlJheSA9IFJheTtcbiAgICAvKipcbiAgICAgKiBBIDJEIGxpbmUgc2VnbWVudFxuICAgICAqIEBjbGFzcyBMaW5lXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGJlZ2luIHtQb2ludH0gVGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgKiBAcGFyYW0gZW5kIHtQb2ludH0gVGhlIGVuZGluZyBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50XG4gICAgICovXG4gICAgdmFyIExpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMaW5lKGJlZ2luLCBlbmQpIHtcbiAgICAgICAgICAgIHRoaXMuYmVnaW4gPSBiZWdpbjtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzbG9wZSBvZiB0aGUgbGluZSBpbiB0aGUgZm9ybSBvZiBhIHZlY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldFNsb3BlXG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgTGluZS5wcm90b3R5cGUuZ2V0U2xvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLmJlZ2luLnRvVmVjdG9yKCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQudG9WZWN0b3IoKTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XG4gICAgICAgICAgICByZXR1cm4gZW5kLm1pbnVzKGJlZ2luKS5zY2FsZSgxIC8gZGlzdGFuY2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgaW4gcGl4ZWxzXG4gICAgICAgICAqIEBtZXRob2QgZ2V0TGVuZ3RoXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgTGluZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJlZ2luID0gdGhpcy5iZWdpbi50b1ZlY3RvcigpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kLnRvVmVjdG9yKCk7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBiZWdpbi5kaXN0YW5jZShlbmQpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGluZTtcbiAgICB9KSgpO1xuICAgIGV4LkxpbmUgPSBMaW5lO1xuICAgIHZhciBQcm9qZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUHJvamVjdGlvbihtaW4sIG1heCkge1xuICAgICAgICAgICAgdGhpcy5taW4gPSBtaW47XG4gICAgICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXggPiBwcm9qZWN0aW9uLm1pbiAmJiBwcm9qZWN0aW9uLm1heCA+IHRoaXMubWluO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRPdmVybGFwID0gZnVuY3Rpb24gKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJsYXBzKHByb2plY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ID4gcHJvamVjdGlvbi5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb24ubWF4IC0gdGhpcy5taW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXggLSBwcm9qZWN0aW9uLm1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb2plY3Rpb247XG4gICAgfSkoKTtcbiAgICBleC5Qcm9qZWN0aW9uID0gUHJvamVjdGlvbjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWxnZWJyYS50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudHMudHNcIi8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIFV0aWw7XG4gICAgKGZ1bmN0aW9uIChVdGlsKSB7XG4gICAgICAgIFV0aWwuVHdvUEkgPSBNYXRoLlBJICogMjtcbiAgICAgICAgZnVuY3Rpb24gYmFzZTY0RW5jb2RlKGlucHV0U3RyKSB7XG4gICAgICAgICAgICB2YXIgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgICAgICAgICAgdmFyIG91dHB1dFN0ciA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGlucHV0U3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vYWxsIHRocmVlIFwiJiAweGZmXCIgYWRkZWQgYmVsb3cgYXJlIHRoZXJlIHRvIGZpeCBhIGtub3duIGJ1ZyBcbiAgICAgICAgICAgICAgICAvL3dpdGggYnl0ZXMgcmV0dXJuZWQgYnkgeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgICAgIHZhciBieXRlMSA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xuICAgICAgICAgICAgICAgIHZhciBlbmMxID0gYnl0ZTEgPj4gMjtcbiAgICAgICAgICAgICAgICB2YXIgZW5jMiA9ICgoYnl0ZTEgJiAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5jMywgZW5jNDtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYnl0ZTIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmMzID0gKChieXRlMiAmIDE1KSA8PCAyKSB8IChieXRlMyA+PiA2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGJ5dGUzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jNCA9IDY0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jNCA9IGJ5dGUzICYgNjM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0U3RyICs9IGI2NC5jaGFyQXQoZW5jMSkgKyBiNjQuY2hhckF0KGVuYzIpICsgYjY0LmNoYXJBdChlbmMzKSArIGI2NC5jaGFyQXQoZW5jNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0U3RyO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwuYmFzZTY0RW5jb2RlID0gYmFzZTY0RW5jb2RlO1xuICAgICAgICBmdW5jdGlvbiBjbGFtcCh2YWwsIG1pbiwgbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsIDw9IG1pbiA/IG1pbiA6ICh2YWwgPj0gbWF4ID8gbWF4IDogdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLmNsYW1wID0gY2xhbXA7XG4gICAgICAgIGZ1bmN0aW9uIGRyYXdMaW5lKGN0eCwgY29sb3IsIHN0YXJ0eCwgc3RhcnR5LCBlbmR4LCBlbmR5KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3RhcnR4LCBzdGFydHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhlbmR4LCBlbmR5KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlsLmRyYXdMaW5lID0gZHJhd0xpbmU7XG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUluUmFuZ2UobWluLCBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5yYW5kb21JblJhbmdlID0gcmFuZG9tSW5SYW5nZTtcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShtaW4sIG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocmFuZG9tSW5SYW5nZShtaW4sIG1heCkpO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwucmFuZG9tSW50SW5SYW5nZSA9IHJhbmRvbUludEluUmFuZ2U7XG4gICAgICAgIGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUFuZ2xlKGFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgdG1wQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgIGlmIChhbmdsZSA+IHRoaXMuVHdvUEkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodG1wQW5nbGUgPiB0aGlzLlR3b1BJKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcEFuZ2xlIC09IHRoaXMuVHdvUEk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0bXBBbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wQW5nbGUgKz0gdGhpcy5Ud29QSTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG1wQW5nbGU7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5jYW5vbmljYWxpemVBbmdsZSA9IGNhbm9uaWNhbGl6ZUFuZ2xlO1xuICAgICAgICBmdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICAgICAgICAgICAgcmV0dXJuIDE4MCAvIE1hdGguUEkgKiByYWRpYW5zO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwudG9EZWdyZWVzID0gdG9EZWdyZWVzO1xuICAgICAgICBmdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xuICAgICAgICAgICAgcmV0dXJuIGRlZ3JlZXMgLyAxODAgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwudG9SYWRpYW5zID0gdG9SYWRpYW5zO1xuICAgICAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIG9MZWZ0ID0gMCwgb1RvcCA9IDA7XG4gICAgICAgICAgICB2YXIgY2FsY09mZnNldExlZnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgb0xlZnQgKz0gcGFyZW50Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY09mZnNldExlZnQocGFyZW50Lm9mZnNldFBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjYWxjT2Zmc2V0VG9wID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIG9Ub3AgKz0gcGFyZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjT2Zmc2V0VG9wKHBhcmVudC5vZmZzZXRQYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYWxjT2Zmc2V0TGVmdChlbCk7XG4gICAgICAgICAgICBjYWxjT2Zmc2V0VG9wKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQob0xlZnQsIG9Ub3ApO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwuZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcbiAgICAgICAgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVTaWRlKHNpZGUpIHtcbiAgICAgICAgICAgIGlmIChzaWRlID09PSAxIC8qIFRvcCAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBCb3R0b20gKi87XG4gICAgICAgICAgICBpZiAoc2lkZSA9PT0gMiAvKiBCb3R0b20gKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogVG9wICovO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT09IDMgLyogTGVmdCAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gNCAvKiBSaWdodCAqLztcbiAgICAgICAgICAgIGlmIChzaWRlID09PSA0IC8qIFJpZ2h0ICovKVxuICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIExlZnQgKi87XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICB9XG4gICAgICAgIFV0aWwuZ2V0T3Bwb3NpdGVTaWRlID0gZ2V0T3Bwb3NpdGVTaWRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhjYWxpYnVycyBkeW5hbWljYWxseSByZXNpemluZyBjb2xsZWN0aW9uXG4gICAgICAgICAqIEBjbGFzcyBDb2xsZWN0aW9uXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gW2luaXRpYWxTaXplPTIwMF0ge251bWJlcn0gSW5pdGlhbCBzaXplIG9mIHRoZSBpbnRlcm5hbCBiYWNraW5nIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgQ29sbGVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKGluaXRpYWxTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEFycmF5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gaW5pdGlhbFNpemUgfHwgQ29sbGVjdGlvbi5EZWZhdWx0U2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLmludGVybmFsQXJyYXkubGVuZ3RoICogMjtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3U2l6ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdBcnJheVtpXSA9IHRoaXMuaW50ZXJuYWxBcnJheVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJuYWxBcnJheTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQXJyYXkgPSBuZXdBcnJheTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFB1c2ggZWxlbWVudHMgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBwdXNoXG4gICAgICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCB7VH1cbiAgICAgICAgICAgICAqIEByZXR1cm5zIFRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kUG9pbnRlciA9PT0gdGhpcy5pbnRlcm5hbEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5W3RoaXMuZW5kUG9pbnRlcisrXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBwb3BcbiAgICAgICAgICAgICAqIEByZXR1cm5zIFRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kUG9pbnRlciA9IHRoaXMuZW5kUG9pbnRlciAtIDEgPCAwID8gMCA6IHRoaXMuZW5kUG9pbnRlciAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxBcnJheVt0aGlzLmVuZFBvaW50ZXJdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgY291bnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBtZXRob2QgY291bnRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRQb2ludGVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1wdGllcyB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBjbGVhclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYmFja2luZyBhcnJheVxuICAgICAgICAgICAgICogQG1ldGhvZCBpbnRlcm5hbFNpemVcbiAgICAgICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5pbnRlcm5hbFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxuICAgICAgICAgICAgICogQG1ldGhvZCBlbGVtZW50QXRcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSBJbmRleCBvZiBlbGVtZW50IHRvIHJldHJlaXZlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyBUXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVsZW1lbnRBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5W2luZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluc2VydHMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluc2VydFxuICAgICAgICAgICAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IEluZGV4IHRvIGluc2VydCB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICogQHJldHVybnMgVFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gSW5kZXggb2YgZWxlbWVudCB0byByZW1vdmVcbiAgICAgICAgICAgICAqIEByZXR1cm5zIFRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIE8obikgU2hpZnQgXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLmludGVybmFsQXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEFycmF5W2ldID0gdGhpcy5pbnRlcm5hbEFycmF5W2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRQb2ludGVyLS07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgYnkgcmVmZXJlbmNlXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50IHtUfSBJbmRleCBvZiBlbGVtZW50IHRvIHJldHJlaXZlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW50ZXJuYWxBcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBhcnJheSByZXByZXNlbnRpbmcgdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBtZXRob2QgdG9BcnJheVxuICAgICAgICAgICAgICogQHJldHVybnMgVFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxBcnJheS5zbGljZSgwLCB0aGlzLmVuZFBvaW50ZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSXRlcmF0ZSBvdmVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBtZXRob2QgZm9yRWFjaFxuICAgICAgICAgICAgICogQHBhcmFtIGZ1bmMgeyhULG51bWJlcik9PmFueX0gQ2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBlbGVtZW50IHBhc3NpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCwgcmV0dXJuZWQgdmFsdWVzIGFyZSBpZ25vcmVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHRoaXMuaW50ZXJuYWxBcnJheVtpXSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTXV0YXRlIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBtZXRob2QgbWFwXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnVuYyB7KFQsbnVtYmVyKT0+YW55fSBDYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGVsZW1lbnQgcGFzc2luZyBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBhbmQgaXRzIGluZGV4LCBhbnkgdmFsdWVzIHJldHVybmVkIG11dGF0ZSB0aGUgY29sbGVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuY291bnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEFycmF5W2ldID0gZnVuYy5jYWxsKHRoaXMsIHRoaXMuaW50ZXJuYWxBcnJheVtpXSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVmYXVsdCBjb2xsZWN0aW9uIHNpemVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBEZWZhdWx0U2l6ZSB7bnVtYmVyfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbGxlY3Rpb24uRGVmYXVsdFNpemUgPSAyMDA7XG4gICAgICAgICAgICByZXR1cm4gQ29sbGVjdGlvbjtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgVXRpbC5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcbiAgICB9KShVdGlsID0gZXguVXRpbCB8fCAoZXguVXRpbCA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEEgU3ByaXRlIGlzIG9uZSBvZiB0aGUgbWFpbiBkcmF3aW5nIHByaW1pdGl2ZXMuIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nXG4gICAgICogaW1hZ2VzIG9yIHBhcnRzIG9mIGltYWdlcyBrbm93biBhcyBUZXh0dXJlcyB0byB0aGUgc2NyZWVuLlxuICAgICAqIEBjbGFzcyBTcHJpdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gaW1hZ2Uge1RleHR1cmV9IFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZVxuICAgICAqIEBwYXJhbSBzeCB7bnVtYmVyfSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgc3ByaXRlXG4gICAgICogQHBhcmFtIHN5IHtudW1iZXJ9IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzcHJpdGVcbiAgICAgKiBAcGFyYW0gc3dpZHRoIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSBzaGVpZ2h0IHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICB2YXIgU3ByaXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3ByaXRlKGltYWdlLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc3ggPSBzeDtcbiAgICAgICAgICAgIHRoaXMuc3kgPSBzeTtcbiAgICAgICAgICAgIHRoaXMuc3dpZHRoID0gc3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5zaGVpZ2h0ID0gc2hlaWdodDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gMS4wO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSAxLjA7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMC4wO1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludCA9IG5ldyBleC5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDYW52YXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5waXhlbERhdGEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5waXhlbHNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlFZmZlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzeCA8IDAgfHwgc3kgPCAwIHx8IHN3aWR0aCA8IDAgfHwgc2hlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNwcml0ZSBjYW5ub3QgaGF2ZSBhbnkgbmVnYXRpdmUgZGltZW5zaW9ucyB4OlwiLCBzeCwgXCJ5OlwiLCBzeSwgXCJ3aWR0aDpcIiwgc3dpZHRoLCBcImhlaWdodDpcIiwgc2hlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUNhbnZhcy53aWR0aCA9IHN3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ2FudmFzLmhlaWdodCA9IHNoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUN0eCA9IHRoaXMuc3ByaXRlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUubG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNwcml0ZUNhbnZhcy53aWR0aCA9IF90aGlzLnNwcml0ZUNhbnZhcy53aWR0aCB8fCBfdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zcHJpdGVDYW52YXMuaGVpZ2h0ID0gX3RoaXMuc3ByaXRlQ2FudmFzLmhlaWdodCB8fCBfdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZFBpeGVscygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRpcnR5RWZmZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRXJyb3IgbG9hZGluZyB0ZXh0dXJlIFwiLCBfdGhpcy50ZXh0dXJlLnBhdGgsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc3dpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUubG9hZFBpeGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cmUuaXNMb2FkZWQoKSAmJiAhdGhpcy5waXhlbHNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhbXAgPSBleC5VdGlsLmNsYW1wO1xuICAgICAgICAgICAgICAgIHZhciBuYXR1cmFsV2lkdGggPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoIHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodCB8fCAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN3aWR0aCA+IG5hdHVyYWxXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhlIHNwcml0ZSB3aWR0aFwiLCB0aGlzLnN3aWR0aCwgXCJleGNlZWRzIHRoZSB3aWR0aFwiLCBuYXR1cmFsV2lkdGgsIFwib2YgdGhlIGJhY2tpbmcgdGV4dHVyZVwiLCB0aGlzLnRleHR1cmUucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoZWlnaHQgPiBuYXR1cmFsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGUgc3ByaXRlIGhlaWdodFwiLCB0aGlzLnNoZWlnaHQsIFwiZXhjZWVkcyB0aGUgaGVpZ2h0XCIsIG5hdHVyYWxIZWlnaHQsIFwib2YgdGhlIGJhY2tpbmcgdGV4dHVyZVwiLCB0aGlzLnRleHR1cmUucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQ3R4LmRyYXdJbWFnZSh0aGlzLnRleHR1cmUuaW1hZ2UsIGNsYW1wKHRoaXMuc3gsIDAsIG5hdHVyYWxXaWR0aCksIGNsYW1wKHRoaXMuc3ksIDAsIG5hdHVyYWxIZWlnaHQpLCBjbGFtcCh0aGlzLnN3aWR0aCwgMCwgbmF0dXJhbFdpZHRoKSwgY2xhbXAodGhpcy5zaGVpZ2h0LCAwLCBuYXR1cmFsSGVpZ2h0KSwgMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICAgICAgLy90aGlzLnBpeGVsRGF0YSA9IHRoaXMuc3ByaXRlQ3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsSW1hZ2Uuc3JjID0gdGhpcy5zcHJpdGVDYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGl4ZWxzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBuZXcge3sjY3Jvc3NMaW5rIEVmZmVjdHMuSVNwcml0ZUVmZmVjdH19e3svY3Jvc3NMaW5rfX0gdG8gdGhpcyBkcmF3aW5nLlxuICAgICAgICAgKiBAbWV0aG9kIGFkZEVmZmVjdFxuICAgICAgICAgKiBAcGFyYW0gZWZmZWN0IHtFZmZlY3RzLklTcHJpdGVFZmZlY3R9IEVmZmVjdCB0byBhZGQgdG8gdGhlIHRoaXMgZHJhd2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5hZGRFZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgICAgICAgICAgLy8gV2UgbXVzdCBjaGVjayBpZiB0aGUgdGV4dHVyZSBhbmQgdGhlIGJhY2tpbmcgc3ByaXRlIHBpeGVscyBhcmUgbG9hZGVkIGFzIHdlbGwgYmVmb3JlIFxuICAgICAgICAgICAgLy8gYW4gZWZmZWN0IGNhbiBiZSBhcHBsaWVkXG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dHVyZS5pc0xvYWRlZCgpIHx8ICF0aGlzLnBpeGVsc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlFZmZlY3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5yZW1vdmVFZmZlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciBpbmRleFRvUmVtb3ZlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhUb1JlbW92ZSA9IHBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXhUb1JlbW92ZSA9IHRoaXMuZWZmZWN0cy5pbmRleE9mKHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSk7XG4gICAgICAgICAgICAvLyBXZSBtdXN0IGNoZWNrIGlmIHRoZSB0ZXh0dXJlIGFuZCB0aGUgYmFja2luZyBzcHJpdGUgcGl4ZWxzIGFyZSBsb2FkZWQgYXMgd2VsbCBiZWZvcmUgXG4gICAgICAgICAgICAvLyBhbiBlZmZlY3QgY2FuIGJlIGFwcGxpZWRcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMucGl4ZWxzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eUVmZmVjdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmFwcGx5RWZmZWN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xhbXAgPSBleC5VdGlsLmNsYW1wO1xuICAgICAgICAgICAgdmFyIG5hdHVyYWxXaWR0aCA9IHRoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsV2lkdGggfHwgMDtcbiAgICAgICAgICAgIHZhciBuYXR1cmFsSGVpZ2h0ID0gdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxIZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQ3R4LmRyYXdJbWFnZSh0aGlzLnRleHR1cmUuaW1hZ2UsIGNsYW1wKHRoaXMuc3gsIDAsIG5hdHVyYWxXaWR0aCksIGNsYW1wKHRoaXMuc3ksIDAsIG5hdHVyYWxIZWlnaHQpLCBjbGFtcCh0aGlzLnN3aWR0aCwgMCwgbmF0dXJhbFdpZHRoKSwgY2xhbXAodGhpcy5zaGVpZ2h0LCAwLCBuYXR1cmFsSGVpZ2h0KSwgMCwgMCwgdGhpcy5zd2lkdGgsIHRoaXMuc2hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnBpeGVsRGF0YSA9IHRoaXMuc3ByaXRlQ3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IF90aGlzLnNoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IF90aGlzLnN3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3QudXBkYXRlUGl4ZWwoeCwgeSwgX3RoaXMucGl4ZWxEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVDdHgucHV0SW1hZ2VEYXRhKHRoaXMucGl4ZWxEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxJbWFnZS5zcmMgPSB0aGlzLnNwcml0ZUNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIGVmZmVjdHMgZnJvbSB0aGUgZHJhd2luZyBhbmQgcmV0dXJuIGl0IHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS5cbiAgICAgICAgICogQG1ldGhvZCBjbGVhckVmZmVjdHNcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuY2xlYXJFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcG9pbnQgYWJvdXQgd2hpY2ggdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBkcmF3aW5nIHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgKiB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGRyYXdpbmcuXG4gICAgICAgICAqIEBtZXRob2QgdHJhbnNmb3JtQWJvdFBvaW50XG4gICAgICAgICAqIEBwYXJhbSBwb2ludCB7UG9pbnR9IFRoZSBwb2ludCBhYm91dCB3aGljaCB0byBhcHBseSB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUudHJhbnNmb3JtQWJvdXRQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludCA9IHBvaW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgY3VycmVudCByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiBmb3IgdGhlIGRyYXdpbmcuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0Um90YXRpb25cbiAgICAgICAgICogQHBhcmFtIHJhZGlhbnMge251bWJlcn0gVGhlIHJvdGF0aW9uIHRvIGFwcGx5IHRvIHRoZSBkcmF3aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIChyYWRpYW5zKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gcmFkaWFucztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm90YXRpb24gZm9yIHRoZSBkcmF3aW5nIGluIHJhZGlhbnMuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Um90YXRpb25cbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRpb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBzY2FsZSB0cmFzZm9ybWF0aW9uIGluIHRoZSB4IGRpcmVjdGlvblxuICAgICAgICAgKiBAbWV0aG9kIHNldFNjYWxlXG4gICAgICAgICAqIEBwYXJhbSBzY2FsZSB7bnVtYmVyfSBUaGUgbWFnbml0dWRlIHRvIHNjYWxlIHRoZSBkcmF3aW5nIGluIHRoZSB4IGRpcmVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5zZXRTY2FsZVggPSBmdW5jdGlvbiAoc2NhbGVYKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHNjYWxlIHRyYXNmb3JtYXRpb24gaW4gdGhlIHggZGlyZWN0aW9uXG4gICAgICAgICAqIEBtZXRob2Qgc2V0U2NhbGVcbiAgICAgICAgICogQHBhcmFtIHNjYWxlIHtudW1iZXJ9IFRoZSBtYWduaXR1ZGUgdG8gc2NhbGUgdGhlIGRyYXdpbmcgaW4gdGhlIHggZGlyZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnNldFNjYWxlWSA9IGZ1bmN0aW9uIChzY2FsZVkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBtYWduaXR1ZGUgb2YgdGhlIGRyYXdpbmcncyBzY2FsZSBpbiB0aGUgeCBkaXJlY3Rpb25cbiAgICAgICAgICogQG1ldGhvZCBnZXRTY2FsZVxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuZ2V0U2NhbGVYID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBtYWduaXR1ZGUgb2YgdGhlIGRyYXdpbmcncyBzY2FsZSBpbiB0aGUgeSBkaXJlY3Rpb25cbiAgICAgICAgICogQG1ldGhvZCBnZXRTY2FsZVxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuZ2V0U2NhbGVZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVZO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgZHJhd2luZyAoaWYgYW55KVxuICAgICAgICAgKiBAbWV0aG9kIHJlc2V0XG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRHJhd3MgdGhlIHNwcml0ZSBhcHByb3ByaWF0ZWx5IHRvIHRoZSAyRCByZW5kZXJpbmcgY29udGV4dCwgYXQgYW4geCBhbmQgeSBjb29yZGluYXRlLlxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgMkQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn0gVGhlIHggY29vcmRpbmF0ZSBvZiB3aGVyZSB0byBkcmF3XG4gICAgICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IGNvb3JkaW5hdGUgb2Ygd2hlcmUgdG8gZHJhd1xuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHlFZmZlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlFZmZlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZsaXBIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnN3aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZsaXBWZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgdGhpcy5zaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxJbWFnZSkge1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbnRlcm5hbEltYWdlLCAwLCAwLCB0aGlzLnN3aWR0aCwgdGhpcy5zaGVpZ2h0LCAtKHRoaXMudHJhbnNmb3JtUG9pbnQueCAqIHRoaXMuc3dpZHRoKSAqIHRoaXMuc2NhbGVYLCAtKHRoaXMudHJhbnNmb3JtUG9pbnQueSAqIHRoaXMuc2hlaWdodCkgKiB0aGlzLnNjYWxlWSwgdGhpcy5zd2lkdGggKiB0aGlzLnNjYWxlWCwgdGhpcy5zaGVpZ2h0ICogdGhpcy5zY2FsZVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGEgY29weSBvZiB0aGUgY3VycmVudCBzcHJpdGVcbiAgICAgICAgICogQG1ldGhvZCBjbG9uZVxuICAgICAgICAgKiBAcmV0dXJucyBTcHJpdGVcbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFNwcml0ZSh0aGlzLnRleHR1cmUsIHRoaXMuc3gsIHRoaXMuc3ksIHRoaXMuc3dpZHRoLCB0aGlzLnNoZWlnaHQpO1xuICAgICAgICAgICAgcmVzdWx0LnNjYWxlWCA9IHRoaXMuc2NhbGVYO1xuICAgICAgICAgICAgcmVzdWx0LnNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuICAgICAgICAgICAgcmVzdWx0LnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgICAgIHJlc3VsdC5mbGlwSG9yaXpvbnRhbCA9IHRoaXMuZmxpcEhvcml6b250YWw7XG4gICAgICAgICAgICByZXN1bHQuZmxpcFZlcnRpY2FsID0gdGhpcy5mbGlwVmVydGljYWw7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRFZmZlY3QoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTcHJpdGU7XG4gICAgfSkoKTtcbiAgICBleC5TcHJpdGUgPSBTcHJpdGU7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNwcml0ZS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogU3ByaXRlU2hlZXRzIGFyZSBhIHVzZWZ1bCBtZWNoYW5pc20gZm9yIHNsaWNpbmcgdXAgaW1hZ2UgcmVzb3VyY2VzIGludG9cbiAgICAgKiBzZXBhcmF0ZSBzcHJpdGVzIG9yIGZvciBnZW5lcmF0aW5nIGluIGdhbWUgYW5pbWF0aW9ucy4gU3ByaXRlcyBhcmUgb3JnYW5pemVkXG4gICAgICogaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBTcHJpdGVTaGVldC5cbiAgICAgKiBAY2xhc3MgU3ByaXRlU2hlZXRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gaW1hZ2Uge1RleHR1cmV9IFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZVNoZWV0XG4gICAgICogQHBhcmFtIGNvbHVtbnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBpbWFnZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHJvd3Mge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBpbWFnZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHNwV2lkdGgge251bWJlcn0gVGhlIHdpZHRoIG9mIGVhY2ggaW5kaXZpZHVhbCBzcHJpdGUgaW4gcGl4ZWxzXG4gICAgICogQHBhcmFtIHNwSGVpZ2h0IHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgZWFjaCBpbmRpdmlkdWFsIHNwcml0ZSBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICB2YXIgU3ByaXRlU2hlZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTcHJpdGVTaGVldChpbWFnZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmludGVybmFsSW1hZ2UgPSBpbWFnZS5pbWFnZTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IG5ldyBBcnJheShjb2x1bW5zICogcm93cyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBJbnNwZWN0IGFjdHVhbCBpbWFnZSBkaW1lbnNpb25zIHdpdGggcHJlbG9hZGluZ1xuICAgICAgICAgICAgLyppZihzcFdpZHRoICogY29sdW1ucyA+IHRoaXMuaW50ZXJuYWxJbWFnZS5uYXR1cmFsV2lkdGgpe1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ByaXRlU2hlZXQgc3BlY2lmaWVkIGlzIHdpZGVyIHRoYW4gaW1hZ2Ugd2lkdGhcIik7XG4gICAgICAgICAgICB9XG4gICBcbiAgICAgICAgICAgIGlmKHNwSGVpZ2h0ICogcm93cyA+IHRoaXMuaW50ZXJuYWxJbWFnZS5uYXR1cmFsSGVpZ2h0KXtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNwcml0ZVNoZWV0IHNwZWNpZmllZCBpcyBoaWdoZXIgdGhhbiBpbWFnZSBoZWlnaHRcIik7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tqICsgaSAqIGNvbHVtbnNdID0gbmV3IGV4LlNwcml0ZSh0aGlzLmltYWdlLCBqICogc3BXaWR0aCwgaSAqIHNwSGVpZ2h0LCBzcFdpZHRoLCBzcEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gYW5pbWF0aW9uIGZyb20gdGhlIHRoaXMgU3ByaXRlU2hlZXQgYnkgbGlzdGluZyBvdXQgdGhlXG4gICAgICAgICAqIHNwcml0ZSBpbmRpY2VzLiBTcHJpdGVzIGFyZSBvcmdhbml6ZWQgaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBTcHJpdGVTaGVldC5cbiAgICAgICAgICogQG1ldGhvZCBnZXRBbmltYXRpb25CeUluZGljZXNcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBFbmdpbmVcbiAgICAgICAgICogQHBhcmFtIGluZGljZXMge251bWJlcltdfSBBbiBhcnJheSBvZiBzcHJpdGUgaW5kaWNlcyB0byB1c2UgaW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQge251bWJlcn0gVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogQHJldHVybnMgQW5pbWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGVTaGVldC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uQnlJbmRpY2VzID0gZnVuY3Rpb24gKGVuZ2luZSwgaW5kaWNlcywgc3BlZWQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW1hZ2VzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNwcml0ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbWFnZXMgPSBpbWFnZXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5BbmltYXRpb24oZW5naW5lLCBpbWFnZXMsIHNwZWVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbiBhbmltYXRpb24gZnJvbSB0aGUgdGhpcyBTcHJpdGVTaGVldCBieSBzcGVjaWZpbmcgdGhlIHJhbmdlIG9mXG4gICAgICAgICAqIGltYWdlcyB3aXRoIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBpbmRleFxuICAgICAgICAgKiBAbWV0aG9kIGdldEFuaW1hdGlvbkJldHdlZW5cbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBFbmdpbmVcbiAgICAgICAgICogQHBhcmFtIGJlZ2luSW5kZXgge251bWJlcn0gVGhlIGluZGV4IHRvIHN0YXJ0IHRha2luZyBmcmFtZXNcbiAgICAgICAgICogQHBhcmFtIGVuZEluZGV4IHtudW1iZXJ9IFRoZSBpbmRleCB0byBzdG9wIHRha2luZyBmcmFtZXNcbiAgICAgICAgICogQHBhcmFtIHNwZWVkIHtudW1iZXJ9IFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIEFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlU2hlZXQucHJvdG90eXBlLmdldEFuaW1hdGlvbkJldHdlZW4gPSBmdW5jdGlvbiAoZW5naW5lLCBiZWdpbkluZGV4LCBlbmRJbmRleCwgc3BlZWQpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSB0aGlzLnNwcml0ZXMuc2xpY2UoYmVnaW5JbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICAgICAgaW1hZ2VzID0gaW1hZ2VzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguQW5pbWF0aW9uKGVuZ2luZSwgaW1hZ2VzLCBzcGVlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmVhdCB0aGUgZW50aXJlIFNwcml0ZVNoZWV0IGFzIG9uZSBhbmltYXRpb24sIG9yZ2FuaXppbmcgdGhlIGZyYW1lcyBpblxuICAgICAgICAgKiByb3cgbWFqb3Igb3JkZXIuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uRm9yQWxsXG4gICAgICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgRW5naW5lXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBBbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIFNwcml0ZVNoZWV0LnByb3RvdHlwZS5nZXRBbmltYXRpb25Gb3JBbGwgPSBmdW5jdGlvbiAoZW5naW5lLCBzcGVlZCkge1xuICAgICAgICAgICAgdmFyIHNwcml0ZXMgPSB0aGlzLnNwcml0ZXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5BbmltYXRpb24oZW5naW5lLCBzcHJpdGVzLCBzcGVlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyZWl2ZSBhIHNwZWNpZmljIHNwcml0ZSBmcm9tIHRoZSBTcHJpdGVTaGVldCBieSBpdHMgaW5kZXguIFNwcml0ZXMgYXJlIG9yZ2FuaXplZFxuICAgICAgICAgKiBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFNwcml0ZVNoZWV0LlxuICAgICAgICAgKiBAbWV0aG9kIGdldFNwcml0ZVxuICAgICAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBzcHJpdGVcbiAgICAgICAgICogQHJldHVybnMgU3ByaXRlXG4gICAgICAgICAqL1xuICAgICAgICBTcHJpdGVTaGVldC5wcm90b3R5cGUuZ2V0U3ByaXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGVzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNwcml0ZVNoZWV0O1xuICAgIH0pKCk7XG4gICAgZXguU3ByaXRlU2hlZXQgPSBTcHJpdGVTaGVldDtcbiAgICAvKipcbiAgICAgKiBTcHJpdGVGb250cyBhcmUgYSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSB7eyNjcm9zc0xpbmsgTGFiZWx9fXt7L2Nyb3NzTGlua319IHRvIHNwZWNpZnlcbiAgICAgKiBhIHBhcnRpY3VsYXIgYml0bWFwIGFzIGEgZm9udC5cbiAgICAgKiBAY2xhc3MgU3ByaXRlRm9udFxuICAgICAqIEBleHRlbmRzIFNwcml0ZVNoZWV0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGltYWdlIHtUZXh0dXJlfSBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVGb250XG4gICAgICogQHBhcmFtIGFscGhhYmV0IHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgdGhlIGNoYXJhdGVycyBpbiB0aGUgaW1hZ2UsIGluIHJvdyBtYWpvciBvcmRlci5cbiAgICAgKiBAcGFyYW0gY2FzZUluc2Vuc2l0dmUge2Jvb2xlYW59IEluZGljYXRlIHdoZXRoZXIgdGhpcyBmb250IHRha2VzIGNhc2UgaW50byBhY2NvdW50XG4gICAgICogQHBhcmFtIGNvbHVtbnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2x1bW5zIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHJvd3Mge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHNwV2RpdGgge251bWJlcn0gVGhlIHdpZHRoIG9mIGVhY2ggY2hhcmFjdGVyIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSBzcEhlaWdodCB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIGVhY2ggY2hhcmFjdGVyIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHZhciBTcHJpdGVGb250ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFNwcml0ZUZvbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNwcml0ZUZvbnQoaW1hZ2UsIGFscGhhYmV0LCBjYXNlSW5zZW5zaXRpdmUsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBpbWFnZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0O1xuICAgICAgICAgICAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSBjYXNlSW5zZW5zaXRpdmU7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUxvb2t1cCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jb2xvckxvb2t1cCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gZXguQ29sb3IuQmxhY2s7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBkaWN0aW9uYXJ5IHRoYXQgbWFwcyBlYWNoIGNoYXJhY3RlciBpbiB0aGUgYWxwaGFiZXQgdG8gdGhlIGFwcHJvcHJpYXRlIFNwcml0ZS5cbiAgICAgICAgICogQG1ldGhvZCBnZXRUZXh0U3ByaXRlc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgU3ByaXRlRm9udC5wcm90b3R5cGUuZ2V0VGV4dFNwcml0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuYWxwaGFiZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvb2t1cFtjaGFyXSA9IHRoaXMuc3ByaXRlc1tpXS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNwcml0ZUZvbnQ7XG4gICAgfSkoU3ByaXRlU2hlZXQpO1xuICAgIGV4LlNwcml0ZUZvbnQgPSBTcHJpdGVGb250O1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFbmdpbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNwcml0ZVNoZWV0LnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgVGlsZVNwcml0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRpbGVTcHJpdGUoc3ByaXRlU2hlZXRLZXksIHNwcml0ZUlkKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZVNoZWV0S2V5ID0gc3ByaXRlU2hlZXRLZXk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUlkID0gc3ByaXRlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRpbGVTcHJpdGU7XG4gICAgfSkoKTtcbiAgICBleC5UaWxlU3ByaXRlID0gVGlsZVNwcml0ZTtcbiAgICAvKipcbiAgICAgKiBBIGxpZ2h0LXdlaWdodCBvYmplY3QgdGhhdCBvY2N1cGllcyBhIHNwYWNlIGluIGEgY29sbGlzaW9uIG1hcC4gR2VuZXJhbGx5XG4gICAgICogY3JlYXRlZCBieSBhIENvbGxpc2lvbk1hcC5cbiAgICAgKiBAY2xhc3MgQ2VsbFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHkge251bWJlcn1cbiAgICAgKiBAcGFyYW0gd2lkdGgge251bWJlcn1cbiAgICAgKiBAcGFyYW0gaGVpZ2h0IHtudW1iZXJ9XG4gICAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9XG4gICAgICogQHBhcmFtIFtzb2xpZD1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICogQHBhcmFtIFtzcHJpdGVJZD0tMV0ge251bWJlcn1cbiAgICAgKi9cbiAgICB2YXIgQ2VsbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENlbGwoXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHgsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgeSBjb29yZGluYXRlIG9mIHRoZSBjZWxsIGluIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgeSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB5LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSB3aWR0aCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHdpZHRoIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHdpZHRoLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBoZWlnaHQge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaGVpZ2h0LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBjZWxsIGluIHJvdyBtYWpvciBvcmRlclxuICAgICAgICAgICAgICogQHByb3BlcnR5IGluZGV4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluZGV4LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhpcyBjZWxsIGlzIHNvbGlkXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgc29saWQge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNvbGlkLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBzcHJpdGUgdG8gdXNlIGZyb20gdGhlIENvbGxpc2lvbk1hcCBTcHJpdGVTaGVldCwgaWYgLTEgaXMgc3BlY2lmaWVkIG5vdGhpbmcgaXMgZHJhd24uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgbnVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNwcml0ZXMpIHtcbiAgICAgICAgICAgIGlmIChzb2xpZCA9PT0gdm9pZCAwKSB7IHNvbGlkID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChzcHJpdGVzID09PSB2b2lkIDApIHsgc3ByaXRlcyA9IFtdOyB9XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5zb2xpZCA9IHNvbGlkO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzID0gc3ByaXRlcztcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBleC5Cb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSwgdGhpcy54ICsgdGhpcy53aWR0aCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIHRoaXMgY2VsbFxuICAgICAgICAgKiBAbWV0aG9kIGdldEJvdW5kc1xuICAgICAgICAgKiBAcmV0dXJucyBCb3VuZGluZ0JveFxuICAgICAgICAgKi9cbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgICAgICAgfTtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5WZWN0b3IodGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMik7XG4gICAgICAgIH07XG4gICAgICAgIENlbGwucHJvdG90eXBlLnB1c2hTcHJpdGUgPSBmdW5jdGlvbiAodGlsZVNwcml0ZSkge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzLnB1c2godGlsZVNwcml0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIENlbGwucHJvdG90eXBlLnJlbW92ZVNwcml0ZSA9IGZ1bmN0aW9uICh0aWxlU3ByaXRlKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGlmICgoaW5kZXggPSB0aGlzLnNwcml0ZXMuaW5kZXhPZih0aWxlU3ByaXRlKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5jbGVhclNwcml0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENlbGw7XG4gICAgfSkoKTtcbiAgICBleC5DZWxsID0gQ2VsbDtcbiAgICAvKipcbiAgICAgKiBUaGUgQ29sbGlzaW9uTWFwIG9iamVjdCBwcm92aWRlcyBhIGxpZ2h0d2VpZ2h0IHdheSB0byBkbyBsYXJnZSBjb21wbGV4IHNjZW5lcyB3aXRoIGNvbGxpc2lvblxuICAgICAqIHdpdGhvdXQgdGhlIG92ZXJoZWFkIG9mIGFjdG9ycy5cbiAgICAgKiBAY2xhc3MgQ29sbGlzaW9uTWFwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHgge251bWJlcn0gVGhlIHggY29vcmRpbmF0ZSB0byBhbmNob3IgdGhlIGNvbGxpc2lvbiBtYXAncyB1cHBlciBsZWZ0IGNvcm5lciAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSB5IHtudW1iZXJ9IFRoZSB5IGNvb3JkaW5hdGUgdG8gYW5jaG9yIHRoZSBjb2xsaXNpb24gbWFwJ3MgdXBwZXIgbGVmdCBjb3JuZXIgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcbiAgICAgKiBAcGFyYW0gY2VsbFdpZHRoIHtudW1iZXJ9IFRoZSBpbmRpdmlkdWFsIHdpZHRoIG9mIGVhY2ggY2VsbCAoaW4gcGl4ZWxzKSAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxuICAgICAqIEBwYXJhbSBjZWxsSGVpZ2h0IHtudW1iZXJ9IFRoZSBpbmRpdmlkdWFsIGhlaWdodCBvZiBlYWNoIGNlbGwgKGluIHBpeGVscykgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcbiAgICAgKiBAcGFyYW0gcm93cyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGNvbGxpc2lvbiBtYXAgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcbiAgICAgKiBAcGFyYW0gY29scyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHMgaW4gdGhlIGNvbGxpc2lvbiBtYXAgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcbiAgICAgKiBAcGFyYW0gc3ByaXRlU2hlZXQge1Nwcml0ZVNoZWV0fSBUaGUgc3ByaXRlU2hlZXQgdG8gdXNlIGZvciBkcmF3aW5nXG4gICAgICovXG4gICAgdmFyIFRpbGVNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUaWxlTWFwKHgsIHksIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcm93cywgY29scykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgdGhpcy5jZWxsV2lkdGggPSBjZWxsV2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNlbGxIZWlnaHQgPSBjZWxsSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5yb3dzID0gcm93cztcbiAgICAgICAgICAgIHRoaXMuY29scyA9IGNvbHM7XG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRpbmdYID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRpbmdZID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlblhTdGFydCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlblhFbmQgPSA5OTk5O1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5ZU3RhcnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5ZRW5kID0gOTk5OTtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEFycmF5KHJvd3MgKiBjb2xzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3dzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZCA9IG5ldyBDZWxsKGkgKiBjZWxsV2lkdGggKyB4LCBqICogY2VsbEhlaWdodCArIHksIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgaSArIGogKiBjb2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRhdGFbaSArIGogKiBjb2xzXSA9IGNkO1xuICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5yZWdpc3RlclNwcml0ZVNoZWV0ID0gZnVuY3Rpb24gKGtleSwgc3ByaXRlU2hlZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0c1trZXldID0gc3ByaXRlU2hlZXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbnRlc2VjdGlvbiB2ZWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNvbHZlIGNvbGxpc2lvbnMgd2l0aCBhY3RvcnMuIElmIHRoZXJlXG4gICAgICAgICAqIGlzIG5vIGNvbGxpc2lvbiBudWxsIGlzIHJldHVybmVkLlxuICAgICAgICAgKiBAbWV0aG9kIGNvbGxpZGVzXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9XG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgVGlsZU1hcC5wcm90b3R5cGUuY29sbGlkZXMgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGFjdG9yLnggKyBhY3Rvci5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFjdG9yLnkgKyBhY3Rvci5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIHZhciBhY3RvckJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gYWN0b3JCb3VuZHMubGVmdDsgeCA8PSB3aWR0aDsgeCArPSBNYXRoLm1pbihhY3Rvci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5jZWxsV2lkdGggLyAyKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSBhY3RvckJvdW5kcy50b3A7IHkgPD0gaGVpZ2h0OyB5ICs9IE1hdGgubWluKGFjdG9yLmdldEhlaWdodCgpIC8gMiwgdGhpcy5jZWxsSGVpZ2h0IC8gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldENlbGxCeVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCAmJiBjZWxsLnNvbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcCA9IGFjdG9yQm91bmRzLmNvbGxpZGVzKGNlbGwuZ2V0Qm91bmRzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IGFjdG9yLmdldENlbnRlcigpLm1pbnVzKGNlbGwuZ2V0Q2VudGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgJiYgb3ZlcmxhcC5kb3QoZGlyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwcy5wdXNoKG92ZXJsYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJsYXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzbWFsbGVzdCBjaGFuZ2Ugb3RoZXIgdGhhbiB6ZXJvXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3ZlcmxhcHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgbmV4dCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gYWNjdW0ueDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGFjY3VtLnk7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGFjY3VtLngpIDwgTWF0aC5hYnMobmV4dC54KSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbmV4dC54O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYWNjdW0ueSkgPCBNYXRoLmFicyhuZXh0LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBuZXh0Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXguVmVjdG9yKHgsIHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICAvKlxuICAgICAgICBwdWJsaWMgY29sbGlkZXNBY3RvcihhY3RvcjogQWN0b3IpOiBib29sZWFue1xuICAgICAgICAgICBcbiAgICAgICAgICAgdmFyIHBvaW50czogUG9pbnRbXSA9IFtdO1xuICAgICAgICAgICB2YXIgd2lkdGggPSBhY3Rvci54ICsgYWN0b3IuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgdmFyIGhlaWdodCA9IGFjdG9yLnkgKyBhY3Rvci5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgZm9yKHZhciB4ID0gYWN0b3IueDsgeCA8PSB3aWR0aDsgeCArPSBNYXRoLm1pbihhY3Rvci5nZXRXaWR0aCgpLzIsdGhpcy5jZWxsV2lkdGgvMikpe1xuICAgICAgICAgICAgICBmb3IodmFyIHkgPSBhY3Rvci55OyB5IDw9IGhlaWdodDsgeSArPSBNYXRoLm1pbihhY3Rvci5nZXRIZWlnaHQoKS8yLCB0aGlzLmNlbGxIZWlnaHQvMikpe1xuICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChuZXcgUG9pbnQoeCx5KSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICB2YXIgcmVzdWx0ID0gcG9pbnRzLnNvbWUoKHApID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXNQb2ludChwLngsIHAueSk7XG4gICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgXG4gICAgICAgIH0qL1xuICAgICAgICAvKlxuICAgICAgICBwdWJsaWMgY29sbGlkZXNQb2ludCh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW57XG4gICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcih4L3RoaXMuY2VsbFdpZHRoKTsvLyAtIE1hdGguZmxvb3IodGhpcy54L3RoaXMuY2VsbFdpZHRoKTtcbiAgICAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKHkvdGhpcy5jZWxsSGVpZ2h0KTtcbiAgXG4gIFxuICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0Q2VsbCh4LCB5KTtcbiAgICAgICAgICAgaWYoeCA+PSAwICYmIHkgPj0gMCAmJiB4IDwgdGhpcy5jb2xzICYmIHkgPCB0aGlzLnJvd3MgJiYgY2VsbCl7XG4gICAgICAgICAgICAgIGlmKGNlbGwuc29saWQpe1xuICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaWRpbmdYID0geDtcbiAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkaW5nWSA9IHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuc29saWQ7XG4gICAgICAgICAgIH1cbiAgXG4gIFxuICBcbiAgICAgICAgICAgXG4gICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjZWxsIGJ5IGluZGV4IChyb3cgbWFqb3Igb3JkZXIpXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Q2VsbEJ5SW5kZXhcbiAgICAgICAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9XG4gICAgICAgICAqIEByZXR1cm5zIENlbGxcbiAgICAgICAgICovXG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLmdldENlbGxCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNlbGwgYnkgaXQncyB4IGFuZCB5IGNvb3JkaW5hdGVzXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Q2VsbFxuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfVxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfVxuICAgICAgICAgKiBAcmV0dXJucyBDZWxsXG4gICAgICAgICAqL1xuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5nZXRDZWxsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IHRoaXMuY29scyB8fCB5ID49IHRoaXMucm93cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt4ICsgeSAqIHRoaXMuY29sc107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjZWxsIGJ5IHRlc3RpbmcgYSBwb2ludCBpbiBnbG9iYWwgY29vcmRpbmF0ZXMsXG4gICAgICAgICAqIHJldHVybnMgbnVsbCBpZiBubyBjZWxsIHdhcyBmb3VuZC5cbiAgICAgICAgICogQG1ldGhvZCBnZXRDZWxsQnlQb2ludFxuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfVxuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfVxuICAgICAgICAgKiBAcmV0dXJucyBDZWxsXG4gICAgICAgICAqL1xuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5nZXRDZWxsQnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoKHggLSB0aGlzLngpIC8gdGhpcy5jZWxsV2lkdGgpOyAvLyAtIE1hdGguZmxvb3IodGhpcy54L3RoaXMuY2VsbFdpZHRoKTtcbiAgICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcigoeSAtIHRoaXMueSkgLyB0aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldENlbGwoeCwgeSk7XG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHkgPj0gMCAmJiB4IDwgdGhpcy5jb2xzICYmIHkgPCB0aGlzLnJvd3MgJiYgY2VsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFRpbGVNYXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgd29ybGRDb29yZHNVcHBlckxlZnQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBleC5Qb2ludCgwLCAwKSk7XG4gICAgICAgICAgICB2YXIgd29ybGRDb29yZHNMb3dlclJpZ2h0ID0gZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgZXguUG9pbnQoZW5naW5lLndpZHRoLCBlbmdpbmUuaGVpZ2h0KSk7XG4gICAgICAgICAgICB0aGlzLl9vblNjcmVlblhTdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3Iod29ybGRDb29yZHNVcHBlckxlZnQueCAvIHRoaXMuY2VsbFdpZHRoKSAtIDIsIDApO1xuICAgICAgICAgICAgdGhpcy5fb25TY3JlZW5ZU3RhcnQgPSBNYXRoLm1heChNYXRoLmZsb29yKCh3b3JsZENvb3Jkc1VwcGVyTGVmdC55IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCkgLSAyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWEVuZCA9IE1hdGgubWF4KE1hdGguZmxvb3Iod29ybGRDb29yZHNMb3dlclJpZ2h0LnggLyB0aGlzLmNlbGxXaWR0aCkgKyAyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX29uU2NyZWVuWUVuZCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzTG93ZXJSaWdodC55IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCkgKyAyLCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIHRoZSBjb2xsaXNpb24gbWFwIHRvIHRoZSBzY3JlZW4uIENhbGxlZCBieSB0aGUgU2NlbmUuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCBkcmF3XG4gICAgICAgICAqL1xuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gdGhpcy5fb25TY3JlZW5YU3RhcnQ7IHggPCBNYXRoLm1pbih0aGlzLl9vblNjcmVlblhFbmQsIHRoaXMuY29scyk7IHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSB0aGlzLl9vblNjcmVlbllTdGFydDsgeSA8IE1hdGgubWluKHRoaXMuX29uU2NyZWVuWUVuZCwgdGhpcy5yb3dzKTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2VsbCh4LCB5KS5zcHJpdGVzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuc3ByaXRlSWQgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAodHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcyA9IF90aGlzLl9zcHJpdGVTaGVldHNbdHMuc3ByaXRlU2hlZXRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNzLmdldFNwcml0ZSh0cy5zcHJpdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuZHJhdyhjdHgsIHggKiBfdGhpcy5jZWxsV2lkdGgsIHkgKiBfdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiU3ByaXRlIGRvZXMgbm90IGV4aXN0IGZvciBpZFwiLCB0cy5zcHJpdGVJZCwgXCJpbiBzcHJpdGUgc2hlZXRcIiwgdHMuc3ByaXRlU2hlZXRLZXksIHNwcml0ZSwgc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiU3ByaXRlIHNoZWV0XCIsIHRzLnNwcml0ZVNoZWV0S2V5LCBcImRvZXMgbm90IGV4aXN0XCIsIHNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIGFsbCB0aGUgY29sbGlzaW9uIG1hcCdzIGRlYnVnIGluZm8uIENhbGxlZCBieSB0aGUgU2NlbmUuXG4gICAgICAgICAqIEBtZXRob2QgZHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBUaWxlTWFwLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNvbHMgKiB0aGlzLmNlbGxXaWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnJvd3MgKiB0aGlzLmNlbGxIZWlnaHQ7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZXguQ29sb3IuUmVkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuY29scyArIDE7IHgrKykge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMueCArIHggKiB0aGlzLmNlbGxXaWR0aCwgdGhpcy55KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRoaXMueCArIHggKiB0aGlzLmNlbGxXaWR0aCwgdGhpcy55ICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHRoaXMucm93cyArIDE7IHkrKykge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMueCwgdGhpcy55ICsgeSAqIHRoaXMuY2VsbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnggKyB3aWR0aCwgdGhpcy55ICsgeSAqIHRoaXMuY2VsbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvbGlkID0gZXguQ29sb3IuUmVkLmNsb25lKCk7XG4gICAgICAgICAgICBzb2xpZC5hID0gLjM7XG4gICAgICAgICAgICB0aGlzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuc29saWQ7XG4gICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHNvbGlkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGNlbGwueCwgY2VsbC55LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsaWRpbmdZID4gLTEgJiYgdGhpcy5fY29sbGlkaW5nWCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGV4LkNvbG9yLkN5YW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QodGhpcy54ICsgdGhpcy5fY29sbGlkaW5nWCAqIHRoaXMuY2VsbFdpZHRoLCB0aGlzLnkgKyB0aGlzLl9jb2xsaWRpbmdZICogdGhpcy5jZWxsSGVpZ2h0LCB0aGlzLmNlbGxXaWR0aCwgdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUaWxlTWFwO1xuICAgIH0pKCk7XG4gICAgZXguVGlsZU1hcCA9IFRpbGVNYXA7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0FsZ2VicmEudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIChmdW5jdGlvbiAoQ29sbGlzaW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgQ29sbGlzaW9uU3RyYXRlZ3lbQ29sbGlzaW9uU3RyYXRlZ3lbXCJOYWl2ZVwiXSA9IDBdID0gXCJOYWl2ZVwiO1xuICAgICAgICBDb2xsaXNpb25TdHJhdGVneVtDb2xsaXNpb25TdHJhdGVneVtcIkR5bmFtaWNBQUJCVHJlZVwiXSA9IDFdID0gXCJEeW5hbWljQUFCQlRyZWVcIjtcbiAgICAgICAgQ29sbGlzaW9uU3RyYXRlZ3lbQ29sbGlzaW9uU3RyYXRlZ3lbXCJTZXBhcmF0aW5nQXhpc1wiXSA9IDJdID0gXCJTZXBhcmF0aW5nQXhpc1wiO1xuICAgIH0pKGV4LkNvbGxpc2lvblN0cmF0ZWd5IHx8IChleC5Db2xsaXNpb25TdHJhdGVneSA9IHt9KSk7XG4gICAgdmFyIENvbGxpc2lvblN0cmF0ZWd5ID0gZXguQ29sbGlzaW9uU3RyYXRlZ3k7XG4gICAgLyoqXG4gICAgICogQXhpcyBBbGlnbmVkIGNvbGxpc2lvbiBwcmltaXRpdmUgZm9yIEV4Y2FsaWJ1ci5cbiAgICAgKiBAY2xhc3MgQm91bmRpbmdCb3hcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gbGVmdCB7bnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgZWRnZVxuICAgICAqIEBwYXJhbSB0b3Age251bWJlcn0geSBjb29yZGluYXRlIG9mIHRoZSB0b3AgZWRnZVxuICAgICAqIEBwYXJhbSByaWdodCB7bnVtYmVyfSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGVkZ2VcbiAgICAgKiBAcGFyYW0gYm90dG9tIHtudW1iZXJ9IHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIGVkZ2VcbiAgICAgKi9cbiAgICB2YXIgQm91bmRpbmdCb3ggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCb3VuZGluZ0JveChsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSB2b2lkIDApIHsgbGVmdCA9IDA7IH1cbiAgICAgICAgICAgIGlmICh0b3AgPT09IHZvaWQgMCkgeyB0b3AgPSAwOyB9XG4gICAgICAgICAgICBpZiAocmlnaHQgPT09IHZvaWQgMCkgeyByaWdodCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChib3R0b20gPT09IHZvaWQgMCkgeyBib3R0b20gPSAwOyB9XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCB3aWR0aCBvZiB0aGUgYm91bmRpbmcgYm94XG4gICAgICAgICAqIEBtZXRob2QgZ2V0V2lkdGhcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodCAtIHRoaXMubGVmdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNhbGN1bGF0ZWQgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAgICAgICogQG1ldGhvZCBnZXRIZWlnaHRcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwZXJpbWV0ZXIgb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgICAgICAgKiBAbWV0aG9kIGdldFBlcmltZXRlclxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRQZXJpbWV0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd3ggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgICAgICB2YXIgd3kgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuIDIgKiAod3ggKyB3eSk7XG4gICAgICAgIH07XG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBleC5Qb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5sZWZ0IDw9IHZhbC54ICYmIHRoaXMudG9wIDw9IHZhbC55ICYmIHRoaXMuYm90dG9tID49IHZhbC55ICYmIHRoaXMucmlnaHQgPj0gdmFsLngpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0IDwgdmFsLmxlZnQgJiYgdGhpcy50b3AgPCB2YWwudG9wICYmIHZhbC5ib3R0b20gPCB0aGlzLmJvdHRvbSAmJiB2YWwucmlnaHQgPCB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21iaW5lcyB0aGlzIGJvdW5kaW5nIGJveCBhbmQgYW5vdGhlciB0b2dldGhlciByZXR1cm5pbmcgYSBuZXcgYm91bmRpbmcgYm94XG4gICAgICAgICAqIEBtZXRob2QgY29tYmluZVxuICAgICAgICAgKiBAcGFyYW0gb3RoZXIge0JvdW5kaW5nQm94fSBUaGUgYm91bmRpbmcgYm94IHRvIGNvbWJpbmVcbiAgICAgICAgICogQHJldHVybnMgQm91bmRpbmdCb3hcbiAgICAgICAgICovXG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9zaXRlQkIgPSBuZXcgQm91bmRpbmdCb3goTWF0aC5taW4odGhpcy5sZWZ0LCBvdGhlci5sZWZ0KSwgTWF0aC5taW4odGhpcy50b3AsIG90aGVyLnRvcCksIE1hdGgubWF4KHRoaXMucmlnaHQsIG90aGVyLnJpZ2h0KSwgTWF0aC5tYXgodGhpcy5ib3R0b20sIG90aGVyLmJvdHRvbSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUJCO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB3ZXRoZXIgdGhpcyBib3VuZGluZyBib3ggY29sbGlkZXMgd2l0aCBhbm90aGVyIHJldHVybmluZyxcbiAgICAgICAgICogdGhlIGludGVyc2VjdGlvbiB2ZWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNvdmxlIHRoZSBjb2xsaXNpb24uIElmIHRoZXJlXG4gICAgICAgICAqIGlzIG5vIGNvbGxpc2lvbiBudWxsIGlzIHJldHVybmVkLlxuICAgICAgICAgKiBAbWV0aG9kIGNvbGxpZGVzXG4gICAgICAgICAqIEBwYXJhbSBjb2xsaWRhYmxlIHtJQ29sbGlkYWJsZX0gT3RoZXIgY29sbGlkYWJsZSB0byB0ZXN0XG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGNvbGxpZGFibGUpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaWRhYmxlIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjb2xsaWRhYmxlO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbEJvdW5kaW5nQm94ID0gdGhpcy5jb21iaW5lKG90aGVyKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgYm91bmRpbmcgYm94IGlzIGxlc3MgdGhhbiB0aGUgc3VtIG9mIHRoZSAyIGJvdW5kcyB0aGVuIHRoZXJlIGlzIGNvbGxpc2lvblxuICAgICAgICAgICAgICAgIGlmICh0b3RhbEJvdW5kaW5nQm94LmdldFdpZHRoKCkgPCBvdGhlci5nZXRXaWR0aCgpICsgdGhpcy5nZXRXaWR0aCgpICYmIHRvdGFsQm91bmRpbmdCb3guZ2V0SGVpZ2h0KCkgPCBvdGhlci5nZXRIZWlnaHQoKSArIHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29sbGlzaW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwWCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID49IG90aGVyLmxlZnQgJiYgdGhpcy5yaWdodCA8PSBvdGhlci5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5sZWZ0IC0gdGhpcy5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBYID0gb3RoZXIucmlnaHQgLSB0aGlzLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudG9wIDw9IG90aGVyLmJvdHRvbSAmJiB0aGlzLnRvcCA+PSBvdGhlci50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gb3RoZXIuYm90dG9tIC0gdGhpcy50b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLnRvcCAtIHRoaXMuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhvdmVybGFwWCkgPCBNYXRoLmFicyhvdmVybGFwWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXguVmVjdG9yKG92ZXJsYXBYLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXguVmVjdG9yKDAsIG92ZXJsYXBZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveDtcbiAgICB9KSgpO1xuICAgIGV4LkJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3g7XG4gICAgdmFyIFNBVEJvdW5kaW5nQm94ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU0FUQm91bmRpbmdCb3gocG9pbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRvVmVjdG9yKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRTaWRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChuZXcgZXguTGluZSh0aGlzLl9wb2ludHNbaV0sIHRoaXMuX3BvaW50c1soaSArIDEpICUgbGVuXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgICAgICB9O1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGVzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBheGVzLnB1c2godGhpcy5fcG9pbnRzW2ldLm1pbnVzKHRoaXMuX3BvaW50c1soaSArIDEpICUgbGVuXSkubm9ybWFsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF4ZXM7XG4gICAgICAgIH07XG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBzY2FsYXJzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzY2FsYXJzLnB1c2godGhpcy5fcG9pbnRzW2ldLmRvdChheGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGV4LlByb2plY3Rpb24oTWF0aC5taW4uYXBwbHkoTWF0aCwgc2NhbGFycyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjYWxhcnMpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNhbGN1bGF0ZWQgd2lkdGggb2YgdGhlIGJvdW5kaW5nIGJveCwgYnkgZ2VuZXJhdGluZyBhbiBheGlzIGFsaWduZWQgYm94IGFyb3VuZCB0aGUgY3VycmVudFxuICAgICAgICAgKiBAbWV0aG9kIGdldFdpZHRoXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgcCwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGFjY3VtLCBwLngpO1xuICAgICAgICAgICAgfSwgSW5maW5pdHkpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHAsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChhY2N1bSwgcC54KTtcbiAgICAgICAgICAgIH0sIC1JbmZpbml0eSk7XG4gICAgICAgICAgICByZXR1cm4gcmlnaHQgLSBsZWZ0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveCwgYnkgZ2VuZXJhdGluZyBhbiBheGlzIGFsaWduZWQgYm94IGFyb3VuZCB0aGUgY3VycmVudFxuICAgICAgICAgKiBAbWV0aG9kIGdldEhlaWdodFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5fcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHAsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihhY2N1bSwgcC55KTtcbiAgICAgICAgICAgIH0sIEluZmluaXR5KTtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSB0aGlzLl9wb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgcCwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGFjY3VtLCBwLnkpO1xuICAgICAgICAgICAgfSwgLUluZmluaXR5KTtcbiAgICAgICAgICAgIHJldHVybiB0b3AgLSBib3R0b207XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyB3ZXRoZXIgYSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIHRoZSBib3VuZGluZyBib3gsIHVzaW5nIHRoZSBQSVAgYWxnb3JpdGhtXG4gICAgICAgICAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9pbnRfaW5fcG9seWdvblxuICAgICAgICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAgICAgICAqIEBwYXJhbSBwIHtQb2ludH0gVGhlIHBvaW50IHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgU0FUQm91bmRpbmdCb3gucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjYXN0IHRvIHRoZSByaWdodCwgYXMgbG9uZyBhcyB3ZSBjYXN0IGluIGEgY29uc2l0ZW50IGZpeGVkIGRpcmVjdGlvbiB3ZVxuICAgICAgICAgICAgLy8gd2lsbCBiZSBmaW5lXG4gICAgICAgICAgICB2YXIgdGVzdFJheSA9IG5ldyBleC5SYXkocCwgbmV3IGV4LlZlY3RvcigxLCAwKSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0Q291bnQgPSB0aGlzLmdldFNpZGVzKCkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgc2lkZSwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RSYXkuaW50ZXJzZWN0KHNpZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0Q291bnQgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIFNBVEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb2xsaWRlcyA9IGZ1bmN0aW9uIChjb2xsaWRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoY29sbGlkYWJsZSBpbnN0YW5jZW9mIFNBVEJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY29sbGlkYWJsZTtcbiAgICAgICAgICAgICAgICB2YXIgYXhlcyA9IHRoaXMuZ2V0QXhlcygpO1xuICAgICAgICAgICAgICAgIGF4ZXMgPSBvdGhlci5nZXRBeGVzKCkuY29uY2F0KGF4ZXMpO1xuICAgICAgICAgICAgICAgIHZhciBtaW5PdmVybGFwID0gOTk5OTk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkF4aXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvajEgPSB0aGlzLnByb2plY3QoYXhlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9qMiA9IG90aGVyLnByb2plY3QoYXhlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVybGFwID0gcHJvajEuZ2V0T3ZlcmxhcChwcm9qMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwIDw9IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5BeGlzID0gYXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWluQXhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWluQXhpcy5ub3JtYWxpemUoKS5zY2FsZShtaW5PdmVybGFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBTQVRCb3VuZGluZ0JveC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHN1cHBsaWVkIHBvaW50cyBhbmQgY29udHJ1Y3QgYSAncG9seWdvbidcbiAgICAgICAgICAgIHZhciBmaXJzdFBvaW50ID0gdGhpcy5fcG9pbnRzWzBdO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGV4LkNvbG9yLkJsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNBVEJvdW5kaW5nQm94O1xuICAgIH0pKCk7XG4gICAgZXguU0FUQm91bmRpbmdCb3ggPSBTQVRCb3VuZGluZ0JveDtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRXZlbnRzLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBFeGNhbGlidXIgYmFzZSBjbGFzc1xuICAgICAqIEBjbGFzcyBDbGFzc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBDbGFzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENsYXNzKCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIgPSBuZXcgZXguRXZlbnREaXNwYXRjaGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIuIFlvdSBjYW4gbGlzdGVuIGZvciBhIHZhcmlldHkgb2ZcbiAgICAgICAgICogZXZlbnRzIG9mZiBvZiB0aGUgZW5naW5lOyBzZWUgdGhlIGV2ZW50cyBzZWN0aW9uIGJlbG93IGZvciBhIGNvbXBsZXRlIGxpc3QuXG4gICAgICAgICAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXIge2V2ZW50PT52b2lkfSBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBDbGFzcy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnN1YnNjcmliZShldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lci4gSWYgb25seSB0aGUgZXZlbnROYW1lIGlzIHNwZWNpZmllZFxuICAgICAgICAgKiBpdCB3aWxsIHJlbW92ZSBhbGwgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgdGhhdCBzcGVjaWZpYyBldmVudC4gSWYgdGhlIGV2ZW50TmFtZVxuICAgICAgICAgKiBhbmQgdGhlIGhhbmRsZXIgaW5zdGFuY2UgYXJlIHNwZWNpZmllZCBqdXN0IHRoYXQgaGFuZGxlciB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIFtoYW5kbGVyPXVuZGVmaW5lZF0ge2V2ZW50PT52b2lkfSBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBDbGFzcy5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnVuc3Vic2NyaWJlKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgXCJhZGRFdmVudExpc3RlbmVyXCIuIFlvdSBjYW4gbGlzdGVuIGZvciBhIHZhcmlldHkgb2ZcbiAgICAgICAgICogZXZlbnRzIG9mZiBvZiB0aGUgZW5naW5lOyBzZWUgdGhlIGV2ZW50cyBzZWN0aW9uIGJlbG93IGZvciBhIGNvbXBsZXRlIGxpc3QuXG4gICAgICAgICAqIEBtZXRob2Qgb25cbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyIHtldmVudD0+dm9pZH0gRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgQ2xhc3MucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuc3Vic2NyaWJlKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgXCJyZW1vdmVFdmVudExpc3RlbmVyXCIuIElmIG9ubHkgdGhlIGV2ZW50TmFtZSBpcyBzcGVjaWZpZWRcbiAgICAgICAgICogaXQgd2lsbCByZW1vdmUgYWxsIGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIHRoYXQgc3BlY2lmaWMgZXZlbnQuIElmIHRoZSBldmVudE5hbWVcbiAgICAgICAgICogYW5kIHRoZSBoYW5kbGVyIGluc3RhbmNlIGFyZSBzcGVjaWZpZWQgb25seSB0aGF0IGhhbmRsZXIgd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcbiAgICAgICAgICogQHBhcmFtIFtoYW5kbGVyPXVuZGVmaW5lZF0ge2V2ZW50PT52b2lkfSBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBDbGFzcy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIudW5zdWJzY3JpYmUoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBtYXkgd2lzaCB0byBleHRlbmQgbmF0aXZlIEV4Y2FsaWJ1ciBmdW5jdGlvbmFsaXR5LiBBbnkgbWV0aG9kIG9uXG4gICAgICAgICAqIGFjdG9yIG1heSBiZSBleHRlbmRlZCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl5LiBJbiB0aGVcbiAgICAgICAgICogZXhhbXBsZSBiZWxvdyB3ZSBjcmVhdGUgYSBuZXcgdHlwZSBjYWxsZWQgXCJNeUFjdG9yXCJcbiAgICAgICAgICogPGJyLz48Yj5FeGFtcGxlPC9iPjxwcmU+dmFyIE15QWN0b3IgPSBBY3Rvci5leHRlbmQoe1xuICAgICBjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMubmV3cHJvcCA9ICdzb21ldGhpbmcnO1xuICAgICAgICBBY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICB9LFxuICAgICB1cGRhdGUgOiBmdW5jdGlvbihlbmdpbmUsIGRlbHRhKXtcbiAgICAgICAgLy8gSW1wbGVtZW50IGN1c3RvbSB1cGRhdGVcbiAgXG4gICAgICAgICAgIC8vIENhbGwgc3VwZXIgY29uc3RydWN0b3IgdXBkYXRlXG4gICAgICAgICAgIEFjdG9yLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgY29uc29sZS5sb2coXCJTb21ldGhpbmcgY29vbCFcIik7XG4gICAgIH1cbiAgfSk7XG4gIHZhciBteUFjdG9yID0gbmV3IE15QWN0b3IoMTAwLCAxMDAsIDEwMCwgMTAwLCBDb2xvci5BenVyZSk7PC9wcmU+XG4gICAgICAgICAqIEBtZXRob2QgZXh0ZW5kXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIG1ldGhvZHMge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChtZXRob2RzKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG1ldGhvZHMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2luZyBjb25zdHJ1Y3RvciBhbGxvd3MgSlMgdG8gbGF6aWx5IGluc3RhbnRpYXRlIHN1cGVyIGNsYXNzZXNcbiAgICAgICAgICAgIHZhciBTdXBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU3VwZXIucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXBlcjtcbiAgICAgICAgICAgIGlmIChtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcm90b3R5cGVbcHJvcF0gPSBtZXRob2RzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdWJjbGFzc2VzIGV4dGVuZGFibGVcbiAgICAgICAgICAgIGNoaWxkLmV4dGVuZCA9IENsYXNzLmV4dGVuZDtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENsYXNzO1xuICAgIH0pKCk7XG4gICAgZXguQ2xhc3MgPSBDbGFzcztcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIFRpbWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBFeGNhbGlidXIgdGltZXIgaG9va3MgaW50byB0aGUgaW50ZXJuYWwgdGltZXIgYW5kIGZpcmVzIGNhbGxiYWNrcywgYWZ0ZXIgYSBjZXJ0YWluIGludGVydmFsLCBvcHRpb25hbGx5IHJlcGVhdGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzIFRpbWVyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sge2NhbGxiYWNrfSBUaGUgY2FsbGJhY2sgdG8gYmUgZmlyZWQgYWZ0ZXIgdGhlIGludGVydmFsIGlzIGNvbXBsZXRlLlxuICAgICAgICAgKiBAcGFyYW0gW3JlcGVhdHM9ZmFsc2VdIHtib29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbGwgYmFjayBzaG91bGQgYmUgZmlyZWQgb25seSBvbmNlLCBvciByZXBlYXQgYWZ0ZXIgZXZlcnkgaW50ZXJ2YWwgYXMgY29tcGxldGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVGltZXIoZmNuLCBpbnRlcnZhbCwgcmVwZWF0cykge1xuICAgICAgICAgICAgdGhpcy5pZCA9IDA7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gMTA7XG4gICAgICAgICAgICB0aGlzLmZjbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJlcGVhdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lQWxpdmUgPSAwO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlkID0gVGltZXIuaWQrKztcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCB0aGlzLmludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5mY24gPSBmY24gfHwgdGhpcy5mY247XG4gICAgICAgICAgICB0aGlzLnJlcGVhdHMgPSByZXBlYXRzIHx8IHRoaXMucmVwZWF0cztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdGltZXIgYWZ0ZXIgYSBjZXJ0YWluIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgZW5naW5lLlxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gTnVtYmVyIG9mIGVsYXBzZWQgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZUFsaXZlICs9IGRlbHRhO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsYXBzZWRUaW1lID4gdGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmNuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVGltZXIucHJvdG90eXBlLmdldFRpbWVSdW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsVGltZUFsaXZlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuY2VscyB0aGUgdGltZXIsIHByZXZlbnRpbmcgYW55IGZ1cnRoZXIgZXhlY3V0aW9ucy5cbiAgICAgICAgICogQG1ldGhvZCBjYW5jZWxcbiAgICAgICAgICovXG4gICAgICAgIFRpbWVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuY2FuY2VsVGltZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFRpbWVyLmlkID0gMDtcbiAgICAgICAgcmV0dXJuIFRpbWVyO1xuICAgIH0pKCk7XG4gICAgZXguVGltZXIgPSBUaW1lcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQWN0b3IudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2lkZS50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJQ29sbGlzaW9uUmVzb2x2ZXIudHNcIi8+IFxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBOYWl2ZUNvbGxpc2lvblJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmFpdmVDb2xsaXNpb25SZXNvbHZlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBOYWl2ZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vIHBhc3NcbiAgICAgICAgfTtcbiAgICAgICAgTmFpdmVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRhcnRldCkge1xuICAgICAgICAgICAgLy8gcGFzc1xuICAgICAgICB9O1xuICAgICAgICBOYWl2ZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBwb3RlbnRpYWwgY29sbGlkZXJzLCBleGNsdWRlIGtpbGxlZCwgcHJldmVudGVkLCBhbmQgc2VsZlxuICAgICAgICAgICAgdmFyIHBvdGVudGlhbENvbGxpZGVycyA9IHRhcmdldHMuZmlsdGVyKGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhb3RoZXIuaXNLaWxsZWQoKSAmJiBvdGhlci5jb2xsaXNpb25UeXBlICE9PSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhY3RvcjE7XG4gICAgICAgICAgICB2YXIgYWN0b3IyO1xuICAgICAgICAgICAgdmFyIGNvbGxpc2lvblBhaXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHBvdGVudGlhbENvbGxpZGVycy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhY3RvcjEgPSBwb3RlbnRpYWxDb2xsaWRlcnNbal07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGogKyAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdG9yMiA9IHBvdGVudGlhbENvbGxpZGVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbmltdW1UcmFuc2xhdGlvblZlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmltdW1UcmFuc2xhdGlvblZlY3RvciA9IGFjdG9yMS5jb2xsaWRlcyhhY3RvcjIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IGFjdG9yMS5nZXRTaWRlRnJvbUludGVyc2VjdChtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvblBhaXIgPSBuZXcgZXguQ29sbGlzaW9uUGFpcihhY3RvcjEsIGFjdG9yMiwgbWluaW11bVRyYW5zbGF0aW9uVmVjdG9yLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sbGlzaW9uUGFpcnMuc29tZShmdW5jdGlvbiAoY3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3AuZXF1YWxzKGNvbGxpc2lvblBhaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25QYWlycy5wdXNoKGNvbGxpc2lvblBhaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sbGlzaW9uUGFpcnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5ldmFsdWF0ZSgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsaXNpb25QYWlycztcbiAgICAgICAgfTtcbiAgICAgICAgTmFpdmVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICBOYWl2ZUNvbGxpc2lvblJlc29sdmVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmFpdmVDb2xsaXNpb25SZXNvbHZlcjtcbiAgICB9KSgpO1xuICAgIGV4Lk5haXZlQ29sbGlzaW9uUmVzb2x2ZXIgPSBOYWl2ZUNvbGxpc2lvblJlc29sdmVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJCb3VuZGluZ0JveC50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgVHJlZU5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUcmVlTm9kZShwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMgPSBuZXcgZXguQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUuaXNMZWFmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICghdGhpcy5sZWZ0ICYmICF0aGlzLnJpZ2h0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRyZWVOb2RlO1xuICAgIH0pKCk7XG4gICAgZXguVHJlZU5vZGUgPSBUcmVlTm9kZTtcbiAgICB2YXIgRHluYW1pY1RyZWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEeW5hbWljVHJlZSgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5vZGVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChsZWFmKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbm9kZXMgaW4gdGhlIHRyZWUsIG1ha2UgdGhpcyB0aGUgcm9vdCBsZWFmXG4gICAgICAgICAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gbGVhZjtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWFyY2ggdGhlIHRyZWUgZm9yIGEgbm9kZSB0aGF0IGlzIG5vdCBhIGxlYWYgYW5kIGZpbmQgdGhlIGJlc3QgcGxhY2UgdG8gaW5zZXJ0XG4gICAgICAgICAgICB2YXIgbGVhZkFBQkIgPSBsZWFmLmJvdW5kcztcbiAgICAgICAgICAgIHZhciBjdXJyZW50Um9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHdoaWxlICghY3VycmVudFJvb3QuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGN1cnJlbnRSb290LmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gY3VycmVudFJvb3QucmlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGFyZWEgPSBjdXJyZW50Um9vdC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVkQUFCQiA9IGN1cnJlbnRSb290LmJvdW5kcy5jb21iaW5lKGxlYWZBQUJCKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tYmluZWRBcmVhID0gY29tYmluZWRBQUJCLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjb3N0IGhldXJpc3RpYyBmb3IgY3JlYXRpbmcgYSBuZXcgcGFyZW50IGFuZCBsZWFmXG4gICAgICAgICAgICAgICAgdmFyIGNvc3QgPSAyICogY29tYmluZWRBcmVhO1xuICAgICAgICAgICAgICAgIC8vIE1pbmltdW0gY29zdCBvZiBwdXNoaW5nIHRoZSBsZWFmIGRvd24gdGhlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGFuY2VDb3N0ID0gMiAqIChjb21iaW5lZEFyZWEgLSBhcmVhKTtcbiAgICAgICAgICAgICAgICAvLyBDb3N0IG9mIGRlc2NlbmRpbmdcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENvc3QgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q29tYmluZWQgPSBsZWFmQUFCQi5jb21iaW5lKGxlZnQuYm91bmRzKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXJlYTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQXJlYTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5pc0xlYWYoKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q29zdCA9IGxlZnRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEFyZWEgPSBsZWZ0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJlYSA9IGxlZnRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdENvc3QgPSAobmV3QXJlYSAtIG9sZEFyZWEpICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRDb3N0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRDb21iaW5lZCA9IGxlYWZBQUJCLmNvbWJpbmUocmlnaHQuYm91bmRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaXNMZWFmKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDb3N0ID0gcmlnaHRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEFyZWEgPSByaWdodC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FyZWEgPSByaWdodENvbWJpbmVkLmdldFBlcmltZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENvc3QgPSAobmV3QXJlYSAtIG9sZEFyZWEpICsgaW5oZXJpdGFuY2VDb3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb3N0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICBpZiAoY29zdCA8IGxlZnRDb3N0ICYmIGNvc3QgPCByaWdodENvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgdG8gdGhlIGRlcHRoc1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0Q29zdCA8IHJpZ2h0Q29zdCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um9vdCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um9vdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IHBhcmVudCBub2RlIGFuZCBpbnNlcnQgaW50byB0aGUgdHJlZVxuICAgICAgICAgICAgdmFyIG9sZFBhcmVudCA9IGN1cnJlbnRSb290LnBhcmVudDtcbiAgICAgICAgICAgIHZhciBuZXdQYXJlbnQgPSBuZXcgVHJlZU5vZGUob2xkUGFyZW50KTtcbiAgICAgICAgICAgIG5ld1BhcmVudC5ib3VuZHMgPSBsZWFmQUFCQi5jb21iaW5lKGN1cnJlbnRSb290LmJvdW5kcyk7XG4gICAgICAgICAgICBuZXdQYXJlbnQuaGVpZ2h0ID0gY3VycmVudFJvb3QuaGVpZ2h0ICsgMTtcbiAgICAgICAgICAgIGlmIChvbGRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyBub2RlIHdhcyBub3QgdGhlIHJvb3RcbiAgICAgICAgICAgICAgICBpZiAob2xkUGFyZW50LmxlZnQgPT09IGN1cnJlbnRSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFBhcmVudC5sZWZ0ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50LnJpZ2h0ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQubGVmdCA9IGN1cnJlbnRSb290O1xuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5yaWdodCA9IGxlYWY7XG4gICAgICAgICAgICAgICAgY3VycmVudFJvb3QucGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgbm9kZSB3YXMgdGhlIHJvb3RcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQubGVmdCA9IGN1cnJlbnRSb290O1xuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5yaWdodCA9IGxlYWY7XG4gICAgICAgICAgICAgICAgY3VycmVudFJvb3QucGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIGxlYWYucGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ld1BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdhbGsgdXAgdGhlIHRyZWUgZml4aW5nIGhlaWdodHMgYW5kIEFBQkJzXG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBsZWFmLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy5iYWxhbmNlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IG9mIGN1cnJlbnQgbGVhZiBjYW5ub3QgaGF2ZSBhIG51bGwgbGVmdCBjaGlsZFwiICsgY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBvZiBjdXJyZW50IGxlYWYgY2Fubm90IGhhdmUgYSBudWxsIHJpZ2h0IGNoaWxkXCIgKyBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChjdXJyZW50Tm9kZS5sZWZ0LmhlaWdodCwgY3VycmVudE5vZGUucmlnaHQuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMgPSBjdXJyZW50Tm9kZS5sZWZ0LmJvdW5kcy5jb21iaW5lKGN1cnJlbnROb2RlLnJpZ2h0LmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobGVhZikge1xuICAgICAgICAgICAgaWYgKGxlYWYgPT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGxlYWYucGFyZW50O1xuICAgICAgICAgICAgdmFyIGdyYW5kUGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5sZWZ0ID09PSBsZWFmKSB7XG4gICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFuZFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChncmFuZFBhcmVudC5sZWZ0ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQubGVmdCA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5yaWdodCA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gZ3JhbmRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gZ3JhbmRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy5iYWxhbmNlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzID0gY3VycmVudE5vZGUubGVmdC5ib3VuZHMuY29tYmluZShjdXJyZW50Tm9kZS5yaWdodC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoY3VycmVudE5vZGUubGVmdC5oZWlnaHQsIGN1cnJlbnROb2RlLnJpZ2h0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUucmVnaXN0ZXJBY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgVHJlZU5vZGUoKTtcbiAgICAgICAgICAgIG5vZGUuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgIG5vZGUuYm91bmRzID0gYWN0b3IuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICBub2RlLmJvdW5kcy5sZWZ0IC09IDI7XG4gICAgICAgICAgICBub2RlLmJvdW5kcy50b3AgLT0gMjtcbiAgICAgICAgICAgIG5vZGUuYm91bmRzLnJpZ2h0ICs9IDI7XG4gICAgICAgICAgICBub2RlLmJvdW5kcy5ib3R0b20gKz0gMjtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbYWN0b3IuaWRdID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KG5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUudXBkYXRlQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1thY3Rvci5pZF07XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGIgPSBhY3Rvci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIGlmIChub2RlLmJvdW5kcy5jb250YWlucyhiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgYi5sZWZ0IC09IDU7XG4gICAgICAgICAgICBiLnRvcCAtPSA1O1xuICAgICAgICAgICAgYi5yaWdodCArPSA1O1xuICAgICAgICAgICAgYi5ib3R0b20gKz0gNTtcbiAgICAgICAgICAgIHZhciBtdWx0ZHggPSBhY3Rvci5keCAqIDI7XG4gICAgICAgICAgICB2YXIgbXVsdGR5ID0gYWN0b3IuZHkgKiAyO1xuICAgICAgICAgICAgaWYgKG11bHRkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBiLmxlZnQgKz0gbXVsdGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYi5yaWdodCArPSBtdWx0ZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXVsdGR5IDwgMCkge1xuICAgICAgICAgICAgICAgIGIudG9wICs9IG11bHRkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGIuYm90dG9tICs9IG11bHRkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuYm91bmRzID0gYjtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5yZW1vdmVBY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2FjdG9yLmlkXTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbYWN0b3IuaWRdID0gbnVsbDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVzW2FjdG9yLmlkXTtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWUucHJvdG90eXBlLmJhbGFuY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYmFsYW5jZSBhdCBudWxsIG5vZGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYoKSB8fCBub2RlLmhlaWdodCA8IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgIHZhciBhID0gbm9kZTtcbiAgICAgICAgICAgIHZhciBiID0gbGVmdDtcbiAgICAgICAgICAgIHZhciBjID0gcmlnaHQ7XG4gICAgICAgICAgICB2YXIgZCA9IGxlZnQubGVmdDtcbiAgICAgICAgICAgIHZhciBlID0gbGVmdC5yaWdodDtcbiAgICAgICAgICAgIHZhciBmID0gcmlnaHQubGVmdDtcbiAgICAgICAgICAgIHZhciBnID0gcmlnaHQucmlnaHQ7XG4gICAgICAgICAgICB2YXIgYmFsYW5jZSA9IGMuaGVpZ2h0IC0gYi5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBSb3RhdGUgYyBub2RlIHVwXG4gICAgICAgICAgICBpZiAoYmFsYW5jZSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBTd2FwIHRoZSByaWdodCBub2RlIHdpdGggaXQncyBwYXJlbnRcbiAgICAgICAgICAgICAgICBjLmxlZnQgPSBhO1xuICAgICAgICAgICAgICAgIGMucGFyZW50ID0gYS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgYS5wYXJlbnQgPSBjO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBub2RlJ3Mgb2xkIHBhcmVudCBzaG91bGQgcG9pbnQgdG8gdGhlIHJpZ2h0IG5vZGVcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG1lZ2EgY29uZnVzaW5nXG4gICAgICAgICAgICAgICAgaWYgKGMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnBhcmVudC5sZWZ0ID09PSBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnBhcmVudC5sZWZ0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMucGFyZW50LnJpZ2h0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUm90YXRlXG4gICAgICAgICAgICAgICAgaWYgKGYuaGVpZ2h0ID4gZy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5yaWdodCA9IGY7XG4gICAgICAgICAgICAgICAgICAgIGEucmlnaHQgPSBnO1xuICAgICAgICAgICAgICAgICAgICBnLnBhcmVudCA9IGE7XG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYi5ib3VuZHMuY29tYmluZShnLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGMuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShmLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGIuaGVpZ2h0LCBnLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBmLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjLnJpZ2h0ID0gZztcbiAgICAgICAgICAgICAgICAgICAgYS5yaWdodCA9IGY7XG4gICAgICAgICAgICAgICAgICAgIGYucGFyZW50ID0gYTtcbiAgICAgICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBiLmJvdW5kcy5jb21iaW5lKGYuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYy5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGcuYm91bmRzKTtcbiAgICAgICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYi5oZWlnaHQsIGYuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYy5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSb3RhdGUgbGVmdCBub2RlIHVwXG4gICAgICAgICAgICBpZiAoYmFsYW5jZSA8IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcFxuICAgICAgICAgICAgICAgIGIubGVmdCA9IGE7XG4gICAgICAgICAgICAgICAgYi5wYXJlbnQgPSBhLnBhcmVudDtcbiAgICAgICAgICAgICAgICBhLnBhcmVudCA9IGI7XG4gICAgICAgICAgICAgICAgLy8gbm9kZSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIGJcbiAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIucGFyZW50LmxlZnQgPT09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucGFyZW50LmxlZnQgPSBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIucGFyZW50LnJpZ2h0ICE9PSBhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3Igcm90YXRpbmcgRHluYW1pYyBUcmVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnBhcmVudC5yaWdodCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJvdGF0ZVxuICAgICAgICAgICAgICAgIGlmIChkLmhlaWdodCA+IGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGIucmlnaHQgPSBkO1xuICAgICAgICAgICAgICAgICAgICBhLmxlZnQgPSBlO1xuICAgICAgICAgICAgICAgICAgICBlLnBhcmVudCA9IGE7XG4gICAgICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYy5ib3VuZHMuY29tYmluZShlLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGIuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShkLmJvdW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGMuaGVpZ2h0LCBlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGIuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBkLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiLnJpZ2h0ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgYS5sZWZ0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgZC5wYXJlbnQgPSBhO1xuICAgICAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGMuYm91bmRzLmNvbWJpbmUoZC5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBiLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZS5ib3VuZHMpO1xuICAgICAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChjLmhlaWdodCwgZC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBiLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5oZWlnaHQ7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChhY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBhY3Rvci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUuYm91bmRzLmNvbGxpZGVzKGJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlzTGVhZigpICYmIGN1cnJlbnROb2RlLmFjdG9yICE9PSBhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoYWN0b3IsIGN1cnJlbnROb2RlLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSB8fCBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcih0aGlzLnJvb3QpO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUucmF5Q2FzdCA9IGZ1bmN0aW9uIChyYXksIG1heCkge1xuICAgICAgICAgICAgLy8gdG9kbyBpbXBsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBEeW5hbWljVHJlZS5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3VycmVudE5vZGVdLmNvbmNhdChoZWxwZXIoY3VycmVudE5vZGUubGVmdCksIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGVscGVyKHRoaXMucm9vdCk7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgLy8gZHJhdyBhbGwgdGhlIG5vZGVzIGluIHRoZSBEeW5hbWljIFRyZWVcbiAgICAgICAgICAgIHZhciBoZWxwZXIgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlzTGVhZigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBoZWxwZXIodGhpcy5yb290KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIER5bmFtaWNUcmVlO1xuICAgIH0pKCk7XG4gICAgZXguRHluYW1pY1RyZWUgPSBEeW5hbWljVHJlZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSUNvbGxpc2lvblJlc29sdmVyLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkR5bmFtaWNUcmVlLnRzXCIvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBEeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlcigpIHtcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlID0gbmV3IGV4LkR5bmFtaWNUcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5yZWdpc3RlckFjdG9yKHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnJlbW92ZUFjdG9yKHRhcmdldCk7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIHBvdGVudGlhbCBjb2xsaWRlcnMsIGV4Y2x1ZGUga2lsbGVkLCBwcmV2ZW50ZWQsIGFuZCBzZWxmXG4gICAgICAgICAgICB2YXIgcG90ZW50aWFsQ29sbGlkZXJzID0gdGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvdGhlci5pc0tpbGxlZCgpICYmIG90aGVyLmNvbGxpc2lvblR5cGUgIT09IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGFjdG9yO1xuICAgICAgICAgICAgdmFyIGNvbGxpc2lvblBhaXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHBvdGVudGlhbENvbGxpZGVycy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhY3RvciA9IHBvdGVudGlhbENvbGxpZGVyc1tqXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5xdWVyeShhY3RvciwgZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlci5jb2xsaXNpb25UeXBlID09PSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi8gfHwgb3RoZXIuaXNLaWxsZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbmltdW1UcmFuc2xhdGlvblZlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmltdW1UcmFuc2xhdGlvblZlY3RvciA9IGFjdG9yLmNvbGxpZGVzKG90aGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGUgPSBhY3Rvci5nZXRTaWRlRnJvbUludGVyc2VjdChtaW5pbXVtVHJhbnNsYXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvblBhaXIgPSBuZXcgZXguQ29sbGlzaW9uUGFpcihhY3Rvciwgb3RoZXIsIG1pbmltdW1UcmFuc2xhdGlvblZlY3Rvciwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxpc2lvblBhaXJzLnNvbWUoZnVuY3Rpb24gKGNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNwLmVxdWFscyhjb2xsaXNpb25QYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uUGFpcnMucHVzaChjb2xsaXNpb25QYWlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxpc2lvblBhaXJzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuZXZhbHVhdGUoKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29sbGlzaW9uUGFpcnM7XG4gICAgICAgIH07XG4gICAgICAgIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSAwO1xuICAgICAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS51cGRhdGVBY3RvcihhKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgfTtcbiAgICAgICAgRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlci5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLmRlYnVnRHJhdyhjdHgsIGRlbHRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIER5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXI7XG4gICAgfSkoKTtcbiAgICBleC5EeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyID0gRHluYW1pY1RyZWVDb2xsaXNpb25SZXNvbHZlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQ29sbGlzaW9uIHBhaXJzIGFyZSB1c2VkIGludGVybmFsbHkgYnkgRXhjYWxpYnVyIHRvIHJlc29sdmUgY29sbGlzaW9uIGJldHdlZW4gYWN0b3JzLiBUaGVcbiAgICAgKiBQYWlyIHByZXZlbnRzIGNvbGxpc2lvbnMgZnJvbSBiZWluZyBldmFsdWF0ZWQgbW9yZSB0aGFuIG9uZSB0aW1lXG4gICAgICogQGNsYXNzIENvbGxpc2lvblBhaXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gbGVmdCB7QWN0b3J9IFRoZSBmaXJzdCBhY3RvciBpbiB0aGUgY29sbGlzaW9uIHBhaXJcbiAgICAgKiBAcGFyYW0gcmlnaHQge0FjdG9yfSBUaGUgc2Vjb25kIGFjdG9yIGluIHRoZSBjb2xsaXNpb24gcGFpclxuICAgICAqIEBwYXJhbSBpbnRlcnNlY3Qge1ZlY3Rvcn0gVGhlIG1pbmltdW0gdHJhbnNsYXRpb24gdmVjdG9yIHRvIHNlcGFyYXRlIHRoZSBhY3RvcnMgZnJvbSB0aGUgcGVyc3BlY3RpdmUgb2YgdGhlIGxlZnQgYWN0b3JcbiAgICAgKiBAcGFyYW0gc2lkZSB7U2lkZX0gVGhlIHNpZGUgb24gd2hpY2ggdGhlIGNvbGxpc2lvbiBvY2N1cmVkIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBsZWZ0IGFjdG9yXG4gICAgICovXG4gICAgdmFyIENvbGxpc2lvblBhaXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb2xsaXNpb25QYWlyKGxlZnQsIHJpZ2h0LCBpbnRlcnNlY3QsIHNpZGUpIHtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdCA9IGludGVyc2VjdDtcbiAgICAgICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhpcyBjb2xsaXNpb24gcGFpciBhbmQgYW5vdGhlciBhcmUgZXF1aXZhbGVudC5cbiAgICAgICAgICogQG1ldGhvZCBlcXVhbHNcbiAgICAgICAgICogQHBhcmFtIGNvbGxpc2lvblBhaXIge0NvbGxpc2lvblBhaXJ9XG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIENvbGxpc2lvblBhaXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChjb2xsaXNpb25QYWlyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNvbGxpc2lvblBhaXIubGVmdCA9PT0gdGhpcy5sZWZ0ICYmIGNvbGxpc2lvblBhaXIucmlnaHQgPT09IHRoaXMucmlnaHQpIHx8IChjb2xsaXNpb25QYWlyLnJpZ2h0ID09PSB0aGlzLmxlZnQgJiYgY29sbGlzaW9uUGFpci5sZWZ0ID09PSB0aGlzLnJpZ2h0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2YWx1YXRlcyB0aGUgY29sbGlzaW9uIHBhaXIsIHBlcmZvcm1pbmcgY29sbGlzaW9uIHJlc29sdXRpb24gYW5kIGV2ZW50IHB1Ymxpc2hpbmcgYXBwcm9wcmlhdGUgdG8gZWFjaCBjb2xsaXNpb24gdHlwZS5cbiAgICAgICAgICogQG1ldGhvZCBldmFsdWF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uUGFpci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0b2RvIGZpcmUgY29sbGlzaW9uIGV2ZW50cyBvbiBsZWZ0IGFuZCByaWdodCBhY3RvclxuICAgICAgICAgICAgLy8gdG9kbyByZXNvbHZlIGNvbGxpc2lvbnMgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggY29sbGlzaW9uIGV2ZW50cyBvbiBib3RoIHBhcnRpY2lwYW50c1xuICAgICAgICAgICAgdGhpcy5sZWZ0LmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdjb2xsaXNpb24nLCBuZXcgZXguQ29sbGlzaW9uRXZlbnQodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LCB0aGlzLnNpZGUsIHRoaXMuaW50ZXJzZWN0KSk7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0LmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdjb2xsaXNpb24nLCBuZXcgZXguQ29sbGlzaW9uRXZlbnQodGhpcy5yaWdodCwgdGhpcy5sZWZ0LCBleC5VdGlsLmdldE9wcG9zaXRlU2lkZSh0aGlzLnNpZGUpLCB0aGlzLmludGVyc2VjdC5zY2FsZSgtMS4wKSkpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGFjdG9yIGlzIGFjdGl2ZSBwdXNoIHRoZSBhY3RvciBvdXQgaWYgaXRzIG5vdCBwYXNzaXZlXG4gICAgICAgICAgICB2YXIgbGVmdFNpZGUgPSB0aGlzLnNpZGU7XG4gICAgICAgICAgICBpZiAoKHRoaXMubGVmdC5jb2xsaXNpb25UeXBlID09PSAyIC8qIEFjdGl2ZSAqLyB8fCB0aGlzLmxlZnQuY29sbGlzaW9uVHlwZSA9PT0gMyAvKiBFbGFzdGljICovKSAmJiB0aGlzLnJpZ2h0LmNvbGxpc2lvblR5cGUgIT09IDEgLyogUGFzc2l2ZSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMubGVmdC55ICs9IHRoaXMuaW50ZXJzZWN0Lnk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnggKz0gdGhpcy5pbnRlcnNlY3QueDtcbiAgICAgICAgICAgICAgICAvLyBOYWl2ZSBlbGFzdGljIGJvdW5jZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQuY29sbGlzaW9uVHlwZSA9PT0gMyAvKiBFbGFzdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0U2lkZSA9PT0gMyAvKiBMZWZ0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZHggPSBNYXRoLmFicyh0aGlzLmxlZnQuZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRTaWRlID09PSA0IC8qIFJpZ2h0ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZHggPSAtTWF0aC5hYnModGhpcy5sZWZ0LmR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsZWZ0U2lkZSA9PT0gMSAvKiBUb3AgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5keSA9IE1hdGguYWJzKHRoaXMubGVmdC5keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdFNpZGUgPT09IDIgLyogQm90dG9tICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZHkgPSAtTWF0aC5hYnModGhpcy5sZWZ0LmR5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByaWdodFNpZGUgPSBleC5VdGlsLmdldE9wcG9zaXRlU2lkZSh0aGlzLnNpZGUpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0SW50ZXJzZWN0ID0gdGhpcy5pbnRlcnNlY3Quc2NhbGUoLTEuMCk7XG4gICAgICAgICAgICBpZiAoKHRoaXMucmlnaHQuY29sbGlzaW9uVHlwZSA9PT0gMiAvKiBBY3RpdmUgKi8gfHwgdGhpcy5yaWdodC5jb2xsaXNpb25UeXBlID09PSAzIC8qIEVsYXN0aWMgKi8pICYmIHRoaXMubGVmdC5jb2xsaXNpb25UeXBlICE9PSAxIC8qIFBhc3NpdmUgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnkgKz0gcmlnaHRJbnRlcnNlY3QueTtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnggKz0gcmlnaHRJbnRlcnNlY3QueDtcbiAgICAgICAgICAgICAgICAvLyBOYWl2ZSBlbGFzdGljIGJvdW5jZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0LmNvbGxpc2lvblR5cGUgPT09IDMgLyogRWxhc3RpYyAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRTaWRlID09PSAzIC8qIExlZnQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZHggPSBNYXRoLmFicyh0aGlzLnJpZ2h0LmR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFNpZGUgPT09IDQgLyogUmlnaHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZHggPSAtTWF0aC5hYnModGhpcy5yaWdodC5keCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRTaWRlID09PSAxIC8qIFRvcCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5keSA9IE1hdGguYWJzKHRoaXMucmlnaHQuZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0U2lkZSA9PT0gMiAvKiBCb3R0b20gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZHkgPSAtTWF0aC5hYnModGhpcy5yaWdodC5keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25QYWlyO1xuICAgIH0pKCk7XG4gICAgZXguQ29sbGlzaW9uUGFpciA9IENvbGxpc2lvblBhaXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVuZ2luZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWxnZWJyYS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgKiBBIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYSBjYW1lcmEuIFRoaXMgY2xhc3MgaXMgbWVhbnQgdG8gYmUgZXh0ZW5kZWQuXG4gICAgKiBAY2xhc3MgQ2FtZXJhXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVuZ2luZVxuICAgICovXG4gICAgdmFyIEJhc2VDYW1lcmEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCYXNlQ2FtZXJhKCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1cyA9IG5ldyBleC5Qb2ludCgwLCAwKTtcbiAgICAgICAgICAgIHRoaXMubGVycCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gMSAqIDEwMDA7IC8vIDUgc2Vjb25kc1xuICAgICAgICAgICAgdGhpcy5fdG90YWxMZXJwVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG51bGw7XG4gICAgICAgICAgICAvL2NhbWVyYSBlZmZlY3RzXG4gICAgICAgICAgICB0aGlzLmlzU2hha2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zaGFrZU1hZ25pdHVkZVggPSAwO1xuICAgICAgICAgICAgdGhpcy5zaGFrZU1hZ25pdHVkZVkgPSAwO1xuICAgICAgICAgICAgdGhpcy5zaGFrZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZFNoYWtlVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Wm9vbVNjYWxlID0gMTtcbiAgICAgICAgICAgIHRoaXMubWF4Wm9vbVNjYWxlID0gMTtcbiAgICAgICAgICAgIHRoaXMuem9vbUR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZFpvb21UaW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMuem9vbUluY3JlbWVudCA9IDAuMDE7XG4gICAgICAgIH1cbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZWFzZUluT3V0Q3ViaWMgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAtPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIChjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyAyKSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIFNldHMgdGhlIHt7I2Nyb3NzTGluayBBY3Rvcn19e3svY3Jvc3NMaW5rfX0gdG8gZm9sbG93IHdpdGggdGhlIGNhbWVyYVxuICAgICAgICAqIEBtZXRob2Qgc2V0QWN0b3JUb0ZvbGxvd1xuICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0byBmb2xsb3dcbiAgICAgICAgKi9cbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuc2V0QWN0b3JUb0ZvbGxvdyA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5mb2xsb3cgPSBhY3RvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogUmV0dXJucyB0aGUgZm9jYWwgcG9pbnQgb2YgdGhlIGNhbWVyYVxuICAgICAgICAqIEBtZXRob2QgZ2V0Rm9jdXNcbiAgICAgICAgKiBAcmV0dXJucyBQb2ludFxuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5nZXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvY3VzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBTZXRzIHRoZSBmb2NhbCBwb2ludCBvZiB0aGUgY2FtZXJhLiBUaGlzIHZhbHVlIGNhbiBvbmx5IGJlIHNldCBpZiB0aGVyZSBpcyBubyBhY3RvciB0byBiZSBmb2xsb3dlZC5cbiAgICAgICAgKiBAbWV0aG9kIHNldEZvY3VzXG4gICAgICAgICogQHBhcmFtIHgge251bWJlcn0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgZm9jYWwgcG9pbnRcbiAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBmb2NhbCBwb2ludFxuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5zZXRGb2N1cyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9sbG93ICYmICF0aGlzLmxlcnApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzLnggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMueSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sZXJwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gdGhpcy5mb2N1cy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgZXguUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBTZXRzIHRoZSBjYW1lcmEgdG8gc2hha2UgYXQgdGhlIHNwZWNpZmllZCBtYWduaXR1ZGVzIGZvciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uXG4gICAgICAgICogQG1ldGhvZCBzaGFrZVxuICAgICAgICAqIEBwYXJhbSBtYWduaXR1ZGVYIHtudW1iZXJ9IHRoZSB4IG1hZ25pdHVkZSBvZiB0aGUgc2hha2VcbiAgICAgICAgKiBAcGFyYW0gbWFnbml0dWRlWSB7bnVtYmVyfSB0aGUgeSBtYWduaXR1ZGUgb2YgdGhlIHNoYWtlXG4gICAgICAgICogQHBhcmFtIGR1cmF0aW9uIHtudW1iZXJ9IHRoZSBkdXJhdGlvbiBvZiB0aGUgc2hha2VcbiAgICAgICAgKi9cbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuc2hha2UgPSBmdW5jdGlvbiAobWFnbml0dWRlWCwgbWFnbml0dWRlWSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaXNTaGFraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2hha2VNYWduaXR1ZGVYID0gbWFnbml0dWRlWDtcbiAgICAgICAgICAgIHRoaXMuc2hha2VNYWduaXR1ZGVZID0gbWFnbml0dWRlWTtcbiAgICAgICAgICAgIHRoaXMuc2hha2VEdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgKiBab29tcyB0aGUgY2FtZXJhIGluIG9yIG91dCBieSB0aGUgc3BlY2lmaWVkIHNjYWxlIG92ZXIgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAgICAgICAgKiBJZiBubyBkdXJhdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgem9vbSBieSBhIHNldCBhbW91bnQgdW50aWwgdGhlIHNjYWxlIGlzIHJlYWNoZWQuXG4gICAgICAgICogQG1ldGhvZCB6b29tXG4gICAgICAgICogQHBhcmFtIHNjYWxlIHtudW1iZXJ9IHRoZSBzY2FsZSBvZiB0aGUgem9vbVxuICAgICAgICAqIEBwYXJhbSBbZHVyYXRpb25dIHtudW1iZXJ9IHRoZSBkdXJhdGlvbiBvZiB0aGUgem9vbVxuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24gKHNjYWxlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5pc1pvb21pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXhab29tU2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgIHRoaXMuem9vbUR1cmF0aW9uID0gZHVyYXRpb24gfCAwO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29tSW5jcmVtZW50ID0gTWF0aC5hYnModGhpcy5tYXhab29tU2NhbGUgLSB0aGlzLmN1cnJlbnRab29tU2NhbGUpIC8gZHVyYXRpb24gKiAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWF4Wm9vbVNjYWxlIDwgMSkge1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb21JbmNyZW1lbnQgPSAtMSAqIHRoaXMuem9vbUluY3JlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNab29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFpvb21TY2FsZSh0aGlzLm1heFpvb21TY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRab29tU2NhbGUodGhpcy5tYXhab29tU2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiem9vbSBpbmNyZW1lbnQ6IFwiICsgdGhpcy56b29tSW5jcmVtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogZ2V0cyB0aGUgY3VycmVudCB6b29tIHNjYWxlXG4gICAgICAgICogQG1ldGhvZCBnZXRab29tXG4gICAgICAgICogQHJldHVybnMge051bWJlcn0gdGhlIGN1cnJlbnQgem9vbSBzY2FsZVxuICAgICAgICAqL1xuICAgICAgICBCYXNlQ2FtZXJhLnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFpvb21TY2FsZTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuc2V0Q3VycmVudFpvb21TY2FsZSA9IGZ1bmN0aW9uICh6b29tU2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFpvb21TY2FsZSA9IHpvb21TY2FsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogQXBwbGllcyB0aGUgcmVsZXZhbnQgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBnYW1lIGNhbnZhcyB0byBcIm1vdmVcIiBvciBhcHBseSBlZmZlY3RzIHRvIHRoZSBDYW1lcmFcbiAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcbiAgICAgICAgKi9cbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGN0eCwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuZ2V0Rm9jdXMoKTtcbiAgICAgICAgICAgIHZhciB4U2hha2UgPSAwO1xuICAgICAgICAgICAgdmFyIHlTaGFrZSA9IDA7XG4gICAgICAgICAgICB2YXIgY2FudmFzV2lkdGggPSBjdHguY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IGN0eC5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIG5ld0NhbnZhc1dpZHRoID0gY2FudmFzV2lkdGggKiB0aGlzLmdldFpvb20oKTtcbiAgICAgICAgICAgIHZhciBuZXdDYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQgKiB0aGlzLmdldFpvb20oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlcnApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudExlcnBUaW1lIDwgdGhpcy5fbGVycER1cmF0aW9uICYmIHRoaXMuX2NhbWVyYU1vdmluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC54IDwgdGhpcy5fbGVycFN0YXJ0LngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMueCA9IHRoaXMuX2xlcnBTdGFydC54IC0gKHRoaXMuZWFzZUluT3V0Q3ViaWModGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC54KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMueCA9IHRoaXMuZWFzZUluT3V0Q3ViaWModGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnkgPCB0aGlzLl9sZXJwU3RhcnQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cy55ID0gdGhpcy5fbGVycFN0YXJ0LnkgLSAodGhpcy5lYXNlSW5PdXRDdWJpYyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1cy55ID0gdGhpcy5lYXNlSW5PdXRDdWJpYyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycEVuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRG9uZVNoYWtpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTaGFraW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkU2hha2VUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWtlTWFnbml0dWRlWCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFrZU1hZ25pdHVkZVkgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hha2VEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRTaGFrZVRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgeFNoYWtlID0gKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNoYWtlTWFnbml0dWRlWCB8IDApICsgMTtcbiAgICAgICAgICAgICAgICB5U2hha2UgPSAoTWF0aC5yYW5kb20oKSAqIHRoaXMuc2hha2VNYWduaXR1ZGVZIHwgMCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtZm9jdXMueCArIHhTaGFrZSArIChuZXdDYW52YXNXaWR0aCAvIDIpLCAtZm9jdXMueSArIHlTaGFrZSArIChuZXdDYW52YXNIZWlnaHQgLyAyKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RvbmVab29taW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFpvb21UaW1lID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21EdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50Wm9vbVNjYWxlKHRoaXMubWF4Wm9vbVNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFpvb21UaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFpvb21TY2FsZSh0aGlzLmdldFpvb20oKSArIHRoaXMuem9vbUluY3JlbWVudCAqIGRlbHRhIC8gMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5nZXRab29tKCksIHRoaXMuZ2V0Wm9vbSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpcy5nZXRGb2N1cygpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhmb2N1cy54LCBmb2N1cy55LCAxNSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFzZUNhbWVyYS5wcm90b3R5cGUuaXNEb25lU2hha2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHRoaXMuaXNTaGFraW5nKSB8fCAodGhpcy5lbGFwc2VkU2hha2VUaW1lID49IHRoaXMuc2hha2VEdXJhdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIEJhc2VDYW1lcmEucHJvdG90eXBlLmlzRG9uZVpvb21pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy56b29tRHVyYXRpb24gIT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5lbGFwc2VkWm9vbVRpbWUgPj0gdGhpcy56b29tRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4Wm9vbVNjYWxlIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY3VycmVudFpvb21TY2FsZSA8PSB0aGlzLm1heFpvb21TY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY3VycmVudFpvb21TY2FsZSA+PSB0aGlzLm1heFpvb21TY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQmFzZUNhbWVyYTtcbiAgICB9KSgpO1xuICAgIGV4LkJhc2VDYW1lcmEgPSBCYXNlQ2FtZXJhO1xuICAgIC8qKlxuICAgICogQW4gZXh0ZW5zaW9uIG9mIEJhc2VDYW1lcmEgdGhhdCBpcyBsb2NrZWQgdmVydGljYWxseTsgaXQgd2lsbCBvbmx5IG1vdmUgc2lkZSB0byBzaWRlLlxuICAgICogQGNsYXNzIFNpZGVDYW1lcmFcbiAgICAqIEBleHRlbmRzIEJhc2VDYW1lcmFcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW5naW5lXG4gICAgKi9cbiAgICB2YXIgU2lkZUNhbWVyYSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTaWRlQ2FtZXJhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTaWRlQ2FtZXJhKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2lkZUNhbWVyYS5wcm90b3R5cGUuZ2V0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb2xsb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGV4LlBvaW50KHRoaXMuZm9sbG93LnggKyB0aGlzLmZvbGxvdy5nZXRXaWR0aCgpIC8gMiwgdGhpcy5mb2N1cy55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvY3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2lkZUNhbWVyYTtcbiAgICB9KShCYXNlQ2FtZXJhKTtcbiAgICBleC5TaWRlQ2FtZXJhID0gU2lkZUNhbWVyYTtcbiAgICAvKipcbiAgICAqIEFuIGV4dGVuc2lvbiBvZiBCYXNlQ2FtZXJhIHRoYXQgaXMgbG9ja2VkIHRvIGFuIGFjdG9yIG9yIGZvY2FsIHBvaW50OyB0aGUgYWN0b3Igd2lsbCBhcHBlYXIgaW4gdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuLlxuICAgICogQGNsYXNzIFRvcENhbWVyYVxuICAgICogQGV4dGVuZHMgQmFzZUNhbWVyYVxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBlbmdpbmVcbiAgICAqL1xuICAgIHZhciBUb3BDYW1lcmEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVG9wQ2FtZXJhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUb3BDYW1lcmEoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBUb3BDYW1lcmEucHJvdG90eXBlLmdldEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9sbG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5Qb2ludCh0aGlzLmZvbGxvdy54ICsgdGhpcy5mb2xsb3cuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuZm9sbG93LnkgKyB0aGlzLmZvbGxvdy5nZXRIZWlnaHQoKSAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUb3BDYW1lcmE7XG4gICAgfSkoQmFzZUNhbWVyYSk7XG4gICAgZXguVG9wQ2FtZXJhID0gVG9wQ2FtZXJhO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDbGFzcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVGltZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbGxpc2lvbi9OYWl2ZUNvbGxpc2lvblJlc29sdmVyLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbGxpc2lvbi9EeW5hbWljVHJlZUNvbGxpc2lvblJlc29sdmVyLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNvbGxpc2lvblBhaXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNhbWVyYS50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQWN0b3JzIGFyZSBjb21wb3NlZCB0b2dldGhlciBpbnRvIGdyb3VwaW5ncyBjYWxsZWQgU2NlbmVzIGluXG4gICAgICogRXhjYWxpYnVyLiBUaGUgbWV0YXBob3IgbW9kZWxzIHRoZSBzYW1lIGlkZWEgYmVoaW5kIHJlYWwgd29ybGRcbiAgICAgKiBhY3RvcnMgaW4gYSBzY2VuZS4gT25seSBhY3RvcnMgaW4gc2NlbmVzIHdpbGwgYmUgdXBkYXRlZCBhbmQgZHJhd24uXG4gICAgICogQGNsYXNzIFNjZW5lXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFNjZW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFNjZW5lLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTY2VuZShlbmdpbmUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgYWN0b3JzIGluIHRoZSBjdXJyZW50IHNjZW5lXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgY2hpbGRyZW4ge0FjdG9yW119XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudGlsZU1hcHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudWlBY3RvcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblJlc29sdmVyID0gbmV3IGV4LkR5bmFtaWNUcmVlQ29sbGlzaW9uUmVzb2x2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2tpbGxRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fdGltZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgZXguQmFzZUNhbWVyYSgpO1xuICAgICAgICAgICAgaWYgKGVuZ2luZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLnNldEZvY3VzKGVuZ2luZS53aWR0aCAvIDIsIGVuZ2luZS5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2NlbmUgaXMgbWFkZSBhY3RpdmUgYW5kIHN0YXJ0ZWQuIEl0IGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbixcbiAgICAgICAgICogdGhpcyBpcyB3aGVyZSB5b3Ugc2hvdWxkIHNldHVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXG4gICAgICAgICAqIEBtZXRob2Qgb25BY3RpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIG1hZGUgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhbmQgc3RvcHBlZC4gSXQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuLFxuICAgICAgICAgKiB0aGlzIGlzIHdoZXJlIHlvdSBzaG91bGQgY2xlYW51cCBhbnkgRE9NIFVJIG9yIGV2ZW50IGhhbmRsZXJzIG5lZWRlZCBmb3IgdGhlIHNjZW5lLlxuICAgICAgICAgKiBAbWV0aG9kIG9uRGVhY3RpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgb2YgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxuICAgICAgICAgKiBvdmVycmlkZGVuLiBUaGlzIGlzIHdoZXJlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkIGFjdG9ycyBzaG91bGQgdGFrZSBwbGFjZS5cbiAgICAgICAgICogQG1ldGhvZCBvbkluaXRpYWxpemVcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLm9uSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHVibGlzaCBhbiBldmVudCB0byBhbGwgYWN0b3JzIGluIHRoZSBzY2VuZVxuICAgICAgICAgKiBAbWV0aG9kIHB1Ymxpc2hcbiAgICAgICAgICogQHBhcmFtIGV2ZW50VHlwZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcHVibGlzaFxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQge0dhbWVFdmVudH0gVGhlIGV2ZW50IG9iamVjdCB0byBzZW5kXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYWN0b3IudHJpZ2dlckV2ZW50KGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGFsbCB0aGUgYWN0b3JzIGFuZCB0aW1lcnMgaW4gdGhlIFNjZW5lLiBDYWxsZWQgYnkgdGhlIEVuZ2luZS5cbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfSBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRW5naW5lXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUoZW5naW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdpbml0aWFsaXplJywgbmV3IGV4LkluaXRpYWxpemVFdmVudChlbmdpbmUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudWlBY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAodWkpIHtcbiAgICAgICAgICAgICAgICB1aS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGlsZU1hcHMuZm9yRWFjaChmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICBjbS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJ1biBjb2xsaXNpb24gcmVzb2x1dGlvbiBzdHJhdGVneVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxpc2lvblJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUmVzb2x2ZXIudXBkYXRlKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblJlc29sdmVyLmV2YWx1YXRlKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFjdG9ycyBmcm9tIHNjZW5lIGdyYXBoIGFmdGVyIGJlaW5nIGtpbGxlZFxuICAgICAgICAgICAgdmFyIGFjdG9ySW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2tpbGxRdWV1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFjdG9ySW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YodGhpcy5fa2lsbFF1ZXVlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3JJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGFjdG9ySW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2tpbGxRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRpbWVycyBpbiB0aGUgY2FuY2VsIHF1ZXVlIGJlZm9yZSB1cGRhdGluZyB0aGVtXG4gICAgICAgICAgICB2YXIgdGltZXJJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fY2FuY2VsUXVldWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbWVyKHRoaXMuX2NhbmNlbFF1ZXVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIHRpbWVycyB1cGRhdGluZyB0aW1lcnNcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycyA9IHRoaXMuX3RpbWVycy5maWx0ZXIoZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGltZXIudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRpbWVyLmNvbXBsZXRlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3cyBhbGwgdGhlIGFjdG9ycyBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgRW5naW5lLlxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgZHJhd1xuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZShjdHgsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGlsZU1hcHMuZm9yRWFjaChmdW5jdGlvbiAoY20pIHtcbiAgICAgICAgICAgICAgICBjbS5kcmF3KGN0eCwgZGVsdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICB2YXIgZW5kID0gMDtcbiAgICAgICAgICAgIHZhciBhY3RvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWN0b3IgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgZHJhdyBhY3RvcnMgdGhhdCBhcmUgdmlzaWJsZVxuICAgICAgICAgICAgICAgIGlmIChhY3Rvci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZHJhdyhjdHgsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd5ZWxsb3cnO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh1aSkge1xuICAgICAgICAgICAgICAgIGlmICh1aS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLmRyYXcoY3R4LCBkZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMudWlBY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAodWkpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3cyBhbGwgdGhlIGFjdG9ycycgZGVidWcgaW5mb3JtYXRpb24gaW4gdGhlIFNjZW5lLiBDYWxsZWQgYnkgdGhlIEVuZ2luZS5cbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB0aGlzLnRpbGVNYXBzLmZvckVhY2goZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgICAgIG1hcC5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgIGFjdG9yLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0b2RvIHBvc3NpYmx5IGVuYWJsZSB0aGlzIHdpdGggZXhjYWxpYnVyIGZsYWdzIGZlYXR1cmVzP1xuICAgICAgICAgICAgLy90aGlzLl9jb2xsaXNpb25SZXNvbHZlci5kZWJ1Z0RyYXcoY3R4LCAyMCk7XG4gICAgICAgICAgICAvL3RoaXMuY2FtZXJhLmRlYnVnRHJhdyhjdHgpO1xuICAgICAgICB9O1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlVJQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFVJQWN0b3IoZW50aXR5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRpbWVyKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVGlsZU1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGlsZU1hcChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlVJQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVVJQWN0b3IoZW50aXR5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguQWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25SZXNvbHZlci5yZW1vdmUoZW50aXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbWVyKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguVGlsZU1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZU1hcChlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byBhY3QgYXMgYSBwaWVjZSBvZiBVSSwgbWVhbmluZyBpdCBpcyBhbHdheXMgcG9zaXRpb25lZFxuICAgICAgICAgKiBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFVJIGFjdG9ycyBkbyBub3QgcGFydGljaXBhdGUgaW4gY29sbGlzaW9uc1xuICAgICAgICAgKiBAbWV0aG9kIGFkZFVJQWN0b3JcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn1cbiAgICAgICAgICovXG4gICAgICAgIFNjZW5lLnByb3RvdHlwZS5hZGRVSUFjdG9yID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnVpQWN0b3JzLnB1c2goYWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBhcyBhIHBpZWMgb2YgVUlcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVVSUFjdG9yXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlVUlBY3RvciA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy51aUFjdG9ycy5pbmRleE9mKGFjdG9yKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51aUFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byB0aGUgU2NlbmUsIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBhY3RvciB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGFkZENoaWxkXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblJlc29sdmVyLnJlZ2lzdGVyKGFjdG9yKTtcbiAgICAgICAgICAgIGFjdG9yLnNjZW5lID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhY3Rvcik7XG4gICAgICAgICAgICBhY3Rvci5wYXJlbnQgPSB0aGlzLmFjdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIFRpbGVNYXAgdG8gdGhlIFNjZW5lLCBvbmNlIHRoaXMgaXMgZG9uZSB0aGUgVGlsZU1hcCB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGFkZFRpbGVNYXBcbiAgICAgICAgICogQHBhcmFtIHRpbGVNYXAge1RpbGVNYXB9XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XG4gICAgICAgICAgICB0aGlzLnRpbGVNYXBzLnB1c2godGlsZU1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgVGlsZU1hcCBmcm9tIHRoZSBTY2VuZSwgaXQgd2lsbG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVRpbGVNYXBcbiAgICAgICAgICogQHBhcmFtIHRpbGVNYXAge1RpbGVNYXB9XG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlVGlsZU1hcCA9IGZ1bmN0aW9uICh0aWxlTWFwKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnRpbGVNYXBzLmluZGV4T2YodGlsZU1hcCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGlsZU1hcHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gYWN0b3IgZnJvbSB0aGUgU2NlbmUsIGl0IHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRvIHJlbW92ZVxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25SZXNvbHZlci5yZW1vdmUoYWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5fa2lsbFF1ZXVlLnB1c2goYWN0b3IpO1xuICAgICAgICAgICAgYWN0b3IucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSB0aW1lciB0byB0aGUgU2NlbmVcbiAgICAgICAgICogQG1ldGhvZCBhZGRUaW1lclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIge1RpbWVyfSBUaGUgdGltZXIgdG8gYWRkXG4gICAgICAgICAqIEByZXR1cm5zIFRpbWVyXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuYWRkVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycy5wdXNoKHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyLnNjZW5lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSB0aW1lciB0byB0aGUgU2NlbmUsIGNhbiBiZSBkYW5nZXJvdXNcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVUaW1lclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gdGltZXIge1RpbWVyfSBUaGUgdGltZXIgdG8gcmVtb3ZlXG4gICAgICAgICAqIEByZXR1cm5zIFRpbWVyXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUucmVtb3ZlVGltZXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fdGltZXJzLmluZGV4T2YodGltZXIpO1xuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbmNlbHMgYSB0aW1lciwgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgc2NlbmUgbmljZWx5XG4gICAgICAgICAqIEBtZXRob2QgY2FuY2VsVGltZXJcbiAgICAgICAgICogQHBhcmFtIHRpbWVyIHtUaW1lcn0gVGhlIHRpbWVyIHRvIGNhbmNlbFxuICAgICAgICAgKiBAcmV0dXJucyBUaW1lclxuICAgICAgICAgKi9cbiAgICAgICAgU2NlbmUucHJvdG90eXBlLmNhbmNlbFRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxRdWV1ZS5wdXNoKHRpbWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3RzIHdoZXRoZXIgYSB0aW1lciBpcyBhY3RpdmUgaW4gdGhlIHNjZW5lXG4gICAgICAgICAqIEBtZXRob2QgaXNUaW1lckFjdGl2ZVxuICAgICAgICAgKiBAcGFyYW0gdGltZXIge1RpbWVyfVxuICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBTY2VuZS5wcm90b3R5cGUuaXNUaW1lckFjdGl2ZSA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl90aW1lcnMuaW5kZXhPZih0aW1lcikgPiAtMSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTY2VuZTtcbiAgICB9KShleC5DbGFzcyk7XG4gICAgZXguU2NlbmUgPSBTY2VuZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWxnZWJyYS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRW5naW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIEludGVybmFsO1xuICAgIChmdW5jdGlvbiAoSW50ZXJuYWwpIHtcbiAgICAgICAgdmFyIEFjdGlvbnM7XG4gICAgICAgIChmdW5jdGlvbiAoQWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIEVhc2VUbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRWFzZVRvKGFjdG9yLCB4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXNpbmdGY24gPSBlYXNpbmdGY247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IDEgKiAxMDAwOyAvLyA1IHNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbmV3IGV4LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbmV3IGV4LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgZXguUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEVhc2VUby5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBleC5Qb2ludCh0aGlzLmFjdG9yLngsIHRoaXMuYWN0b3IueSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbGVycFN0YXJ0LnRvVmVjdG9yKCkuZGlzdGFuY2UodGhpcy5fbGVycEVuZC50b1ZlY3RvcigpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEVhc2VUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3WCA9IHRoaXMuYWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1kgPSB0aGlzLmFjdG9yLnk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnggPCB0aGlzLl9sZXJwU3RhcnQueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ggPSB0aGlzLl9sZXJwU3RhcnQueCAtICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WCA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LngsIHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycER1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnkgPCB0aGlzLl9sZXJwU3RhcnQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1kgPSB0aGlzLl9sZXJwU3RhcnQueSAtICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WSA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycER1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueCA9IG5ld1g7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSBuZXdZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci54ID0gdGhpcy5fbGVycEVuZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci55ID0gdGhpcy5fbGVycEVuZC55O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBFYXNlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKG5ldyBleC5WZWN0b3IoYWN0b3IueCwgYWN0b3IueSkpLmRpc3RhbmNlKHRoaXMuX2xlcnBTdGFydC50b1ZlY3RvcigpKSA+PSB0aGlzLl9kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEVhc2VUby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBFYXNlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVhc2VUbztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLkVhc2VUbyA9IEVhc2VUbztcbiAgICAgICAgICAgIHZhciBNb3ZlVG8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1vdmVUbyhhY3RvciwgZGVzdHgsIGRlc3R5LCBzcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBleC5WZWN0b3IoZGVzdHgsIGRlc3R5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNb3ZlVG8ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBleC5WZWN0b3IodGhpcy5hY3Rvci54LCB0aGlzLmFjdG9yLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMuc3RhcnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmVuZC5taW51cyh0aGlzLnN0YXJ0KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuZGlyLnNjYWxlKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gbS54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gbS55O1xuICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIlBvcyB4OiBcIiArIHRoaXMuYWN0b3IueCArXCIgIHk6XCIgKyB0aGlzLmFjdG9yLnksIExvZy5ERUJVRyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueCA9IHRoaXMuZW5kLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSB0aGlzLmVuZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTW92ZVRvLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChuZXcgZXguVmVjdG9yKGFjdG9yLngsIGFjdG9yLnkpKS5kaXN0YW5jZSh0aGlzLnN0YXJ0KSA+PSB0aGlzLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTW92ZVRvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTW92ZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vdmVUbztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLk1vdmVUbyA9IE1vdmVUbztcbiAgICAgICAgICAgIHZhciBNb3ZlQnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1vdmVCeShhY3RvciwgZGVzdHgsIGRlc3R5LCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IGV4LlZlY3RvcihkZXN0eCwgZGVzdHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihcIkF0dGVtcHRlZCB0byBtb3ZlQnkgdGltZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyA6IFwiICsgdGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW92ZSBpbiB0aW1lIDw9IDBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgZXguVmVjdG9yKHRoaXMuYWN0b3IueCwgdGhpcy5hY3Rvci55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLnN0YXJ0LmRpc3RhbmNlKHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyID0gdGhpcy5lbmQubWludXModGhpcy5zdGFydCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gdGhpcy5kaXN0YW5jZSAvICh0aGlzLnRpbWUgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuZGlyLnNjYWxlKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gbS54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gbS55O1xuICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIlBvcyB4OiBcIiArIHRoaXMuYWN0b3IueCArXCIgIHk6XCIgKyB0aGlzLmFjdG9yLnksIExvZy5ERUJVRyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IueCA9IHRoaXMuZW5kLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnkgPSB0aGlzLmVuZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChuZXcgZXguVmVjdG9yKGFjdG9yLngsIGFjdG9yLnkpKS5kaXN0YW5jZSh0aGlzLnN0YXJ0KSA+PSB0aGlzLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTW92ZUJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1vdmVCeTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLk1vdmVCeSA9IE1vdmVCeTtcbiAgICAgICAgICAgIHZhciBGb2xsb3cgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZvbGxvdyhhY3RvciwgYWN0b3JUb0ZvbGxvdywgZm9sbG93RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvclRvRm9sbG93ID0gYWN0b3JUb0ZvbGxvdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IGV4LlZlY3Rvcih0aGlzLmFjdG9yLngsIHRoaXMuYWN0b3IueSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IGV4LlZlY3RvcihhY3RvclRvRm9sbG93LngsIGFjdG9yVG9Gb2xsb3cueSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4aW11bURpc3RhbmNlID0gKGZvbGxvd0Rpc3RhbmNlICE9IHVuZGVmaW5lZCkgPyBmb2xsb3dEaXN0YW5jZSA6IHRoaXMuY3VycmVudC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBGb2xsb3cucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZUJldHdlZW4gPSB0aGlzLmN1cnJlbnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmVuZC5taW51cyh0aGlzLmN1cnJlbnQpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RvclRvRm9sbG93U3BlZWQgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5hY3RvclRvRm9sbG93LmR4LCAyKSArIE1hdGgucG93KHRoaXMuYWN0b3JUb0ZvbGxvdy5keSwgMikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0b3JUb0ZvbGxvd1NwZWVkICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBhY3RvclRvRm9sbG93U3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmFjdG9yLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5hY3Rvci55O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZC54ID0gdGhpcy5hY3RvclRvRm9sbG93Lng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kLnkgPSB0aGlzLmFjdG9yVG9Gb2xsb3cueTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZUJldHdlZW4gPSB0aGlzLmN1cnJlbnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuZW5kLm1pbnVzKHRoaXMuY3VycmVudCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc3RhbmNlQmV0d2VlbiA+PSB0aGlzLm1heGltdW1EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLmRpci5zY2FsZSh0aGlzLnNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSBtLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gbS55O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLmR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnggPSB0aGlzLmVuZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci55ID0gdGhpcy5lbmQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZvbGxvdy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZvbGxvdy5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0b3IgZm9sbG93aW5nIHNob3VsZCBuZXZlciBzdG9wIHVubGVzcyBzcGVjaWZpZWQgdG8gZG8gc29cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBGb2xsb3cucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9sbG93O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuRm9sbG93ID0gRm9sbG93O1xuICAgICAgICAgICAgdmFyIE1lZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1lZXQoYWN0b3IsIGFjdG9yVG9NZWV0LCBzcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yVG9NZWV0ID0gYWN0b3JUb01lZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBleC5WZWN0b3IodGhpcy5hY3Rvci54LCB0aGlzLmFjdG9yLnkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBleC5WZWN0b3IoYWN0b3JUb01lZXQueCwgYWN0b3JUb01lZXQueSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlZWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgTWVldC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlQmV0d2VlbiA9IHRoaXMuY3VycmVudC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IHRoaXMuZW5kLm1pbnVzKHRoaXMuY3VycmVudCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdG9yVG9NZWV0U3BlZWQgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5hY3RvclRvTWVldC5keCwgMikgKyBNYXRoLnBvdyh0aGlzLmFjdG9yVG9NZWV0LmR5LCAyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYWN0b3JUb01lZXRTcGVlZCAhPSAwKSAmJiAoIXRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IGFjdG9yVG9NZWV0U3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmFjdG9yLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5hY3Rvci55O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZC54ID0gdGhpcy5hY3RvclRvTWVldC54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZC55ID0gdGhpcy5hY3RvclRvTWVldC55O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlQmV0d2VlbiA9IHRoaXMuY3VycmVudC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyID0gdGhpcy5lbmQubWludXModGhpcy5jdXJyZW50KS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLmRpci5zY2FsZSh0aGlzLnNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IG0ueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IG0ueTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJtZWV0aW5nIGlzIGNvbXBsZXRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnggPSB0aGlzLmVuZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci55ID0gdGhpcy5lbmQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1lZXQucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuZGlzdGFuY2VCZXR3ZWVuIDw9IDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWVldC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5keSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IuZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1lZXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWVldDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLk1lZXQgPSBNZWV0O1xuICAgICAgICAgICAgdmFyIFJvdGF0ZVRvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSb3RhdGVUbyhhY3RvciwgYW5nbGVSYWRpYW5zLCBzcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IGFuZ2xlUmFkaWFucztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5hY3Rvci5yb3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBNYXRoLmFicyh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucnggPSB0aGlzLnNwZWVkO1xuICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIlBvcyB4OiBcIiArIHRoaXMuYWN0b3IueCArXCIgIHk6XCIgKyB0aGlzLmFjdG9yLnksIExvZy5ERUJVRyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iucm90YXRpb24gPSB0aGlzLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucnggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSb3RhdGVUby5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAoTWF0aC5hYnModGhpcy5hY3Rvci5yb3RhdGlvbiAtIHRoaXMuc3RhcnQpID49IHRoaXMuZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUm90YXRlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IucnggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJvdGF0ZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJvdGF0ZVRvO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuUm90YXRlVG8gPSBSb3RhdGVUbztcbiAgICAgICAgICAgIHZhciBSb3RhdGVCeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUm90YXRlQnkoYWN0b3IsIGFuZ2xlUmFkaWFucywgdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IGFuZ2xlUmFkaWFucztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9ICh0aGlzLmVuZCAtIHRoaXMuYWN0b3Iucm90YXRpb24pIC8gdGltZSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLmFjdG9yLnJvdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IE1hdGguYWJzKHRoaXMuZW5kIC0gdGhpcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IHRoaXMuc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkubG9nKFwiUG9zIHg6IFwiICsgdGhpcy5hY3Rvci54ICtcIiAgeTpcIiArIHRoaXMuYWN0b3IueSwgTG9nLkRFQlVHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSh0aGlzLmFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yb3RhdGlvbiA9IHRoaXMuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJvdGF0ZUJ5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IChNYXRoLmFicyh0aGlzLmFjdG9yLnJvdGF0aW9uIC0gdGhpcy5zdGFydCkgPj0gdGhpcy5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSb3RhdGVCeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5yeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUm90YXRlQnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUm90YXRlQnk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5Sb3RhdGVCeSA9IFJvdGF0ZUJ5O1xuICAgICAgICAgICAgdmFyIFNjYWxlVG8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNjYWxlVG8oYWN0b3IsIHNjYWxlWCwgc2NhbGVZLCBzcGVlZFgsIHNwZWVkWSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFggPSBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kWSA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZFggPSBzcGVlZFg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWRZID0gc3BlZWRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRYID0gdGhpcy5hY3Rvci5zY2FsZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFkgPSB0aGlzLmFjdG9yLnNjYWxlLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlWCA9IE1hdGguYWJzKHRoaXMuZW5kWCAtIHRoaXMuc3RhcnRYKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VZID0gTWF0aC5hYnModGhpcy5lbmRZIC0gdGhpcy5zdGFydFkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKE1hdGguYWJzKHRoaXMuYWN0b3Iuc2NhbGUueCAtIHRoaXMuc3RhcnRYKSA+PSB0aGlzLmRpc3RhbmNlWCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25YID0gdGhpcy5lbmRZIDwgdGhpcy5zdGFydFkgPyAtMSA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gdGhpcy5zcGVlZFggKiBkaXJlY3Rpb25YO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnModGhpcy5hY3Rvci5zY2FsZS55IC0gdGhpcy5zdGFydFkpID49IHRoaXMuZGlzdGFuY2VZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblkgPSB0aGlzLmVuZFkgPCB0aGlzLnN0YXJ0WSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSB0aGlzLnNwZWVkWSAqIGRpcmVjdGlvblk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmxvZyhcIlBvcyB4OiBcIiArIHRoaXMuYWN0b3IueCArXCIgIHk6XCIgKyB0aGlzLmFjdG9yLnksIExvZy5ERUJVRyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc2NhbGUueCA9IHRoaXMuZW5kWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc2NhbGUueSA9IHRoaXMuZW5kWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKChNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnkgLSB0aGlzLnN0YXJ0WCkgPj0gdGhpcy5kaXN0YW5jZVgpICYmIChNYXRoLmFicyh0aGlzLmFjdG9yLnNjYWxlLnkgLSB0aGlzLnN0YXJ0WSkgPj0gdGhpcy5kaXN0YW5jZVkpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFNjYWxlVG8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBTY2FsZVRvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNjYWxlVG87XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5TY2FsZVRvID0gU2NhbGVUbztcbiAgICAgICAgICAgIHZhciBTY2FsZUJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBTY2FsZUJ5KGFjdG9yLCBzY2FsZVgsIHNjYWxlWSwgdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFggPSBzY2FsZVg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kWSA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGVlZFggPSAodGhpcy5lbmRYIC0gdGhpcy5hY3Rvci5zY2FsZS54KSAvIHRpbWUgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkWSA9ICh0aGlzLmVuZFkgLSB0aGlzLmFjdG9yLnNjYWxlLnkpIC8gdGltZSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFNjYWxlQnkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFggPSB0aGlzLmFjdG9yLnNjYWxlLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0WSA9IHRoaXMuYWN0b3Iuc2NhbGUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VYID0gTWF0aC5hYnModGhpcy5lbmRYIC0gdGhpcy5zdGFydFgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLmVuZFkgLSB0aGlzLnN0YXJ0WSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblggPSB0aGlzLmVuZFggPCB0aGlzLnN0YXJ0WCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvblkgPSB0aGlzLmVuZFkgPCB0aGlzLnN0YXJ0WSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeCA9IHRoaXMuc3BlZWRYICogZGlyZWN0aW9uWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IHRoaXMuc3BlZWRZICogZGlyZWN0aW9uWTtcbiAgICAgICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5sb2coXCJQb3MgeDogXCIgKyB0aGlzLmFjdG9yLnggK1wiICB5OlwiICsgdGhpcy5hY3Rvci55LCBMb2cuREVCVUcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnNjYWxlLnggPSB0aGlzLmVuZFg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnNjYWxlLnkgPSB0aGlzLmVuZFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3Iuc3kgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICgoTWF0aC5hYnModGhpcy5hY3Rvci5zY2FsZS54IC0gdGhpcy5zdGFydFgpID49IHRoaXMuZGlzdGFuY2VYKSAmJiAoTWF0aC5hYnModGhpcy5hY3Rvci5zY2FsZS55IC0gdGhpcy5zdGFydFkpID49IHRoaXMuZGlzdGFuY2VZKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBTY2FsZUJ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnN4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5zeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgU2NhbGVCeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBTY2FsZUJ5O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuU2NhbGVCeSA9IFNjYWxlQnk7XG4gICAgICAgICAgICB2YXIgRGVsYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIERlbGF5KGFjdG9yLCBkZWxheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBEZWxheS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5hY3Rvci54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLmFjdG9yLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEZWxheS5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5lbGFwc2VkVGltZSA+PSB0aGlzLmRlbGF5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIERlbGF5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIERlbGF5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBEZWxheTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLkRlbGF5ID0gRGVsYXk7XG4gICAgICAgICAgICB2YXIgQmxpbmsgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJsaW5rKGFjdG9yLCB0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtQmxpbmtzID09PSB2b2lkIDApIHsgbnVtQmxpbmtzID0gMTsgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVWaXNpYmxlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lTm90VmlzaWJsZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZVZpc2libGUgPSB0aW1lVmlzaWJsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lTm90VmlzaWJsZSA9IHRpbWVOb3RWaXNpYmxlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gKHRpbWVWaXNpYmxlICsgdGltZU5vdFZpc2libGUpICogbnVtQmxpbmtzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBCbGluay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgKz0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdG9yLnZpc2libGUgJiYgdGhpcy5lbGFwc2VkVGltZSA+PSB0aGlzLnRpbWVWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY3Rvci52aXNpYmxlICYmIHRoaXMuZWxhcHNlZFRpbWUgPj0gdGhpcy50aW1lTm90VmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5hY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsaW5rLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLnRvdGFsVGltZSA+PSB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsaW5rLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJsaW5rLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJsaW5rO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuQmxpbmsgPSBCbGluaztcbiAgICAgICAgICAgIHZhciBGYWRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGYWRlKGFjdG9yLCBlbmRPcGFjaXR5LCBzcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGx5ZXIgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZE9wYWNpdHkgPSBlbmRPcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRPcGFjaXR5IDwgYWN0b3Iub3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBseWVyID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRmFkZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLm9wYWNpdHkgKz0gdGhpcy5tdWx0aXBseWVyICogKE1hdGguYWJzKHRoaXMuYWN0b3Iub3BhY2l0eSAtIHRoaXMuZW5kT3BhY2l0eSkgKiBkZWx0YSkgLyB0aGlzLnNwZWVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgLT0gZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKFwiYWN0b3Igb3BhY2l0eTogXCIgKyB0aGlzLmFjdG9yLm9wYWNpdHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yLm9wYWNpdHkgPSB0aGlzLmVuZE9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZhZGUucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKE1hdGguYWJzKHRoaXMuYWN0b3Iub3BhY2l0eSAtIHRoaXMuZW5kT3BhY2l0eSkgPCAwLjA1KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEZhZGUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRmFkZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBGYWRlO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuRmFkZSA9IEZhZGU7XG4gICAgICAgICAgICB2YXIgRGllID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBEaWUoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgRGllLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rvci5raWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRGllLnByb3RvdHlwZS5pc0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIERpZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIERpZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGllO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuRGllID0gRGllO1xuICAgICAgICAgICAgdmFyIENhbGxNZXRob2QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENhbGxNZXRob2QoYWN0b3IsIG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0aG9kLmNhbGwodGhpcy5fYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENhbGxNZXRob2QucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0JlZW5DYWxsZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDYWxsTWV0aG9kLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2FsbE1ldGhvZC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2FsbE1ldGhvZDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLkNhbGxNZXRob2QgPSBDYWxsTWV0aG9kO1xuICAgICAgICAgICAgdmFyIFJlcGVhdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUmVwZWF0KGFjdG9yLCByZXBlYXQsIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uUXVldWUoYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbFJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWN0aW9uUXVldWUuYWRkKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSZXBlYXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLmFjdG9yLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuYWN0b3IueTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGlvblF1ZXVlLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBlYXQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSZXBlYXQucHJvdG90eXBlLmlzQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8ICh0aGlzLnJlcGVhdCA8PSAwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSZXBlYXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdCA9IHRoaXMub3JpZ2luYWxSZXBlYXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVwZWF0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIEFjdGlvbnMuUmVwZWF0ID0gUmVwZWF0O1xuICAgICAgICAgICAgdmFyIFJlcGVhdEZvcmV2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFJlcGVhdEZvcmV2ZXIoYWN0b3IsIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUgPSBuZXcgQWN0aW9uUXVldWUoYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3Rpb25RdWV1ZS5hZGQoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLmFjdG9yLng7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuYWN0b3IueTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aW9uUXVldWUuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUmVwZWF0Rm9yZXZlci5wcm90b3R5cGUuaXNDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBSZXBlYXRGb3JldmVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFJlcGVhdEZvcmV2ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlcGVhdEZvcmV2ZXI7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgQWN0aW9ucy5SZXBlYXRGb3JldmVyID0gUmVwZWF0Rm9yZXZlcjtcbiAgICAgICAgICAgIHZhciBBY3Rpb25RdWV1ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQWN0aW9uUXVldWUoYWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBBY3Rpb25RdWV1ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9hY3Rpb25zLmluZGV4T2YoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmNsZWFyQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24uc3RvcCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLmdldEFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmNvbmNhdCh0aGlzLl9jb21wbGV0ZWRBY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQWN0aW9uUXVldWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25zID0gdGhpcy5nZXRBY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEFjdGlvblF1ZXVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IHRoaXMuX2FjdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEFjdGlvbi5pc0NvbXBsZXRlKHRoaXMuYWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5sb2coXCJBY3Rpb24gY29tcGxldGUhXCIsIExvZy5ERUJVRyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucy5wdXNoKHRoaXMuX2FjdGlvbnMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBBY3Rpb25RdWV1ZTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICBBY3Rpb25zLkFjdGlvblF1ZXVlID0gQWN0aW9uUXVldWU7XG4gICAgICAgIH0pKEFjdGlvbnMgPSBJbnRlcm5hbC5BY3Rpb25zIHx8IChJbnRlcm5hbC5BY3Rpb25zID0ge30pKTtcbiAgICB9KShJbnRlcm5hbCA9IGV4LkludGVybmFsIHx8IChleC5JbnRlcm5hbCA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBFYXNpbmdGdW5jdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFYXNpbmdGdW5jdGlvbnMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgfSxcbiAgICAgICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqICgyIC0gdCkgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA8IC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdCAqIHQgfSxcbiAgICAgICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgICAgIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuICgtLXQpICogdCAqIHQgKyAxIH0sXG4gICAgICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxIH0sXG4gICAgICAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAgIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAqIHQgKiB0ICogdCB9LFxuICAgICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSAtICgtLXQpICogdCAqIHQgKiB0IH0sXG4gICAgICAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gICAgICAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogKC0tdCkgKiB0ICogdCAqIHQgfSxcbiAgICAgICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ICogdCAqIHQgKiB0ICogdCB9LFxuICAgICAgIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSArICgtLXQpICogdCAqIHQgKiB0ICogdCB9LFxuICAgICAgIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAgIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCA8IC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqICgtLXQpICogdCAqIHQgKiB0ICogdCB9XG4gICAgICAgICovXG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5MaW5lYXIgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluUXVhZCA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvL2VuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZU91dFF1YWQgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgLy9lbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gLWVuZFZhbHVlICogY3VycmVudFRpbWUgKiAoY3VycmVudFRpbWUgLSAyKSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGVuZFZhbHVlID0gKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPCAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZSAvIDIgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lLS07XG4gICAgICAgICAgICByZXR1cm4gLWVuZFZhbHVlIC8gMiAqIChjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpIC0gMSkgKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluQ3ViaWMgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRWFzaW5nRnVuY3Rpb25zLkVhc2VPdXRDdWJpYyA9IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWUgKiAoY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgMSkgKyBzdGFydFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBFYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWMgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSAoZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICBjdXJyZW50VGltZSAtPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlIC8gMiAqIChjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyAyKSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFYXNpbmdGdW5jdGlvbnM7XG4gICAgfSkoKTtcbiAgICBleC5FYXNpbmdGdW5jdGlvbnMgPSBFYXNpbmdGdW5jdGlvbnM7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkludGVyZmFjZXMvSURyYXdhYmxlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJNb2R1bGVzL01vdmVtZW50TW9kdWxlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJNb2R1bGVzL09mZnNjcmVlbkN1bGxpbmdNb2R1bGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vZHVsZXMvQ2FwdHVyZVBvaW50ZXJNb2R1bGUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vZHVsZXMvQ29sbGlzaW9uRGV0ZWN0aW9uTW9kdWxlLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb2xsaXNpb24vU2lkZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWxnZWJyYS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVXRpbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVGlsZU1hcC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29sbGlzaW9uL0JvdW5kaW5nQm94LnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTY2VuZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0aW9uLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFYXNpbmdGdW5jdGlvbnMudHNcIi8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgdHlwZXMgb2YgY29sbGlzaW9ucyBhY3RvcnMgY2FuIHBhcnRpY2lwYXRlIGluXG4gICAgICogQGNsYXNzIENvbGxpc2lvblR5cGVcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKENvbGxpc2lvblR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdG9ycyB3aXRoIHRoZSBQcmV2ZW50Q29sbGlzaW9uIHNldHRpbmcgZG8gbm90IHBhcnRpY2lwYXRlIGluIGFueVxuICAgICAgICAgKiBjb2xsaXNpb25zIGFuZCBkbyBub3QgcmFpc2UgY29sbGlzaW9uIGV2ZW50cy5cbiAgICAgICAgICogQHByb3BlcnR5IFByZXZlbnRDb2xsaXNpb24ge0NvbGxpc2lvblR5cGV9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIlByZXZlbnRDb2xsaXNpb25cIl0gPSAwXSA9IFwiUHJldmVudENvbGxpc2lvblwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIFBhc3NpdmUgc2V0dGluZyBvbmx5IHJhaXNlIGNvbGxpc2lvbiBldmVudHMsIGJ1dCBhcmUgbm90XG4gICAgICAgICAqIGluZmx1ZW5jZWQgb3IgbW92ZWQgYnkgb3RoZXIgYWN0b3JzIGFuZCBkbyBub3QgaW5mbHVlbmNlIG9yIG1vdmUgb3RoZXIgYWN0b3JzLlxuICAgICAgICAgKiBAcHJvcGVydHkgUGFzc2l2ZSB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiUGFzc2l2ZVwiXSA9IDFdID0gXCJQYXNzaXZlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RvcnMgd2l0aCB0aGUgQWN0aXZlIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGVcbiAgICAgICAgICogaW4gY29sbGlzaW9ucyB3aXRoIG90aGVyIGFjdG9ycyBhbmQgd2lsbCBiZSBwdXNoIG9yIG1vdmVkIGJ5IGFjdG9ycyBzaGFyaW5nXG4gICAgICAgICAqIHRoZSBBY3RpdmUgb3IgRml4ZWQgc2V0dGluZy5cbiAgICAgICAgICogQHByb3BlcnR5IEFjdGl2ZSB7Q29sbGlzaW9uVHlwZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sbGlzaW9uVHlwZVtDb2xsaXNpb25UeXBlW1wiQWN0aXZlXCJdID0gMl0gPSBcIkFjdGl2ZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIEVsYXN0aWMgc2V0dGluZyB3aWxsIGJlaGF2ZSB0aGUgc2FtZSBhcyBBY3RpdmUsIGV4Y2VwdCB0aGF0IHRoZXkgd2lsbFxuICAgICAgICAgKiBcImJvdW5jZVwiIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gZ2l2ZW4gdGhlaXIgdmVsb2NpdHkgZHgvZHkuIFRoaXMgaXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiBtZWFudCBmb3JcbiAgICAgICAgICogcHJvdG90eXBpbmcsIGZvciBhIG1vcmUgcm9idXN0IGVsYXN0aWMgY29sbGlzaW9uIGxpc3RlbiB0byB0aGUgXCJjb2xsaXNpb25cIiBldmVudCBhbmQgcGVyZm9ybSB5b3VyIGN1c3RvbSBsb2dpYy5cbiAgICAgICAgICogQHByb3BlcnR5IEVsYXN0aWMge0NvbGxpc2lvblR5cGV9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIkVsYXN0aWNcIl0gPSAzXSA9IFwiRWxhc3RpY1wiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWN0b3JzIHdpdGggdGhlIEZpeGVkIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGUgaW5cbiAgICAgICAgICogY29sbGlzaW9ucyB3aXRoIG90aGVyIGFjdG9ycy4gQWN0b3JzIHdpdGggdGhlIEZpeGVkIHNldHRpbmcgd2lsbCBub3QgYmVcbiAgICAgICAgICogcHVzaGVkIG9yIG1vdmVkIGJ5IG90aGVyIGFjdG9ycyBzaGFyaW5nIHRoZSBGaXhlZCBvciBBY3RvcnMuIFRoaW5rIG9mIEZpeGVkXG4gICAgICAgICAqIGFjdG9ycyBhcyBcImltbW92YWJsZS9vbnN0b3BwYWJsZVwiIG9iamVjdHMuIElmIHR3byBGaXhlZCBhY3RvcnMgbWVldCB0aGV5IHdpbGxcbiAgICAgICAgICogbm90IGJlIHB1c2hlZCBvciBtb3ZlZCBieSBlYWNoIG90aGVyLCB0aGV5IHdpbGwgbm90IGludGVyYWN0IGV4Y2VwdCB0byB0aHJvd1xuICAgICAgICAgKiBjb2xsaXNpb24gZXZlbnRzLlxuICAgICAgICAgKiBAcHJvcGVydHkgRml4ZWQge0NvbGxpc2lvblR5cGV9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIENvbGxpc2lvblR5cGVbQ29sbGlzaW9uVHlwZVtcIkZpeGVkXCJdID0gNF0gPSBcIkZpeGVkXCI7XG4gICAgfSkoZXguQ29sbGlzaW9uVHlwZSB8fCAoZXguQ29sbGlzaW9uVHlwZSA9IHt9KSk7XG4gICAgdmFyIENvbGxpc2lvblR5cGUgPSBleC5Db2xsaXNpb25UeXBlO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IGltcG9ydGFudCBwcmltaXRpdmUgaW4gRXhjYWxpYnVyIGlzIGFuIFwiQWN0b3IuXCIgQW55dGhpbmcgdGhhdFxuICAgICAqIGNhbiBtb3ZlIG9uIHRoZSBzY3JlZW4sIGNvbGxpZGUgd2l0aCBhbm90aGVyIEFjdG9yLCByZXNwb25kIHRvIGV2ZW50cyxcbiAgICAgKiBvciBpbnRlcmFjdCB3aXRoIHRoZSBjdXJyZW50IHNjZW5lLCBtdXN0IGJlIGFuIGFjdG9yLiBBbiBBY3RvciA8Yj5tdXN0PC9iPlxuICAgICAqIGJlIHBhcnQgb2YgYSB7eyNjcm9zc0xpbmsgXCJTY2VuZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgaXQgdG8gYmUgZHJhd24gdG8gdGhlIHNjcmVlbi5cbiAgICAgKiBAY2xhc3MgQWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBDbGFzc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbeD0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyB4IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFt5PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHkgY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW3dpZHRoPTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIHdpZHRoIG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbaGVpZ2h0PTAuMF0ge251bWJlcn0gVGhlIHN0YXJ0aW5nIGhlaWdodCBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW2NvbG9yPXVuZGVmaW5lZF0ge0NvbG9yfSBUaGUgc3RhcnRpbmcgY29sb3Igb2YgdGhlIGFjdG9yXG4gICAgICovXG4gICAgdmFyIEFjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEFjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBY3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGFjdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaWQgPSBBY3Rvci5tYXhJZCsrO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBhY3RvciAobGVmdCBlZGdlKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYWN0b3IgKHRvcCBlZGdlKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHkge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGFjdG9yIGluIHJhZGlhbnNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSByb3RhdGlvbiB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDsgLy8gcmFkaWFuc1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNvbmRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSByeCB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJ4ID0gMDsgLy9yYWRpb25zL3NlY1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgc2NhbGUgdmVjdG9yIG9mIHRoZSBhY3RvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHNjYWxlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgZXguVmVjdG9yKDEsIDEpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeCBzY2FsYXIgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHNjYWxlL3NlY29uZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHN4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3ggPSAwOyAvL3NjYWxlL3NlY1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeSBzY2FsYXIgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHNjYWxlL3NlY29uZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHN5IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3kgPSAwOyAvL3NjYWxlL3NlY1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgeCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IGR4IHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZHggPSAwOyAvLyBwaXhlbHMvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB4IHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgZHgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5keSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB4IGFjY2VsZXJhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZF4yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgYXgge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5heCA9IDA7IC8vIHBpeGVscy9zZWMvc2VjXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB5IGFjY2VsZXJhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZF4yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgYXkge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5heSA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3ZXRoZXIgdGhlIGFjdG9yIGlzIHBoeXNpY2FsbHkgaW4gdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgaXNPZmZTY3JlZW4ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNPZmZTY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZpc2liaWxpdHkgb2YgYW4gYWN0b3JcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB2aXNpYmxlIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgb3BhY2l0eSBvZiBhbiBhY3RvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IG9wYWNpdHkge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNPcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVuaWVuY2UgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgbG9nZ2VyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgbG9nZ2VyIHtMb2dnZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogVGhlIHNjZW5lIHRoYXQgdGhlIGFjdG9yIGlzIGluXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSBzY2VuZSB7U2NlbmV9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7IC8vZm9ybWVybHkgXCJwYXJlbnRcIlxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIFRoZSBwYXJlbnQgb2YgdGhpcyBhY3RvclxuICAgICAgICAgICAgKiBAcHJvcGVydHkgcGFyZW50IHtBY3Rvcn1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBjb2xsaXNpb24gdHlwZSBvZiB0aGlzIGFjdG9yLiBCeVxuICAgICAgICAgICAgICogZGVmYXVsdCBhbGwgYWN0b3JzIHBhcnRpY2lwYXRlIGluIEFjdGl2ZSBjb2xsaXNpb25zLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGNvbGxpc2lvblR5cGUge0NvbGxpc2lvblR5cGV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXBzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5mcmFtZXMgPSB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWNjZXNzIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcgb24gZm9yIHRoZSBhY3RvciwgdGhpcyBjYW4gYmUgYW4ge3sjY3Jvc3NMaW5rIFwiQW5pbWF0aW9uXCJ9fXt7L2Nyb3NzTGlua319LFxuICAgICAgICAgICAgICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlXCJ9fXt7L2Nyb3NzTGlua319LCBvciB7eyNjcm9zc0xpbmsgXCJQb2x5Z29uXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAgICAgICAgICogU2V0IGRyYXdpbmdzIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIkFjdG9yL3NldERyYXdpbmc6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAgICAgICAgICogQHByb3BlcnR5IGN1cnJlbnREcmF3aW5nIHtJRHJhd2FibGV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJEcmF3aW5nWCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJEcmF3aW5nWSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNb2RpZnkgdGhlIGN1cnJlbnQgYWN0b3IgdXBkYXRlIHBpcGVsaW5lLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gZW5hYmxlIHRoZSBDYXB0dXJlUG9pbnRlciB0cmFpdCB0aGF0IHByb3BvZ2F0ZXMgcG9pbnRlciBldmVudHMgdG8gdGhpcyBhY3RvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtlbmFibGVDYXB0dXJlUG9pbnRlcj1mYWxzZV0ge2Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2FwdHVyZVBvaW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uZmlndXJhdGlvbiBmb3IgQ2FwdHVyZVBvaW50ZXIgdHJhaXRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBjYXB0dXJlUG9pbnRlciB7SUNhcHR1cmVQb2ludGVyQ29uZmlnfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVQb2ludGVyID0ge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVNb3ZlRXZlbnRzOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2lzS2lsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgICAgICAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBvcGFjaXR5IG9mIGFuIGFjdG9yIHRvIHRoZSBjb2xvclxuICAgICAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGNvbG9yLmE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWlsZCBkZWZhdWx0IHBpcGVsaW5lXG4gICAgICAgICAgICB0aGlzLnBpcGVsaW5lLnB1c2gobmV3IGV4Lk1vdmVtZW50TW9kdWxlKCkpO1xuICAgICAgICAgICAgLy90aGlzLnBpcGVsaW5lLnB1c2gobmV3IGV4LkNvbGxpc2lvbkRldGVjdGlvbk1vZHVsZSgpKTtcbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUucHVzaChuZXcgZXguT2Zmc2NyZWVuQ3VsbGluZ01vZHVsZSgpKTtcbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUucHVzaChuZXcgZXguQ2FwdHVyZVBvaW50ZXJNb2R1bGUoKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlID0gbmV3IGV4LkludGVybmFsLkFjdGlvbnMuQWN0aW9uUXVldWUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lTm9kZSA9IG5ldyBleC5TY2VuZSgpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZU5vZGUuYWN0b3IgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5hbmNob3IgPSBuZXcgZXguUG9pbnQoLjUsIC41KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgb2YgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxuICAgICAgICAgKiBvdmVycmlkZGVuLiBUaGlzIGlzIHdoZXJlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkIGFjdG9ycyBzaG91bGQgdGFrZSBwbGFjZS5cbiAgICAgICAgICogQG1ldGhvZCBvbkluaXRpYWxpemVcbiAgICAgICAgICogQHBhcmFtIGVuZ2luZSB7RW5naW5lfVxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLm9uSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgfTtcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLl9jaGVja0ZvclBvaW50ZXJPcHRJbiA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgJiYgKGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAncG9pbnRlcmRvd24nIHx8IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAncG9pbnRlcmRvd24nIHx8IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAncG9pbnRlcm1vdmUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2FwdHVyZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3BvaW50ZXJtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxuICAgICAgICAqIGV2ZW50cyBvZmYgb2YgdGhlIGVuZ2luZTsgc2VlIHRoZSBldmVudHMgc2VjdGlvbiBiZWxvdyBmb3IgYSBjb21wbGV0ZSBsaXN0LlxuICAgICAgICAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAqIEBwYXJhbSBoYW5kbGVyIHtldmVudD0+dm9pZH0gRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxuICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9yUG9pbnRlck9wdEluKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIFwiYWRkRXZlbnRMaXN0ZW5lclwiLiBZb3UgY2FuIGxpc3RlbiBmb3IgYSB2YXJpZXR5IG9mXG4gICAgICAgICAqIGV2ZW50cyBvZmYgb2YgdGhlIGVuZ2luZTsgc2VlIHRoZSBldmVudHMgc2VjdGlvbiBiZWxvdyBmb3IgYSBjb21wbGV0ZSBsaXN0LlxuICAgICAgICAgKiBAbWV0aG9kIG9uXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUge3N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICAgKiBAcGFyYW0gaGFuZGxlciB7ZXZlbnQ9PnZvaWR9IEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9yUG9pbnRlck9wdEluKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5zdWJzY3JpYmUoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBjdXJyZW50IGFjdG9ycyBpcyBhIG1lbWJlciBvZiB0aGUgc2NlbmUuIFRoaXMgd2lsbCByZW1vdmVcbiAgICAgICAgICogaXQgZnJvbSB0aGUgc2NlbmUgZ3JhcGguIEl0IHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2Qga2lsbFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNLaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkNhbm5vdCBraWxsIGFjdG9yLCBpdCB3YXMgbmV2ZXIgYWRkZWQgdG8gdGhlIFNjZW5lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdldGhlciB0aGUgYWN0b3IgaGFzIGJlZW4ga2lsbGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGlzS2lsbGVkXG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5pc0tpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0tpbGxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBjaGlsZCBhY3RvciB0byB0aGlzIGFjdG9yLiBBbGwgbW92ZW1lbnQgb2YgdGhlIGNoaWxkIGFjdG9yIHdpbGwgYmVcbiAgICAgICAgICogcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBhY3Rvci4gTWVhbmluZyBpZiB0aGUgcGFyZW50IG1vdmVzIHRoZSBjaGlsZCB3aWxsXG4gICAgICAgICAqIG1vdmUgd2l0aFxuICAgICAgICAgKiBAbWV0aG9kIGFkZENoaWxkXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBjaGlsZCBhY3RvciB0byBhZGRcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgYWN0b3IuY29sbGlzaW9uVHlwZSA9IDAgLyogUHJldmVudENvbGxpc2lvbiAqLztcbiAgICAgICAgICAgIHRoaXMuc2NlbmVOb2RlLmFkZENoaWxkKGFjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBjaGlsZCBhY3RvciBmcm9tIHRoaXMgYWN0b3IuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGNoaWxkIGFjdG9yIHRvIHJlbW92ZVxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lTm9kZS5yZW1vdmVDaGlsZChhY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGRyYXdpbmcgb2YgdGhlIGFjdG9yIHRvIHRoZSBkcmF3aW5nIGNvcnJlc3BvZGluZyB0b1xuICAgICAgICAgKiB0aGUga2V5LlxuICAgICAgICAgKiBAbWV0aG9kIHNldERyYXdpbmdcbiAgICAgICAgICogQHBhcmFtIGtleSB7c3RyaW5nfSBUaGUga2V5IG9mIHRoZSBkcmF3aW5nXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2V0RHJhd2luZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmF3aW5nICE9IHRoaXMuZnJhbWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1trZXldLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nID0gdGhpcy5mcmFtZXNba2V5XTtcbiAgICAgICAgfTtcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmFkZERyYXdpbmcgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1thcmd1bWVudHNbMF1dID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50RHJhd2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBleC5TcHJpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREcmF3aW5nKFwiZGVmYXVsdFwiLCBhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgZXguVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERyYXdpbmcoXCJkZWZhdWx0XCIsIGFyZ3VtZW50c1swXS5hc1Nwcml0ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcnRpZmljaWFsbHkgdHJpZ2dlciBhbiBldmVudCBvbiBhbiBhY3RvciwgdXNlZnVsIHdoZW4gY3JlYXRpbmcgY3VzdG9tIGV2ZW50cy5cbiAgICAgICAgICogQG1ldGhvZCB0cmlnZ2VyRXZlbnRcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlclxuICAgICAgICAgKiBAcGFyYW0gW2V2ZW50PXVuZGVmaW5lZF0ge0dhbWVFdmVudH0gVGhlIGV2ZW50IG9iamVjdCB0byBwYXNzIHRvIHRoZSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBhY3RvciB0byBhIGNvbGxpc2lvbiBncm91cC4gQWN0b3JzIHdpdGggbm8gbmFtZWQgY29sbGlzaW9uIGdyb3VwIGFyZVxuICAgICAgICAgKiBjb25zaWRlcmVkIHRvIGJlIGluIGV2ZXJ5IGNvbGxpc2lvbiBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogT25jZSBpbiBhIGNvbGxpc2lvbiBncm91cChzKSBhY3RvcnMgd2lsbCBvbmx5IGNvbGxpZGUgd2l0aCBvdGhlciBhY3RvcnMgaW5cbiAgICAgICAgICogdGhhdCBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhZGRDb2xsaXNpb25Hcm91cFxuICAgICAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgY29sbGlzaW9uIGdyb3VwXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuYWRkQ29sbGlzaW9uR3JvdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMucHVzaChuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbiBhY3RvciBmcm9tIGEgY29sbGlzaW9uIGdyb3VwLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUNvbGxpc2lvbkdyb3VwXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yZW1vdmVDb2xsaXNpb25Hcm91cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uR3JvdXBzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGNlbnRlciBwb2ludCBvZiBhbiBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldENlbnRlclxuICAgICAgICAgKiBAcmV0dXJucyBWZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZEFuY2hvcigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleC5WZWN0b3IodGhpcy54ICsgdGhpcy5nZXRXaWR0aCgpIC8gMiwgdGhpcy55ICsgdGhpcy5nZXRIZWlnaHQoKSAvIDIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY2FsY3VsYXRlZCB3aWR0aCBvZiBhbiBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldFdpZHRoXG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLnNjYWxlLng7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB3aWR0aCBvZiBhbiBhY3RvciwgZmFjdG9yaW5nIGluIHRoZSBjdXJyZW50IHNjYWxlXG4gICAgICAgICAqIEBtZXRob2Qgc2V0V2lkdGhcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gdGhpcy5zY2FsZS54O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgYW4gYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRIZWlnaHRcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ICogdGhpcy5zY2FsZS55O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGFuIGFjdG9yLCBmYWN0b3JpbmcgaW4gdGhlIGN1cnJlbnQgc2NhbGVcbiAgICAgICAgICogQG1ldGhvZCBzZXRIZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHRoaXMuc2NhbGUueTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENlbnRlcnMgdGhlIGFjdG9yJ3MgZHJhd2luZyBhcm91bmQgdGhlIGNlbnRlciBvZiB0aGUgYWN0b3IncyBib3VuZGluZyBib3hcbiAgICAgICAgICogQG1ldGhvZCBzZXRDZW50ZXJEcmF3aW5nXG4gICAgICAgICAqIEBwYXJhbSBjZW50ZXIge2Jvb2xlYW59IEluZGljYXRlcyB0byBjZW50ZXIgdGhlIGRyYXdpbmcgYXJvdW5kIHRoZSBhY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnNldENlbnRlckRyYXdpbmcgPSBmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlckRyYXdpbmdZID0gY2VudGVyO1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJEcmF3aW5nWCA9IGNlbnRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGxlZnQgZWRnZSBvZiB0aGUgYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRMZWZ0XG4gICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRSaWdodFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLmdldFdpZHRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0b3AgZWRnZSBvZiB0aGUgYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCBnZXRUb3BcbiAgICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldEJvdHRvbVxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5nZXRIZWlnaHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICogR2V0cyB0aGUgeCB2YWx1ZSBvZiB0aGUgQWN0b3IgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICAgICogQG1ldGhvZCBnZXRHbG9iYWxYXG4gICAgICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5nZXRHbG9iYWxYID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMucGFyZW50LnNjYWxlLnkgKyB0aGlzLnBhcmVudC5nZXRHbG9iYWxYKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAqIEdldHMgdGhlIHkgdmFsdWUgb2YgdGhlIEFjdG9yIGluIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAgICAqIEBtZXRob2QgZ2V0R2xvYmFsWVxuICAgICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0R2xvYmFsWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKiB0aGlzLnBhcmVudC5zY2FsZS55ICsgdGhpcy5wYXJlbnQuZ2V0R2xvYmFsWSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZ2xvYmFsIHNjYWxlIG9mIHRoZSBBY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGdldEdsb2JhbFNjYWxlXG4gICAgICAgICAqIEByZXR1cm5zIFBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xuICAgICAgICAgICAgdmFyIHBhcmVudFNjYWxlID0gdGhpcy5wYXJlbnQuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQodGhpcy5zY2FsZS54ICogcGFyZW50U2NhbGUueCwgdGhpcy5zY2FsZS55ICogcGFyZW50U2NhbGUueSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhY3RvcidzIGJvdW5kaW5nIGJveCBjYWxjdWxhdGVkIGZvciB0aGlzIGluc3RhbnQuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Qm91bmRzXG4gICAgICAgICAqIEByZXR1cm5zIEJvdW5kaW5nQm94XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2dldENhbGN1bGF0ZWRBbmNob3IoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguQm91bmRpbmdCb3godGhpcy5nZXRHbG9iYWxYKCkgLSBhbmNob3IueCwgdGhpcy5nZXRHbG9iYWxZKCkgLSBhbmNob3IueSwgdGhpcy5nZXRHbG9iYWxYKCkgKyB0aGlzLmdldFdpZHRoKCkgLSBhbmNob3IueCwgdGhpcy5nZXRHbG9iYWxZKCkgKyB0aGlzLmdldEhlaWdodCgpIC0gYW5jaG9yLnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgd2hldGhlciB0aGUgeC95IHNwZWNpZmllZCBhcmUgY29udGFpbmVkIGluIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFggY29vcmRpbmF0ZSB0byB0ZXN0IChpbiB3b3JsZCBjb29yZGluYXRlcylcbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn0gWSBjb29yZGluYXRlIHRvIHRlc3QgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKG5ldyBleC5Qb2ludCh4LCB5KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzaWRlIG9mIHRoZSBjb2xsaXNpb24gYmFzZWQgb24gdGhlIGludGVyc2VjdGlvblxuICAgICAgICAgKiBAbWV0aG9kIGdldFNpZGVGcm9tSW50ZXJzZWN0XG4gICAgICAgICAqIEBwYXJhbSBpbnRlcnNlY3Qge1ZlY3Rvcn0gVGhlIGRpc3BsYWNlbWVudCB2ZWN0b3IgcmV0dXJuZWQgYnkgYSBjb2xsaXNpb25cbiAgICAgICAgICogQHJldHVybnMgU2lkZVxuICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZ2V0U2lkZUZyb21JbnRlcnNlY3QgPSBmdW5jdGlvbiAoaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGludGVyc2VjdC54KSA+IE1hdGguYWJzKGludGVyc2VjdC55KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0LnggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNCAvKiBSaWdodCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBMZWZ0ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdC55IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQm90dG9tICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFRvcCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBhY3RvciBoYXMgY29sbGlkZWQgd2l0aCBhbm90aGVyIGFjdG9yLCByZXR1cm5zIHRoZSBzaWRlIG9mIHRoZSBjdXJyZW50IGFjdG9yIHRoYXQgY29sbGlkZWQuXG4gICAgICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIG90aGVyIGFjdG9yIHRvIHRlc3RcbiAgICAgICAgICogQHJldHVybnMgU2lkZVxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmNvbGxpZGVzV2l0aFNpZGUgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uVmVjdG9yID0gdGhpcy5jb2xsaWRlcyhhY3Rvcik7XG4gICAgICAgICAgICBpZiAoIXNlcGFyYXRpb25WZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNlcGFyYXRpb25WZWN0b3IueCkgPiBNYXRoLmFicyhzZXBhcmF0aW9uVmVjdG9yLnkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMueCA8IGFjdG9yLngpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQgLyogUmlnaHQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBMZWZ0ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnkgPCBhY3Rvci55KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEJvdHRvbSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFRvcCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCB3aGV0aGVyIHRoZSBhY3RvciBoYXMgY29sbGlkZWQgd2l0aCBhbm90aGVyIGFjdG9yLCByZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIG9uIGNvbGxpc2lvbi4gUmV0dXJuc1xuICAgICAgICAgKiBudWxsIHdoZW4gdGhlcmUgaXMgbm8gY29sbGlzaW9uO1xuICAgICAgICAgKiBAbWV0aG9kIGNvbGxpZGVzXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBvdGhlciBhY3RvciB0byB0ZXN0XG4gICAgICAgICAqIEByZXR1cm5zIFZlY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHZhciBvdGhlckJvdW5kcyA9IGFjdG9yLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IGJvdW5kcy5jb2xsaWRlcyhvdGhlckJvdW5kcyk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIHRvIGZpcmUgd2hlbiB0aGlzIGFjdG9yIGNvbGxpZGVzIHdpdGggYW5vdGhlciBpbiBhIHNwZWNpZmllZCBncm91cFxuICAgICAgICAgKiBAbWV0aG9kIG9uQ29sbGlkZXNXaXRoXG4gICAgICAgICAqIEBwYXJhbSBncm91cCB7c3RyaW5nfSBUaGUgZ3JvdXAgbmFtZSB0byBsaXN0ZW4gZm9yXG4gICAgICAgICAqIEBwYXJhbSBmdW5jIHtjYWxsYmFja30gVGhlIGNhbGxiYWNrIHRvIGZpcmUgb24gY29sbGlzaW9uIHdpdGggYW5vdGhlciBhY3RvciBmcm9tIHRoZSBncm91cC4gVGhlIGNhbGxiYWNrIGlzIHBhc3NlZCB0aGUgb3RoZXIgYWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUub25Db2xsaWRlc1dpdGggPSBmdW5jdGlvbiAoZ3JvdXAsIGZ1bmMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uSGFuZGxlcnNbZ3JvdXBdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0ucHVzaChmdW5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmdldENvbGxpc2lvbkhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpc2lvbkhhbmRsZXJzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgY29sbGlzaW9uIGhhbmRsZXJzIGZvciB0aGlzIGdyb3VwIG9uIHRoaXMgYWN0b3JcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVDb2xsaWRlc1dpdGhcbiAgICAgICAgICogQHBhcmFtIGdyb3VwIHtzdHJpbmd9IEdyb3VwIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnMgZm9yIG9uIHRoaXMgYWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUucmVtb3ZlQ29sbGlkZXNXaXRoID0gZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25IYW5kbGVyc1tncm91cF0gPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGFjdG9ycyBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBkaXN0YW5jZSBzcGVjaWZpZWQgZnJvbSBlYWNoIG90aGVyXG4gICAgICAgICAqIEBtZXRob2Qgd2l0aGluXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IEFjdG9yIHRvIHRlc3RcbiAgICAgICAgICogQHBhcmFtIGRpc3RhbmNlIHtudW1iZXJ9IERpc3RhbmNlIGluIHBpeGVscyB0byB0ZXN0XG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbiAoYWN0b3IsIGRpc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIGFjdG9yLngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gYWN0b3IueSwgMikpIDw9IGRpc3RhbmNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBxdWV1ZWQgYWN0aW9ucyBmcm9tIHRoZSBBY3RvclxuICAgICAgICAgKiBAbWV0aG9kIGNsZWFyQWN0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmNsZWFyQWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XG4gICAgICAgIH07XG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5lYXNlVG8gPSBmdW5jdGlvbiAoeCwgeSwgZHVyYXRpb24sIGVhc2luZ0Zjbikge1xuICAgICAgICAgICAgaWYgKGVhc2luZ0ZjbiA9PT0gdm9pZCAwKSB7IGVhc2luZ0ZjbiA9IGV4LkVhc2luZ0Z1bmN0aW9ucy5MaW5lYXI7IH1cbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkVhc2VUbyh0aGlzLCB4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbW92ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgICAqIHNwZWVkIHNwZWNpZmllZCAoaW4gcGl4ZWxzIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXNcbiAgICAgICAgICogbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIG1vdmVUb1xuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSBUaGUgeCBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xuICAgICAgICAgKiBAcGFyYW0geSB7bnVtYmVyfSBUaGUgeSBsb2NhdGlvbiB0byBtb3ZlIHRoZSBhY3RvciB0b1xuICAgICAgICAgKiBAcGFyYW0gc3BlZWQge251bWJlcn0gVGhlIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kIHRvIG1vdmVcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSwgc3BlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLk1vdmVUbyh0aGlzLCB4LCB5LCBzcGVlZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1vdmUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGJ5IGFcbiAgICAgICAgICogY2VydGFpbiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxuICAgICAgICAgKiAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBtb3ZlQnlcbiAgICAgICAgICogQHBhcmFtIHgge251bWJlcn0gVGhlIHggbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgbG9jYXRpb24gdG8gbW92ZSB0aGUgYWN0b3IgdG9cbiAgICAgICAgICogQHBhcmFtIHRpbWUge251bWJlcn0gVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdGhlIGFjdG9yIHRvIG1vdmUgdG8gdGhlIG5ldyBsb2NhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5tb3ZlQnkgPSBmdW5jdGlvbiAoeCwgeSwgdGltZSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuTW92ZUJ5KHRoaXMsIHgsIHksIHRpbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCByb3RhdGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBhbmdsZSBhdCB0aGUgc3BlZWRcbiAgICAgICAgICogc3BlY2lmaWVkIChpbiByYWRpYW5zIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXNcbiAgICAgICAgICogbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHJvdGF0ZVRvXG4gICAgICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnMge251bWJlcn0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0byBpbiByYWRpYW5zXG4gICAgICAgICAqIEBwYXJhbSBzcGVlZCB7bnVtYmVyfSBUaGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgcm90YXRpb24gc3BlY2lmaWVkIGluIHJhZGlhbnMgcGVyIHNlY29uZFxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJvdGF0ZVRvID0gZnVuY3Rpb24gKGFuZ2xlUmFkaWFucywgc3BlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLlJvdGF0ZVRvKHRoaXMsIGFuZ2xlUmFkaWFucywgc3BlZWQpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCByb3RhdGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBhbmdsZSBieSBhIGNlcnRhaW5cbiAgICAgICAgICogdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0XG4gICAgICAgICAqIG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCByb3RhdGVCeVxuICAgICAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zIHtudW1iZXJ9IFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFuc1xuICAgICAgICAgKiBAcGFyYW0gdGltZSB7bnVtYmVyfSBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0aGUgYWN0b3IgdG8gY29tcGxldGUgdGhlIHJvdGF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJvdGF0ZUJ5ID0gZnVuY3Rpb24gKGFuZ2xlUmFkaWFucywgdGltZSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuUm90YXRlQnkodGhpcywgYW5nbGVSYWRpYW5zLCB0aW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgc2NhbGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBzaXplIGF0IHRoZSBzcGVlZFxuICAgICAgICAgKiBzcGVjaWZpZWQgKGluIG1hZ25pdHVkZSBpbmNyZWFzZSBwZXIgc2Vjb25kKSBhbmQgcmV0dXJuIGJhY2sgdGhlXG4gICAgICAgICAqIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nXG4gICAgICAgICAqIGFjdGlvbiBjaGFpbmluZy5cbiAgICAgICAgICogQG1ldGhvZCBzY2FsZVRvXG4gICAgICAgICAqIEBwYXJhbSBzaXplIHtudW1iZXJ9IFRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseVxuICAgICAgICAgKiBAcGFyYW0gc3BlZWQge251bWJlcn0gVGhlIHNwZWVkIG9mIHNjYWxpbmcgc3BlY2lmaWVkIGluIG1hZ25pdHVkZSBpbmNyZWFzZSBwZXIgc2Vjb25kXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2NhbGVUbyA9IGZ1bmN0aW9uIChzaXplWCwgc2l6ZVksIHNwZWVkWCwgc3BlZWRZKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5TY2FsZVRvKHRoaXMsIHNpemVYLCBzaXplWSwgc3BlZWRYLCBzcGVlZFkpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBzY2FsZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIHNpemUgYnkgYSBjZXJ0YWluIHRpbWVcbiAgICAgICAgICogKGluIG1pbGxpc2Vjb25kcykgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGVcbiAgICAgICAgICogYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2Qgc2NhbGVCeVxuICAgICAgICAgKiBAcGFyYW0gc2l6ZSB7bnVtYmVyfSBUaGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHlcbiAgICAgICAgICogQHBhcmFtIHRpbWUge251bWJlcn0gVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gY29tcGxldGUgdGhlIHNjYWxpbmcgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuc2NhbGVCeSA9IGZ1bmN0aW9uIChzaXplWCwgc2l6ZVksIHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLlNjYWxlQnkodGhpcywgc2l6ZVgsIHNpemVZLCB0aW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgYW4gYWN0b3IgdG8gYmxpbmsgKGJlY29tZSB2aXNpYmxlIGFuZCBub3RcbiAgICAgICAgICogdmlzaWJsZSkuIE9wdGlvbmFsbHksIHlvdSBtYXkgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIGJsaW5rcy4gU3BlY2lmeSB0aGUgYW1vdW50IG9mIHRpbWVcbiAgICAgICAgICogdGhlIGFjdG9yIHNob3VsZCBiZSB2aXNpYmxlIHBlciBibGluaywgYW5kIHRoZSBhbW91bnQgb2YgdGltZSBub3QgdmlzaWJsZS5cbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgYmxpbmtcbiAgICAgICAgICogQHBhcmFtIHRpbWVWaXNpYmxlIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IHZpc2libGUgcGVyIGJsaW5rIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBAcGFyYW0gdGltZU5vdFZpc2libGUge251bWJlcn0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgbm90IHZpc2libGUgcGVyIGJsaW5rIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBAcGFyYW0gW251bUJsaW5rc10ge251bWJlcn0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBibGlua1xuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmJsaW5rID0gZnVuY3Rpb24gKHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSB7XG4gICAgICAgICAgICBpZiAobnVtQmxpbmtzID09PSB2b2lkIDApIHsgbnVtQmxpbmtzID0gMTsgfVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuQmxpbmsodGhpcywgdGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvcidzIG9wYWNpdHkgdG8gY2hhbmdlIGZyb20gaXRzIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICogdG8gdGhlIHByb3ZpZGVkIHZhbHVlIGJ5IGEgc3BlY2lmaWVkIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIGZhZGVcbiAgICAgICAgICogQHBhcmFtIG9wYWNpdHkge251bWJlcn0gVGhlIGVuZGluZyBvcGFjaXR5XG4gICAgICAgICAqIEBwYXJhbSB0aW1lIHtudW1iZXJ9IFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIGZhZGUgdGhlIGFjdG9yIChpbiBtaWxsaXNlY29uZHMpXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZmFkZSA9IGZ1bmN0aW9uIChvcGFjaXR5LCB0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5GYWRlKHRoaXMsIG9wYWNpdHksIHRpbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBkZWxheSB0aGUgbmV4dCBhY3Rpb24gZnJvbSBleGVjdXRpbmcgZm9yIGEgY2VydGFpblxuICAgICAgICAgKiBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3JcbiAgICAgICAgICogJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZXRob2QgZGVsYXlcbiAgICAgICAgICogQHBhcmFtIHRpbWUge251bWJlcn0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBpbiB0aGUgcXVldWUgZnJvbSBleGVjdXRpbmcgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEByZXR1cm5zIEFjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuRGVsYXkodGhpcywgdGltZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBhbiBhY3Rpb24gdG8gdGhlIHF1ZXVlIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFjdG9yIGZyb20gdGhlXG4gICAgICAgICAqIHNjZW5lIG9uY2UgaXQgaGFzIGNvbXBsZXRlZCBpdHMgcHJldmlvdXMgYWN0aW9ucy4gQW55IGFjdGlvbnMgb24gdGhlXG4gICAgICAgICAqIGFjdGlvbiBxdWV1ZSBhZnRlciB0aGlzIGFjdGlvbiB3aWxsIG5vdCBiZSBleGVjdXRlZC5cbiAgICAgICAgICogQG1ldGhvZCBkaWVcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5kaWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5EaWUodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIGNhbGwgYW4gYXJiaXRyYXJ5IG1ldGhvZCBhcyB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlXG4gICAgICAgICAqIGFjdGlvbiBxdWV1ZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZXhlY3V0ZSBjb2RlIGluIGFmdGVyIGEgc3BlY2lmaWNcbiAgICAgICAgICogYWN0aW9uLCBpLmUgQW4gYWN0b3IgYXJyaXZlcyBhdCBhIGRlc3RpbmF0aW5vIGFmdGVyIHRyYXZlcnNpbmcgYSBwYXRoXG4gICAgICAgICAqIEBtZXRob2QgY2FsbE1ldGhvZFxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmNhbGxNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5DYWxsTWV0aG9kKHRoaXMsIG1ldGhvZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBwcmV2aW91c2x5XG4gICAgICAgICAqIGNhbGxlZCBhY3Rpb25zIGEgY2VydGFpbiBudW1iZXIgb2YgdGltZXMuIElmIHRoZSBudW1iZXIgb2YgcmVwZWF0c1xuICAgICAgICAgKiBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgcmVwZWF0IGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2ZcbiAgICAgICAgICogdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nXG4gICAgICAgICAqIEBtZXRob2QgcmVwZWF0XG4gICAgICAgICAqIEBwYXJhbSBbdGltZXM9dW5kZWZpbmVkXSB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBhbGwgdGhlIHByZXZpb3VzIGFjdGlvbnMgaW4gdGhlIGFjdGlvbiBxdWV1ZS4gSWYgbm90aGluZyBpcyBzcGVjaWZpZWQgdGhlIGFjdGlvbnMgd2lsbCByZXBlYXQgZm9yZXZlclxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uICh0aW1lcykge1xuICAgICAgICAgICAgaWYgKCF0aW1lcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0Rm9yZXZlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuUmVwZWF0KHRoaXMsIHRpbWVzLCB0aGlzLmFjdGlvblF1ZXVlLmdldEFjdGlvbnMoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBwcmV2aW91c2x5XG4gICAgICAgICAqIGNhbGxlZCBhY3Rpb25zIGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nXG4gICAgICAgICAqIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWV0aG9kIHJlcGVhdEZvcmV2ZXJcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5yZXBlYXRGb3JldmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS5hZGQobmV3IGV4LkludGVybmFsLkFjdGlvbnMuUmVwZWF0Rm9yZXZlcih0aGlzLCB0aGlzLmFjdGlvblF1ZXVlLmdldEFjdGlvbnMoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byBmb2xsb3cgYW5vdGhlciBhdCBhIHNwZWNpZmllZCBkaXN0YW5jZVxuICAgICAgICAgKiBAbWV0aG9kIGZvbGxvd1xuICAgICAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdG8gZm9sbG93XG4gICAgICAgICAqIEBwYXJhbSBbZm9sbG93RGlzdGFuY2U9Y3VycmVudERpc3RhbmNlXSB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgdG8gbWFpbnRhaW4gd2hlbiBmb2xsb3dpbmcsIGlmIG5vdCBzcGVjaWZpZWQgdGhlIGFjdG9yIHdpbGwgZm9sbG93IGF0IHRoZSBjdXJyZW50IGRpc3RhbmNlLlxuICAgICAgICAgKiBAcmV0dXJucyBBY3RvclxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmZvbGxvdyA9IGZ1bmN0aW9uIChhY3RvciwgZm9sbG93RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChmb2xsb3dEaXN0YW5jZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLmFkZChuZXcgZXguSW50ZXJuYWwuQWN0aW9ucy5Gb2xsb3codGhpcywgYWN0b3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkZvbGxvdyh0aGlzLCBhY3RvciwgZm9sbG93RGlzdGFuY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gbW92ZSB0b3dhcmRzIGFub3RoZXIgdW50aWwgdGhleVxuICAgICAgICAgKiBjb2xsaWRlIFwibWVldFwiIGF0IGEgc3BlY2lmaWVkIHNwZWVkLlxuICAgICAgICAgKiBAbWV0aG9kIG1lZXRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRvIG1lZXRcbiAgICAgICAgICogQHBhcmFtIFtzcGVlZD0wXSB7bnVtYmVyfSBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZSwgaWYgbm90IHNwZWNpZmllZCBpdCB3aWxsIG1hdGNoIHRoZSBzcGVlZCBvZiB0aGUgb3RoZXIgYWN0b3JcbiAgICAgICAgICogQHJldHVybnMgQWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5tZWV0ID0gZnVuY3Rpb24gKGFjdG9yLCBzcGVlZCkge1xuICAgICAgICAgICAgaWYgKHNwZWVkID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLk1lZXQodGhpcywgYWN0b3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUXVldWUuYWRkKG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLk1lZXQodGhpcywgYWN0b3IsIHNwZWVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3VycmVudCBhY3Rpb24gcXVldWUgdXAgdG8gbm93XG4gICAgICAgICAqIGlzIGZpbmlzaGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGFzUHJvbWlzZVxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuYXNQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbE1ldGhvZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIEFjdG9yLnByb3RvdHlwZS5fZ2V0Q2FsY3VsYXRlZEFuY2hvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQodGhpcy5nZXRXaWR0aCgpICogdGhpcy5hbmNob3IueCwgdGhpcy5nZXRIZWlnaHQoKSAqIHRoaXMuYW5jaG9yLnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBhY3RvclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZShlbmdpbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goJ2luaXRpYWxpemUnLCBuZXcgZXguSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV2ZW50RGlzcGF0Y2hlciA9IHRoaXMuZXZlbnREaXNwYXRjaGVyO1xuICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGlvbiBxdWV1ZVxuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBpcGVsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waXBlbGluZVtpXS51cGRhdGUodGhpcywgZW5naW5lLCBkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudERpc3BhdGNoZXIucHVibGlzaChleC5FdmVudFR5cGVbNSAvKiBVcGRhdGUgKi9dLCBuZXcgZXguVXBkYXRlRXZlbnQoZGVsdGEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCBkcmF3cyB0aGUgYWN0b3IgdG8gdGhlIHNjcmVlblxuICAgICAgICAgKiBAbWV0aG9kIGRyYXdcbiAgICAgICAgICogQHBhcmFtIGN0eCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBUaGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGRyYXcgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc09mZlNjcmVlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhbmNob3JQb2ludCA9IHRoaXMuX2dldENhbGN1bGF0ZWRBbmNob3IoKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGNoYW5naW5nIG9wYWNpdHlcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzT3BhY2l0eSAhPSB0aGlzLm9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkcmF3aW5nIGluIHRoaXMuZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVzW2RyYXdpbmddLmFkZEVmZmVjdChuZXcgZXguRWZmZWN0cy5PcGFjaXR5KHRoaXMub3BhY2l0eSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmF3aW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhEaWZmID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeURpZmYgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNlbnRlckRyYXdpbmdYKSB7XG4gICAgICAgICAgICAgICAgICAgIHhEaWZmID0gKHRoaXMuY3VycmVudERyYXdpbmcud2lkdGggKiB0aGlzLmN1cnJlbnREcmF3aW5nLmdldFNjYWxlWCgpIC0gdGhpcy5nZXRXaWR0aCgpKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNlbnRlckRyYXdpbmdZKSB7XG4gICAgICAgICAgICAgICAgICAgIHlEaWZmID0gKHRoaXMuY3VycmVudERyYXdpbmcuaGVpZ2h0ICogdGhpcy5jdXJyZW50RHJhd2luZy5nZXRTY2FsZVkoKSAtIHRoaXMuZ2V0SGVpZ2h0KCkpIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZy5kcmF3KGN0eCwgLXhEaWZmIC0gYW5jaG9yUG9pbnQueCwgLXlEaWZmIC0gYW5jaG9yUG9pbnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoLWFuY2hvclBvaW50LngsIC1hbmNob3JQb2ludC55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2VuZU5vZGUuZHJhdyhjdHgsIGRlbHRhKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgZHJhd3MgdGhlIGFjdG9ycyBkZWJ1Z2dpbmcgdG8gdGhlIHNjcmVlblxuICAgICAgICAgKiBAbWV0aG9kIGRlYnVnRHJhd1xuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgQWN0b3IucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBiYiA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICBiYi5kZWJ1Z0RyYXcoY3R4KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBleC5Db2xvci5ZZWxsb3cudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy54LCB0aGlzLnksIDMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhlIG5leHQgaWQgdG8gYmUgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBBY3Rvci5tYXhJZCA9IDA7XG4gICAgICAgIHJldHVybiBBY3RvcjtcbiAgICB9KShleC5DbGFzcyk7XG4gICAgZXguQWN0b3IgPSBBY3Rvcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogTG9nZ2luZyBsZXZlbCB0aGF0IEV4Y2FsaWJ1ciB3aWxsIHRhZ1xuICAgICAqIEBjbGFzcyBMb2dMZXZlbFxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICBAcHJvcGVydHkgRGVidWcge0xvZ0xldmVsfVxuICAgICAgICAgQHN0YXRpY1xuICAgICAgICAgQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEluZm8ge0xvZ0xldmVsfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IFdhcm4ge0xvZ0xldmVsfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IEVycm9yIHtMb2dMZXZlbH1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBGYXRhbCB7TG9nTGV2ZWx9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGVidWdcIl0gPSAwXSA9IFwiRGVidWdcIjtcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJbmZvXCJdID0gMV0gPSBcIkluZm9cIjtcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXYXJuXCJdID0gMl0gPSBcIldhcm5cIjtcbiAgICAgICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDNdID0gXCJFcnJvclwiO1xuICAgICAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkZhdGFsXCJdID0gNF0gPSBcIkZhdGFsXCI7XG4gICAgfSkoZXguTG9nTGV2ZWwgfHwgKGV4LkxvZ0xldmVsID0ge30pKTtcbiAgICB2YXIgTG9nTGV2ZWwgPSBleC5Mb2dMZXZlbDtcbiAgICAvKipcbiAgICAgKiBTdGF0aWMgc2luZ2xldG9uIHRoYXQgcmVwcmVzZW50cyB0aGUgbG9nZ2luZyBmYWNpbGl0eSBmb3IgRXhjYWxpYnVyLlxuICAgICAqIEV4Y2FsaWJ1ciBjb21lcyBidWlsdC1pbiB3aXRoIGEgQ29uc29sZUFwcGVuZGVyIGFuZCBTY3JlZW5BcHBlbmRlci5cbiAgICAgKiBEZXJpdmUgZnJvbSBJQXBwZW5kZXIgdG8gY3JlYXRlIHlvdXIgb3duIGxvZ2dpbmcgYXBwZW5kZXJzLlxuICAgICAqIEBjbGFzcyBMb2dnZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgdmFyIExvZ2dlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZXJzID0gW107XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZGVmYXVsdCBsb2dnaW5nIGxldmVsLiBFeGNhbGlidXIgd2lsbCBvbmx5IGxvZ1xuICAgICAgICAgICAgICogbWVzc2FnZXMgaWYgZXF1YWwgdG8gb3IgYWJvdmUgdGhpcyBsZXZlbC5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0TGV2ZWwge0xvZ0xldmVsfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCA9IDEgLyogSW5mbyAqLztcbiAgICAgICAgICAgIGlmIChMb2dnZXIuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9nZ2VyIGlzIGEgc2luZ2xldG9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGNvbnNvbGUgYXBwZW5kZXJcbiAgICAgICAgICAgIExvZ2dlci5faW5zdGFuY2UuYWRkQXBwZW5kZXIobmV3IENvbnNvbGVBcHBlbmRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBMb2dnZXIuX2luc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRpYyBpbnN0YW5jZSBvZiBMb2dnZXJcbiAgICAgICAgICogQG1ldGhvZCBnZXRJbnN0YW5jZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEByZXR1cm5zIExvZ2dlclxuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKExvZ2dlci5faW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIExvZ2dlci5faW5zdGFuY2UgPSBuZXcgTG9nZ2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTG9nZ2VyLl9pbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBuZXcgSUFwcGVuZGVyIHRvIHRoZSBsaXN0IG9mIGFwcGVuZGVycyB0byB3cml0ZSB0b1xuICAgICAgICAgKiBAbWV0aG9kIGFkZEFwcGVuZGVyXG4gICAgICAgICAqIEBwYXJhbSBhcHBlbmRlciB7SUFwcGVuZGVyfSBBcHBlbmRlciB0byBhZGRcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuYWRkQXBwZW5kZXIgPSBmdW5jdGlvbiAoYXBwZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kZXJzLnB1c2goYXBwZW5kZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBhcHBlbmRlcnMgZnJvbSB0aGUgbG9nZ2VyXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJBcHBlbmRlcnNcbiAgICAgICAgICovXG4gICAgICAgIExvZ2dlci5wcm90b3R5cGUuY2xlYXJBcHBlbmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZGVycy5sZW5ndGggPSAwO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9ncyBhIG1lc3NhZ2UgYXQgYSBnaXZlbiBMb2dMZXZlbFxuICAgICAgICAgKiBAbWV0aG9kIF9sb2dcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIGxldmVsIHtMb2dMZXZlbH1UaGUgTG9nTGV2ZWxgdG8gbG9nIHRoZSBtZXNzYWdlIGF0XG4gICAgICAgICAqIEBwYXJhbSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byB3cml0ZSB0byBhbiBhcHBlbmRlclxuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5fbG9nID0gZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMuZGVmYXVsdExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmRlcnMuZm9yRWFjaChmdW5jdGlvbiAoYXBwZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gX3RoaXMuZGVmYXVsdExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZGVyLmxvZyhsZXZlbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgTG9nTGV2ZWwuRGVidWcgbGV2ZWxcbiAgICAgICAgICogQG1ldGhvZCBkZWJ1Z1xuICAgICAgICAgKiBAcGFyYW0gLi4uYXJncyBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvZygwIC8qIERlYnVnICovLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBMb2dMZXZlbC5JbmZvIGxldmVsXG4gICAgICAgICAqIEBtZXRob2QgaW5mb1xuICAgICAgICAgKiBAcGFyYW0gLi4uYXJncyBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nKDEgLyogSW5mbyAqLywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgTG9nTGV2ZWwuV2FybiBsZXZlbFxuICAgICAgICAgKiBAbWV0aG9kIHdhcm5cbiAgICAgICAgICogQHBhcmFtIC4uLmFyZ3MgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvZygyIC8qIFdhcm4gKi8sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIExvZ0xldmVsLkVycm9yIGxldmVsXG4gICAgICAgICAqIEBtZXRob2QgZXJyb3JcbiAgICAgICAgICogQHBhcmFtIC4uLmFyZ3MgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgTG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2coMyAvKiBFcnJvciAqLywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgTG9nTGV2ZWwuRmF0YWwgbGV2ZWxcbiAgICAgICAgICogQG1ldGhvZCBmYXRhbFxuICAgICAgICAgKiBAcGFyYW0gLi4uYXJncyBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBMb2dnZXIucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvZyg0IC8qIEZhdGFsICovLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgTG9nZ2VyLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBMb2dnZXI7XG4gICAgfSkoKTtcbiAgICBleC5Mb2dnZXIgPSBMb2dnZXI7XG4gICAgLyoqXG4gICAgICogQ29uc29sZSBhcHBlbmRlciBmb3IgYnJvd3NlcnMgKGkuZS4gY29uc29sZS5sb2cpXG4gICAgICogQGNsYXNzIENvbnNvbGVBcHBlbmRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIElBcHBlbmRlclxuICAgICAqL1xuICAgIHZhciBDb25zb2xlQXBwZW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb25zb2xlQXBwZW5kZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ29uc29sZUFwcGVuZGVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjb25zb2xlIHN1cHBvcnRcbiAgICAgICAgICAgIGlmICghY29uc29sZSAmJiAhY29uc29sZS5sb2cgJiYgY29uc29sZS53YXJuICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvIG1heWJlIGRvIHNvbWV0aGluZyBiZXR0ZXIgdGhhbiBub3RoaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbnNvbGUgYXJncyBhcnJheVxuICAgICAgICAgICAgdmFyIGNvbnNvbGVBcmdzID0gW107XG4gICAgICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0LmFwcGx5KGNvbnNvbGVBcmdzLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnNvbGVBcmdzLnVuc2hpZnQoXCJbXCIgKyBMb2dMZXZlbFtsZXZlbF0gKyBcIl0gOiBcIik7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCAyIC8qIFdhcm4gKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIC5sb2cgZm9yIERlYnVnL0luZm9cbiAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyByZXF1aXJlZCBvbiBzb21lIG9sZGVyIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBhcHBseSBvbiBjb25zb2xlLmxvZyA6KFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb25zb2xlQXJncy5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxldmVsIDwgMyAvKiBFcnJvciAqLykge1xuICAgICAgICAgICAgICAgIC8vIENhbGwgLndhcm4gZm9yIFdhcm5cbiAgICAgICAgICAgICAgICBpZiAoY29uc29sZS53YXJuLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oY29uc29sZUFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIC5lcnJvciBmb3IgRXJyb3IvRmF0YWxcbiAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvci5hcHBseSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY29uc29sZUFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb25zb2xlQXBwZW5kZXI7XG4gICAgfSkoKTtcbiAgICBleC5Db25zb2xlQXBwZW5kZXIgPSBDb25zb2xlQXBwZW5kZXI7XG4gICAgLyoqXG4gICAgICogT24tc2NyZWVuIChjYW52YXMpIGFwcGVuZGVyXG4gICAgICogQHRvZG8gQ2xlYW4gdGhpcyB1cFxuICAgICAqIEBjbGFzcyBTY3JlZW5BcHBlbmRlclxuICAgICAqIEBleHRlbmRzIElBcHBlbmRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB3aWR0aCB7bnVtYmVyfSBXaWR0aCBvZiB0aGUgc2NyZWVuIGFwcGVuZGVyIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSBoZWlnaHQge251bWJlcn0gSGVpZ2h0IG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgdmFyIFNjcmVlbkFwcGVuZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2NyZWVuQXBwZW5kZXIod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoIHx8IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIFNjcmVlbkFwcGVuZGVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gYXJncy5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzLnVuc2hpZnQoXCJbXCIgKyBMb2dMZXZlbFtsZXZlbF0gKyBcIl0gOiBcIiArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgdmFyIHBvcyA9IDEwO1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSAxLjA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsJyArIG9wYWNpdHkudG9GaXhlZCgyKSArICcpJztcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dCh0aGlzLl9tZXNzYWdlc1tpXSwgMjAwLCBwb3MpO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICBvcGFjaXR5ID0gb3BhY2l0eSA+IDAgPyBvcGFjaXR5IC0gLjA1IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNjcmVlbkFwcGVuZGVyO1xuICAgIH0pKCk7XG4gICAgZXguU2NyZWVuQXBwZW5kZXIgPSBTY3JlZW5BcHBlbmRlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRW5naW5lLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTG9nLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBBbiBlbnVtIHJlcHJlc2VudGluZyBhbGwgb2YgdGhlIGJ1aWx0IGluIGV2ZW50IHR5cGVzIGZvciBFeGNhbGlidXJcbiAgICAgKiBAY2xhc3MgRXZlbnRUeXBlXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChFdmVudFR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBVc2VyRXZlbnQge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBCbHVyIHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgRm9jdXMge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBVcGRhdGUge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBFbnRlclZpZXdQb3J0IHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgRXhpdFZpZXdQb3J0IHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgQWN0aXZhdGUge0V2ZW50VHlwZX1cbiAgICAgICAgQHN0YXRpY1xuICAgICAgICBAZmluYWxcbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBEZWFjdGl2YXRlIHtFdmVudFR5cGV9XG4gICAgICAgIEBzdGF0aWNcbiAgICAgICAgQGZpbmFsXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgSW5pdGlhbGl6ZSB7RXZlbnRUeXBlfVxuICAgICAgICBAc3RhdGljXG4gICAgICAgIEBmaW5hbFxuICAgICAgICAqL1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiQ29sbGlzaW9uXCJdID0gMF0gPSBcIkNvbGxpc2lvblwiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiRW50ZXJWaWV3UG9ydFwiXSA9IDFdID0gXCJFbnRlclZpZXdQb3J0XCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJFeGl0Vmlld1BvcnRcIl0gPSAyXSA9IFwiRXhpdFZpZXdQb3J0XCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJCbHVyXCJdID0gM10gPSBcIkJsdXJcIjtcbiAgICAgICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkZvY3VzXCJdID0gNF0gPSBcIkZvY3VzXCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJVcGRhdGVcIl0gPSA1XSA9IFwiVXBkYXRlXCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJBY3RpdmF0ZVwiXSA9IDZdID0gXCJBY3RpdmF0ZVwiO1xuICAgICAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiRGVhY3RpdmF0ZVwiXSA9IDddID0gXCJEZWFjdGl2YXRlXCI7XG4gICAgICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJJbml0aWFsaXplXCJdID0gOF0gPSBcIkluaXRpYWxpemVcIjtcbiAgICB9KShleC5FdmVudFR5cGUgfHwgKGV4LkV2ZW50VHlwZSA9IHt9KSk7XG4gICAgdmFyIEV2ZW50VHlwZSA9IGV4LkV2ZW50VHlwZTtcbiAgICAvKipcbiAgICAgKiBCYXNlIGV2ZW50IHR5cGUgaW4gRXhjYWxpYnVyIHRoYXQgYWxsIG90aGVyIGV2ZW50IHR5cGVzIGRlcml2ZSBmcm9tLlxuICAgICAqXG4gICAgICogQGNsYXNzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB0YXJnZXQge2FueX0gRXZlbnRzIGNhbiBoYXZlIHRhcmdldCBnYW1lIG9iamVjdCwgbGlrZSB0aGUgRW5naW5lLCBvciBhbiBBY3Rvci5cbiAgICAgKi9cbiAgICB2YXIgR2FtZUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gR2FtZUV2ZW50KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBHYW1lRXZlbnQ7XG4gICAgfSkoKTtcbiAgICBleC5HYW1lRXZlbnQgPSBHYW1lRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgcmVjZWl2ZWQgYnkgdGhlIEVuZ2luZSB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKiBAY2xhc3MgVmlzaWJsZUV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFZpc2libGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhWaXNpYmxlRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFZpc2libGVFdmVudCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWaXNpYmxlRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5WaXNpYmxlRXZlbnQgPSBWaXNpYmxlRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgcmVjZWl2ZWQgYnkgdGhlIEVuZ2luZSB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyBoaWRkZW5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBIaWRkZW5FdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBIaWRkZW5FdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhIaWRkZW5FdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSGlkZGVuRXZlbnQoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGlkZGVuRXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5IaWRkZW5FdmVudCA9IEhpZGRlbkV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBhY3RvciB3aGVuIGEgY29sbGlzaW9uIGhhcyBvY2N1cmVkXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ29sbGlzaW9uRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gYWN0b3Ige0FjdG9yfSBUaGUgYWN0b3IgdGhlIGV2ZW50IHdhcyB0aHJvd24gb25cbiAgICAgKiBAcGFyYW0gb3RoZXIge0FjdG9yfSBUaGUgYWN0b3IgdGhhdCB3YXMgY29sbGlkZWQgd2l0aFxuICAgICAqIEBwYXJhbSBzaWRlIHtTaWRlfSBUaGUgc2lkZSB0aGF0IHdhcyBjb2xsaWRlZCB3aXRoXG4gICAgICovXG4gICAgdmFyIENvbGxpc2lvbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKENvbGxpc2lvbkV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDb2xsaXNpb25FdmVudChhY3Rvciwgb3RoZXIsIHNpZGUsIGludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XG4gICAgICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguQ29sbGlzaW9uRXZlbnQgPSBDb2xsaXNpb25FdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYSBnYW1lIG9iamVjdCBvbiBFeGNhbGlidXIgdXBkYXRlXG4gICAgICpcbiAgICAgKiBAY2xhc3MgVXBkYXRlRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gZGVsdGEge251bWJlcn0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlXG4gICAgICovXG4gICAgdmFyIFVwZGF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFVwZGF0ZUV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBVcGRhdGVFdmVudChkZWx0YSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRlbHRhID0gZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVwZGF0ZUV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguVXBkYXRlRXZlbnQgPSBVcGRhdGVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gQWN0b3Igb25seSBvbmNlIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIGNhbGxcbiAgICAgKlxuICAgICAqIEBjbGFzcyBJbml0aWFsaXplRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBHYW1lRXZlbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gZW5naW5lIHtFbmdpbmV9IFRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW5naW5lXG4gICAgICovXG4gICAgdmFyIEluaXRpYWxpemVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhJbml0aWFsaXplRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEluaXRpYWxpemVFdmVudChlbmdpbmUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEluaXRpYWxpemVFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkluaXRpYWxpemVFdmVudCA9IEluaXRpYWxpemVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYSBTY2VuZSBvbiBhY3RpdmF0aW9uXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQWN0aXZhdGVFdmVudFxuICAgICAqIEBleHRlbmRzIEdhbWVFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBvbGRTY2VuZSB7U2NlbmV9IFRoZSByZWZlcmVuY2UgdG8gdGhlIG9sZCBzY2VuZVxuICAgICAqL1xuICAgIHZhciBBY3RpdmF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEFjdGl2YXRlRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFjdGl2YXRlRXZlbnQob2xkU2NlbmUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbGRTY2VuZSA9IG9sZFNjZW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBY3RpdmF0ZUV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguQWN0aXZhdGVFdmVudCA9IEFjdGl2YXRlRXZlbnQ7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhyb3duIG9uIGEgU2NlbmUgb24gZGVhY3RpdmF0aW9uXG4gICAgICpcbiAgICAgKiBAY2xhc3MgRGVhY3RpdmF0ZUV2ZW50XG4gICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIG5ld1NjZW5lIHtTY2VuZX0gVGhlIHJlZmVyZW5jZSB0byB0aGUgbmV3IHNjZW5lXG4gICAgICovXG4gICAgdmFyIERlYWN0aXZhdGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhEZWFjdGl2YXRlRXZlbnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERlYWN0aXZhdGVFdmVudChuZXdTY2VuZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm5ld1NjZW5lID0gbmV3U2NlbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlYWN0aXZhdGVFdmVudDtcbiAgICB9KShHYW1lRXZlbnQpO1xuICAgIGV4LkRlYWN0aXZhdGVFdmVudCA9IERlYWN0aXZhdGVFdmVudDtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0aHJvd24gb24gYW4gQWN0b3Igd2hlbiBpdCBjb21wbGV0ZWx5IGxlYXZlcyB0aGUgc2NyZWVuLlxuICAgICAqIEBjbGFzcyBFeGl0Vmlld1BvcnRFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBFeGl0Vmlld1BvcnRFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhFeGl0Vmlld1BvcnRFdmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRXhpdFZpZXdQb3J0RXZlbnQoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXhpdFZpZXdQb3J0RXZlbnQ7XG4gICAgfSkoR2FtZUV2ZW50KTtcbiAgICBleC5FeGl0Vmlld1BvcnRFdmVudCA9IEV4aXRWaWV3UG9ydEV2ZW50O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRocm93biBvbiBhbiBBY3RvciB3aGVuIGl0IGNvbXBsZXRlbHkgbGVhdmVzIHRoZSBzY3JlZW4uXG4gICAgICogQGNsYXNzIEVudGVyVmlld1BvcnRFdmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBFbnRlclZpZXdQb3J0RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRW50ZXJWaWV3UG9ydEV2ZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFbnRlclZpZXdQb3J0RXZlbnQoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRW50ZXJWaWV3UG9ydEV2ZW50O1xuICAgIH0pKEdhbWVFdmVudCk7XG4gICAgZXguRW50ZXJWaWV3UG9ydEV2ZW50ID0gRW50ZXJWaWV3UG9ydEV2ZW50O1xuICAgIC8qKlxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgbW91c2UgYnV0dG9uc1xuICAgICAqIEBjbGFzcyBNb3VzZUJ1dHRvblxuICAgICAqL1xuICAgIChmdW5jdGlvbiAoTW91c2VCdXR0b24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlQnV0dG9uW01vdXNlQnV0dG9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBNb3VzZUJ1dHRvbltNb3VzZUJ1dHRvbltcIk1pZGRsZVwiXSA9IDFdID0gXCJNaWRkbGVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIE1vdXNlQnV0dG9uW01vdXNlQnV0dG9uW1wiUmlnaHRcIl0gPSAyXSA9IFwiUmlnaHRcIjtcbiAgICB9KShleC5Nb3VzZUJ1dHRvbiB8fCAoZXguTW91c2VCdXR0b24gPSB7fSkpO1xuICAgIHZhciBNb3VzZUJ1dHRvbiA9IGV4Lk1vdXNlQnV0dG9uO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudHMudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEV4Y2FsaWJ1cidzIGludGVybmFsIGV2ZW50IGRpc3BhdGNoZXIgaW1wbGVtZW50YXRpb24uIENhbGxiYWNrcyBhcmUgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW4gZXZlbnQgaXMgcHVibGlzaGVkXG4gICAgICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB0YXJnZXQge2FueX0gVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlIHJlY2lwaWVudCBvZiBldmVudHMgZnJvbSB0aGlzIGV2ZW50IGRpc3BhdGNoZXJcbiAgICAgKi9cbiAgICB2YXIgRXZlbnREaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubG9nID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUHVibGlzaCBhbiBldmVudCBmb3IgdGFyZ2V0XG4gICAgICAgICAqIEBtZXRob2QgcHVibGlzaFxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBwdWJsaXNoXG4gICAgICAgICAqIEBwYXJhbSBbZXZlbnQ9dW5kZWZpbmVkXSB7R2FtZUV2ZW50fSBPcHRpb25hbGx5IHBhc3MgYW4gZXZlbnQgZGF0YSBvYmplY3QgdG8gdGhlIGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIGtleSBub3QgbWFwcGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXguR2FtZUV2ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyIHRvIGEgcGFydGljdWxhciBldmVudCBuYW1lLCBtdWx0aXBsZSBoYW5kbGVycyBwZXIgZXZlbnQgbmFtZSBhcmUgYWxsb3dlZC5cbiAgICAgICAgICogQG1ldGhvZCBzdWJzY3JpYmVcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXG4gICAgICAgICAqIEBwYXJhbSBoYW5kbGVyIHtHYW1lRXZlbnQ9PnZvaWR9IFRoZSBoYW5kbGVyIGNhbGxiYWNrIHRvIGZpcmUgb24gdGhpcyBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuc3Vic2NyaWJlIGEgZXZlbnQgaGFuZGxlcihzKSBmcm9tIGFuIGV2ZW50LiBJZiBhIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgICAgICogaXMgc3BlY2lmaWVkIGZvciBhbiBldmVudCwgb25seSB0aGF0IGhhbmRsZXIgd2lsbCBiZSB1bnN1YnNjcmliZWQuXG4gICAgICAgICAqIE90aGVyd2lzZSBhbGwgaGFuZGxlcnMgd2lsbCBiZSB1bnN1YnNjcmliZWQgZm9yIHRoYXQgZXZlbnQuXG4gICAgICAgICAqIEBtZXRob2QgdW5zdWJzY3JpYmVcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdW5zdWJzY3JpYmVcbiAgICAgICAgICogQHBhcmFtIFtoYW5kbGVyPXVuZGVmaW5lZF0gT3B0aW9uYWxseSB0aGUgc3BlY2lmaWMgaGFuZGxlciB0byB1bnN1YnNjcmliZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBleHBsaWNpdCBoYW5kbGVyIGlzIGdpdmUgd2l0aCB0aGUgZXZlbnQgbmFtZSBjbGVhciBhbGwgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZXZlbnRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXZlbnREaXNwYXRjaGVyO1xuICAgIH0pKCk7XG4gICAgZXguRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgQ29sb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGFuIHIsIGcsIGIsIGFcbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzIENvbG9yXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0gciB7bnVtYmVyfSBUaGUgcmVkIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXG4gICAgICAgICAqIEBwYXJhbSBnIHtudW1iZXJ9IFRoZSBncmVlbiBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxuICAgICAgICAgKiBAcGFyYW0gYiB7bnVtYmVyfSBUaGUgYmx1ZSBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxuICAgICAgICAgKiBAcGFyYW0gW2E9MV0ge251bWJlcn0gVGhlIGFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAoMC0xLjApXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb2xvcihyLCBnLCBiLCBhKSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgICAgICB0aGlzLmEgPSBhO1xuICAgICAgICAgICAgdGhpcy5hID0gKGEgIT0gbnVsbCA/IGEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGFuIHIsIGcsIGIsIGFcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBmcm9tUkdCXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHIge251bWJlcn0gVGhlIHJlZCBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxuICAgICAgICAgKiBAcGFyYW0gZyB7bnVtYmVyfSBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcbiAgICAgICAgICogQHBhcmFtIGIge251bWJlcn0gVGhlIGJsdWUgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcbiAgICAgICAgICogQHBhcmFtIFthPTFdIHtudW1iZXJ9IFRoZSBhbHBoYSBjb21wb25lbnQgb2YgY29sb3IgKDAtMS4wKVxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuZnJvbVJHQiA9IGZ1bmN0aW9uIChyLCBnLCBiLCBhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnNjYW5jZSBvZiBDb2xvciBmcm9tIGEgaGV4IHN0cmluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGZyb21IZXhcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gaGV4IHtzdHJpbmd9IENTUyBjb2xvciBzdHJpbmcgb2YgdGhlIGZvcm0gI2ZmZmZmZiwgdGhlIGFscGhhIGNvbXBvbmVudCBpcyBvcHRpb25hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuZnJvbUhleCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICAgICAgICAgIHZhciBoZXhSZWdFeCA9IC9eIz8oWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pPyQvaTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPSBoZXgubWF0Y2goaGV4UmVnRXgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgICAgICBhID0gcGFyc2VJbnQobWF0Y2hbNF0sIDE2KSAvIDI1NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaGV4IHN0cmluZzogXCIgKyBoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cbiAgICAgICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBTdHJpbmcodGhpcy5yLnRvRml4ZWQoMCkpICsgXCIsIFwiICsgU3RyaW5nKHRoaXMuZy50b0ZpeGVkKDApKSArIFwiLCBcIiArIFN0cmluZyh0aGlzLmIudG9GaXhlZCgwKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hICE9PSB1bmRlZmluZWQgfHwgdGhpcy5hICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIHJlc3VsdCArIFwiLCBcIiArIFN0cmluZyh0aGlzLmEpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJyZ2IoXCIgKyByZXN1bHQgKyBcIilcIjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBDU1Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXG4gICAgICAgICAqIEBtZXRob2QgZmlsbFN0eWxlXG4gICAgICAgICAqIEByZXR1cm5zIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmZpbGxTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgY29sb3IuXG4gICAgICAgICAqIEBtZXRob2QgY2xvbmVcbiAgICAgICAgICogQHJldHVybnMgQ29sb3JcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBCbGFjayB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5CbGFjayA9IENvbG9yLmZyb21IZXgoJyMwMDAwMDAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBXaGl0ZSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5XaGl0ZSA9IENvbG9yLmZyb21IZXgoJyNGRkZGRkYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBHcmF5IHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkdyYXkgPSBDb2xvci5mcm9tSGV4KCcjODA4MDgwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgTGlnaHRHcmF5IHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkxpZ2h0R3JheSA9IENvbG9yLmZyb21IZXgoJyNEM0QzRDMnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBEYXJrR3JheSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5EYXJrR3JheSA9IENvbG9yLmZyb21IZXgoJyNBOUE5QTknKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBZZWxsb3cge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuWWVsbG93ID0gQ29sb3IuZnJvbUhleCgnI0ZGRkYwMCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IE9yYW5nZSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5PcmFuZ2UgPSBDb2xvci5mcm9tSGV4KCcjRkZBNTAwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgUmVkIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLlJlZCA9IENvbG9yLmZyb21IZXgoJyNGRjAwMDAnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBWZXJtaWxsaW9uIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLlZlcm1pbGxpb24gPSBDb2xvci5mcm9tSGV4KCcjRkY1QjMxJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgUm9zZSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5Sb3NlID0gQ29sb3IuZnJvbUhleCgnI0ZGMDA3RicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IE1hZ2VudGEge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuTWFnZW50YSA9IENvbG9yLmZyb21IZXgoJyNGRjAwRkYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBWaW9sZXQge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuVmlvbGV0ID0gQ29sb3IuZnJvbUhleCgnIzdGMDBGRicpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IEJsdWUge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuQmx1ZSA9IENvbG9yLmZyb21IZXgoJyMwMDAwRkYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBBenVyZSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5BenVyZSA9IENvbG9yLmZyb21IZXgoJyMwMDdGRkYnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbG9yIGNvbnN0YW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBDeWFuIHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLkN5YW4gPSBDb2xvci5mcm9tSGV4KCcjMDBGRkZGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgVmlyaWRpYW4ge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuVmlyaWRpYW4gPSBDb2xvci5mcm9tSGV4KCcjNTk5NzhGJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgR3JlZW4ge2V4LkNvbG9yfVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBmaW5hbFxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IuR3JlZW4gPSBDb2xvci5mcm9tSGV4KCcjMDBGRjAwJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xvciBjb25zdGFudFxuICAgICAgICAgKiBAcHJvcGVydHkgQ2hhcnRyZXVzZSB7ZXguQ29sb3J9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQGZpbmFsXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5DaGFydHJldXNlID0gQ29sb3IuZnJvbUhleCgnIzdGRkYwMCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sb3IgY29uc3RhbnRcbiAgICAgICAgICogQHByb3BlcnR5IFRyYW5zcGFyZW50IHtleC5Db2xvcn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAZmluYWxcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLlRyYW5zcGFyZW50ID0gQ29sb3IuZnJvbUhleCgnI0ZGRkZGRjAwJyk7XG4gICAgICAgIHJldHVybiBDb2xvcjtcbiAgICB9KSgpO1xuICAgIGV4LkNvbG9yID0gQ29sb3I7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgQWN0b3IgcHJpbWl0aXZlIGZvciBkcmF3aW5nIFVJJ3MsIG9wdGltaXplZCBmb3IgVUkgZHJhd2luZy4gRG9lc1xuICAgICAqIG5vdCBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zLlxuICAgICAqIEBjbGFzcyBVSUFjdG9yXG4gICAgICogQGV4dGVuZHMgQWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW3g9MC4wXSB7bnVtYmVyfSBUaGUgc3RhcnRpbmcgeCBjb29yZGluYXRlIG9mIHRoZSBhY3RvclxuICAgICAqIEBwYXJhbSBbeT0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyB5IGNvb3JkaW5hdGUgb2YgdGhlIGFjdG9yXG4gICAgICogQHBhcmFtIFt3aWR0aD0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyB3aWR0aCBvZiB0aGUgYWN0b3JcbiAgICAgKiBAcGFyYW0gW2hlaWdodD0wLjBdIHtudW1iZXJ9IFRoZSBzdGFydGluZyBoZWlnaHQgb2YgdGhlIGFjdG9yXG4gICAgICovXG4gICAgdmFyIFVJQWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVUlBY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVUlBY3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucGlwZWxpbmUucHVzaChuZXcgZXguTW92ZW1lbnRNb2R1bGUoKSk7XG4gICAgICAgICAgICB0aGlzLnBpcGVsaW5lLnB1c2gobmV3IGV4LkNhcHR1cmVQb2ludGVyTW9kdWxlKCkpO1xuICAgICAgICAgICAgdGhpcy5hbmNob3Iuc2V0VG8oMCwgMCk7XG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblR5cGUgPSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBVSUFjdG9yLnByb3RvdHlwZS5vbkluaXRpYWxpemUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIFVJQWN0b3IucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHgsIHksIHVzZVdvcmxkKSB7XG4gICAgICAgICAgICBpZiAodXNlV29ybGQgPT09IHZvaWQgMCkgeyB1c2VXb3JsZCA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmICh1c2VXb3JsZClcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jb250YWlucy5jYWxsKHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2VuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KHgsIHkpKTtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbnRhaW5zLmNhbGwodGhpcywgY29vcmRzLngsIGNvb3Jkcy55KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFVJQWN0b3I7XG4gICAgfSkoZXguQWN0b3IpO1xuICAgIGV4LlVJQWN0b3IgPSBVSUFjdG9yO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJBY3Rvci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRW5naW5lLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIG1ldGhvZCBvZiBmaXJpbmcgYXJiaXRyYXJ5IGNvZGUgb24gY29sbGlzaW9uLiBUaGVzZSBhcmUgdXNlZnVsXG4gICAgICogYXMgJ2J1dHRvbnMnLCAnc3dpdGNoZXMnLCBvciB0byB0cmlnZ2VyIGVmZmVjdHMgaW4gYSBnYW1lLiBCeSBkZWZ1YWx0IHRyaWdnZXJzXG4gICAgICogYXJlIGludmlzaWJsZSwgYW5kIGNhbiBvbmx5IGJlIHNlZW4gd2l0aCBkZWJ1ZyBtb2RlIGVuYWJsZWQgb24gdGhlIEVuZ2luZS5cbiAgICAgKiBAY2xhc3MgVHJpZ2dlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbeD0wXSB7bnVtYmVyfSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlclxuICAgICAqIEBwYXJhbSBbeT0wXSB7bnVtYmVyfSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgdHJpZ2dlclxuICAgICAqIEBwYXJhbSBbd2lkdGg9MF0ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIFtoZWlnaHQ9MF0ge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgdHJpZ2dlclxuICAgICAqIEBwYXJhbSBbYWN0aW9uPW51bGxdIHsoKT0+dm9pZH0gQ2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRyaWdnZXIgaXMgYWN0aXZhdGVkXG4gICAgICogQHBhcmFtIFtyZXBlYXRzPTFdIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgdGltZXMgdGhhdCB0aGlzIHRyaWdnZXIgc2hvdWxkIGZpcmUsIGJ5IGRlZmF1bHQgaXQgaXMgMSwgaWYgLTEgaXMgc3VwcGxpZWQgaXQgd2lsbCBmaXJlIGluZGVmaW5pdGVseVxuICAgICAqL1xuICAgIHZhciBUcmlnZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFRyaWdnZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFRyaWdnZXIoeCwgeSwgd2lkdGgsIGhlaWdodCwgYWN0aW9uLCByZXBlYXRzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0cyA9IDE7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdHMgPSByZXBlYXRzIHx8IHRoaXMucmVwZWF0cztcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uIHx8IHRoaXMuYWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25UeXBlID0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovO1xuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIgPSBuZXcgZXguRXZlbnREaXNwYXRjaGVyKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25RdWV1ZSA9IG5ldyBleC5JbnRlcm5hbC5BY3Rpb25zLkFjdGlvblF1ZXVlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYWN0aW9uIHF1ZXVlXG4gICAgICAgICAgICB0aGlzLmFjdGlvblF1ZXVlLnVwZGF0ZShkZWx0YSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgcGxhY2VtZW50cyBiYXNlZCBvbiBsaW5lYXIgYWxnZWJyYVxuICAgICAgICAgICAgdGhpcy54ICs9IHRoaXMuZHggKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICB0aGlzLnkgKz0gdGhpcy5keSAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gKz0gdGhpcy5yeCAqIGRlbHRhIC8gMTAwMDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCArPSB0aGlzLnN4ICogZGVsdGEgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy5zY2FsZS55ICs9IHRoaXMuc3kgKiBkZWx0YSAvIDEwMDA7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdHJpZ2dlciBjb2xsaXNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsaWRlcyh0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEFjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5naW5lLmN1cnJlbnRTY2VuZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBlbmdpbmUuY3VycmVudFNjZW5lLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIgIT09IHRoaXMgJiYgb3RoZXIuY29sbGlzaW9uVHlwZSAhPT0gMCAvKiBQcmV2ZW50Q29sbGlzaW9uICovICYmIHRoaXMuY29sbGlkZXMob3RoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoQWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgdHJpZ2dlciBpZiBpdHMgZG9uZSwgLTEgcmVwZWF0IGZvcmV2ZXJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVHJpZ2dlci5wcm90b3R5cGUuZGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRzLS07XG4gICAgICAgIH07XG4gICAgICAgIFRyaWdnZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgLy8gZG9lcyBub3QgZHJhd1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBUcmlnZ2VyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlYnVnRHJhdy5jYWxsKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICAvLyBNZWFudCB0byBkcmF3IGRlYnVnIGluZm9ybWF0aW9uIGFib3V0IGFjdG9yc1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIGJiLmxlZnQgPSBiYi5sZWZ0IC0gdGhpcy5nZXRHbG9iYWxYKCk7XG4gICAgICAgICAgICBiYi5yaWdodCA9IGJiLnJpZ2h0IC0gdGhpcy5nZXRHbG9iYWxYKCk7XG4gICAgICAgICAgICBiYi50b3AgPSBiYi50b3AgLSB0aGlzLmdldEdsb2JhbFkoKTtcbiAgICAgICAgICAgIGJiLmJvdHRvbSA9IGJiLmJvdHRvbSAtIHRoaXMuZ2V0R2xvYmFsWSgpO1xuICAgICAgICAgICAgLy8gQ3VycmVudGx5IGNvbGxpc2lvbiBwcmltaXRpdmVzIGNhbm5vdCByb3RhdGUgXG4gICAgICAgICAgICAvLyBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGV4LkNvbG9yLlZpb2xldC50b1N0cmluZygpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZXguQ29sb3IuVmlvbGV0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoJ1RyaWdnZXInLCAxMCwgMTApO1xuICAgICAgICAgICAgYmIuZGVidWdEcmF3KGN0eCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJpZ2dlcjtcbiAgICB9KShleC5BY3Rvcik7XG4gICAgZXguVHJpZ2dlciA9IFRyaWdnZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkVuZ2luZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWxnZWJyYS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVXRpbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSB0eXBlcyBvZiBlbWl0dGVyIG5venpsZXNcbiAgICAgKiBAY2xhc3MgRW1pdHRlclR5cGVcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKEVtaXR0ZXJUeXBlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCBmb3IgdGhlIGNpcmN1bGFyIGVtaXR0ZXIgdHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkgQ2lyY2xlIHtFbWl0dGVyVHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIEVtaXR0ZXJUeXBlW0VtaXR0ZXJUeXBlW1wiQ2lyY2xlXCJdID0gMF0gPSBcIkNpcmNsZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgZm9yIHRoZSByZWN0YW5ndWxhciBlbWl0dGVyIHR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IFJlY3RhbmdsZSB7RW1pdHRlclR5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBFbWl0dGVyVHlwZVtFbWl0dGVyVHlwZVtcIlJlY3RhbmdsZVwiXSA9IDFdID0gXCJSZWN0YW5nbGVcIjtcbiAgICB9KShleC5FbWl0dGVyVHlwZSB8fCAoZXguRW1pdHRlclR5cGUgPSB7fSkpO1xuICAgIHZhciBFbWl0dGVyVHlwZSA9IGV4LkVtaXR0ZXJUeXBlO1xuICAgIHZhciBQYXJ0aWNsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBhcnRpY2xlKGVtaXR0ZXIsIGxpZmUsIG9wYWNpdHksIGJlZ2luQ29sb3IsIGVuZENvbG9yLCBwb3NpdGlvbiwgdmVsb2NpdHksIGFjY2VsZXJhdGlvbiwgc3RhcnRTaXplLCBlbmRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3IGV4LlZlY3RvcigwLCAwKTtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgZXguVmVjdG9yKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgZXguVmVjdG9yKDAsIDApO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNBY2NlbCA9IDA7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gZXguQ29sb3IuV2hpdGUuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sb3IgPSBleC5Db2xvci5XaGl0ZS5jbG9uZSgpO1xuICAgICAgICAgICAgLy8gTGlmZSBpcyBjb3VudGVkIGluIG1zXG4gICAgICAgICAgICB0aGlzLmxpZmUgPSAzMDA7XG4gICAgICAgICAgICB0aGlzLmZhZGVGbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDb2xvciB0cmFuc2l0aW9uc1xuICAgICAgICAgICAgdGhpcy5yUmF0ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmdSYXRlID0gMTtcbiAgICAgICAgICAgIHRoaXMuYlJhdGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5hUmF0ZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvciA9IGV4LkNvbG9yLldoaXRlLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSA1O1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNpemVSYXRlID0gMDtcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IGxpZmUgfHwgdGhpcy5saWZlO1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eSB8fCB0aGlzLm9wYWNpdHk7XG4gICAgICAgICAgICB0aGlzLmVuZENvbG9yID0gZW5kQ29sb3IgfHwgdGhpcy5lbmRDb2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gYmVnaW5Db2xvciB8fCB0aGlzLmJlZ2luQ29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yID0gdGhpcy5iZWdpbkNvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gfHwgdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCB0aGlzLnZlbG9jaXR5O1xuICAgICAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBhY2NlbGVyYXRpb24gfHwgdGhpcy5hY2NlbGVyYXRpb247XG4gICAgICAgICAgICB0aGlzLnJSYXRlID0gKHRoaXMuZW5kQ29sb3IuciAtIHRoaXMuYmVnaW5Db2xvci5yKSAvIHRoaXMubGlmZTtcbiAgICAgICAgICAgIHRoaXMuZ1JhdGUgPSAodGhpcy5lbmRDb2xvci5nIC0gdGhpcy5iZWdpbkNvbG9yLmcpIC8gdGhpcy5saWZlO1xuICAgICAgICAgICAgdGhpcy5iUmF0ZSA9ICh0aGlzLmVuZENvbG9yLmIgLSB0aGlzLmJlZ2luQ29sb3IuYikgLyB0aGlzLmxpZmU7XG4gICAgICAgICAgICB0aGlzLmFSYXRlID0gdGhpcy5vcGFjaXR5IC8gdGhpcy5saWZlO1xuICAgICAgICAgICAgdGhpcy5zdGFydFNpemUgPSBzdGFydFNpemUgfHwgMDtcbiAgICAgICAgICAgIHRoaXMuZW5kU2l6ZSA9IGVuZFNpemUgfHwgMDtcbiAgICAgICAgICAgIGlmICgodGhpcy5lbmRTaXplID4gMCkgJiYgKHRoaXMuc3RhcnRTaXplID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVSYXRlID0gKHRoaXMuZW5kU2l6ZSAtIHRoaXMuc3RhcnRTaXplKSAvIHRoaXMubGlmZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IHRoaXMuc3RhcnRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnJlbW92ZVBhcnRpY2xlKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBQYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICB0aGlzLmxpZmUgPSB0aGlzLmxpZmUgLSBkZWx0YTtcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgPSB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyICsgZGVsdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5saWZlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMua2lsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmFkZUZsYWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSBleC5VdGlsLmNsYW1wKHRoaXMuYVJhdGUgKiB0aGlzLmxpZmUsIDAuMDAwMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuc3RhcnRTaXplID4gMCkgJiYgKHRoaXMuZW5kU2l6ZSA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSBleC5VdGlsLmNsYW1wKHRoaXMuc2l6ZVJhdGUgKiBkZWx0YSArIHRoaXMucGFydGljbGVTaXplLCBNYXRoLm1pbih0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKSwgTWF0aC5tYXgodGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IuciA9IGV4LlV0aWwuY2xhbXAodGhpcy5jdXJyZW50Q29sb3IuciArIHRoaXMuclJhdGUgKiBkZWx0YSwgMCwgMjU1KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbG9yLmcgPSBleC5VdGlsLmNsYW1wKHRoaXMuY3VycmVudENvbG9yLmcgKyB0aGlzLmdSYXRlICogZGVsdGEsIDAsIDI1NSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xvci5iID0gZXguVXRpbC5jbGFtcCh0aGlzLmN1cnJlbnRDb2xvci5iICsgdGhpcy5iUmF0ZSAqIGRlbHRhLCAwLCAyNTUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IuYSA9IGV4LlV0aWwuY2xhbXAodGhpcy5vcGFjaXR5LCAwLjAwMDEsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWNjZWwgPSB0aGlzLmZvY3VzLm1pbnVzKHRoaXMucG9zaXRpb24pLm5vcm1hbGl6ZSgpLnNjYWxlKHRoaXMuZm9jdXNBY2NlbCkuc2NhbGUoZGVsdGEgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eS5hZGQoYWNjZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkuYWRkKHRoaXMuYWNjZWxlcmF0aW9uLnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uYWRkKHRoaXMudmVsb2NpdHkuc2NhbGUoZGVsdGEgLyAxMDAwKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvdGF0aW9uID0gKHRoaXMuY3VycmVudFJvdGF0aW9uICsgdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSAqIGRlbHRhIC8gMTAwMCkgJSAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQYXJ0aWNsZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpY2xlU3ByaXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5zZXRSb3RhdGlvbih0aGlzLmN1cnJlbnRSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5zZXRTY2FsZVgodGhpcy5wYXJ0aWNsZVNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUuc2V0U2NhbGVZKHRoaXMucGFydGljbGVTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLmRyYXcoY3R4LCB0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sb3IuYSA9IGV4LlV0aWwuY2xhbXAodGhpcy5vcGFjaXR5LCAwLjAwMDEsIDEpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3VycmVudENvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55LCB0aGlzLnBhcnRpY2xlU2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlO1xuICAgIH0pKCk7XG4gICAgZXguUGFydGljbGUgPSBQYXJ0aWNsZTtcbiAgICAvKipcbiAgICAgKiBVc2luZyBhIHBhcnRpY2xlIGVtaXR0ZXIgaXMgYSBncmVhdCB3YXkgdG8gY3JlYXRlIGludGVyZXN0aW5nIGVmZmVjdHNcbiAgICAgKiBpbiB5b3VyIGdhbWUsIGxpa2Ugc21va2UsIGZpcmUsIHdhdGVyLCBleHBsb3Npb25zLCBldGMuIFBhcnRpY2xlIEVtaXR0ZXJzXG4gICAgICogZXh0ZW5kIEFjdG9yIGFsbG93aW5nIHlvdSB0byB1c2UgYWxsIG9mIHRoZSBmZWF0dXJlcyB0aGF0IGNvbWUgd2l0aCBBY3RvclxuICAgICAqIEBjbGFzcyBQYXJ0aWNsZUVtaXR0ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW3g9MF0ge251bWJlcn0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGVtaXR0ZXJcbiAgICAgKiBAcGFyYW0gW3k9MF0ge251bWJlcn0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGVtaXR0ZXJcbiAgICAgKiBAcGFyYW0gW3dpZHRoPTBdIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZW1pdHRlclxuICAgICAqIEBwYXJhbSBbaGVpZ2h0PTBdIHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIGVtaXR0ZXJcbiAgICAgKi9cbiAgICB2YXIgUGFydGljbGVFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFBhcnRpY2xlRW1pdHRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUGFydGljbGVFbWl0dGVyKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGV4LkNvbG9yLldoaXRlKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA9IDA7XG4gICAgICAgICAgICB0aGlzLm51bVBhcnRpY2xlcyA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaXNFbWl0dGluZyBmbGFnXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgaXNFbWl0dGluZyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc0VtaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYWNraW5nIHBhcnRpY2xlIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBwYXJ0aWNsZXMge1V0aWwuQ29sbGVjdGlvbiZsdDtQYXJ0aWNsZSZndDt9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYWNraW5nIGRlYWRQYXJ0aWNsZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgcGFydGljbGVzIHtVdGlsLkNvbGxlY3Rpb24mbHQ7UGFydGljbGUmZ3Q7fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gcGFydGljYWwgdmVsb2NpdHlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWluVmVsPTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWluVmVsID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHBhcnRpY2FsIHZlbG9jaXR5XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW21heFZlbD0wXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1heFZlbCA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBmb3IgYWxsIHBhcnRpY2xlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFthY2NlbGVyYXRpb249bmV3IFZlY3RvcigwLDApXSB7VmVjdG9yfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBleC5WZWN0b3IoMCwgMCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBhbmdsZSBpbiByYWRpYW5zXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW21pbkFuZ2xlPTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubWluQW5nbGUgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gYW5nbGUgaW4gcmFkaWFuc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFttYXhBbmdsZT0wXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1heEFuZ2xlID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWlzc2lvbiByYXRlIGZvciBwYXJ0aWNsZXMgKHBhcnRpY2xlcy9zZWMpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2VtaXRSYXRlPTFdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW1pdFJhdGUgPSAxOyAvL3BhcnRpY2xlcy9zZWNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBsaWZlIG9mIGVhY2ggcGFydGljbGUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW3BhcnRpY2xlTGlmZT0yMDAwXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlTGlmZSA9IDIwMDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3BhY2l0eSBvZiBlYWNoIHBhcnRpY2xlIGZyb20gMCB0byAxLjBcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbb3BhY2l0eT0xLjBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZmFkZSBmbGFnIHdoaWNoIGNhdXNlcyBwYXJ0aWNsZXMgdG8gZ3JhZHVhbGx5IGZhZGUgb3V0IG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVpciBsaWZlLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtmYWRlPWZhbHNlXSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mYWRlRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIGZvY3VzIHdoZXJlIGFsbCBwYXJ0aWNsZXMgc2hvdWxkIGFjY2VsZXJhdGUgdG93YXJkc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFtmb2N1cz1udWxsXSB7VmVjdG9yfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBhY2NlbGVyYXRpb24gZm9yIGZvY3VzaW5nIHBhcnRpY2xlcyBpZiBhIGZvY3VzIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtmb2N1c0FjY2VsPTFdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm9jdXNBY2NlbCA9IDE7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBzdGFydGluZyBzaXplIGZvciB0aGUgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW3N0YXJ0U2l6ZT1udWxsXSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2l6ZSA9IG51bGw7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBlbmRpbmcgc2l6ZSBmb3IgdGhlIHBhcnRpY2xlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFtlbmRTaXplPW51bGxdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW5kU2l6ZSA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBzaXplIG9mIGFsbCBwYXJ0aWNsZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbbWluU2l6ZT01XSB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm1pblNpemUgPSA1O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gc2l6ZSBvZiBhbGwgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW21heFNpemU9NV0ge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5tYXhTaXplID0gNTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiZWdpbm5pbmcgY29sb3Igb2YgYWxsIHBhcnRpY2xlc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IFtiZWdpbkNvbG9yPUNvbG9yLldoaXRlXSB7Q29sb3J9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IGV4LkNvbG9yLldoaXRlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVuZGluZyBjb2xvciBvZiBhbGwgcGFydGljbGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2VuZENvbG9yPUNvbG9yLldoaXRlXSB7Q29sb3J9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZW5kQ29sb3IgPSBleC5Db2xvci5XaGl0ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBzcHJpdGUgdGhhdCBhIHBhcnRpY2xlIHNob3VsZCB1c2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcGFydGljbGVTcHJpdGU9bnVsbF0ge1Nwcml0ZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZSA9IG51bGw7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pdHRlciB0eXBlIGZvciB0aGUgcGFydGljbGUgZW1pdHRlclxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtlbWl0dGVyVHlwZT1FbWl0dGVyVHlwZS5SZWN0YW5nbGVdIHtFbWl0dGVyVHlwZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyVHlwZSA9IDEgLyogUmVjdGFuZ2xlICovO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXR0ZXIgcmFkaXVzLCBvbmx5IHRha2VzIGVmZmVjdCB3aGVuIHRoZSBlbWl0dGVyVHlwZSBpcyBDaXJjbGVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcmFkaXVzPTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBwYXJ0aWNsZSByb3RhdGlvbmFsIHNwZWVkIHZlbG9jaXR5XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW3BhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5PTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBwYXJ0aWNsZXMgc2hvdWxkIHN0YXJ0IHdpdGggYSByYW5kb20gcm90YXRpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbcmFuZG9tUm90YXRpb249ZmFsc2VdIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJhbmRvbVJvdGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblR5cGUgPSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IG5ldyBleC5VdGlsLkNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcyA9IG5ldyBleC5VdGlsLkNvbGxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBQYXJ0aWNsZUVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZVBhcnRpY2xlID0gZnVuY3Rpb24gKHBhcnRpY2xlKSB7XG4gICAgICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXVzZXMgdGhlIGVtaXR0ZXIgdG8gZW1pdCBwYXJ0aWNsZXNcbiAgICAgICAgICogQG1ldGhvZCBlbWl0XG4gICAgICAgICAqIEBwYXJhbSBwYXJ0aWNsZUNvdW50IHtudW1iZXJ9IE51bWJlciBvZiBwYXJ0aWNsZXMgdG8gZW1pdCByaWdodCBub3dcbiAgICAgICAgICovXG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChwYXJ0aWNsZUNvdW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVzLnB1c2godGhpcy5jcmVhdGVQYXJ0aWNsZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5jbGVhclBhcnRpY2xlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVzLmNsZWFyKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgcGFydGljbGUgZ2l2ZW4gdGhlIGNvbnRyYWludHMgb2YgdGhlIGVtaXR0ZXJcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5jcmVhdGVQYXJ0aWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gaW1wbGVtZW50IGVtaXR0ZXIgY29udHJhaW50cztcbiAgICAgICAgICAgIHZhciByYW5YID0gMDtcbiAgICAgICAgICAgIHZhciByYW5ZID0gMDtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSh0aGlzLm1pbkFuZ2xlLCB0aGlzLm1heEFuZ2xlKTtcbiAgICAgICAgICAgIHZhciB2ZWwgPSBleC5VdGlsLnJhbmRvbUluUmFuZ2UodGhpcy5taW5WZWwsIHRoaXMubWF4VmVsKTtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5zdGFydFNpemUgfHwgZXguVXRpbC5yYW5kb21JblJhbmdlKHRoaXMubWluU2l6ZSwgdGhpcy5tYXhTaXplKTtcbiAgICAgICAgICAgIHZhciBkeCA9IHZlbCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBkeSA9IHZlbCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVtaXR0ZXJUeXBlID09PSAxIC8qIFJlY3RhbmdsZSAqLykge1xuICAgICAgICAgICAgICAgIHJhblggPSBleC5VdGlsLnJhbmRvbUluUmFuZ2UodGhpcy54LCB0aGlzLnggKyB0aGlzLmdldFdpZHRoKCkpO1xuICAgICAgICAgICAgICAgIHJhblkgPSBleC5VdGlsLnJhbmRvbUluUmFuZ2UodGhpcy55LCB0aGlzLnkgKyB0aGlzLmdldEhlaWdodCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZW1pdHRlclR5cGUgPT09IDAgLyogQ2lyY2xlICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSgwLCB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgcmFuWCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSArIHRoaXMueDtcbiAgICAgICAgICAgICAgICByYW5ZID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpICsgdGhpcy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHAgPSBuZXcgUGFydGljbGUodGhpcywgdGhpcy5wYXJ0aWNsZUxpZmUsIHRoaXMub3BhY2l0eSwgdGhpcy5iZWdpbkNvbG9yLCB0aGlzLmVuZENvbG9yLCBuZXcgZXguVmVjdG9yKHJhblgsIHJhblkpLCBuZXcgZXguVmVjdG9yKGR4LCBkeSksIHRoaXMuYWNjZWxlcmF0aW9uLCB0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKTtcbiAgICAgICAgICAgIHAuZmFkZUZsYWcgPSB0aGlzLmZhZGVGbGFnO1xuICAgICAgICAgICAgcC5wYXJ0aWNsZVNpemUgPSBzaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFydGljbGVTcHJpdGUpIHtcbiAgICAgICAgICAgICAgICBwLnBhcnRpY2xlU3ByaXRlID0gdGhpcy5wYXJ0aWNsZVNwcml0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5O1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZG9tUm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICBwLmN1cnJlbnRSb3RhdGlvbiA9IGV4LlV0aWwucmFuZG9tSW5SYW5nZSgwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mb2N1cykge1xuICAgICAgICAgICAgICAgIHAuZm9jdXMgPSB0aGlzLmZvY3VzLmFkZChuZXcgZXguVmVjdG9yKHRoaXMueCwgdGhpcy55KSk7XG4gICAgICAgICAgICAgICAgcC5mb2N1c0FjY2VsID0gdGhpcy5mb2N1c0FjY2VsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGVuZ2luZSwgZGVsdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbWl0dGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpY2xlc1RvRW1pdCArPSB0aGlzLmVtaXRSYXRlICogKGRlbHRhIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgdmFyIG51bVBhcnRpY2xlcyA9IE1hdGguY2VpbCh0aGlzLmVtaXRSYXRlICogZGVsdGEgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGFydGljbGVzVG9FbWl0ID4gMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChNYXRoLmZsb29yKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgLSBNYXRoLmZsb29yKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydGljbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcGFydGljbGUudXBkYXRlKGRlbHRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBhcnRpY2xlcy5yZW1vdmVFbGVtZW50KHBhcnRpY2xlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLmNsZWFyKCk7XG4gICAgICAgIH07XG4gICAgICAgIFBhcnRpY2xlRW1pdHRlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgsIGRlbHRhKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvIGlzIHRoZXJlIGEgbW9yZSBlZmZpY2llbnQgdG8gZHJhdyBcbiAgICAgICAgICAgICAgICAvLyBwb3NzaWJseSB1c2UgYSB3ZWJnbCBvZmZzY3JlZW4gY2FudmFzIGFuZCBzaGFkZXJzIHRvIGRvIHBhcnRpY2xlcz9cbiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5kcmF3KGN0eCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUGFydGljbGVFbWl0dGVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlYnVnRHJhdy5jYWxsKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZXguQ29sb3IuQmxhY2sudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChcIlBhcnRpY2xlczogXCIgKyB0aGlzLnBhcnRpY2xlcy5jb3VudCgpLCB0aGlzLngsIHRoaXMueSArIDIwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMuZm9jdXMueCArIHRoaXMueCwgdGhpcy5mb2N1cy55ICsgdGhpcy55LCAzLCAzKTtcbiAgICAgICAgICAgICAgICBleC5VdGlsLmRyYXdMaW5lKGN0eCwgXCJ5ZWxsb3dcIiwgdGhpcy5mb2N1cy54ICsgdGhpcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnksIF9zdXBlci5wcm90b3R5cGUuZ2V0Q2VudGVyLmNhbGwodGhpcykueCwgX3N1cGVyLnByb3RvdHlwZS5nZXRDZW50ZXIuY2FsbCh0aGlzKS55KTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoXCJGb2N1c1wiLCB0aGlzLmZvY3VzLnggKyB0aGlzLngsIHRoaXMuZm9jdXMueSArIHRoaXMueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQYXJ0aWNsZUVtaXR0ZXI7XG4gICAgfSkoZXguQWN0b3IpO1xuICAgIGV4LlBhcnRpY2xlRW1pdHRlciA9IFBhcnRpY2xlRW1pdHRlcjtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9ucyBhbGxvdyB5b3UgdG8gZGlzcGxheSBhIHNlcmllcyBvZiBpbWFnZXMgb25lIGFmdGVyIGFub3RoZXIsXG4gICAgICogY3JlYXRpbmcgdGhlIGlsbHVzaW9uIG9mIGNoYW5nZS4gR2VuZXJhbGx5IHRoZXNlIGltYWdlcyB3aWxsIGNvbWUgZnJvbSBhIHNwcml0ZSBzaGVldCBzb3VyY2UuXG4gICAgICogQGNsYXNzIEFuaW1hdGlvblxuICAgICAqIEBleHRlbmRzIElEcmF3YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBlbmdpbmUge0VuZ2luZX0gUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgZW5naW5lXG4gICAgICogQHBhcmFtIGltYWdlcyB7U3ByaXRlW119IEFuIGFycmF5IG9mIHNwcml0ZXMgdG8gY3JlYXRlIHRoZSBmcmFtZXMgZm9yIHRoZSBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gc3BlZWQge251bWJlcn0gVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gW2xvb3A9ZmFsc2VdIHtib29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIHNob3VsZCBsb29wIGFmdGVyIGl0IGlzIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb24oZW5naW5lLCBpbWFnZXMsIHNwZWVkLCBsb29wKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLm9sZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gMS4wO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSAxLjA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3AgYWZ0ZXIgaXQgaXMgY29tcGxldGVkXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2xvb3A9ZmFsc2VdIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZnJlZXplRnJhbWUgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcyA9IGltYWdlcztcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICAgICAgaWYgKGxvb3AgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGltYWdlc1swXSA/IGltYWdlc1swXS5oZWlnaHQgOiAwO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGltYWdlc1swXSA/IGltYWdlc1swXS53aWR0aCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5hZGRFZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5hZGRFZmZlY3QoZWZmZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5yZW1vdmVFZmZlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnJlbW92ZUVmZmVjdChwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuY2xlYXJFZmZlY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uY2xlYXJFZmZlY3RzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUudHJhbnNmb3JtQWJvdXRQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0udHJhbnNmb3JtQWJvdXRQb2ludChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2V0Um90YXRpb24gPSBmdW5jdGlvbiAocmFkaWFucykge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJhZGlhbnM7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5zZXRSb3RhdGlvbihyYWRpYW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnNldFNjYWxlWCA9IGZ1bmN0aW9uIChzY2FsZVgpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uc2V0U2NhbGVYKHNjYWxlWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2V0U2NhbGVZID0gZnVuY3Rpb24gKHNjYWxlWSkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5zZXRTY2FsZVkoc2NhbGVZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRTY2FsZVggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVg7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuZ2V0U2NhbGVZID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVZO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBhbmltYXRpb24gdG8gZmlyc3QgZnJhbWUuXG4gICAgICAgICAqIEBtZXRob2QgcmVzZXRcbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJJbmRleCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLCBhbmltYXRpb25zIHRoYXQgbG9vcCBhcmUgbmV2ZXIgY29tcGxldGUuXG4gICAgICAgICAqIEBtZXRob2QgaXNEb25lXG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICghdGhpcy5sb29wICYmIHRoaXMuY3VyckluZGV4ID49IHRoaXMuc3ByaXRlcy5sZW5ndGgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTm90IG1lYW50IHRvIGJlIGNhbGxlZCBieSBnYW1lIGRldmVsb3BlcnMuIFRpY2tzIHRoZSBhbmltYXRpb24gZm9yd2FyZCBpbnRlcm5hbGx5IGFuXG4gICAgICAgICAqIGNhbGN1bGF0ZXMgd2hldGhlciB0byBjaGFuZ2UgdG8gdGVoIGZyYW1lLlxuICAgICAgICAgKiBAbWV0aG9kIHRpY2tcbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbi5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmICgodGltZSAtIHRoaXMub2xkVGltZSkgPiB0aGlzLnNwZWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJySW5kZXggPSAodGhpcy5sb29wID8gKHRoaXMuY3VyckluZGV4ICsgMSkgJSB0aGlzLnNwcml0ZXMubGVuZ3RoIDogdGhpcy5jdXJySW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZFRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2tpcHMgYWhlYWQgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIEBtZXRob2Qgc2tpcFxuICAgICAgICAgKiBAcGFyYW0gZnJhbWVzIHtudW1iZXJ9IEZyYW1lcyB0byBza2lwIGFoZWFkXG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoZnJhbWVzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJJbmRleCA9ICh0aGlzLmN1cnJJbmRleCArIGZyYW1lcykgJSB0aGlzLnNwcml0ZXMubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJJbmRleCA8IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclNwcml0ZSA9IHRoaXMuc3ByaXRlc1t0aGlzLmN1cnJJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZmxpcFZlcnRpY2FsID0gdGhpcy5mbGlwVmVydGljYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsaXBIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZmxpcEhvcml6b250YWwgPSB0aGlzLmZsaXBIb3Jpem9udGFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyU3ByaXRlLmRyYXcoY3R4LCB4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZyZWV6ZUZyYW1lICE9PSAtMSAmJiB0aGlzLmN1cnJJbmRleCA+PSB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJTcHJpdGUgPSB0aGlzLnNwcml0ZXNbZXguVXRpbC5jbGFtcCh0aGlzLmZyZWV6ZUZyYW1lLCAwLCB0aGlzLnNwcml0ZXMubGVuZ3RoIC0gMSldO1xuICAgICAgICAgICAgICAgIGN1cnJTcHJpdGUuZHJhdyhjdHgsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxheXMgYW4gYW5pbWF0aW9uIGF0IGFuIGFyYml0cmFyeSBsb2NhdGlvbiBpbiB0aGUgZ2FtZS5cbiAgICAgICAgICogQG1ldGhvZCBwbGF5XG4gICAgICAgICAqIEBwYXJhbSB4IHtudW1iZXJ9IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBnYW1lIHRvIHBsYXlcbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn0gVGhlIHkgcG9zaXRpb24gaW4gdGhlIGdhbWUgdG8gcGxheVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnBsYXlBbmltYXRpb24odGhpcywgeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmltYXRpb247XG4gICAgfSkoKTtcbiAgICBleC5BbmltYXRpb24gPSBBbmltYXRpb247XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1vbmtleVBhdGNoLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVdGlsLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2cudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBJbnRlcm5hbDtcbiAgICAoZnVuY3Rpb24gKEludGVybmFsKSB7XG4gICAgICAgIHZhciBGYWxsYmFja0F1ZGlvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZhbGxiYWNrQXVkaW8ocGF0aCwgdm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwiVXNpbmcgbmV3IFdlYiBBdWRpbyBBcGkgZm9yIFwiICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsID0gbmV3IFdlYkF1ZGlvKHBhdGgsIHZvbHVtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcIkZhbGxpbmcgYmFjayB0byBBdWRpbyBFbGVtZW50IGZvciBcIiArIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbCA9IG5ldyBBdWRpb1RhZyhwYXRoLCB2b2x1bWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBGYWxsYmFja0F1ZGlvLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5zZXRMb29wKGxvb3ApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwub25sb2FkID0gdGhpcy5vbmxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMuc291bmRJbXBsLmxvYWQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBGYWxsYmFja0F1ZGlvLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291bmRJbXBsLmlzUGxheWluZygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291bmRJbXBsLnBsYXkoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBGYWxsYmFja0F1ZGlvLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kSW1wbC5wYXVzZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEZhbGxiYWNrQXVkaW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VuZEltcGwuc3RvcCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0F1ZGlvO1xuICAgICAgICB9KSgpO1xuICAgICAgICBJbnRlcm5hbC5GYWxsYmFja0F1ZGlvID0gRmFsbGJhY2tBdWRpbztcbiAgICAgICAgdmFyIEF1ZGlvVGFnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEF1ZGlvVGFnKHBhdGgsIHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHMgPSBuZXcgQXJyYXkoNSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVkQXVkaW8gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF1ZGlvRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdWRpb0VsZW1lbnRzW2ldID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Vm9sdW1lKGV4LlV0aWwuY2xhbXAodm9sdW1lLCAwLCAxLjApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Vm9sdW1lKDEuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5hdWRpb0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBdWRpb1RhZy5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEudm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICBhLmxvb3AgPSBsb29wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5nZXRMb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50cy5zb21lKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmxvb3A7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdGhpcy5wYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLm9ucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZy5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGF1ZGlvIHJlc291cmNlIFwiLCBfdGhpcy5wYXRoLCBcIiBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZVwiLCByZXF1ZXN0LnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9hZGVkQXVkaW8gPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdWRpb0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuc3JjID0gX3RoaXMuX2xvYWRlZEF1ZGlvO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25sb2FkKGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXVkaW9UYWcucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHNbdGhpcy5pbmRleF0ubG9hZCgpO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5hdWRpb0VsZW1lbnRzW3RoaXMuaW5kZXhdLmN1cnJlbnRUaW1lID0gdGhpcy5fY3VycmVudE9mZnNldDtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudHNbdGhpcy5pbmRleF0ucGxheSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBkb25lID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRMb29wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzW3RoaXMuaW5kZXhdLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9ICh0aGlzLmluZGV4ICsgMSkgJSB0aGlzLmF1ZGlvRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gKHRoaXMuaW5kZXggLSAxICsgdGhpcy5hdWRpb0VsZW1lbnRzLmxlbmd0aCkgJSB0aGlzLmF1ZGlvRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSB0aGlzLmF1ZGlvRWxlbWVudHNbdGhpcy5pbmRleF0uY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEF1ZGlvVGFnLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgLy9hLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gQXVkaW9UYWc7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEludGVybmFsLkF1ZGlvVGFnID0gQXVkaW9UYWc7XG4gICAgICAgIGlmICh3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgV2ViQXVkaW8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gV2ViQXVkaW8oc291bmRQYXRoLCB2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBzb3VuZFBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHZvbHVtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZS5nYWluLnZhbHVlID0gZXguVXRpbC5jbGFtcCh2b2x1bWUsIDAsIDEuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZS5nYWluLnZhbHVlID0gMS4wOyAvLyBtYXggdm9sdW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2b2x1bWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZS5nYWluLnZhbHVlID0gdm9sdW1lO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHRoaXMucGF0aCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMub25wcm9ncmVzcztcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBhdWRpbyByZXNvdXJjZSBcIiwgX3RoaXMucGF0aCwgXCIgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGVycm9yIGNvZGVcIiwgcmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25sb2FkKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIlVuYWJsZSB0byBkZWNvZGUgXCIgKyBfdGhpcy5wYXRoICsgXCIgdGhpcyBicm93c2VyIG1heSBub3QgZnVsbHkgc3VwcG9ydCB0aGlzIGZvcm1hdCwgb3IgdGhlIGZpbGUgbWF5IGJlIGNvcnJ1cHQsIFwiICsgXCJpZiB0aGlzIGlzIGFuIG1wMyB0cnkgcmVtb3ZpbmcgaWQzIHRhZ3MgYW5kIGFsYnVtIGFydCBmcm9tIHRoZSBmaWxlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmxvYWQoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBzb3VuZCEgSWYgdGhpcyBpcyBhIGNyb3NzIG9yaWdpbiBlcnJvciwgeW91IG11c3QgaG9zdCB5b3VyIHNvdW5kIHdpdGggeW91ciBodG1sIGFuZCBqYXZhc2NyaXB0LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2ViQXVkaW8ucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFdlYkF1ZGlvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZCA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5sb29wID0gdGhpcy5sb29wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLmNvbm5lY3QodGhpcy52b2x1bWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZvbHVtZS5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQuc3RhcnQoMCwgdGhpcy5fY3VycmVudE9mZnNldCAlIHRoaXMuYnVmZmVyLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb25lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9wbGF5UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5fcGxheVByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291bmQub25lbmRlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlQcm9taXNlID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXguUHJvbWlzZS53cmFwKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzUGxheWluZykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9wbGF5aW5nVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VuZC5zdG9wKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVGhlIHNvdW5kIGNsaXBcIiwgdGhpcy5wYXRoLCBcImhhcyBhbHJlYWR5IGJlZW4gcGF1c2VkIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXZWJBdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9wbGF5aW5nVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLnN0b3AoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaGUgc291bmQgY2xpcFwiLCB0aGlzLnBhdGgsIFwiaGFzIGFscmVhZHkgYmVlbiBzdG9wcGVkIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gV2ViQXVkaW87XG4gICAgICAgIH0pKCk7XG4gICAgICAgIEludGVybmFsLldlYkF1ZGlvID0gV2ViQXVkaW87XG4gICAgfSkoSW50ZXJuYWwgPSBleC5JbnRlcm5hbCB8fCAoZXguSW50ZXJuYWwgPSB7fSkpO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2cudHNcIiAvPlxuLy8gUHJvbWlzZXMvQSsgU3BlYyBodHRwOi8vcHJvbWlzZXMtYXBsdXMuZ2l0aHViLmlvL3Byb21pc2VzLXNwZWMvXG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogVmFsaWQgc3RhdGVzIGZvciBhIHByb21pc2UgdG8gYmUgaW5cbiAgICAgKiBAY2xhc3MgUHJvbWlzZVN0YXRlXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChQcm9taXNlU3RhdGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBSZXNvbHZlZCB7UHJvbWlzZVN0YXRlfVxuICAgICAgICAqL1xuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUmVzb2x2ZWRcIl0gPSAwXSA9IFwiUmVzb2x2ZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBSZWplY3RlZCB7UHJvbWlzZVN0YXRlfVxuICAgICAgICAqL1xuICAgICAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUmVqZWN0ZWRcIl0gPSAxXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBQZW5kaW5nIHtQcm9taXNlU3RhdGV9XG4gICAgICAgICovXG4gICAgICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJQZW5kaW5nXCJdID0gMl0gPSBcIlBlbmRpbmdcIjtcbiAgICB9KShleC5Qcm9taXNlU3RhdGUgfHwgKGV4LlByb21pc2VTdGF0ZSA9IHt9KSk7XG4gICAgdmFyIFByb21pc2VTdGF0ZSA9IGV4LlByb21pc2VTdGF0ZTtcbiAgICAvKipcbiAgICAgKiBQcm9taXNlcy9BKyBzcGVjIGltcGxlbWVudGF0aW9uIG9mIHByb21pc2VzXG4gICAgICogQGNsYXNzIFByb21pc2VcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUHJvbWlzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFByb21pc2UoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDIgLyogUGVuZGluZyAqLztcbiAgICAgICAgICAgIHRoaXMuc3VjY2Vzc0NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWplY3RDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwIGEgdmFsdWUgaW4gYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICAgICAqIEBtZXRob2Qgd3JhcDxUPlxuICAgICAgICAgKiBAcGFyYW0gW3ZhbHVlPXVuZGVmaW5lZF0ge1R9IEFuIG9wdGlvbmFsIHZhbHVlIHRvIHdyYXAgaW4gYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UmbHQ7VCZndDtcbiAgICAgICAgICovXG4gICAgICAgIFByb21pc2Uud3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSAobmV3IFByb21pc2UoKSkucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBuZXcgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHRoZSBwcm9taXNlcyBwYXNzZWQgdG8gaXQgcmVzb2x2ZSwgb3IgcmVqZWN0c1xuICAgICAgICAgKiB3aGVuIGF0IGxlYXN0IDEgcHJvbWlzZSByZWplY3RzLlxuICAgICAgICAgKiBAcGFyYW0gcHJvbWlzZXMge1Byb21pc2VbXX1cbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS5qb2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGpvaW5lZFByb21pc2UgPSBuZXcgUHJvbWlzZSgpO1xuICAgICAgICAgICAgaWYgKCFwcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBqb2luZWRQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzZXMgPSAwO1xuICAgICAgICAgICAgdmFyIHJlamVjdHMgPSAwO1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgcHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NlcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc2VzID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3VjY2Vzc2VzICsgcmVqZWN0cyArIGVycm9ycy5sZW5ndGggPT09IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3RzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyByZWplY3RzICsgZXJyb3JzLmxlbmd0aCA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChlcnJvcnMubGVuZ3RoICsgc3VjY2Vzc2VzICsgcmVqZWN0cykgPT09IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBqb2luZWRQcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhaW4gc3VjY2VzcyBhbmQgcmVqZWN0IGNhbGxiYWNrcyBhZnRlciB0aGUgcHJvbWlzZSBpcyByZXNvdmxlZFxuICAgICAgICAgKiBAbWV0aG9kIHRoZW5cbiAgICAgICAgICogQHBhcmFtIHN1Y2Nlc3NDYWxsYmFjayB7VD0+YW55fSBDYWxsIG9uIHJlc29sdXRpb24gb2YgcHJvbWlzZVxuICAgICAgICAgKiBAcGFyYW0gcmVqZWN0Q2FsbGJhY2sge2FueT0+YW55fSBDYWxsIG9uIHJlamVjdGlvbiBvZiBwcm9taXNlXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UmbHQ7VCZndDtcbiAgICAgICAgICovXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoc3VjY2Vzc0NhbGxiYWNrLCByZWplY3RDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VjY2Vzc0NhbGxiYWNrcy5wdXNoKHN1Y2Nlc3NDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZXNvdmxlZCBjYWxsIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gMCAvKiBSZXNvbHZlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLmNhbGwodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVqZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdENhbGxiYWNrID0gcmVqZWN0Q2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZWplY3RlZCBjYWxsIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gMSAvKiBSZWplY3RlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFuIGVycm9yIGNhbGxiYWNrIHRvIHRoZSBwcm9taXNlXG4gICAgICAgICAqIEBtZXRob2QgZXJyb3JcbiAgICAgICAgICogQHBhcmFtIGVycm9yQ2FsbGJhY2sge2FueT0+YW55fSBDYWxsIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBpbiBhIGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UmbHQ7VCZndDtcbiAgICAgICAgICovXG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrID0gZXJyb3JDYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZSB0aGUgcHJvbWlzZSBhbmQgcGFzcyBhbiBvcHRpb24gdmFsdWUgdG8gdGhlIHN1Y2Nlc3MgY2FsbGJhY2tzXG4gICAgICAgICAqIEBtZXRob2QgcmVzb2x2ZVxuICAgICAgICAgKiBAcGFyYW0gW3ZhbHVlPXVuZGVmaW5lZF0ge1R9IFZhbHVlIHRvIHBhc3MgdG8gdGhlIHN1Y2Nlc3MgY2FsbGJhY2tzXG4gICAgICAgICAqL1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSAyIC8qIFBlbmRpbmcgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSAwIC8qIFJlc29sdmVkICovO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3NDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoX3RoaXMsIF90aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBhIHByb21pc2UgdGhhdCBpcyBub3QgaW4gYSBwZW5kaW5nIHN0YXRlIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWplY3QgdGhlIHByb21pc2UgYW5kIHBhc3MgYW4gb3B0aW9uIHZhbHVlIHRvIHRoZSByZWplY3QgY2FsbGJhY2tzXG4gICAgICAgICAqIEBtZXRob2QgcmVqZWN0XG4gICAgICAgICAqIEBwYXJhbSBbdmFsdWU9dW5kZWZpbmVkXSB7VH0gVmFsdWUgdG8gcGFzcyB0byB0aGUgcmVqZWN0IGNhbGxiYWNrc1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IDIgLyogUGVuZGluZyAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDEgLyogUmVqZWN0ZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWplY3QgYSBwcm9taXNlIHRoYXQgaXMgbm90IGluIGEgcGVuZGluZyBzdGF0ZSEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5wZWN0IHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgcHJvbWlzZVxuICAgICAgICAgKiBAbWV0aG9kIHN0YXRlXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2VTdGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgICAgIH07XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yQ2FsbGJhY2suY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlO1xuICAgIH0pKCk7XG4gICAgZXguUHJvbWlzZSA9IFByb21pc2U7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkludGVyZmFjZXMvSUxvYWRhYmxlLnRzXCIgLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgUmVzb3VyY2UgdHlwZSBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgZ2VuZXJpYyByZXNvdXJjZXMuXG4gICAgICogRm9yIGFueSB0eXBlIG9mIHJlbW90ZSByZXNvdXJjZSBpdCBpcyByZWNvbWVcbiAgICAgKiBAY2xhc3MgUmVzb3VyY2VcbiAgICAgKiBAZXh0ZW5kIElMb2FkYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBwYXRoIHtzdHJpbmd9IFBhdGggdG8gdGhlIHJlbW90ZSByZXNvdXJjZVxuICAgICAqL1xuICAgIHZhciBSZXNvdXJjZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlc291cmNlKHBhdGgsIHJlc3BvbnNlVHlwZSwgYnVzdENhY2hlKSB7XG4gICAgICAgICAgICBpZiAoYnVzdENhY2hlID09PSB2b2lkIDApIHsgYnVzdENhY2hlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBSZXNvdXJjZSBpcyBjb21wbGV0ZWx5IGxvYWRlZCBhbmQgaXMgcmVhZHlcbiAgICAgICAgICogdG8gYmUgZHJhd24uXG4gICAgICAgICAqIEBtZXRob2QgaXNMb2FkZWRcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5kYXRhO1xuICAgICAgICB9O1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUud2lyZUVuZ2luZSA9IGZ1bmN0aW9uIChlbmdpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLmNhY2hlQnVzdCA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IC9cXD9cXHcqPVxcdyovO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LnRlc3QodXJpKSkge1xuICAgICAgICAgICAgICAgIHVyaSArPSAoXCImX189XCIgKyBEYXRlLm5vdygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVyaSArPSAoXCI/X189XCIgKyBEYXRlLm5vdygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmk7XG4gICAgICAgIH07XG4gICAgICAgIFJlc291cmNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJTdGFydGVkIGxvYWRpbmcgcmVzb3VyY2UgXCIgKyB0aGlzLnBhdGgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmVnaW4gbG9hZGluZyB0aGUgcmVzb3VyY2UgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cbiAgICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UmbHQ7YW55Jmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdGhpcy5idXN0Q2FjaGUgPyB0aGlzLmNhY2hlQnVzdCh0aGlzLnBhdGgpIDogdGhpcy5wYXRoLCB0cnVlKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RhcnQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBsb2FkIHJlc291cmNlIFwiLCBfdGhpcy5wYXRoLCBcIiBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZVwiLCByZXF1ZXN0LnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uZXJyb3IocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0YSA9IF90aGlzLnByb2Nlc3NEb3dubG9hZChyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiQ29tcGxldGVkIGxvYWRpbmcgcmVzb3VyY2VcIiwgX3RoaXMucGF0aCk7XG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShfdGhpcy5kYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxvYWRlZCBkYXRhIG9uY2UgdGhlIHJlc291cmNlIGlzIGxvYWRlZFxuICAgICAgICAgKiBAbWV0aG9kIEdldERhdGFcbiAgICAgICAgICogQHJldHVybnMgYW55XG4gICAgICAgICAqL1xuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4gdG8gaGFuZGxlIGFueSBhZGRpdGlvbmFsXG4gICAgICAgICAqIHByb2Nlc3NpbmcuIFN1Y2ggYXMgZGVjb2RpbmcgZG93bmxvYWRlZCBhdWRpbyBiaXRzLlxuICAgICAgICAgKiBAbWV0aG9kIFByb2Nlc3NEb3dubG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgUmVzb3VyY2UucHJvdG90eXBlLnByb2Nlc3NEb3dubG9hZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgYW55IGFkZGl0aW9uYWwgbG9hZGluZyBhZnRlciB0aGUgeGhyIGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlc291cmNlO1xuICAgIH0pKCk7XG4gICAgZXguUmVzb3VyY2UgPSBSZXNvdXJjZTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU291bmQudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlV0aWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlByb21pc2VzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJSZXNvdXJjZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiSW50ZXJmYWNlcy9JTG9hZGFibGUudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBUZXh0dXJlIG9iamVjdCBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgaW1hZ2UgcmVzb3VyY2VzLlxuICAgICAqIEl0IGlzIGdlbmVyYWxseSByZWNvbW1lbmRlZCB0byBwcmVsb2FkIGltYWdlcyB1c2luZyB0aGUgXCJUZXh0dXJlXCIgb2JqZWN0LlxuICAgICAqIEBjbGFzcyBUZXh0dXJlXG4gICAgICogQGV4dGVuZCBSZXNvdXJjZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBwYXRoIHtzdHJpbmd9IFBhdGggdG8gdGhlIGltYWdlIHJlc291cmNlXG4gICAgICogQHBhcmFtIFtidXN0Q2FjaGU9dHJ1ZV0ge2Jvb2xlYW59IE9wdGlvbmFsbHkgbG9hZCB0ZXh0dXJlIHdpdGggY2FjaGUgYnVzdGluZ1xuICAgICAqL1xuICAgIHZhciBUZXh0dXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFRleHR1cmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFRleHR1cmUocGF0aCwgYnVzdENhY2hlKSB7XG4gICAgICAgICAgICBpZiAoYnVzdENhY2hlID09PSB2b2lkIDApIHsgYnVzdENhY2hlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcGF0aCwgJ2Jsb2InLCBidXN0Q2FjaGUpO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgIHRoaXMuYnVzdENhY2hlID0gYnVzdENhY2hlO1xuICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdGhpcy5faXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUgPSBuZXcgZXguU3ByaXRlKHRoaXMsIDAsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFRleHR1cmUgaXMgY29tcGxldGVseSBsb2FkZWQgYW5kIGlzIHJlYWR5XG4gICAgICAgICAqIHRvIGJlIGRyYXduLlxuICAgICAgICAgKiBAbWV0aG9kIGlzTG9hZGVkXG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIFRleHR1cmUucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHRleHR1cmUgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cbiAgICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UmbHQ7SFRNTEltYWdlRWxlbWVudCZndDtcbiAgICAgICAgICovXG4gICAgICAgIFRleHR1cmUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gbmV3IGV4LlByb21pc2UoKTtcbiAgICAgICAgICAgIHZhciBsb2FkZWQgPSBfc3VwZXIucHJvdG90eXBlLmxvYWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGxvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud2lkdGggPSBfdGhpcy5fc3ByaXRlLnN3aWR0aCA9IF90aGlzLl9zcHJpdGUud2lkdGggPSBfdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhlaWdodCA9IF90aGlzLl9zcHJpdGUuc2hlaWdodCA9IF90aGlzLl9zcHJpdGUuaGVpZ2h0ID0gX3RoaXMuaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9hZGVkLnJlc29sdmUoX3RoaXMuaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLmltYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbWFnZS5zcmMgPSBfc3VwZXIucHJvdG90eXBlLmdldERhdGEuY2FsbChfdGhpcyk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVqZWN0KFwiRXJyb3IgbG9hZGluZyB0ZXh0dXJlLlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICBUZXh0dXJlLnByb3RvdHlwZS5hc1Nwcml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcHJpdGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUZXh0dXJlO1xuICAgIH0pKGV4LlJlc291cmNlKTtcbiAgICBleC5UZXh0dXJlID0gVGV4dHVyZTtcbiAgICAvKipcbiAgICAgKiBUaGUgU291bmQgb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBhdWRpb1xuICAgICAqIGNvbXBvbmVudHMsIGZyb20gc291bmR0cmFja3MgdG8gc291bmQgZWZmZWN0cy4gSXQgaXMgZ2VuZXJhbGx5XG4gICAgICogcmVjb21tZW5kZWQgdG8gbG9hZCBzb3VuZCByZXNvdXJjZXMgd2hlbiB1c2luZyBFeGNhbGlidXJcbiAgICAgKiBAY2xhc3MgU291bmRcbiAgICAgKiBAZXh0ZW5kIFJlc291cmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIC4uLnBhdGhzIHtzdHJpbmdbXX0gQSBsaXN0IG9mIGF1ZGlvIHNvdXJjZXMgKGNsaXAud2F2LCBjbGlwLm1wMywgY2xpcC5vZ2cpIGZvciB0aGlzIGF1ZGlvIGNsaXAuIFRoaXMgaXMgZG9uZSBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5LlxuICAgICAqL1xuICAgIHZhciBTb3VuZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNvdW5kKCkge1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhdGhzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEZpbGUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAvKiBDaHJvbWUgOiBNUDMsIFdBViwgT2dnXG4gICAgICAgICAgICAgKiBGaXJlZm94IDogV0FWLCBPZ2csXG4gICAgICAgICAgICAgKiBJRSA6IE1QMywgV0FWIGNvbWluZyBzb29uXG4gICAgICAgICAgICAgKiBTYWZhcmkgTVAzLCBXQVYsIE9nZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEZpbGUgPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChTb3VuZC5jYW5QbGF5RmlsZShwYXRoc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWxlID0gcGF0aHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fc2VsZWN0ZWRGaWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFueSBvZiB0aGUgZmlsZXMgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsZSA9IHBhdGhzWzBdOyAvLyBzZWxlY3QgdGhlIGZpcnN0IHNwZWNpZmllZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb3VuZCA9IG5ldyBleC5JbnRlcm5hbC5GYWxsYmFja0F1ZGlvKHRoaXMuX3NlbGVjdGVkRmlsZSwgMS4wKTtcbiAgICAgICAgfVxuICAgICAgICBTb3VuZC5jYW5QbGF5RmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGV0eXBlID0gLy4qXFwuKFtBLVphLXowLTldKykkLztcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpbGUubWF0Y2goZmlsZXR5cGUpWzFdO1xuICAgICAgICAgICAgICAgIGlmIChhLmNhblBsYXlUeXBlKCdhdWRpby8nICsgdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXguTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihcIkNhbm5vdCBkZXRlcm1pbmUgYXVkaW8gc3VwcG9ydCwgYXNzdW1pbmcgbm8gc3VwcG9ydCBmb3IgdGhlIEF1ZGlvIFRhZ1wiLCBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChlbmdpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCdoaWRkZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucGF1c2VBdWRpb1doZW5IaWRkZW4gJiYgX3RoaXMuaXNQbGF5aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5vbigndmlzaWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2luZS5wYXVzZUF1ZGlvV2hlbkhpZGRlbiAmJiBfdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHZvbHVtZSBvZiB0aGUgc291bmQgY2xpcFxuICAgICAgICAgKiBAbWV0aG9kIHNldFZvbHVtZVxuICAgICAgICAgKiBAcGFyYW0gdm9sdW1lIHtudW1iZXJ9IEEgdm9sdW1lIHZhbHVlIGJldHdlZW4gMC0xLjBcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VuZClcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLnNldFZvbHVtZSh2b2x1bWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNsaXAgc2hvdWxkIGxvb3Agd2hlbiBjb21wbGV0ZVxuICAgICAgICAgKiBAbWV0aG9kIHNldExvb3BcbiAgICAgICAgICogQHBhcmFtIGxvb3Age2Jvb2xlYW59IFNldCB0aGUgbG9vcGluZyBmbGFnXG4gICAgICAgICAqL1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VuZClcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLnNldExvb3AobG9vcCk7XG4gICAgICAgIH07XG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VuZC5pc1BsYXlpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYXkgdGhlIHNvdW5kLCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHNvdW5kIGlzIGRvbmUgcGxheWluZ1xuICAgICAgICAgKiBAbWV0aG9kIHBsYXlcbiAgICAgICAgICogQHJldHVybiBleC5Qcm9taXNlXG4gICAgICAgICAqL1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdW5kLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgdGhlIHNvdW5kLCBhbmQgZG8gbm90IHJld2luZFxuICAgICAgICAgKiBAbWV0aG9kIHBhdXNlXG4gICAgICAgICAqL1xuICAgICAgICBTb3VuZC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VuZClcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLnBhdXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIHRoZSBzb3VuZCBhbmQgcmV3aW5kXG4gICAgICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgU291bmQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VuZClcbiAgICAgICAgICAgICAgICB0aGlzLnNvdW5kLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc291bmQgaXMgbG9hZGVkXG4gICAgICAgICAqIEBtZXRob2QgaXNMb2FkZWRcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xvYWRlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSBzb3VuZCBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxuICAgICAgICAgKiBAbWV0aG9kIGxvYWRcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSZsdDtTb3VuZCZndDtcbiAgICAgICAgICovXG4gICAgICAgIFNvdW5kLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlN0YXJ0ZWQgbG9hZGluZyBzb3VuZFwiLCB0aGlzLl9zZWxlY3RlZEZpbGUpO1xuICAgICAgICAgICAgdGhpcy5zb3VuZC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xuICAgICAgICAgICAgdGhpcy5zb3VuZC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmRlYnVnKFwiQ29tcGxldGVkIGxvYWRpbmcgc291bmRcIiwgX3RoaXMuX3NlbGVjdGVkRmlsZSk7XG4gICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZShfdGhpcy5zb3VuZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zb3VuZC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zb3VuZC5sb2FkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTb3VuZDtcbiAgICB9KSgpO1xuICAgIGV4LlNvdW5kID0gU291bmQ7XG4gICAgLyoqXG4gICAgICogVGhlIGxvYWRlciBwcm92aWRlcyBhIG1lY2hhbmlzbSB0byBwcmVsb2FkIG11bHRpcGxlIHJlc291cmNlcyBhdFxuICAgICAqIG9uZSB0aW1lLiBUaGUgbG9hZGVyIG11c3QgYmUgcGFzc2VkIHRvIHRoZSBlbmdpbmUgaW4gb3JkZXIgdG9cbiAgICAgKiB0cmlnZ2VyIHRoZSBsb2FkaW5nIHByb2dyZXNzIGJhclxuICAgICAqIEBjbGFzcyBMb2FkZXJcbiAgICAgKiBAZXh0ZW5kIElMb2FkYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbbG9hZGFibGVzPXVuZGVmaW5lZF0ge0lMb2FkYWJsZVtdfSBPcHRpb25hbGx5IHByb3ZpZGUgdGhlIGxpc3Qgb2YgcmVzb3VyY2VzIHlvdSB3YW50IHRvIGxvYWQgYXQgY29uc3RydWN0b3IgdGltZVxuICAgICAqL1xuICAgIHZhciBMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMb2FkZXIobG9hZGFibGVzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTGlzdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5udW1Mb2FkZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0NvdW50cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy50b3RhbENvdW50cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxvYWRhYmxlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmVzb3VyY2VzKGxvYWRhYmxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS53aXJlRW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgcmVzb3VyY2UgdG8gdGhlIGxvYWRlciB0byBsb2FkXG4gICAgICAgICAqIEBtZXRob2QgYWRkUmVzb3VyY2VcbiAgICAgICAgICogQHBhcmFtIGxvYWRhYmxlIHtJTG9hZGFibGV9IFJlc291cmNlIHRvIGFkZFxuICAgICAgICAgKi9cbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5hZGRSZXNvdXJjZSA9IGZ1bmN0aW9uIChsb2FkYWJsZSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VMaXN0LnB1c2gobG9hZGFibGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0NvdW50c1trZXldID0gMDtcbiAgICAgICAgICAgIHRoaXMudG90YWxDb3VudHNba2V5XSA9IDE7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlQ291bnQrKztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIHRoZSBsb2FkZXIgdG8gbG9hZFxuICAgICAgICAgKiBAbWV0aG9kIGFkZFJlc291cmNlc1xuICAgICAgICAgKiBAcGFyYW0gbG9hZGFibGVzIHtJTG9hZGFibGVbXX0gVGhlIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGxvYWRcbiAgICAgICAgICovXG4gICAgICAgIExvYWRlci5wcm90b3R5cGUuYWRkUmVzb3VyY2VzID0gZnVuY3Rpb24gKGxvYWRhYmxlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGxvYWRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkUmVzb3VyY2UobCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5zdW1Db3VudHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IG9ialtpXSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBsb2FkZXIgaGFzIGNvbXBsZXRlbHkgbG9hZGVkIGFsbCByZXNvdXJjZXNcbiAgICAgICAgICogQG1ldGhvZCBpc0xvYWRlZFxuICAgICAgICAgKi9cbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bUxvYWRlZCA9PT0gdGhpcy5yZXNvdXJjZUNvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmVnaW4gbG9hZGluZyBhbGwgb2YgdGhlIHN1cHBsaWVkIHJlc291cmNlcywgcmV0dXJuaW5nIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gbG9hZGluZyBvZiBhbGwgaXMgY29tcGxldGVcbiAgICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICAqIEByZXR1cm5zIFByb21zaWUmbHQ7YW55Jmd0O1xuICAgICAgICAgKi9cbiAgICAgICAgTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzb3VyY2VMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1lLm9uY29tcGxldGUuY2FsbChtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb2dyZXNzQXJyYXkgPSBuZXcgQXJyYXkodGhpcy5yZXNvdXJjZUxpc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc0NodW5rcyA9IHRoaXMucmVzb3VyY2VMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VMaXN0LmZvckVhY2goZnVuY3Rpb24gKHIsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2VuZ2luZSkge1xuICAgICAgICAgICAgICAgICAgICByLndpcmVFbmdpbmUoX3RoaXMuX2VuZ2luZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NBcnJheVtpXSA9IHsgbG9hZGVkOiAoKGxvYWRlZCAvIHRvdGFsKSAqICgxMDAgLyBwcm9ncmVzc0NodW5rcykpLCB0b3RhbDogMTAwIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc1Jlc3VsdCA9IHByb2dyZXNzQXJyYXkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbG9hZGVkOiAoYWNjdW0ubG9hZGVkICsgbmV4dC5sb2FkZWQpLCB0b3RhbDogMTAwIH07XG4gICAgICAgICAgICAgICAgICAgIH0sIHsgbG9hZGVkOiAwLCB0b3RhbDogMTAwIH0pO1xuICAgICAgICAgICAgICAgICAgICBtZS5vbnByb2dyZXNzLmNhbGwobWUsIHByb2dyZXNzUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHIub25jb21wbGV0ZSA9IHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWUubnVtTG9hZGVkKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZS5udW1Mb2FkZWQgPT09IG1lLnJlc291cmNlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9ucHJvZ3Jlc3MuY2FsbChtZSwgeyBsb2FkZWQ6IDEwMCwgdG90YWw6IDEwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLm9uY29tcGxldGUuY2FsbChtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBsb2FkTmV4dChsaXN0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghbGlzdFtpbmRleF0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsaXN0W2luZGV4XS5sb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWROZXh0KGxpc3QsIGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2FkTmV4dCh0aGlzLnJlc291cmNlTGlzdCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMb2FkZXI7XG4gICAgfSkoKTtcbiAgICBleC5Mb2FkZXIgPSBMb2FkZXI7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlByb21pc2VzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJMb2FkZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkxvZy50c1wiIC8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogRXhjYWxpYnVyJ3MgYnVpbHQgaW4gdGVtcGxhdGluZyBjbGFzcywgaXQgaXMgYSBsb2FkYWJsZSB0aGF0IHdpbGwgbG9hZFxuICAgICAqIGFuZCBodG1sIGZyYWdtZW50IGZyb20gYSB1cmwuIEV4Y2FsaWJ1ciB0ZW1wbGF0aW5nIGlzIHZlcnkgYmFzaWMgb25seVxuICAgICAqIGFsbG93aW5nIGJpbmRpbmdzIG9mIHRoZSB0eXBlIGRhdGEtdGV4dD1cInRoaXMub2JqLnNvbWVwcm9wXCIsXG4gICAgICogZGF0YS1zdHlsZT1cImNvbG9yOnRoaXMub2JqLmNvbG9yLnRvU3RyaW5nKClcIi4gQmluZGluZ3MgYWxsb3cgYWxsIHZhbGlkXG4gICAgICogamF2YXNjcmlwdCBleHByZXNzaW9ucy5cbiAgICAgKiBAY2xhc3MgVGVtcGxhdGVcbiAgICAgKiBAZXh0ZW5kcyBJTG9hZGFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcGF0aCB7c3RyaW5nfSBMb2NhdGlvbiBvZiB0aGUgaHRtbCB0ZW1wbGF0ZVxuICAgICAqL1xuICAgIHZhciBUZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlKHBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBleC5Mb2dnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2lubmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5faW5uZXJFbGVtZW50LmNsYXNzTmFtZSA9IFwiZXhjYWxpYnVyLXRlbXBsYXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLndpcmVFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBmdWxsIGh0bWwgdGVtcGxhdGUgc3RyaW5nIG9uY2UgbG9hZGVkLlxuICAgICAgICAgKiBAbWV0aG9kIGdldFRlbXBsYXRlU3RyaW5nXG4gICAgICAgICAqIEByZXR1cm5zIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmdldFRlbXBsYXRlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0xvYWRlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9odG1sU3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9pbm5lckVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5faHRtbFN0cmluZztcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlRWxlbWVudHMgPSB0aGlzLl9pbm5lckVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc3R5bGVdJyk7XG4gICAgICAgICAgICB0aGlzLl90ZXh0RWxlbWVudHMgPSB0aGlzLl9pbm5lckVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGV4dF0nKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLl9ldmFsdWF0ZUV4cHJlc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBjdHgpIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgZXhwcmVzc2lvbiArIFwiO1wiKTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBmdW5jLmNhbGwoY3R4KTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIGFueSBjdHggb2JqZWN0IHlvdSB3aXNoIGFuZCBldmFsdWF0ZXMgdGhlIHRlbXBsYXRlLlxuICAgICAgICAgKiBPdmVybG9hZCB0aGlzIG1ldGhvZCB0byBpbmNsdWRlIHlvdXIgZmF2b3JpdGUgdGVtcGxhdGUgbGlicmFyeS5cbiAgICAgICAgICogWW91IG1heSByZXR1cm4gZWl0aGVyIGFuIEhUTUwgc3RyaW5nIG9yIGEgRG9tIG5vZGUuXG4gICAgICAgICAqIEBtZXRob2QgYXBwbHlcbiAgICAgICAgICogQHBhcmFtIGN0eCB7YW55fSBBbnkgb2JqZWN0IHlvdSB3aXNoIHRvIGFwcGx5IHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKiBAcmV0dXJucyBhbnlcbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3N0eWxlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwb29yIG1hbidzIGpzb24gcGFyc2UgZm9yIHRoaW5ncyB0aGF0IGFyZW4ndCBleGFjdGx5IGpzb24gOihcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzdHlsZSBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdHlsZUVsZW1lbnRzW2pdLmRhdGFzZXRbXCJzdHlsZVwiXS5zcGxpdChcIjtcIikuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFscyA9IHMuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1t2YWxzWzBdLnRyaW0oKV0gPSB2YWxzWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHN0eWxlIGluIHN0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHN0eWxlc1tzdHlsZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0eWxlRWxlbWVudHNbal0uc3R5bGVbc3R5bGVdID0gX3RoaXMuX2V2YWx1YXRlRXhwcmVzaW9uKGV4cHJlc3Npb24sIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGV4dEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgdGV4dCBleHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IF90aGlzLl90ZXh0RWxlbWVudHNbaV0uZGF0YXNldFtcInRleHRcIl07XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWxlbWVudHNbaV0uaW5uZXJUZXh0ID0gX3RoaXMuX2V2YWx1YXRlRXhwcmVzaW9uKGV4cHJlc3Npb24sIGN0eCk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0ZW1wbGF0ZSBIVE1MIGhhcyBhIHJvb3QgZWxlbWVudCByZXR1cm4gdGhhdCwgb3RoZXJ3aXNlIHVzZSBjb25zdHJ1Y3RlZCByb290XG4gICAgICAgICAgICBpZiAodGhpcy5faW5uZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lubmVyRWxlbWVudCA9IHRoaXMuX2lubmVyRWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSB0ZW1wbGF0ZS4gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0ZW1wbGF0ZSBzdHJpbmcgd2hlbiBsb2FkZWQuXG4gICAgICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG5ldyBleC5Qcm9taXNlKCk7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHRoaXMucGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gdGhpcy5vbnByb2dyZXNzO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGh0bWwgdGVtcGxhdGUgcmVzb3VyY2UgXCIsIF90aGlzLnBhdGgsIFwiIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlXCIsIHJlcXVlc3Quc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25lcnJvcihyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLnJlc29sdmUoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5faHRtbFN0cmluZyA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMub25jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIkNvbXBsZXRlZCBsb2FkaW5nIHRlbXBsYXRlXCIsIF90aGlzLnBhdGgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jb21waWxlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZS5yZXNvbHZlKF90aGlzLl9odG1sU3RyaW5nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZW1wbGF0ZSBoYXMgYmVlbiBsb2FkZWRcbiAgICAgICAgICogQG1ldGhvZCBpc0xvYWRlZFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0xvYWRlZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRlbXBsYXRlO1xuICAgIH0pKCk7XG4gICAgZXguVGVtcGxhdGUgPSBUZW1wbGF0ZTtcbiAgICAvKipcbiAgICAgKiBFeGNhbGlidXIncyBiaW5kaW5nIGxpYnJhcnkgdGhhdCBhbGxvd3MgeW91IHRvIGJpbmQgYW4gaHRtbFxuICAgICAqIHRlbXBsYXRlIHRvIHRoZSBkb20gZ2l2ZW4gYSBjZXJ0YWluIGNvbnRleHQuIEV4Y2FsaWJ1ciBiaW5kaW5ncyBhcmUgb25seSB1cGRhdGVkXG4gICAgICogd2hlbiB0aGUgdXBkYXRlKCkgbWV0aG9kIGlzIGNhbGxlZFxuICAgICAqIEBjbGFzcyBCaW5kaW5nXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHBhcmVudEVsZW1lbnRJZCB7c3RyaW5nfSBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGRvbSB0byBhdHRhY2ggdGhlIHRlbXBsYXRlIGJpbmRpbmdcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGUge1RlbXBsYXRlfSBUaGUgdGVtcGxhdGUgeW91IHdpc2ggdG8gYmluZFxuICAgICAqIEBwYXJhbSBjdHgge2FueX0gVGhlIGNvbnRleHQgb2YgdGhlIGJpbmRpbmcsIHdoaWNoIGNhbiBiZSBhbnkgb2JqZWN0XG4gICAgICovXG4gICAgdmFyIEJpbmRpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCaW5kaW5nKHBhcmVudEVsZW1lbnRJZCwgdGVtcGxhdGUsIGN0eCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYXJlbnRFbGVtZW50SWQpO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdGVuIHRvIGFueSBhcmJpdHJhcnkgb2JqZWN0J3MgZXZlbnRzIHRvIHVwZGF0ZSB0aGlzIGJpbmRpbmdcbiAgICAgICAgICogQG1ldGhvZCBsaXN0ZW5cbiAgICAgICAgICogQHBhcmFtIG9iaiB7YW55fSBBbnkgb2JqZWN0IHRoYXQgc3VwcG9ydHMgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICAgKiBAcGFyYW0gZXZlbnRzIHtzdHJpbmdbXX0gQSBsaXN0IG9mIGV2ZW50cyB0byBsaXN0ZW4gZm9yXG4gICAgICAgICAqIEBwYXJhbSBbaGFuZGVyPWRlZmF1bHRIYW5kbGVyXSB7Y2FsbGJhY2t9IEEgb3B0aW9uYWwgaGFuZGxlciB0byBmaXJlIG9uIGFueSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgQmluZGluZy5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKG9iaiwgZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gdG9kb1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmouYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKGUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoaXMgdGVtcGxhdGUgYmluZGluZyB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gdGhlIGN0eCByZWZlcmVuY2UgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgQmluZGluZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGh0bWwgPSB0aGlzLl9hcHBseVRlbXBsYXRlKHRoaXMudGVtcGxhdGUsIHRoaXMuX2N0eCk7XG4gICAgICAgICAgICBpZiAoaHRtbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHRtbCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQubGFzdENoaWxkICE9PSBodG1sKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKGh0bWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQmluZGluZy5wcm90b3R5cGUuX2FwcGx5VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUsIGN0eCkge1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUuYXBwbHkoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJpbmRpbmc7XG4gICAgfSkoKTtcbiAgICBleC5CaW5kaW5nID0gQmluZGluZztcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQWN0b3IudHNcIiAvPlxudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIC8qKlxuICAgICAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudHNcbiAgICAgKiBAY2xhc3MgVGV4dEFsaWduXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChUZXh0QWxpZ24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGxlZnQtYWxpZ25lZC5cbiAgICAgICAgICogQHByb3BlcnR5IExlZnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIkxlZnRcIl0gPSAwXSA9IFwiTGVmdFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgaXMgcmlnaHQtYWxpZ25lZC5cbiAgICAgICAgICogQHByb3BlcnR5IFJpZ2h0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJSaWdodFwiXSA9IDFdID0gXCJSaWdodFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgaXMgY2VudGVyZWQuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBDZW50ZXJcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgVGV4dEFsaWduW1RleHRBbGlnbltcIkNlbnRlclwiXSA9IDJdID0gXCJDZW50ZXJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGFsaWduZWQgYXQgdGhlIG5vcm1hbCBzdGFydCBvZiB0aGUgbGluZSAobGVmdC1hbGlnbmVkIGZvciBsZWZ0LXRvLXJpZ2h0IGxvY2FsZXMsIHJpZ2h0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBTdGFydFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBUZXh0QWxpZ25bVGV4dEFsaWduW1wiU3RhcnRcIl0gPSAzXSA9IFwiU3RhcnRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGlzIGFsaWduZWQgYXQgdGhlIG5vcm1hbCBlbmQgb2YgdGhlIGxpbmUgKHJpZ2h0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcywgbGVmdC1hbGlnbmVkIGZvciByaWdodC10by1sZWZ0IGxvY2FsZXMpLlxuICAgICAgICAgKiBAcHJvcGVydHkgRW5kXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIFRleHRBbGlnbltUZXh0QWxpZ25bXCJFbmRcIl0gPSA0XSA9IFwiRW5kXCI7XG4gICAgfSkoZXguVGV4dEFsaWduIHx8IChleC5UZXh0QWxpZ24gPSB7fSkpO1xuICAgIHZhciBUZXh0QWxpZ24gPSBleC5UZXh0QWxpZ247XG4gICAgLyoqXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBiYXNlbGluZSB0ZXh0IGFsaWdubWVudHNcbiAgICAgKiBAY2xhc3MgQmFzZUFsaWduXG4gICAgICovXG4gICAgKGZ1bmN0aW9uIChCYXNlQWxpZ24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSB0b3Agb2YgdGhlIGVtIHNxdWFyZS5cbiAgICAgICAgICogQHByb3BlcnR5IFRvcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiVG9wXCJdID0gMF0gPSBcIlRvcFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGhhbmdpbmcgYmFzZWxpbmUuICBDdXJyZW50bHkgdW5zdXBwb3J0ZWQ7IHRoaXMgd2lsbCBhY3QgbGlrZSBhbHBoYWJldGljLlxuICAgICAgICAgKiBAcHJvcGVydHkgSGFuZ2luZ1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiSGFuZ2luZ1wiXSA9IDFdID0gXCJIYW5naW5nXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgbWlkZGxlIG9mIHRoZSBlbSBzcXVhcmUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBNaWRkbGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIk1pZGRsZVwiXSA9IDJdID0gXCJNaWRkbGVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBub3JtYWwgYWxwaGFiZXRpYyBiYXNlbGluZS5cbiAgICAgICAgICogQHByb3BlcnR5IEFscGhhYmV0aWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIkFscGhhYmV0aWNcIl0gPSAzXSA9IFwiQWxwaGFiZXRpY1wiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lOyB0aGlzIGlzIHRoZSBib3R0b20gb2ZcbiAgICAgICAgICogdGhlIGJvZHkgb2YgdGhlIGNoYXJhY3RlcnMsIGlmIHRoZSBtYWluIGJvZHkgb2YgY2hhcmFjdGVycyBwcm90cnVkZXNcbiAgICAgICAgICogYmVuZWF0aCB0aGUgYWxwaGFiZXRpYyBiYXNlbGluZS4gIEN1cnJlbnRseSB1bnN1cHBvcnRlZDsgdGhpcyB3aWxsXG4gICAgICAgICAqIGFjdCBsaWtlIGFscGhhYmV0aWMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBJZGVvZ3JhcGhpY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqL1xuICAgICAgICBCYXNlQWxpZ25bQmFzZUFsaWduW1wiSWRlb2dyYXBoaWNcIl0gPSA0XSA9IFwiSWRlb2dyYXBoaWNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBib3R0b20gb2YgdGhlIGJvdW5kaW5nIGJveC4gIFRoaXMgZGlmZmVyc1xuICAgICAgICAgKiBmcm9tIHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZSBpbiB0aGF0IHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZVxuICAgICAgICAgKiBkb2Vzbid0IGNvbnNpZGVyIGRlc2NlbmRlcnMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBCb3R0b21cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgQmFzZUFsaWduW0Jhc2VBbGlnbltcIkJvdHRvbVwiXSA9IDVdID0gXCJCb3R0b21cIjtcbiAgICB9KShleC5CYXNlQWxpZ24gfHwgKGV4LkJhc2VBbGlnbiA9IHt9KSk7XG4gICAgdmFyIEJhc2VBbGlnbiA9IGV4LkJhc2VBbGlnbjtcbiAgICAvKipcbiAgICAgKiBMYWJlbHMgYXJlIHRoZSB3YXkgdG8gZHJhdyBzbWFsbCBhbW91bnRzIG9mIHRleHQgdG8gdGhlIHNjcmVlbiBpbiBFeGNhbGlidXIuIFRoZXkgYXJlXG4gICAgICogYWN0b3JzIGFuZCBpbmhlcml0IGFsbCBvZiB0aGUgYmVuaWZpdHMgYW5kIGNhcGFiaWxpdGllcy5cbiAgICAgKiBAY2xhc3MgTGFiZWxcbiAgICAgKiBAZXh0ZW5kcyBBY3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBbdGV4dD1lbXB0eV0ge3N0cmluZ30gVGhlIHRleHQgb2YgdGhlIGxhYmVsXG4gICAgICogQHBhcmFtIFt4PTBdIHtudW1iZXJ9IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBsYWJlbFxuICAgICAqIEBwYXJhbSBbeT0wXSB7bnVtYmVyfSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgbGFiZWxcbiAgICAgKiBAcGFyYW0gW2ZvbnQ9c2Fucy1zZXJpZl0ge3N0cmluZ30gVXNlIGFueSB2YWxpZCBjc3MgZm9udCBzdHJpbmcgZm9yIHRoZSBsYWJlbCdzIGZvbnQuIERlZmF1bHQgaXMgXCIxMHB4IHNhbnMtc2VyaWZcIi5cbiAgICAgKiBAcGFyYW0gW3Nwcml0ZUZvbnQ9dW5kZWZpbmVkXSB7U3ByaXRlRm9udH0gVXNlIGFuIEV4Y2FsaWJ1ciBzcHJpdGUgZm9udCBmb3IgdGhlIGxhYmVsJ3MgZm9udCwgaWYgYSBTcHJpdGVGb250IGlzIHByb3ZpZGVkIGl0IHdpbGwgdGFrZSBwcmVjZW5kZW5jZSBvdmVyIGEgY3NzIGZvbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgTGFiZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTGFiZWwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIExhYmVsKHRleHQsIHgsIHksIGZvbnQsIHNwcml0ZUZvbnQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxldHRlciBzcGFjaW5nIG9uIGEgTGFiZWwuIE9ubHkgc3VwcG9ydGVkIHdpdGggU3ByaXRlIEZvbnRzLlxuICAgICAgICAgICAgICogQHByb3BlcnR5IFtsZXR0ZXJTcGFjaW5nPTBdIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IDA7IC8vcHhcbiAgICAgICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NvbG9yID0gZXguQ29sb3IuQmxhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NvbG9yRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3RleHRTcHJpdGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dTcHJpdGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9jb2xvciA9IGV4LkNvbG9yLkJsYWNrLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSB0ZXh0IHx8IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gZXguQ29sb3IuQmxhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlRm9udCA9IHNwcml0ZUZvbnQ7XG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblR5cGUgPSAwIC8qIFByZXZlbnRDb2xsaXNpb24gKi87XG4gICAgICAgICAgICB0aGlzLmZvbnQgPSBmb250IHx8IFwiMTBweCBzYW5zLXNlcmlmXCI7IC8vIGNvYWxsZXNjZSB0byBkZWZhdWx0IGNhbnZhcyBmb250XG4gICAgICAgICAgICBpZiAoc3ByaXRlRm9udCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTcHJpdGVzID0gc3ByaXRlRm9udC5nZXRUZXh0U3ByaXRlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgdGV4dCBpbiB0aGUgbGFiZWwgKGluIHBpeGVscyk7XG4gICAgICAgICAqIEBtZXRob2QgZ2V0VGV4dFdpZHRoIHtudW1iZXJ9XG4gICAgICAgICAqIEBwYXJhbSBjdHgge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gUmVuZGluZyBjb250ZXh0IHRvIG1lYXN1cmUgdGhlIHN0cmluZyB3aXRoXG4gICAgICAgICAqL1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuZ2V0VGV4dFdpZHRoID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIG9sZEZvbnQgPSBjdHguZm9udDtcbiAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5mb250O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHRoaXMudGV4dCkud2lkdGg7XG4gICAgICAgICAgICBjdHguZm9udCA9IG9sZEZvbnQ7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCBzdXBwb3J0IHN0cmluZyBlbnVtcyA6KFxuICAgICAgICBMYWJlbC5wcm90b3R5cGUuX2xvb2t1cFRleHRBbGlnbiA9IGZ1bmN0aW9uICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIExlZnQgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFJpZ2h0ICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyaWdodFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQ2VudGVyICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIEVuZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTdGFydCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5fbG9va3VwQmFzZUFsaWduID0gZnVuY3Rpb24gKGJhc2VBbGlnbikge1xuICAgICAgICAgICAgc3dpdGNoIChiYXNlQWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogQWxwaGFiZXRpYyAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYWxwaGFiZXRpY1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogQm90dG9tICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIEhhbmdpbmcgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImhhbmdpblwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogSWRlb2dyYXBoaWMgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlkZW9ncmFwaGljXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBNaWRkbGUgKi86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1pZGRsZVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogVG9wICovOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0b3BcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYWxwaGFiZXRpY1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRleHQgc2hhZG93IGZvciBzcHJpdGUgZm9udHNcbiAgICAgICAgICogQG1ldGhvZCBzZXRUZXh0U2hhZG93XG4gICAgICAgICAqIEBwYXJhbSBvZmZzZXRYIHtudW1iZXJ9IFRoZSB4IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xuICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0WSB7bnVtYmVyfSBUaGUgeSBvZmZzZXQgaW4gcGl4bGVzIHRvIHBsYWNlIHRoZSBzaGFkb3dcbiAgICAgICAgICogQHBhcmFtIHNoYWRvd0NvbG9yIHtDb2xvcn0gVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHNoYWRvd1xuICAgICAgICAgKi9cbiAgICAgICAgTGFiZWwucHJvdG90eXBlLnNldFRleHRTaGFkb3cgPSBmdW5jdGlvbiAob2Zmc2V0WCwgb2Zmc2V0WSwgc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gb2Zmc2V0WDtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSBvZmZzZXRZO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3JEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBjaGFyYWN0ZXIgaW4gdGhpcy5fdGV4dFNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0gPSB0aGlzLl90ZXh0U3ByaXRlc1tjaGFyYWN0ZXJdLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgdGV4dCBzaGFkb3dcbiAgICAgICAgICogQG1ldGhvZCBjbGVhclRleHRTaGFkb3dcbiAgICAgICAgICovXG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5jbGVhclRleHRTaGFkb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSAwO1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zaGFkb3dDb2xvciA9IGV4LkNvbG9yLkJsYWNrLmNsb25lKCk7XG4gICAgICAgIH07XG4gICAgICAgIExhYmVsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZW5naW5lLCBkZWx0YSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwcml0ZUZvbnQgJiYgdGhpcy5fY29sb3IgIT09IHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGFyYWN0ZXIgaW4gdGhpcy5fdGV4dFNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNwcml0ZXNbY2hhcmFjdGVyXS5jbGVhckVmZmVjdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNwcml0ZXNbY2hhcmFjdGVyXS5hZGRFZmZlY3QobmV3IGV4LkVmZmVjdHMuRmlsbCh0aGlzLmNvbG9yLmNsb25lKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNwcml0ZUZvbnQgJiYgdGhpcy5fdGV4dFNoYWRvd09uICYmIHRoaXMuX3NoYWRvd0NvbG9yRGlydHkgJiYgdGhpcy5fc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGFyYWN0ZXIgaW4gdGhpcy5fc2hhZG93U3ByaXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0uY2xlYXJFZmZlY3RzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5hZGRFZmZlY3QobmV3IGV4LkVmZmVjdHMuRmlsbCh0aGlzLl9zaGFkb3dDb2xvci5jbG9uZSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NoYWRvd0NvbG9yRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGFiZWwucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dFNoYWRvd09uKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuX3NoYWRvd09mZnNldFgsIHRoaXMuX3NoYWRvd09mZnNldFkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnREcmF3KGN0eCwgZGVsdGEsIHRoaXMuX3NoYWRvd1Nwcml0ZXMpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mb250RHJhdyhjdHgsIGRlbHRhLCB0aGlzLl90ZXh0U3ByaXRlcyk7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRyYXcuY2FsbCh0aGlzLCBjdHgsIGRlbHRhKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIExhYmVsLnByb3RvdHlwZS5fZm9udERyYXcgPSBmdW5jdGlvbiAoY3R4LCBkZWx0YSwgc3ByaXRlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ByaXRlRm9udCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyWCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRoaXMudGV4dFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJTcHJpdGUgPSBzcHJpdGVzW2NoYXJhY3Rlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c09wYWNpdHkgIT09IHRoaXMub3BhY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJTcHJpdGUuY2xlYXJFZmZlY3RzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhclNwcml0ZS5hZGRFZmZlY3QobmV3IGV4LkVmZmVjdHMuT3BhY2l0eSh0aGlzLm9wYWNpdHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJTcHJpdGUuZHJhdyhjdHgsIGN1cnJYLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJYICs9IChjaGFyU3ByaXRlLnN3aWR0aCArIHRoaXMubGV0dGVyU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4LkxvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKFwiU3ByaXRlRm9udCBFcnJvciBkcmF3aW5nIGNoYXIgXCIgKyBjaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzT3BhY2l0eSAhPT0gdGhpcy5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvbGRBbGlnbiA9IGN0eC50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIG9sZFRleHRCYXNlbGluZSA9IGN0eC50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMuX2xvb2t1cFRleHRBbGlnbih0aGlzLnRleHRBbGlnbik7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMuX2xvb2t1cEJhc2VBbGlnbih0aGlzLmJhc2VBbGlnbik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvci5hID0gdGhpcy5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvci50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5mb250O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnRleHQsIDAsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBvbGRBbGlnbjtcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gb2xkVGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMYWJlbC5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWJ1Z0RyYXcuY2FsbCh0aGlzLCBjdHgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGFiZWw7XG4gICAgfSkoZXguQWN0b3IpO1xuICAgIGV4LkxhYmVsID0gTGFiZWw7XG59KShleCB8fCAoZXggPSB7fSkpO1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0V2ZW50cy50c1wiLz5cbnZhciBleDtcbihmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgSW5wdXQ7XG4gICAgKGZ1bmN0aW9uIChJbnB1dCkge1xuICAgICAgICAoZnVuY3Rpb24gKFBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIlRvdWNoXCJdID0gMF0gPSBcIlRvdWNoXCI7XG4gICAgICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIk1vdXNlXCJdID0gMV0gPSBcIk1vdXNlXCI7XG4gICAgICAgICAgICBQb2ludGVyVHlwZVtQb2ludGVyVHlwZVtcIlBlblwiXSA9IDJdID0gXCJQZW5cIjtcbiAgICAgICAgICAgIFBvaW50ZXJUeXBlW1BvaW50ZXJUeXBlW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XG4gICAgICAgIH0pKElucHV0LlBvaW50ZXJUeXBlIHx8IChJbnB1dC5Qb2ludGVyVHlwZSA9IHt9KSk7XG4gICAgICAgIHZhciBQb2ludGVyVHlwZSA9IElucHV0LlBvaW50ZXJUeXBlO1xuICAgICAgICAoZnVuY3Rpb24gKFBvaW50ZXJCdXR0b24pIHtcbiAgICAgICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIkxlZnRcIl0gPSAwXSA9IFwiTGVmdFwiO1xuICAgICAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiTWlkZGxlXCJdID0gMV0gPSBcIk1pZGRsZVwiO1xuICAgICAgICAgICAgUG9pbnRlckJ1dHRvbltQb2ludGVyQnV0dG9uW1wiUmlnaHRcIl0gPSAyXSA9IFwiUmlnaHRcIjtcbiAgICAgICAgICAgIFBvaW50ZXJCdXR0b25bUG9pbnRlckJ1dHRvbltcIlVua25vd25cIl0gPSAzXSA9IFwiVW5rbm93blwiO1xuICAgICAgICB9KShJbnB1dC5Qb2ludGVyQnV0dG9uIHx8IChJbnB1dC5Qb2ludGVyQnV0dG9uID0ge30pKTtcbiAgICAgICAgdmFyIFBvaW50ZXJCdXR0b24gPSBJbnB1dC5Qb2ludGVyQnV0dG9uO1xuICAgICAgICB2YXIgUG9pbnRlckV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhQb2ludGVyRXZlbnQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBQb2ludGVyRXZlbnQoeCwgeSwgaW5kZXgsIHBvaW50ZXJUeXBlLCBidXR0b24sIGV2KSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24gPSBidXR0b247XG4gICAgICAgICAgICAgICAgdGhpcy5ldiA9IGV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudDtcbiAgICAgICAgfSkoZXguR2FtZUV2ZW50KTtcbiAgICAgICAgSW5wdXQuUG9pbnRlckV2ZW50ID0gUG9pbnRlckV2ZW50O1xuICAgICAgICA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHBvaW50ZXIgZXZlbnRzIChtb3VzZSwgdG91Y2gsIHN0eWx1cywgZXRjLikgYW5kIG5vcm1hbGl6ZXMgdG8gVzNDIFBvaW50ZXIgRXZlbnRzLlxuICAgICAgICAgKiBUaGVyZSBpcyBhbHdheXMgYXQgbGVhc3Qgb25lIHBvaW50ZXIgYXZhaWxhYmxlIChwcmltYXJ5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzIFBvaW50ZXJzXG4gICAgICAgICAqIEBleHRlbmRzIENsYXNzXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFBvaW50ZXJzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhQb2ludGVycywgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBvaW50ZXJzKGVuZ2luZSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJEb3duID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlclVwID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlck1vdmUgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyQ2FuY2VsID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQb2ludGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzID0gWy0xXTtcbiAgICAgICAgICAgICAgICB0aGlzLnByaW1hcnkgPSB0aGlzLl9wb2ludGVyc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgcG9pbnRlciBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gVG91Y2ggRXZlbnRzXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoXCJkb3duXCIsIHRoaXMuX3BvaW50ZXJEb3duKSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KFwidXBcIiwgdGhpcy5fcG9pbnRlclVwKSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hFdmVudChcIm1vdmVcIiwgdGhpcy5fcG9pbnRlck1vdmUpKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoXCJjYW5jZWxcIiwgdGhpcy5fcG9pbnRlckNhbmNlbCkpO1xuICAgICAgICAgICAgICAgIC8vIFczQyBQb2ludGVyIEV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQ6IElFMTEsIElFMTBcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRTExXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5jYW52YXMuc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJkb3duXCIsIHRoaXMuX3BvaW50ZXJEb3duKSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcInVwXCIsIHRoaXMuX3BvaW50ZXJVcCkpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcIm1vdmVcIiwgdGhpcy5fcG9pbnRlck1vdmUpKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcImNhbmNlbFwiLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUxMFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyRG93bicsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcImRvd25cIiwgdGhpcy5fcG9pbnRlckRvd24pKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyVXAnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoXCJ1cFwiLCB0aGlzLl9wb2ludGVyVXApKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyTW92ZScsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChcIm1vdmVcIiwgdGhpcy5fcG9pbnRlck1vdmUpKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyQ2FuY2VsJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KFwiY2FuY2VsXCIsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3VzZSBFdmVudHNcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlTW91c2VFdmVudChcImRvd25cIiwgdGhpcy5fcG9pbnRlckRvd24pKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoXCJ1cFwiLCB0aGlzLl9wb2ludGVyVXApKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlTW91c2VFdmVudChcIm1vdmVcIiwgdGhpcy5fcG9pbnRlck1vdmUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJVcC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJEb3duLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlck1vdmUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyQ2FuY2VsLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTYWZlbHkgZ2V0cyBhIFBvaW50ZXIgYXQgYSBzcGVjaWZpYyBpbmRleCBhbmQgaW5pdGlhbGl6ZXMgb25lIGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gVGhlIHBvaW50ZXIgaW5kZXggdG8gcmV0cmlldmVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fcG9pbnRlcnMubGVuZ3RoIC0gMSwgbWF4ID0gaW5kZXg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlcnMucHVzaChuZXcgUG9pbnRlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzLnB1c2goLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyc1tpbmRleF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgbnVtYmVyIG9mIHBvaW50ZXJzIGJlaW5nIHdhdGNoZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVycy5sZW5ndGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcm9wb2dhdGVzIGV2ZW50cyB0byBhY3RvciBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLnByb3BvZ2F0ZSA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgICAgIHZhciBpc1VJQWN0b3IgPSBhY3RvciBpbnN0YW5jZW9mIGV4LlVJQWN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlclVwLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKGUueCwgZS55LCAhaXNVSUFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJwb2ludGVydXBcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyRG93bi5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rvci5jb250YWlucyhlLngsIGUueSwgIWlzVUlBY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwicG9pbnRlcmRvd25cIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZU1vdmVFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlck1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKGUueCwgZS55LCAhaXNVSUFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwicG9pbnRlcm1vdmVcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVyQ2FuY2VsLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdG9yLmNvbnRhaW5zKGUueCwgZS55LCAhaXNVSUFjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goXCJwb2ludGVyY2FuY2VsXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVNb3VzZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZS5wYWdlWCAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gZS5wYWdlWSAtIGV4LlV0aWwuZ2V0UG9zaXRpb24oX3RoaXMuX2VuZ2luZS5jYW52YXMpLnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KHgsIHkpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlID0gbmV3IFBvaW50ZXJFdmVudCh0cmFuc2Zvcm1lZFBvaW50LngsIHRyYW5zZm9ybWVkUG9pbnQueSwgMCwgMSAvKiBNb3VzZSAqLywgZS5idXR0b24sIGUpO1xuICAgICAgICAgICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXQoMCkuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goZXZlbnROYW1lLCBwZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQb2ludGVycy5wcm90b3R5cGUuX2hhbmRsZVRvdWNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxID8gX3RoaXMuX2dldFBvaW50ZXJJbmRleChlLmNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXIpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGUuY2hhbmdlZFRvdWNoZXNbaV0ucGFnZVggLSBleC5VdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VZIC0gZXguVXRpbC5nZXRQb3NpdGlvbihfdGhpcy5fZW5naW5lLmNhbnZhcykueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50ID0gX3RoaXMuX2VuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IGV4LlBvaW50KHgsIHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZSA9IG5ldyBQb2ludGVyRXZlbnQodHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnksIGluZGV4LCAwIC8qIFRvdWNoICovLCAzIC8qIFVua25vd24gKi8sIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goZXZlbnROYW1lLCBwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHdpdGggbXVsdGktcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJ1cFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwb2ludGVyIElEIGZyb20gcG9vbCB3aGVuIHBvaW50ZXIgaXMgbGlmdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lID09PSBcImRvd25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcG9pbnRlciBJRCB0byBnaXZlbiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9oYW5kbGVQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFycikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBmb3IgdGhpcyBwb2ludGVyIElEIGlmIG11bHRpLXBvaW50ZXIgaXMgYXNrZWQgZm9yXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9wb2ludGVycy5sZW5ndGggPiAxID8gX3RoaXMuX2dldFBvaW50ZXJJbmRleChlLnBvaW50ZXJJZCkgOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGUucGFnZVggLSBleC5VdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS54O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGUucGFnZVkgLSBleC5VdGlsLmdldFBvc2l0aW9uKF90aGlzLl9lbmdpbmUuY2FudmFzKS55O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludCA9IF90aGlzLl9lbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBleC5Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZSA9IG5ldyBQb2ludGVyRXZlbnQodHJhbnNmb3JtZWRQb2ludC54LCB0cmFuc2Zvcm1lZFBvaW50LnksIGluZGV4LCBfdGhpcy5fc3RyaW5nVG9Qb2ludGVyVHlwZShlLnBvaW50ZXJUeXBlKSwgZS5idXR0b24sIGUpO1xuICAgICAgICAgICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKGV2ZW50TmFtZSwgcGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHdpdGggbXVsdGktcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwidXBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwb2ludGVyIElEIGZyb20gcG9vbCB3aGVuIHBvaW50ZXIgaXMgbGlmdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lID09PSBcImRvd25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIElEIHRvIGdpdmVuIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IGUucG9pbnRlcklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwb2ludGVyIHNwZWNpZmllZCBmb3IgdGhlIGdpdmVuIHBvaW50ZXIgSUQgb3IgZmluZHMgdGhlIG5leHQgZW1wdHkgcG9pbnRlciBzbG90IGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBJRTEwLzExIHVzZXMgaW5jcmVtZW50aW5nIHBvaW50ZXIgSURzIHNvIHdlIG5lZWQgdG8gc3RvcmUgYSBtYXBwaW5nIG9mIElEID0+IGlkeFxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUG9pbnRlcnMucHJvdG90eXBlLl9nZXRQb2ludGVySW5kZXggPSBmdW5jdGlvbiAocG9pbnRlcklkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeDtcbiAgICAgICAgICAgICAgICBpZiAoKGlkeCA9IHRoaXMuX2FjdGl2ZVBvaW50ZXJzLmluZGV4T2YocG9pbnRlcklkKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZVBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVQb2ludGVyc1tpXSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHBvaW50ZXIgYmVjYXVzZSBnYW1lIGlzbid0IHdhdGNoaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFBvaW50ZXJzLnByb3RvdHlwZS5fc3RyaW5nVG9Qb2ludGVyVHlwZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogVG91Y2ggKi87XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtb3VzZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogTW91c2UgKi87XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIFBlbiAqLztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIFVua25vd24gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQb2ludGVycztcbiAgICAgICAgfSkoZXguQ2xhc3MpO1xuICAgICAgICBJbnB1dC5Qb2ludGVycyA9IFBvaW50ZXJzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FwdHVyZXMgYW5kIGRpc3BhdGNoZXMgUG9pbnRlckV2ZW50c1xuICAgICAgICAgKiBAY2xhc3MgUG9pbnRlclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQGV4dGVuZHMgQ2xhc3NcbiAgICAgICAgICovXG4gICAgICAgIHZhciBQb2ludGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhQb2ludGVyLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUG9pbnRlcigpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQb2ludGVyO1xuICAgICAgICB9KShleC5DbGFzcyk7XG4gICAgICAgIElucHV0LlBvaW50ZXIgPSBQb2ludGVyO1xuICAgIH0pKElucHV0ID0gZXguSW5wdXQgfHwgKGV4LklucHV0ID0ge30pKTtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgdmFyIElucHV0O1xuICAgIChmdW5jdGlvbiAoSW5wdXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICogRW51bSByZXByZXNlbnRpbmcgaW5wdXQga2V5IGNvZGVzXG4gICAgICAgICogQGNsYXNzIEtleXNcbiAgICAgICAgKlxuICAgICAgICAqL1xuICAgICAgICAoZnVuY3Rpb24gKEtleXMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTEge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtMiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW0zIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtNSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW02IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTcge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtOCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOdW05IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE51bTAge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtMVwiXSA9IDk3XSA9IFwiTnVtMVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtMlwiXSA9IDk4XSA9IFwiTnVtMlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtM1wiXSA9IDk5XSA9IFwiTnVtM1wiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtNFwiXSA9IDEwMF0gPSBcIk51bTRcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bTVcIl0gPSAxMDFdID0gXCJOdW01XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW02XCJdID0gMTAyXSA9IFwiTnVtNlwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtN1wiXSA9IDEwM10gPSBcIk51bTdcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk51bThcIl0gPSAxMDRdID0gXCJOdW04XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW05XCJdID0gMTA1XSA9IFwiTnVtOVwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTnVtMFwiXSA9IDk2XSA9IFwiTnVtMFwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTnVtbG9jayB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBLZXlzW0tleXNbXCJOdW1sb2NrXCJdID0gMTQ0XSA9IFwiTnVtbG9ja1wiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgU2VtaWNvbG9uIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlNlbWljb2xvblwiXSA9IDE4Nl0gPSBcIlNlbWljb2xvblwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgQSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBCIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEMge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgRCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBFIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEYge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgRyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBIIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEkge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgSiB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBLIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEwge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgTSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBOIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IE8ge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgUCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBRIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFIge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgUyB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBUIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFUge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgViB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBXIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFgge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgWSB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBaIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkFcIl0gPSA2NV0gPSBcIkFcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkJcIl0gPSA2Nl0gPSBcIkJcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkNcIl0gPSA2N10gPSBcIkNcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkRcIl0gPSA2OF0gPSBcIkRcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkVcIl0gPSA2OV0gPSBcIkVcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkZcIl0gPSA3MF0gPSBcIkZcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkdcIl0gPSA3MV0gPSBcIkdcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkhcIl0gPSA3Ml0gPSBcIkhcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIklcIl0gPSA3M10gPSBcIklcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkpcIl0gPSA3NF0gPSBcIkpcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIktcIl0gPSA3NV0gPSBcIktcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkxcIl0gPSA3Nl0gPSBcIkxcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk1cIl0gPSA3N10gPSBcIk1cIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk5cIl0gPSA3OF0gPSBcIk5cIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIk9cIl0gPSA3OV0gPSBcIk9cIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlBcIl0gPSA4MF0gPSBcIlBcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlFcIl0gPSA4MV0gPSBcIlFcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlJcIl0gPSA4Ml0gPSBcIlJcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlNcIl0gPSA4M10gPSBcIlNcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlRcIl0gPSA4NF0gPSBcIlRcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlVcIl0gPSA4NV0gPSBcIlVcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlZcIl0gPSA4Nl0gPSBcIlZcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIldcIl0gPSA4N10gPSBcIldcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlhcIl0gPSA4OF0gPSBcIlhcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIllcIl0gPSA4OV0gPSBcIllcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlpcIl0gPSA5MF0gPSBcIlpcIjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IFNoaWZ0IHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IEFsdCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBVcCB7S2V5c31cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEBwcm9wZXJ0eSBEb3duIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgQHByb3BlcnR5IExlZnQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgUmlnaHQge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgU3BhY2Uge0tleXN9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBAcHJvcGVydHkgRXNjIHtLZXlzfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlNoaWZ0XCJdID0gMTZdID0gXCJTaGlmdFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiQWx0XCJdID0gMThdID0gXCJBbHRcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIlVwXCJdID0gMzhdID0gXCJVcFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiRG93blwiXSA9IDQwXSA9IFwiRG93blwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiTGVmdFwiXSA9IDM3XSA9IFwiTGVmdFwiO1xuICAgICAgICAgICAgS2V5c1tLZXlzW1wiUmlnaHRcIl0gPSAzOV0gPSBcIlJpZ2h0XCI7XG4gICAgICAgICAgICBLZXlzW0tleXNbXCJTcGFjZVwiXSA9IDMyXSA9IFwiU3BhY2VcIjtcbiAgICAgICAgICAgIEtleXNbS2V5c1tcIkVzY1wiXSA9IDI3XSA9IFwiRXNjXCI7XG4gICAgICAgIH0pKElucHV0LktleXMgfHwgKElucHV0LktleXMgPSB7fSkpO1xuICAgICAgICB2YXIgS2V5cyA9IElucHV0LktleXM7XG4gICAgICAgIDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRocm93biBvbiBhIGdhbWUgb2JqZWN0IGZvciBhIGtleSBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgS2V5RXZlbnRcbiAgICAgICAgICogQGV4dGVuZHMgR2FtZUV2ZW50XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ga2V5IHtJbnB1dEtleX0gVGhlIGtleSByZXNwb25zaWJsZSBmb3IgdGhyb3dpbmcgdGhlIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgS2V5RXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEtleUV2ZW50LCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gS2V5RXZlbnQoa2V5KSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gS2V5RXZlbnQ7XG4gICAgICAgIH0pKGV4LkdhbWVFdmVudCk7XG4gICAgICAgIElucHV0LktleUV2ZW50ID0gS2V5RXZlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIEtleWJvYXJkIGlucHV0IGV2ZW50cyB0aGF0IHlvdSBjYW4gcXVlcnkgb3IgbGlzdGVuIGZvciBldmVudHMgb25cbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzIEtleWJvYXJkXG4gICAgICAgICAqIEBleHRlbmRzIENsYXNzXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEtleWJvYXJkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhLZXlib2FyZCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEtleWJvYXJkKGVuZ2luZSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzVXAgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzRG93biA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZSBLZXlib2FyZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5cy5sZW5ndGggPSAwOyAvLyBlbXB0aWVzIGFycmF5IGVmZmljaWVudGx5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8ga2V5IHVwIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3RoaXMuX2tleXMuaW5kZXhPZihldi5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleXMuc3BsaWNlKGtleSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzVXAucHVzaChldi5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUV2ZW50ID0gbmV3IEtleUV2ZW50KGV2LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaChcInVwXCIsIGtleUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBrZXkgZG93biBpcyBvbiB3aW5kb3cgYmVjYXVzZSBjYW52YXMgY2Fubm90IGhhdmUgZm9jdXNcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2tleXMuaW5kZXhPZihldi5rZXlDb2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlzLnB1c2goZXYua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fa2V5c0Rvd24ucHVzaChldi5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlFdmVudCA9IG5ldyBLZXlFdmVudChldi5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwiZG93blwiLCBrZXlFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBLZXlib2FyZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQga2V5c0Rvd24gYW5kIGtleXNVcCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGVcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzRG93bi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXNVcC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyBsaXN0IG9mIGtleXMgYmVpbmcgcHJlc3NlZCBkb3duXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgaXMgZG93bi5cbiAgICAgICAgICAgICAqIEBtZXRob2QgaXNLZXlEb3duXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5IHtLZXlzfSBUZXN0IHdldGhlciBhIGtleSBpcyBkb3duXG4gICAgICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5pc0tleURvd24gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXNEb3duLmluZGV4T2Yoa2V5KSA+IC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgaXMgcHJlc3NlZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgaXNLZXlQcmVzc2VkXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5IHtLZXlzfSBUZXN0IHdldGhlciBhIGtleSBpcyBwcmVzc2VkXG4gICAgICAgICAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEtleWJvYXJkLnByb3RvdHlwZS5pc0tleVByZXNzZWQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXMuaW5kZXhPZihrZXkpID4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgVGVzdHMgaWYgYSBjZXJ0YWluIGtleSBpcyB1cC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgaXNLZXlVcFxuICAgICAgICAgICAgICogQHBhcmFtIGtleSB7S2V5c30gVGVzdCB3ZXRoZXIgYSBrZXkgaXMgdXBcbiAgICAgICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgS2V5Ym9hcmQucHJvdG90eXBlLmlzS2V5VXAgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleXNVcC5pbmRleE9mKGtleSkgPiAtMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gS2V5Ym9hcmQ7XG4gICAgICAgIH0pKGV4LkNsYXNzKTtcbiAgICAgICAgSW5wdXQuS2V5Ym9hcmQgPSBLZXlib2FyZDtcbiAgICB9KShJbnB1dCA9IGV4LklucHV0IHx8IChleC5JbnB1dCA9IHt9KSk7XG59KShleCB8fCAoZXggPSB7fSkpO1xudmFyIGV4O1xuKGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBJbnB1dDtcbiAgICAoZnVuY3Rpb24gKElucHV0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIEdhbWVwYWQgQVBJIGlucHV0LiBZb3UgY2FuIHF1ZXJ5IHRoZSBnYW1lcGFkcyB0aGF0IGFyZSBjb25uZWN0ZWRcbiAgICAgICAgICogb3IgbGlzdGVuIHRvIGV2ZW50cyAoXCJidXR0b25cIiBhbmQgXCJheGlzXCIpLlxuICAgICAgICAgKiBAY2xhc3MgR2FtZXBhZHNcbiAgICAgICAgICogQGV4dGVuZHMgQ2xhc3NcbiAgICAgICAgICogQHBhcmFtIHBhZHMge0dhbWVwYWRbXX0gVGhlIGNvbm5lY3RlZCBnYW1lcGFkcy5cbiAgICAgICAgICogQHBhcmFtIHN1cHBvcnRlZCB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIEdhbWVwYWQgQVBJIGlzIHByZXNlbnRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBHYW1lcGFkcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoR2FtZXBhZHMsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBHYW1lcGFkcyhlbmdpbmUpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBwb2xsIGZvciBHYW1lcGFkIGlucHV0IChkZWZhdWx0OiBmYWxzZSlcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgZW5hYmxlZCB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBHYW1lcGFkIEFQSSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgc3VwcG9ydGVkIHtib29sZWFufVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcG9ydGVkID0gISFuYXZpZ2F0b3IuZ2V0R2FtZXBhZHM7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2FtZVBhZFRpbWVTdGFtcHMgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkUGFkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0U3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX25hdmlnYXRvciA9IG5hdmlnYXRvcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRTdWNjZXNzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gSW4gQ2hyb21lLCB0aGlzIHdpbGwgcmV0dXJuIDQgdW5kZWZpbmVkIGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcbiAgICAgICAgICAgICAgICAvLyBJbiBGRiwgdGhpcyB3aWxsIG5vdCByZXR1cm4gYW55IGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzID0gdGhpcy5fY2xvbmVQYWRzKHRoaXMuX25hdmlnYXRvci5nZXRHYW1lcGFkcygpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2xkUGFkcy5sZW5ndGggJiYgdGhpcy5fb2xkUGFkc1swXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0U3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlcyBHYW1lcGFkIHN0YXRlIGFuZCBwdWJsaXNoZXMgR2FtZXBhZCBldmVudHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLnN1cHBvcnRlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgICAgIHZhciBnYW1lcGFkcyA9IHRoaXMuX25hdmlnYXRvci5nZXRHYW1lcGFkcygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FtZXBhZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnYW1lcGFkc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgY29ubmVjdGlvbiBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBjb25uZWN0aW9uIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdXBwb3J0ZWQgaW4gQ2hyb21lXG4gICAgICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkc1tpXS50aW1lc3RhbXAgJiYgZ2FtZXBhZHNbaV0udGltZXN0YW1wID09PSB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2FtZVBhZFRpbWVTdGFtcHNbaV0gPSBnYW1lcGFkc1tpXS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dHRvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIsIGEsIHZhbHVlLCBidXR0b25JbmRleCwgYXhlc0luZGV4O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGIgaW4gQnV0dG9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCdXR0b25zW2JdICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5kZXggPSBCdXR0b25zW2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnYW1lcGFkc1tpXS5idXR0b25zW2J1dHRvbkluZGV4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fb2xkUGFkc1tpXS5nZXRCdXR0b24oYnV0dG9uSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLmJ1dHRvbnNbYnV0dG9uSW5kZXhdLnByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS51cGRhdGVCdXR0b24oYnV0dG9uSW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5ldmVudERpc3BhdGNoZXIucHVibGlzaChcImJ1dHRvblwiLCBuZXcgR2FtZXBhZEJ1dHRvbkV2ZW50KGJ1dHRvbkluZGV4LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS51cGRhdGVCdXR0b24oYnV0dG9uSW5kZXgsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGEgaW4gQXhlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBBeGVzW2FdICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhlc0luZGV4ID0gQXhlc1thXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYXhlc1theGVzSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vbGRQYWRzW2ldLmdldEF4ZXMoYXhlc0luZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQXhlcyhheGVzSW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKFwiYXhpc1wiLCBuZXcgR2FtZXBhZEF4aXNFdmVudChheGVzSW5kZXgsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2xkUGFkc1tpXSA9IHRoaXMuX2Nsb25lUGFkKGdhbWVwYWRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTYWZlbHkgcmV0cmlldmVzIGEgR2FtZXBhZCBhdCBhIHNwZWNpZmljIGluZGV4IGFuZCBjcmVhdGVzIG9uZSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fcGFkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3BhZHMubGVuZ3RoIC0gMSwgbWF4ID0gaW5kZXg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFkcy5wdXNoKG5ldyBHYW1lcGFkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2xkUGFkcy5wdXNoKG5ldyBHYW1lcGFkKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWRzW2luZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBjb25uZWN0ZWQgZ2FtZXBhZHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZHMucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWRzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jb25uZWN0ZWQ7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBHYW1lcGFkcy5wcm90b3R5cGUuX2Nsb25lUGFkcyA9IGZ1bmN0aW9uIChwYWRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuX2Nsb25lUGFkKHBhZHNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZhc3Rlc3Qgd2F5IHRvIGNsb25lIGEga25vd24gb2JqZWN0IGlzIHRvIGRvIGl0IHlvdXJzZWxmXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEdhbWVwYWRzLnByb3RvdHlwZS5fY2xvbmVQYWQgPSBmdW5jdGlvbiAocGFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGxlbjtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVkUGFkID0gbmV3IEdhbWVwYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhZDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWRQYWQudXBkYXRlQnV0dG9uKGksIHBhZC5idXR0b25zW2ldLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcGFkLmF4ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkUGFkLnVwZGF0ZUF4ZXMoaSwgcGFkLmF4ZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIG1pbmltdW0gdmFsdWUgYW4gYXhpcyBoYXMgdG8gbW92ZSBiZWZvcmUgY29uc2lkZXJpbmcgaXQgYSBjaGFuZ2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBNaW5BeGlzTW92ZVRocmVzaG9sZCB7bnVtYmVyfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBHYW1lcGFkcy5NaW5BeGlzTW92ZVRocmVzaG9sZCA9IDAuMDU7XG4gICAgICAgICAgICByZXR1cm4gR2FtZXBhZHM7XG4gICAgICAgIH0pKGV4LkNsYXNzKTtcbiAgICAgICAgSW5wdXQuR2FtZXBhZHMgPSBHYW1lcGFkcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGl2aWR1YWwgc3RhdGUgZm9yIGEgR2FtZXBhZFxuICAgICAgICAgKiBAY2xhc3MgR2FtZXBhZFxuICAgICAgICAgKiBAZXh0ZW5kcyBDbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEdhbWVwYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEdhbWVwYWQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBHYW1lcGFkKCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnV0dG9ucyA9IG5ldyBBcnJheSgxNik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhlcyA9IG5ldyBBcnJheSg0KTtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25zW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2F4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXhlc1tpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYnV0dG9uIGlzIHByZXNzZWRcbiAgICAgICAgICAgICAqIEBwYXJhbSBidXR0b24ge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAcGFyYW0gW3RocmVzaG9sZD0xXSB7bnVtYmVyfSBUaGUgdGhyZXNob2xkIG92ZXIgd2hpY2ggdGhlIGJ1dHRvbiBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNzZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUuaXNCdXR0b25QcmVzc2VkID0gZnVuY3Rpb24gKGJ1dHRvbiwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IHRocmVzaG9sZCA9IDE7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uc1tidXR0b25dID49IHRocmVzaG9sZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGdpdmVuIGJ1dHRvbiB2YWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtIGJ1dHRvbiB7QnV0dG9uc31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUuZ2V0QnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idXR0b25zW2J1dHRvbl07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBnaXZlbiBheGlzIHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gYXhlcyB7QXhlc31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgR2FtZXBhZC5wcm90b3R5cGUuZ2V0QXhlcyA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYXhlc1theGVzXTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModmFsdWUpIDwgR2FtZXBhZHMuTWluQXhpc01vdmVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEdhbWVwYWQucHJvdG90eXBlLnVwZGF0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25JbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25zW2J1dHRvbkluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEdhbWVwYWQucHJvdG90eXBlLnVwZGF0ZUF4ZXMgPSBmdW5jdGlvbiAoYXhlc0luZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F4ZXNbYXhlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBHYW1lcGFkO1xuICAgICAgICB9KShleC5DbGFzcyk7XG4gICAgICAgIElucHV0LkdhbWVwYWQgPSBHYW1lcGFkO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2FtZXBhZCBCdXR0b25zIGVudW1lcmF0aW9uXG4gICAgICAgICAqIEBjbGFzcyBCdXR0b25zXG4gICAgICAgICAqL1xuICAgICAgICAoZnVuY3Rpb24gKEJ1dHRvbnMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFjZSAxIGJ1dHRvbiAoZS5nLiBBKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IEZhY2UxIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZhY2UgMiBidXR0b24gKGUuZy4gQilcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBGYWNlMiB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGYWNlIDMgYnV0dG9uIChlLmcuIFgpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRmFjZTMge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFjZSA0IGJ1dHRvbiAoZS5nLiBZKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IEZhY2U0IHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlMVwiXSA9IDBdID0gXCJGYWNlMVwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTJcIl0gPSAxXSA9IFwiRmFjZTJcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UzXCJdID0gMl0gPSBcIkZhY2UzXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlNFwiXSA9IDNdID0gXCJGYWNlNFwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMZWZ0IGJ1bXBlciBidXR0b25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0QnVtcGVyIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJpZ2h0IGJ1bXBlciBidXR0b25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBSaWdodEJ1bXBlciB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdEJ1bXBlclwiXSA9IDRdID0gXCJMZWZ0QnVtcGVyXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodEJ1bXBlclwiXSA9IDVdID0gXCJSaWdodEJ1bXBlclwiO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMZWZ0IHRyaWdnZXIgYnV0dG9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgTGVmdFRyaWdnZXIge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmlnaHQgdHJpZ2dlciBidXR0b25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBSaWdodFRyaWdnZXIge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRUcmlnZ2VyXCJdID0gNl0gPSBcIkxlZnRUcmlnZ2VyXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodFRyaWdnZXJcIl0gPSA3XSA9IFwiUmlnaHRUcmlnZ2VyXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlbGVjdCBidXR0b25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBTZWxlY3Qge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RhcnQgYnV0dG9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgU3RhcnQge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlNlbGVjdFwiXSA9IDhdID0gXCJTZWxlY3RcIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlN0YXJ0XCJdID0gOV0gPSBcIlN0YXJ0XCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlZnQgYW5hbG9nIHN0aWNrIHByZXNzIChlLmcuIEwzKVxuICAgICAgICAgICAgICogQHByb3BlcnR5IExlZnRTdGljayB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSaWdodCBhbmFsb2cgc3RpY2sgcHJlc3MgKGUuZy4gUjMpXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgU3RhcnQge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRTdGlja1wiXSA9IDEwXSA9IFwiTGVmdFN0aWNrXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodFN0aWNrXCJdID0gMTFdID0gXCJSaWdodFN0aWNrXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEQtcGFkIHVwXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRHBhZFVwIHtCdXR0b25zfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEQtcGFkIGRvd25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBEcGFkRG93biB7QnV0dG9uc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBELXBhZCBsZWZ0XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgRHBhZExlZnQge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRC1wYWQgcmlnaHRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBEcGFkUmlnaHQge0J1dHRvbnN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRVcFwiXSA9IDEyXSA9IFwiRHBhZFVwXCI7XG4gICAgICAgICAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkRG93blwiXSA9IDEzXSA9IFwiRHBhZERvd25cIjtcbiAgICAgICAgICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRMZWZ0XCJdID0gMTRdID0gXCJEcGFkTGVmdFwiO1xuICAgICAgICAgICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZFJpZ2h0XCJdID0gMTVdID0gXCJEcGFkUmlnaHRcIjtcbiAgICAgICAgfSkoSW5wdXQuQnV0dG9ucyB8fCAoSW5wdXQuQnV0dG9ucyA9IHt9KSk7XG4gICAgICAgIHZhciBCdXR0b25zID0gSW5wdXQuQnV0dG9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdhbWVwYWQgQXhlcyBlbnVtZXJhdGlvblxuICAgICAgICAgKiBAY2xhc3MgQXhlc1xuICAgICAgICAgKi9cbiAgICAgICAgKGZ1bmN0aW9uIChBeGVzKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWCBkaXJlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0U3RpY2tYIHtBeGVzfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWSBkaXJlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBMZWZ0U3RpY2tZIHtBeGVzfVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJpZ2h0IGFuYWxvZ3VlIHN0aWNrIFggZGlyZWN0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgUmlnaHRTdGlja1gge0F4ZXN9XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmlnaHQgYW5hbG9ndWUgc3RpY2sgWSBkaXJlY3Rpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBSaWdodFN0aWNrWSB7QXhlc31cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXhlc1tBeGVzW1wiTGVmdFN0aWNrWFwiXSA9IDBdID0gXCJMZWZ0U3RpY2tYXCI7XG4gICAgICAgICAgICBBeGVzW0F4ZXNbXCJMZWZ0U3RpY2tZXCJdID0gMV0gPSBcIkxlZnRTdGlja1lcIjtcbiAgICAgICAgICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tYXCJdID0gMl0gPSBcIlJpZ2h0U3RpY2tYXCI7XG4gICAgICAgICAgICBBeGVzW0F4ZXNbXCJSaWdodFN0aWNrWVwiXSA9IDNdID0gXCJSaWdodFN0aWNrWVwiO1xuICAgICAgICB9KShJbnB1dC5BeGVzIHx8IChJbnB1dC5BeGVzID0ge30pKTtcbiAgICAgICAgdmFyIEF4ZXMgPSBJbnB1dC5BeGVzO1xuICAgICAgICB2YXIgR2FtZXBhZEJ1dHRvbkV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhHYW1lcGFkQnV0dG9uRXZlbnQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBHYW1lcGFkQnV0dG9uRXZlbnQoYnV0dG9uLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBHYW1lcGFkQnV0dG9uRXZlbnQ7XG4gICAgICAgIH0pKGV4LkdhbWVFdmVudCk7XG4gICAgICAgIElucHV0LkdhbWVwYWRCdXR0b25FdmVudCA9IEdhbWVwYWRCdXR0b25FdmVudDtcbiAgICAgICAgdmFyIEdhbWVwYWRBeGlzRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEdhbWVwYWRBeGlzRXZlbnQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBHYW1lcGFkQXhpc0V2ZW50KGF4aXMsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR2FtZXBhZEF4aXNFdmVudDtcbiAgICAgICAgfSkoZXguR2FtZUV2ZW50KTtcbiAgICAgICAgSW5wdXQuR2FtZXBhZEF4aXNFdmVudCA9IEdhbWVwYWRBeGlzRXZlbnQ7XG4gICAgfSkoSW5wdXQgPSBleC5JbnB1dCB8fCAoZXguSW5wdXQgPSB7fSkpO1xufSkoZXggfHwgKGV4ID0ge30pKTtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJNb25rZXlQYXRjaC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRXZlbnRzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudERpc3BhdGNoZXIudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkNsYXNzLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb2xvci50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTG9nLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb2xsaXNpb24vU2lkZS50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2NlbmUudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFjdG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJVSUFjdG9yLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJUcmlnZ2VyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQYXJ0aWNsZXMudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkFuaW1hdGlvbi50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ2FtZXJhLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJTb3VuZC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTG9hZGVyLnRzXCIgLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQcm9taXNlcy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVXRpbC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQmluZGluZy50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiVGlsZU1hcC50c1wiIC8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiTGFiZWwudHNcIiAvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlBvc3RQcm9jZXNzaW5nL0lQb3N0UHJvY2Vzc29yLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIklucHV0L0lFbmdpbmVJbnB1dC50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJJbnB1dC9Qb2ludGVyLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIklucHV0L0tleWJvYXJkLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIklucHV0L0dhbWVwYWQudHNcIi8+XG52YXIgZXg7XG4oZnVuY3Rpb24gKGV4KSB7XG4gICAgLyoqXG4gICAgICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBkaXNwbGF5IG1vZGVzIGF2YWlsYWJsZSB0byBFeGNhbGlidXJcbiAgICAgKiBAY2xhc3MgRGlzcGxheU1vZGVcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24gKERpc3BsYXlNb2RlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBnYW1lIGFzIGZ1bGwgc2NyZWVuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBGdWxsU2NyZWVuIHtEaXNwbGF5TW9kZX1cbiAgICAgICAgICovXG4gICAgICAgIERpc3BsYXlNb2RlW0Rpc3BsYXlNb2RlW1wiRnVsbFNjcmVlblwiXSA9IDBdID0gXCJGdWxsU2NyZWVuXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2FsZSB0aGUgZ2FtZSB0byB0aGUgcGFyZW50IERPTSBjb250YWluZXJcbiAgICAgICAgICogQHByb3BlcnR5IENvbnRhaW5lciB7RGlzcGxheU1vZGV9XG4gICAgICAgICAqL1xuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIkNvbnRhaW5lclwiXSA9IDFdID0gXCJDb250YWluZXJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGdhbWUgYXMgYSBmaXhlZCBzaXplXG4gICAgICAgICAqIEBQcm9wZXJ0eSBGaXhlZCB7RGlzcGxheU1vZGV9XG4gICAgICAgICAqL1xuICAgICAgICBEaXNwbGF5TW9kZVtEaXNwbGF5TW9kZVtcIkZpeGVkXCJdID0gMl0gPSBcIkZpeGVkXCI7XG4gICAgfSkoZXguRGlzcGxheU1vZGUgfHwgKGV4LkRpc3BsYXlNb2RlID0ge30pKTtcbiAgICB2YXIgRGlzcGxheU1vZGUgPSBleC5EaXNwbGF5TW9kZTtcbiAgICAvLyBpbnRlcm5hbFxuICAgIHZhciBBbmltYXRpb25Ob2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uTm9kZShhbmltYXRpb24sIHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbk5vZGU7XG4gICAgfSkoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgJ0VuZ2luZScgaXMgdGhlIG1haW4gZHJpdmVyIGZvciBhIGdhbWUuIEl0IGlzIHJlc3BvbnNpYmxlIGZvclxuICAgICAqIHN0YXJ0aW5nL3N0b3BwaW5nIHRoZSBnYW1lLCBtYWludGFpbmluZyBzdGF0ZSwgdHJhbnNtaXR0aW5nIGV2ZW50cyxcbiAgICAgKiBsb2FkaW5nIHJlc291cmNlcywgYW5kIG1hbmFnaW5nIHRoZSBzY2VuZS5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBFbmdpbmVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW3dpZHRoXSB7bnVtYmVyfSBUaGUgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBFeGNhbGlidXIgZ2FtZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBbaGVpZ2h0XSB7bnVtYmVyfSBUaGUgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgRXhjYWxpYnVyIGdhbWUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gW2NhbnZhc0VsZW1lbnRJZF0ge3N0cmluZ30gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIGEgbmV3IGNhbnZhcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIGluc2VydGVkIGludG8gdGhlIGJvZHkuXG4gICAgICogQHBhcmFtIFtkaXNwbGF5TW9kZV0ge0Rpc3BsYXlNb2RlfSBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gaXQgd2lsbCBmYWxsIGJhY2sgdG8gZml4ZWQgaWYgYSBoZWlnaHQgYW5kIHdpZHRoIGFyZSBzcGVjaWZpZWQsIGVsc2UgdGhlIGRpc3BsYXkgbW9kZSB3aWxsIGJlIEZ1bGxTY3JlZW4uXG4gICAgICovXG4gICAgdmFyIEVuZ2luZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhFbmdpbmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVuZ2luZSh3aWR0aCwgaGVpZ2h0LCBjYW52YXNFbGVtZW50SWQsIGRpc3BsYXlNb2RlKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0cyBvciBnZXRzIHRoZSBjb2xsaXNpb24gc3RyYXRlZ3kgZm9yIEV4Y2FsaWJ1clxuICAgICAgICAgICAgICogQHByb3BlcnR5IGNvbGxpc2lvblN0cmF0ZWd5IHtDb2xsaXNpb25TdHJhdGVneX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25TdHJhdGVneSA9IDEgLyogRHluYW1pY0FBQkJUcmVlICovO1xuICAgICAgICAgICAgdGhpcy5oYXNTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZwcyA9IDA7XG4gICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzb3JzID0gW107XG4gICAgICAgICAgICB0aGlzLnNjZW5lSGFzaCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlbmdpbmUgaXMgc2V0IHRvIGZ1bGxzY3JlZW4gb3Igbm90XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgaXNGdWxsc2NyZWVuIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgdGhlIGN1cnJlbnQgRGlzcGxheU1vZGUgb2YgdGhlIGVuZ2luZS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbZGlzcGxheU1vZGU9RnVsbFNjcmVlbl0ge0Rpc3BsYXlNb2RlfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlNb2RlID0gMCAvKiBGdWxsU2NyZWVuICovO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhdWRpbyBzaG91bGQgYmUgcGF1c2VkIHdoZW4gdGhlIGdhbWUgaXMgbm8gbG9uZ2VyIHZpc2libGUuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW3BhdXNlQXVkaW9XaGVuSGlkZGVuPXRydWVdIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBhdXNlQXVkaW9XaGVuSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBzaG91bGQgZHJhdyB3aXRoIGRlYnVnIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgW2lzRGVidWc9ZmFsc2VdIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzRGVidWcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVidWdDb2xvciA9IG5ldyBleC5Db2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0cyB0aGUgYmFja2dyb3VuZCBjb2xvciBmb3IgdGhlIGVuZ2luZS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBbYmFja2dyb3VuZENvbG9yPW5ldyBDb2xvcigwLCAwLCAxMDApXSB7Q29sb3J9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IGV4LkNvbG9yKDAsIDAsIDEwMCk7XG4gICAgICAgICAgICB0aGlzLmlzU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICB0aGlzLnRvdGFsID0gMTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gZXguTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiUG93ZXJlZCBieSBFeGNhbGlidXIuanMgdmlzaXRcIiwgXCJodHRwOi8vZXhjYWxpYnVyanMuY29tXCIsIFwiZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJCdWlsZGluZyBlbmdpbmUuLi5cIik7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnRJZCA9IGNhbnZhc0VsZW1lbnRJZDtcbiAgICAgICAgICAgIGlmIChjYW52YXNFbGVtZW50SWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlVzaW5nIENhbnZhcyBlbGVtZW50IHNwZWNpZmllZDogXCIgKyBjYW52YXNFbGVtZW50SWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzRWxlbWVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiVXNpbmcgZ2VuZXJhdGVkIGNhbnZhcyBlbGVtZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXlNb2RlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlNb2RlID0gMiAvKiBGaXhlZCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJFbmdpbmUgdmlld3BvcnQgaXMgc2l6ZSBcIiArIHdpZHRoICsgXCIgeCBcIiArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRpc3BsYXlNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJFbmdpbmUgdmlld3BvcnQgaXMgZnVsbHNjcmVlblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlNb2RlID0gMCAvKiBGdWxsU2NyZWVuICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgZXguTG9hZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMucm9vdFNjZW5lID0gdGhpcy5jdXJyZW50U2NlbmUgPSBuZXcgZXguU2NlbmUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmFkZFNjZW5lKCdyb290JywgdGhpcy5yb290U2NlbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGF5cyBhIHNwcml0ZSBhbmltYXRpb24gb24gdGhlIHNjcmVlbiBhdCB0aGUgc3BlY2lmaWVkIHggYW5kIHlcbiAgICAgICAgICogKGluIGdhbWUgY29vcmRpbmF0ZXMsIG5vdCBzY3JlZW4gcGl4ZWxzKS4gVGhlc2UgYW5pbWF0aW9ucyBwbGF5XG4gICAgICAgICAqIGluZGVwZW5kZW50IG9mIGFjdG9ycywgYW5kIHdpbGwgYmUgY2xlYW5lZCB1cCBpbnRlcm5hbGx5IGFzIHNvb25cbiAgICAgICAgICogYXMgdGhleSBhcmUgY29tcGxldGUuIE5vdGUgYW5pbWF0aW9ucyB0aGF0IGxvb3Agd2lsbCBuZXZlciBiZVxuICAgICAgICAgKiBjbGVhbmVkIHVwLlxuICAgICAgICAgKiBAbWV0aG9kIHBsYXlBbmltYXRpb25cbiAgICAgICAgICogQHBhcmFtIGFuaW1hdGlvbiB7QW5pbWF0aW9ufSBBbmltYXRpb24gdG8gcGxheVxuICAgICAgICAgKiBAcGFyYW0geCB7bnVtYmVyfSB4IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cbiAgICAgICAgICogQHBhcmFtIHkge251bWJlcn0geSBnYW1lIGNvb3JkaW5hdGUgdG8gcGxheSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbWF0aW9uLCB4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMucHVzaChuZXcgQW5pbWF0aW9uTm9kZShhbmltYXRpb24sIHgsIHkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gYWN0b3IgdG8gdGhlIGN1cnJlbnQgc2NlbmUgb2YgdGhlIGdhbWUuIFRoaXMgaXMgc3lub255bW91c1xuICAgICAgICAgKiB0byBjYWxsaW5nIGVuZ2luZS5jdXJyZW50U2NlbmUuYWRkQ2hpbGQoYWN0b3IgOiBBY3RvcikuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFjdG9ycyBjYW4gb25seSBiZSBkcmF3biBpZiB0aGV5IGFyZSBhIG1lbWJlciBvZiBhIHNjZW5lLCBhbmQgb25seVxuICAgICAgICAgKiB0aGUgJ2N1cnJlbnRTY2VuZScgbWF5IGJlIGRyYXduIG9yIHVwZGF0ZWQuXG4gICAgICAgICAqIEBtZXRob2QgYWRkQ2hpbGRcbiAgICAgICAgICogQHBhcmFtIGFjdG9yIHtBY3Rvcn0gVGhlIGFjdG9yIHRvIGFkZCB0byB0aGUgY3VycmVudCBzY2VuZVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChhY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuYWRkQ2hpbGQoYWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbiBhY3RvciBmcm9tIHRoZSBjdXJyZW50U2NlbmUgb2YgdGhlIGdhbWUuIFRoaXMgaXMgc3lub255bW91c1xuICAgICAgICAgKiB0byBjYWxsaW5nIGVuZ2luZS5jdXJyZW50U2NlbmUucmVtb3ZlQ2hpbGQoYWN0b3IgOiBBY3RvcikuXG4gICAgICAgICAqIEFjdG9ycyB0aGF0IGFyZSByZW1vdmVkIGZyb20gYSBzY2VuZSB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG4gICAgICAgICAqIEBwYXJhbSBhY3RvciB7QWN0b3J9IFRoZSBhY3RvciB0byByZW1vdmUgZnJvbSB0aGUgY3VycmVudCBzY2VuZS5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoYWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZUNoaWxkKGFjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBUaWxlTWFwIHRvIHRoZSBTY2VuZSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIFRpbGVNYXAgd2lsbCBiZSBkcmF3biBhbmQgdXBkYXRlZC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRUaWxlTWFwXG4gICAgICAgICAqIEBwYXJhbSB0aWxlTWFwIHtUaWxlTWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5hZGRUaWxlTWFwID0gZnVuY3Rpb24gKHRpbGVNYXApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZFRpbGVNYXAodGlsZU1hcCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgVGlsZU1hcCBmcm9tIHRoZSBTY2VuZSwgaXQgd2lsbG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZVRpbGVNYXBcbiAgICAgICAgICogQHBhcmFtIHRpbGVNYXAge1RpbGVNYXB9XG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRpbGVNYXAgPSBmdW5jdGlvbiAodGlsZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVGlsZU1hcCh0aWxlTWFwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYW4gZXhjYWxpYnVyIHRpbWVyIHRvIHRoZSBjdXJyZW50IHNjZW5lLlxuICAgICAgICAgKiBAcGFyYW0gdGltZXIge1RpbWVyfSBUaGUgdGltZXIgdG8gYWRkIHRvIHRoZSBjdXJyZW50IHNjZW5lLlxuICAgICAgICAgKiBAbWV0aG9kIGFkZFRpbWVyXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZFRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUuYWRkVGltZXIodGltZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhbiBleGNhbGlidXIgdGltZXIgZnJvbSB0aGUgY3VycmVudCBzY2VuZS5cbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVUaW1lclxuICAgICAgICAgKiBAcGFyYW0gdGltZXIge1RpbWVyfSBUaGUgdGltZXIgdG8gcmVtb3ZlIHRvIHRoZSBjdXJyZW50IHNjZW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5yZW1vdmVUaW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZVRpbWVyKHRpbWVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBzY2VuZSB0byB0aGUgZW5naW5lLCB0aGluayBvZiBzY2VuZXMgaW4gZXhjYWxpYnVyIGFzIHlvdVxuICAgICAgICAgKiB3b3VsZCBzY2VuZXMgaW4gYSBwbGF5LlxuICAgICAgICAgKiBAbWV0aG9kIGFkZFNjZW5lXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBzY2VuZSwgbXVzdCBiZSB1bmlxdWVcbiAgICAgICAgICogQHBhcmFtIHNjZW5lIHtTY2VuZX0gVGhlIHNjZW5lIHRvIGFkZCB0byB0aGUgZW5naW5lXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZFNjZW5lID0gZnVuY3Rpb24gKG5hbWUsIHNjZW5lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZUhhc2hbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiU2NlbmVcIiwgbmFtZSwgXCJhbHJlYWR5IGV4aXN0cyBvdmVyd3JpdGluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NlbmVIYXNoW25hbWVdID0gc2NlbmU7XG4gICAgICAgICAgICBzY2VuZS5lbmdpbmUgPSB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZVNjZW5lID0gZnVuY3Rpb24gKGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIGV4LlNjZW5lKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuc2NlbmVIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lSGFzaC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2VuZUhhc2hba2V5XSA9PT0gZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVIYXNoW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudGl0eSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzY2VuZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lSGFzaFtlbnRpdHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5VSUFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuYWRkVUlBY3RvcihlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5BY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGltZXIoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaWxlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaWxlTWFwKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NlbmUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5VSUFjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVUlBY3RvcihlbnRpdHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5BY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaW1lcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBleC5UaWxlTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlTWFwKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgZXguU2NlbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNjZW5lKGVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudGl0eSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NlbmUoZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnRseSB1cGRhdGluZyBhbmQgZHJhd2luZyBzY2VuZSB0byBhIGRpZmZlcmVudCxcbiAgICAgICAgICogbmFtZWQgc2NlbmUuXG4gICAgICAgICAqIEBtZXRob2QgZ29Ub1NjZW5lXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBzY2VuZSB0byB0cmFzaXRpb24gdG8uXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmdvVG9TY2VuZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2VuZUhhc2hbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkRlYWN0aXZhdGUuY2FsbCh0aGlzLmN1cnJlbnRTY2VuZSk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFNjZW5lID0gdGhpcy5jdXJyZW50U2NlbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUgPSB0aGlzLnNjZW5lSGFzaFtuYW1lXTtcbiAgICAgICAgICAgICAgICBvbGRTY2VuZS5ldmVudERpc3BhdGNoZXIucHVibGlzaCgnZGVhY3RpdmF0ZScsIG5ldyBleC5EZWFjdGl2YXRlRXZlbnQodGhpcy5jdXJyZW50U2NlbmUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkFjdGl2YXRlLmNhbGwodGhpcy5jdXJyZW50U2NlbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdhY3RpdmF0ZScsIG5ldyBleC5BY3RpdmF0ZUV2ZW50KG9sZFNjZW5lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNjZW5lXCIsIG5hbWUsIFwiZG9lcyBub3QgZXhpc3QhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGVuZ2luZXMgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscy5cbiAgICAgICAgICogQG1ldGhvZCBnZXRXaWR0aFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXIgVGhlIHdpZHRoIG9mIHRoZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAvIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRab29tKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lcyBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzLlxuICAgICAgICAgKiBAbWV0aG9kIGdldEhlaWdodFxuICAgICAgICAgKiBAcmV0dXJucyBudW1iZXIgVGhlIGhlaWdodCBvZiB0aGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscy5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodCAvIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRab29tKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2Zvcm1zIHRoZSBjdXJyZW50IHgsIHkgZnJvbSBzY3JlZW4gY29vcmRpbmF0ZXMgdG8gd29ybGQgY29vcmRpbmF0ZXNcbiAgICAgICAgICogQG1ldGhvZCBzY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXNcbiAgICAgICAgICogQHBhcmFtIHBvaW50IHtQb2ludH0gc2NyZWVuIGNvb3JkaW5hdGUgdG8gY29udmVydFxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gc2V0IHRoZXNlIGJhY2sgdGhpcy5jYW52YXMuY2xpZW50V2lkdGhcbiAgICAgICAgICAgIHZhciBuZXdYID0gcG9pbnQueDtcbiAgICAgICAgICAgIHZhciBuZXdZID0gcG9pbnQueTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSB0aGlzLmN1cnJlbnRTY2VuZS5jYW1lcmEuZ2V0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICBuZXdYID0gZm9jdXMueCArIChwb2ludC54IC0gKHRoaXMuZ2V0V2lkdGgoKSAvIDIpKTtcbiAgICAgICAgICAgICAgICBuZXdZID0gZm9jdXMueSArIChwb2ludC55IC0gKHRoaXMuZ2V0SGVpZ2h0KCkgLyAyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdYID0gTWF0aC5mbG9vcigobmV3WCAvIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoKSAqIHRoaXMuZ2V0V2lkdGgoKSk7XG4gICAgICAgICAgICBuZXdZID0gTWF0aC5mbG9vcigobmV3WSAvIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCkgKiB0aGlzLmdldEhlaWdodCgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQobmV3WCwgbmV3WSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2Zvcm1zIGEgd29ybGQgY29vcmRpbmF0ZSwgdG8gYSBzY3JlZW4gY29vcmRpbmF0ZVxuICAgICAgICAgKiBAbWV0aG9kIHdvcmxkVG9TY3JlZW5Db29yZGluYXRlc1xuICAgICAgICAgKiBAcGFyYW0gcG9pbnQge1BvaW50fSB3b3JsZCBjb29yZGluYXRlIHRvIGNvbnZlcnRcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAvLyB0b2RvIHNldCB0aGVzZSBiYWNrIHRoaXMuY2FudmFzLmNsaWVudFdpZHRoXG4gICAgICAgICAgICAvLyB0aGlzIGlzbid0IGNvcnJlY3Qgb24gem9vbVxuICAgICAgICAgICAgdmFyIHNjcmVlblggPSBwb2ludC54O1xuICAgICAgICAgICAgdmFyIHNjcmVlblkgPSBwb2ludC55O1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYSkge1xuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IHRoaXMuY3VycmVudFNjZW5lLmNhbWVyYS5nZXRGb2N1cygpO1xuICAgICAgICAgICAgICAgIHNjcmVlblggPSAocG9pbnQueCAtIGZvY3VzLngpICsgKHRoaXMuZ2V0V2lkdGgoKSAvIDIpOyAvLyh0aGlzLmdldFdpZHRoKCkgLyB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgc2NyZWVuWSA9IChwb2ludC55IC0gZm9jdXMueSkgKyAodGhpcy5nZXRIZWlnaHQoKSAvIDIpOyAvLyAodGhpcy5nZXRIZWlnaHQoKSAvIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JlZW5YID0gTWF0aC5mbG9vcigoc2NyZWVuWCAvIHRoaXMuZ2V0V2lkdGgoKSkgKiB0aGlzLmNhbnZhcy5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgICBzY3JlZW5ZID0gTWF0aC5mbG9vcigoc2NyZWVuWSAvIHRoaXMuZ2V0SGVpZ2h0KCkpICogdGhpcy5jYW52YXMuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXguUG9pbnQoc2NyZWVuWCwgc2NyZWVuWSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBpbnRlcm5hbCBjYW52YXMgaGVpZ2h0IGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBkaXNwbGF5IG1vZGUuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0SGVpZ2h0QnlEaXNwbGF5TW9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5zZXRIZWlnaHRCeURpc3BsYXlNb2RlID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IDEgLyogQ29udGFpbmVyICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSAwIC8qIEZ1bGxTY3JlZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggPSBwYXJlbnQuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IHBhcmVudC5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBjYW52YXMsIHJlbmRlcmluZyBjb250ZXh0LCBkaXNwbGF5bW9kZSwgYW5kIG5hdGl2ZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICogQG1ldGhvZCBpbml0aWFsaXplXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IDAgLyogRnVsbFNjcmVlbiAqLyB8fCB0aGlzLmRpc3BsYXlNb2RlID09PSAxIC8qIENvbnRhaW5lciAqLykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5kaXNwbGF5TW9kZSA9PT0gMSAvKiBDb250YWluZXIgKi8gPyAodGhpcy5jYW52YXMucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KSA6IHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHRCeURpc3BsYXlNb2RlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZGVidWcoXCJWaWV3IHBvcnQgcmVzaXplZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SGVpZ2h0QnlEaXNwbGF5TW9kZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuaW5mbyhcInBhcmVudC5jbGllbnRIZWlnaHQgXCIgKyBwYXJlbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0QW50aWFsaWFzaW5nKF90aGlzLmlzU21vb3RoaW5nRW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGlucHV0c1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBrZXlib2FyZDogbmV3IGV4LklucHV0LktleWJvYXJkKHRoaXMpLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJzOiBuZXcgZXguSW5wdXQuUG9pbnRlcnModGhpcyksXG4gICAgICAgICAgICAgICAgZ2FtZXBhZHM6IG5ldyBleC5JbnB1dC5HYW1lcGFkcyh0aGlzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQuaW5pdCgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLmluaXQoKTtcbiAgICAgICAgICAgIC8vIElzc3VlICMzODUgbWFrZSB1c2Ugb2YgdGhlIHZpc2liaWxpdHkgYXBpXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9Vc2VyX2V4cGVyaWVuY2UvVXNpbmdfdGhlX1BhZ2VfVmlzaWJpbGl0eV9BUElcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuIHx8IGRvY3VtZW50Lm1zSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RGlzcGF0Y2hlci5wdWJsaXNoKCdoaWRkZW4nLCBuZXcgZXguSGlkZGVuRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIldpbmRvdyBoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaCgndmlzaWJsZScsIG5ldyBleC5WaXNpYmxlRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIldpbmRvdyB2aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQgaW4gZmF2b3Igb2YgdmlzaWJpbGl0eSBhcGlcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIucHVibGlzaChFdmVudFR5cGVbRXZlbnRUeXBlLkJsdXJdLCBuZXcgQmx1ckV2ZW50KCkpO1xuICAgICAgICAgICAgfSk7XG4gICBcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHtcbiAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goRXZlbnRUeXBlW0V2ZW50VHlwZS5Gb2N1c10sIG5ldyBGb2N1c0V2ZW50KCkpO1xuICAgICAgICAgICAgfSk7Ki9cbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYW52YXNFbGVtZW50SWQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgdGhpcyB3aWxsIHNldCB0aGUgYW50aWFsaWFzaW5nIGZsYWcgb24gdGhlXG4gICAgICAgICAqIGNhbnZhcy4gU2V0IHRoaXMgdG8gZmFsc2UgaWYgeW91IHdhbnQgYSAnamFnZ2VkJyBwaXhlbCBhcnQgbG9vayB0byB5b3VyXG4gICAgICAgICAqIGltYWdlIHJlc291cmNlcy5cbiAgICAgICAgICogQG1ldGhvZCBzZXRBbnRpYWxpYXNpbmdcbiAgICAgICAgICogQHBhcmFtIGlzU21vb3RoIHtib29sZWFufSBTZXQgc21vb3RoaW5nIHRvIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2V0QW50aWFsaWFzaW5nID0gZnVuY3Rpb24gKGlzU21vb3RoKSB7XG4gICAgICAgICAgICB0aGlzLmlzU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xuICAgICAgICAgICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gaXNTbW9vdGg7XG4gICAgICAgICAgICB0aGlzLmN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcbiAgICAgICAgICAgIHRoaXMuY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGlzU21vb3RoO1xuICAgICAgICAgICAgdGhpcy5jdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBpc1Ntb290aDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBSZXR1cm4gdGhlIGN1cnJlbnQgc21vb3RoaW5nIHN0YXR1cyBvZiB0aGUgY2FudmFzXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QW50aWFsaWFzaW5nXG4gICAgICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuZ2V0QW50aWFsaWFzaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCB0aGlzLmN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgdGhpcy5jdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IHRoaXMuY3R4Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgZW50aXJlIHN0YXRlIG9mIHRoZSBnYW1lXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBkZWx0YSB7bnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgICAgICAgICAgIC8vIHN1c3BlbmQgdXBkYXRlcyB1bnRpbGwgbG9hZGluZyBpcyBmaW5pc2hlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZW5naW5lIGxldmVsIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUudXBkYXRlKHRoaXMsIGRlbHRhKTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBhbmltYXRpb25zXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFhLmFuaW1hdGlvbi5pc0RvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVXBkYXRlIGlucHV0IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5nYW1lcGFkcy51cGRhdGUoZGVsdGEpO1xuICAgICAgICAgICAgLy8gUHVibGlzaCB1cGRhdGUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLnB1Ymxpc2goZXguRXZlbnRUeXBlWzUgLyogVXBkYXRlICovXSwgbmV3IGV4LlVwZGF0ZUV2ZW50KGRlbHRhKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3cyB0aGUgZW50aXJlIGdhbWVcbiAgICAgICAgICogQG1ldGhvZCBkcmF3XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBkcmF3IHtudW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBkcmF3LlxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xvYWRpbmdCYXIoY3R4LCB0aGlzLnByb2dyZXNzLCB0aGlzLnRvdGFsKTtcbiAgICAgICAgICAgICAgICAvLyBEcmF3aW5nIG5vdGhpbmcgZWxzZSB3aGlsZSBsb2FkaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5kcmF3KHRoaXMuY3R4LCBkZWx0YSk7XG4gICAgICAgICAgICAvLyB0b2RvIG5lZWRzIHRvIGJlIGEgYmV0dGVyIHdheSBvZiBkb2luZyB0aGlzXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGEuYW5pbWF0aW9uLmRyYXcoY3R4LCBhLngsIGEueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZnBzID0gMS4wIC8gKGRlbHRhIC8gMTAwMCk7XG4gICAgICAgICAgICAvLyBEcmF3IGRlYnVnIGluZm9ybWF0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZm9udCA9IFwiQ29uc29sYXNcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmRlYnVnQ29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuaW5wdXQua2V5Ym9hcmQuZ2V0S2V5cygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChrZXlzW2pdLnRvU3RyaW5nKCkgKyBcIiA6IFwiICsgKGV4LklucHV0LktleXNba2V5c1tqXV0gPyBleC5JbnB1dC5LZXlzW2tleXNbal1dIDogXCJOb3QgTWFwcGVkXCIpLCAxMDAsIDEwICogaiArIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJGUFM6XCIgKyB0aGlzLmZwcy50b0ZpeGVkKDIpLnRvU3RyaW5nKCksIDEwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9zdFByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzb3JzW2ldLnByb2Nlc3ModGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSwgdGhpcy5jdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jdHguZHJhd0ltYWdlKGN1cnJlbnRJbWFnZSwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHRoZSBpbnRlcm5hbCBnYW1lIGxvb3AgZm9yIEV4Y2FsaWJ1ciBhZnRlciBsb2FkaW5nXG4gICAgICAgICAqIGFueSBwcm92aWRlZCBhc3NldHMuXG4gICAgICAgICAqIEBtZXRob2Qgc3RhcnRcbiAgICAgICAgICogQHBhcmFtIFtsb2FkZXI9dW5kZWZpbmVkXSB7SUxvYWRhYmxlfSBPcHRpb25hbCByZXNvdXJjZXMgdG8gbG9hZCBiZWZvcmVcbiAgICAgICAgICogc3RhcnRpbmcgdGhlIG1haW5sb29wLiBTb21lIGxvYWRhYmxlIHN1Y2ggYXMgYSBMb2FkZXIgY29sbGVjdGlvbiwgU291bmQsIG9yIFRleHR1cmUuXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGluZ0NvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgICAgIGxvYWRlci53aXJlRW5naW5lKHRoaXMpO1xuICAgICAgICAgICAgICAgIGxvYWRpbmdDb21wbGV0ZSA9IHRoaXMubG9hZChsb2FkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZ0NvbXBsZXRlID0gZXguUHJvbWlzZS53cmFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJTdGFydGluZyBnYW1lLi4uXCIpO1xuICAgICAgICAgICAgICAgIC8vIE1haW5sb29wXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2FtZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIG1haW5sb29wKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdhbWUuaGFzU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWFpbmxvb3ApO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRpbWUgdG8gY2FsY3VsYXRlIHRpbWUtZWxhcHNlZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsYXBzZWQgPSBNYXRoLmZsb29yKG5vdyAtIGxhc3RUaW1lKSB8fCAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlcyBpc3N1ZSAjMTM4IGlmIHRoZSBnYW1lIGhhcyBiZWVuIHBhdXNlZCwgb3IgYmx1cnJlZCBmb3IgXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgdGhhbiBhIDIwMCBtaWxsaXNlY29uZHMsIHJlc2V0IGVsYXBzZWQgdGltZSB0byAxLiBUaGlzIGltcHJvdmVzIHJlbGlhYmlsaXR5IFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvdmlkZXMgbW9yZSBleHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSBlbmdpbmUgY29tZXMgYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIGZvY3VzXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGFwc2VkID4gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGFwc2VkID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnYW1lLnVwZGF0ZShlbGFwc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5kcmF3KGVsYXBzZWQpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0VGltZSA9IG5vdztcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiR2FtZSBzdGFydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9hZGluZ0NvbXBsZXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgRXhjYWxpYnVyJ3MgbWFpbmxvb3AsIHVzZWZ1bCBmb3IgcGF1c2luZyB0aGUgZ2FtZS5cbiAgICAgICAgICogQG1ldGhvZCBzdG9wXG4gICAgICAgICAqL1xuICAgICAgICBFbmdpbmUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJHYW1lIHN0b3BwZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIHNjcmVlbiBzaG90IG9mIHRoZSBjdXJyZW50IHZpZXdwb3J0IGFuZCByZXR1cm5zIGl0IGFzIGFuXG4gICAgICAgICAqIEhUTUwgSW1hZ2UgRWxlbWVudC5cbiAgICAgICAgICogQG1ldGhvZCBzY3JlZW5zaG90XG4gICAgICAgICAqIEByZXR1cm5zIEhUTUxJbWFnZUVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2NyZWVuc2hvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIHZhciByYXcgPSB0aGlzLmNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICByZXN1bHQuc3JjID0gcmF3O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYXdzIHRoZSBFeGNhbGlidXIgbG9hZGluZyBiYXJcbiAgICAgICAgICogQG1ldGhvZCBkcmF3TG9hZGluZ0JhclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gY3R4IHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIGxvYWRlZCB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgbG9hZGVkXG4gICAgICAgICAqIEBwYXJhbSB0b3RhbCB7bnVtYmVyfSBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdG8gbG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgRW5naW5lLnByb3RvdHlwZS5kcmF3TG9hZGluZ0JhciA9IGZ1bmN0aW9uIChjdHgsIGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRpbmdEcmF3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nRHJhdyhjdHgsIGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gMztcbiAgICAgICAgICAgIHZhciB4ID0gd2lkdGg7XG4gICAgICAgICAgICAvLyBsb2FkaW5nIGltYWdlXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIC8vIDY0IGJpdCBzdHJpbmcgZW5jb2Rpbmcgb2YgdGhlIGV4Y2FsaWJ1ciBsb2dvXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUF5QUFBQUVzQ0FZQUFBQTdMZGM2QUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFaZEVWWWRGTnZablIzWVhKbEFGQmhhVzUwTGs1RlZDQjJNeTQxTGplbmhKM01BQUE2WTBsRVFWUjRYdTNkVWFna1daM25jVUVFUVlTaVJYQmRtaTJLZFJVWnhnSlpobVY5cU9kbWtXSllsbVlZaGtLV2NXY2ZwRURRRng5SzJPNEZtNlVhVmhvYWhpNEdGMndXaDFwbllhd0hvWHp4cFZ1NkdpbWF0cW5pMGtwVGlHTGhneSsrM1BuOU1rNmtrWGxQWnA0VEdTZmlST1QzQTM5YXEyNUVuTWk2R2ZIL1pjU0ovQkFBQUFBQUFBQUFBQUFBWUF3Lys5blBMcWx1cU82cnJvYy9CZ0FBQUlEaGhOQnhWM1VlNm1uNEt3QUFBQUE0bmtMR2RkVWRoNDBRT3JwMUovd1lBQUFBQVBTallISFY0VUlWQ3gzZHVob1dBUUFBQUlCMERoT3EyNnF6RUM0TzFWbFlGQUFBQUFBT1U0aTRyTHJwTUJGQ3hZVjY2NjIzenQ5OTk5M3o5OTkvLy95ZGQ5N3AvdDN0c0JvQUFBQUFpRk53YUVQSGd4QWtvdFdHanQvODVqZXIrdld2ZjczOU05eCtCUUFBQU9BaWhZWDJzYm5kSjFoZEtGL2hPRHM3VzRXTk5uaTA5Zmp4NCs3UFBnaXJCZ0FBQUlDR2dzTEIwUEh6bi85OForam9sbit1czl6TnNBa0FBQUFBcDB6aFlOOWpjMWZsTU9FckdrK2VQSW1HamUzeXoyMnQ0M0xZSEFBQUFJQlRvMEJ3OExHNWI3Lzk5dmw3NzcyWEhEcTZ4ZTFYQUFBQXdJbFRFRGo0Mk53MmRIend3UWZSWUpGYVhrOW52VGZDRUFBQUFBQXNtWnIvck1mbXhzSkViam04YkczalVoZ09BQUFBZ0tWUnc5L3JzYmxEbGErZ2RMWnpOd3dMQUFBQXdGS28wVC82c2JsREZiZGZBUUFBQUF2bEJsODF5R056aDZoZi9lcFgzVzE3Z2p1M1h3RUFBQUJ6cHFaKzhNZm1EbFcrcmFzempqdGh5QUFBQUFEbVJNMTgwY2ZtRGxXZTBONFowL1V3ZkFBQUFBQzFVd00vMm1Oemh5aFBhTytNN1duWURRQUFBQUMxVXdQdnVSM2RobjVkUXo4MmQ2amk5aXNBQUFCZ2h0UzhSOE5IamFHakxVOXczeHJ2MWJBN0FBQUFBR3FseG4wamZQaHF4MWhQc0RxbVBNYk91TS9DN2dBQUFBQ29sUnIzQytHamhya2RLZVh2RittTS9YYllKUUFBQUFBMVV0TSsyL0RCN1ZjQUFBREFqS2hobjIzNGNQbjdSanJqZnhCMkN3QUFBRUJ0MUxEUE9ueTQvS1dIblgyNEdYWU5BQUFBUUUzVXJNOCtmUGhMRDd2N29Mb2NkZzhBQUFCQUxkU296ejU4dUI0OWV0UU5IOXgrQlFBQUFOUkdqZnBHK1BBdFRITU1IeTUvRTN0blgyNkVYUVFBQUFCUUF6ZnBuWVo5RlQ1cS80NlBYZVhRMU4wWDFhV3dtd0FBQUFDbXBnWjlNZUhEOWQ1NzczWER4OTJ3bXdBQUFBQ21wZ1o5VWVIRHhlMVhBQUFBUUlYY25IY2E5VVdFai9mZmY3OGJQcDZxdVAwS0FBQUFtSm9hODhXRkQ5ZTc3NzdiRFNCM3d1NENBQUFBbUlvYTgwV0dENWNmRzl6WnQrdGhsd0VBQUFCTVFVMzVZc1BIOXUxWFlaY0JBQUFBVEVGTitXTERoK3VkZDk3cEJwRGJZYmNCQUFBQWpFME4rYUxEaC9lbHUzK3FxMkhYQVFBQUFJeEp6ZmlpdzRmcjdPeXNHejdPd3E0REFBQUFHSk9hOGNXSER4ZTNYd0VBQUFBVFV5TitFdUhqeVpNbjNmRGh1aHhlQWdBQUFBQmpVQk4rRXVIRDlmang0Mjc0ZUJCZUFnQUFBQUJqVUJOK011SEQ1ZjNyN08vTjhESUFBQUFBS0UwTitFbUZEMjYvQWdBQUFDYWk1dnVrd29mcjBhTkgzZkJ4UDd3VUFBQUFBRXBTODMxeTRjUDE5dHR2ZHdQSWpmQnlBQUFBQUNqRmpYZW5DVCtaOFBIQkJ4OTB3NGZyVW5oSkFBQUFBSlNncHZza3c0ZnJ2ZmZlNjRhUHUrRWxBUUFBQUZDQ211NlREUjh1YnI4Q0FBQUFSdUtHdTlOOG4xejRlUC85OTd2aDQybDRXUUFBQUFBTVRRMzNTWWNQMTd2dnZ0c05JSGZDU3dNQUFBQmdTR3EyVHo1OHVONTY2NjF1QUxrZVhoNEFBQUFBUTFHalRmaFFQWDc4dUJzK3VQMEtBQUFBR0pvYWJjS0g2dXpzckJzK1hMZkRTd1FBQUFCZ0NHcXlDUitxU1BoNG9PSzdQd0FBQUlDaHFNRW1mS2dJSHdBQUFFQmhhckFKSHlyQ0J3QUFBRkNZR216Q2g0cndBUUFBQUJTbUJwdndvU0o4QUFBQUFJV3B3U1o4cUFnZkFBQUFRR0Zxc0FrZktzSUhBQUFBVUpnYWJNS0hpdkFCQUFBQUZLWUdtL0NoSW53QUFBQUFoYW5CdnQxcHVBa2ZmeXJDQndBQUFEQWtOZGgzT2cwMzRlTlBSZmdBQUFBQWhxUUdtL0NoSW53QUFBQUFoYW5CSm55b0NCOEFBQUJBWVdxd0NSOHF3Z2NBQUFCUW1CcHN3b2VLOEFFQUFBQVVwZ2FiOEtFaWZBQUFBQUNGcWNFbWZLZ0lId0FBQUVCaGFyQUpIeXJDQndBQUFGQ1lHbXpDaDRyd0FRQUFBQlNtQnB2d29TSjhBQUFBQUlXcHdTWjhxQWdmQUFBQVFHRnFzQWtmS3NJSEFBQUFVSmdhYk1LSGl2QUJBQUFBRktZR20vQ2hJbndBQUFBQWhhbkJKbnlvQ0I4QUFBQkFZV3F3Q1I4cXdnY0FBQUJRbUJwc3dvZUs4QUVBQUFBVXBnYWI4S0VpZkFBQUFBQ0ZxY0VtZktnSUh3QUFBRUJoYXJBSkh5ckNCd0FBQUZDWUdtekNoNHJ3QVFBQUFCU21CcHZ3b1NKOEFBQUFBSVdwd1NaOHFCNDlldFFOSGk3Q0J3QUFBREFrTmRpRUQ5Vzc3NzdiRFI0dXdnY0FBQUF3SkRYWWhBOFY0UU1BQUFBb1RBMDI0VU5GK0FBQUFBQUtVNE5OK0ZBUlBnQUFBSURDMUdBVFBsU0VEd0FBQUtBd05kaUVEeFhoQXdBQUFDaE1EVGJoUTBYNEFBQUFBQXBUZzAzNFVCRStBQUFBZ01MVVlCTStWSVFQQUFBQW9EQTEySVFQRmVFREFBQUFLRXdOTnVGRFJmZ0FBQUFBQ2xPRFRmaFFFVDRBQUFDQXd0UmdFejVVaEE4QUFBQ2dNRFhZaEE4VjRRTUFBQUFvVEEwMjRVTkYrQUFBQUFBS1U0Tk4rRkFSUGdBQUFJREMxR0FUUGxTRUR3QUFBS0F3TmRpRUR4WGhBd0FBQUNoTURUYmhRMFg0QUFBQUFBcFRnMDM0VUJFK0FBQUFnTUxVWUJNK1ZJUVBBQUFBb0RBMTJJUVBGZUVEQUFBQUtFd05OdUZEUmZnQU1IZm41K2ZmVUNVTGl4V2gxYi9RYkNYSm0yR3hJclQrZTgxbWt0d0xpd0VBU2xDRFRmaFFFVDRBTElHYTV5b0NpRmI5cFdZTFdWNElpdzlPNnlhQUFFQU4xR0J2aEkrSER4OFNQcG9hTFh6NFJOZWM3eGJoRzJHM0FFekU3OFBtN1pnbUxEWTRyZnJOWmd2WnJvUlZERXJySllBQXdOVFVZRytFRHpmaHNlWjg2VFgxbFErZjZKcnozU0lRUUlDSitYM1l2QjNUaE1VR3BkVmVhZGJleTFmRGFnYWw5UkpBQUdCS2FyQUpINm9hYnJ2eWlhNDUzeTBDQVFTWW1OK0h6ZHN4VFZoc1VGcHRuOXV2V3ErRTFReEs2eVdBQU1CVTFHQVRQbFExaEEvemlhNDUzeTBDQVFTWW1OK0h6ZHN4VFZoc1VGcnRNUUdrU1BQdjlUYXJUMElBQVlDaHFNRW1mS2hxQ1IvbUUxMXp2bHNFQWdnd01iOFBtN2RqbXJEWW9MUmFyb0FBQUFnZmJkVVVQc3dudXVaOHR3Z0VFR0JpZmg4MmI4YzBZYkZCYWJYTUFRR0FVNmNHbS9DaHFpMThtRTkwemZsdUVRZ2d3TVQ4UG16ZWptbkNZb1BUcWg4MVc4akdVN0FBWU83VVlCTStWRFdHRC9PSnJqbmZMUUlCQkppWTM0Zk4yekZOV0d4d1d2Vnp6UmF5RkR1R2FOMEVFQUFZZ3hwc3dvZXExdkJoUHRFMTU3dEZJSUFBRS9QN3NIazdwZ21MRmFIVnY5SnNKUW5maEE0QWM2Y0dtL0NocWpsOG1FOTB6Zmx1RVFnZ3dNVDhQbXplam1uQ1lzVm9FeW5qY1ZENVJGaWtDSzJmQUFJQUphbkJKbnlvYWc4ZjVoTmRjNzViQkFJSU1ERy9ENXUzWTVxd1dGSGFqQ2VsdjZEcWZqdTY1NGc0ZUh3cC9GaFIyZzRCQkFCS1VZTk4rRkROSVh5WVQzVE4rUzVOV0F3QW9uU1lxQzZBMUVDN1NnQUJnQkxVWUJNK1ZITUpIK1lUWFhPK1N4TVdBNEFvSFNZSUlCSGFWUUlJQUF4TkRUYmhRelduOEdFKzBUWG51elJoTVFDSTBtR0NBQktoWFNXQUFNQ1ExR0FUUGxSekN4L21FMTF6dmtzVEZnT0FLQjBtQ0NBUjJsVUNDQUFNUlEwMjRVTTF4L0JoUHRFMTU3czBZVEVBaU5KaGdnQVNvVjBsZ0FEQUVOUmdFejVVY3cwZjVoTmRjNzVMRXhZRGdDZ2RKZ2dnRWRwVkFnZ0FIRXNOTnVGRE5lZndZVDdSTmVlN05HRXhBSWpTWVlJQUVxRmRKWUFBd0RIVVlCTStWSE1QSCtZVFhYTytTeE1XQTRBb0hTWUlJQkhhVlFJSUFQU2xCcHZ3b1ZwQytEQ2Y2SnJ6WFpxd0dBQkU2VEJCQUluUXJoSkFBS0FQTmRpRUQ5VlN3b2Y1Uk5lYzc5S0V4UUFnU29jSkFraUVkcFVBQWdDNTFHQVRQbFJMQ2gvbUUxMXp2a3NURmdPQUtCMG1DQ0FSMmxVQ0NBRGtVSU5OK0ZCRndzZDkxV3pEaC9sRTE1enYwb1RGQUNCS2h3a0NTSVIybFFBQ0FLblVZQk0rVkpId2NTZThSTFBtRTExenZrc1RGZ09BS0IwbUNDQVIybFVDQ0lEeS91bnZQblJaZFMyaGJpWFVIZFg5VHQwSW15bktUWGEzNlNaOExDdDhtRTkwemZrdVRWZ01BS0owbUNDQVJHaFhDU0FBTGxKVDd6Q3czZWp2cXZPSjYxWVlkakZ1c3J0Tk4rRmplZUhEZktKcnpuZHB3bUlBRUtYREJBRWtRcnVhYzZ3bGdBQ253azM5VnBOZmM5ME53eTdDVFhhMzZTWjhMRE44bUU5MHpma3VUVmdNQUtKMG1DQ0FSR2hYYzQ2MUJCRGdWS2lwSHpTQS9PaHJIejcvNmJjK2RyQWV2dlRNK1M5ZS91VGVldnpkVDYycXMvNzdZZGlEYzVQZGJib0pIOHNOSCtZVFhYTytTeE1XQXdhalg2c3ZxWjVYdVhIMTc2UHJrV29YLzEzN2MxN0d5MzRocks1NkdxdjM5NnRoN08xK3ZLbmE1WGVxMmV4dkdHT3lzTmppYVZmOTc1ZHFrQUNpOVh4QjVkK1hGN3pPVUx2TTVuY004NkxmcFNzcUgvTmVWOFdPZGUweDdoV1ZmKzVLV1BRMHFLbGZCNUFITDE0Ni8rMzNMdStzUC83d3MrZm4vL3o1VWVzUFAvak1hbXh0aFdFUHlrMTJ0K2ttZkN3N2ZGaDQweWNMaXdHOTZkZklUVkhiZkEvTjY2em1CS1p4ZkVMMW5Nb24xbjBob3crZnRMM2U1OExtcXFEeEVFQWl0S3M1disrOUE0aVdkY0QxNzhXK0VKL0s2Nmp1ZHd6em9OOGIveTcyT2M2ZjFoVkFOZlhyQU9LckRyRVFNSFcxNHd0MU9ReDlFRzZ5dTAwMzRXUDU0Y1A4Um0vZTcybkNZck9uWGZFbk1tN2djajBmVmpFcGpjT05iZTc0Snp1b2E5dCt2ZjBwN0JCTlVTbzMvUDRrOXhOaEdLUHc5c0oyL1duZldQeTZ1dkVmZFY5andqaVNoY1dLME9wemptOUYzeDllZjdPWkpObGowVEwrblN2NS92SzZIZTVyK0IyYjlYbExROHA2ajhpWHdxS0QwN29ILzczVXovbERwcXgvb3kwRWtOckt0MnkxWTFSZEQwTS9tcHZzYnROTitEaU44R0Yrb3pmdjl6UmhzVVhRN3Zoa211dFJXSHhTR29lYitSd09LNk5mRmRBMi9RblltSTE0alBmOUcyRkl4V2diRGxuK3RMaFBzQjJLdHoxcFNOYjJDU0FSWG4rem1TVEpZOUhQbGc0ZTIycjRIWnYxZVV0RFdtd0EwYy8wT2E5dU83a0E0aWRnbmJzODN5SVdBS1l1M3hyV2psRTF5Sk93M0dSM20yN0N4K21FRC9NYnZYbS9wd21MTFlaMktXdi9nK0xON0Q3YXZqOWR5dlhWc1Bnb3REMDM0MzFlMjJMQzBBYW5WZmU5emFBa2oyZVNUNnExWFFKSWhOZmZiQ1pKU3FNMzlYdk1WeGdubVNlaTdXYnRkMWlzR2hyU0lnT0kvdDRmd0F6aDVBTEkrdkc2bnVjUkN3QlQxeTlmL2ZScWZLR09ub2p1SnJ2YmRCTStUaXQ4bU4vb3pmczlUVmhzTWJSTGZacDVmd0k0MlcwSTJuYld2NW1NZGpEWHRuejdVZTdWbVZHRUlRNUdxMnl2ZU5US3Y2ZWpONGphSmdFa3d1dHZOcFBrVUtQbmVVVlRYbWxyVFhJMVJOdWM5WGxMUTFwY0FOSGZEWGtzSklEVVZyOS8vY3BxZktHZWhxSDM0aWE3MjNRVFBrNHZmSmpmNk0zN1BVMVliRkcwVzdrbkEzc2xMRDRxYmRlM1crUndnekRLclZmYWpzUGNtTGVDWkFuREhJUlcxK2QzWmdxamh4QnRqd0FTNGZVM20wbXlyOUhMUFFhTVlkU3J3dHJlck05Ykd0S2lBb2orZk9nUFlnZ2dOWllmNzl1T1UzVTFERCtMbSt4dTAwMzRPTTN3WVg2ak4rLzNOR0d4eGRHdTlYbEMwZGlOWForSjU2UGNlcVh0MU5nVWJRaERQWnBXNVZ1dTVtUzBFR3JhRmdFa3d1dHZOcE5rckVadlNLTjlLS050emZxOHBTRXRKb0RvejRhWTg3R05BRkpqdmZIdGo2L0dHT3BtR0g0U05kaVhWUGM3RFRmaDQwOTFjdUhEL0VadjN1OXB3bUtMbzEzcjAxU09lcERVOW5KdmJScGxmTnBPelUzUldoanUwYlNxdVFVUWV6TU12emh0aXdBUzRmVTNtMGtTYS9SeW05WXB2QkNHVzVTMk0rdnpsb2EwaUFDaS85L25GdVlVbzU1Yko2ZG1maFlCcE84WEVxckJkdmg0MEdtNENSOS9xcE1NSCtZM2V2TitUeE1XV3lUdFhwKzVDNk04SDEvYnlUM1FqL0twdDdZeGkvQmhZY2hIMDZybUdFQnNsTnRrdkoxbWMybkNZa1ZvOVRuSHQyb0RpUDUvOVZjWU80clBDZEUyWm4zZTBwQ1dFa0NHL202akZnR2t4dHIrUWtMVnBiQUxPNm5CSm55RUlueHM4aHU5ZWIrbkNZc3RrbmJQdHpqbHptRVk1Ykc4Mms3V3Y1TVV2L1ZLMnhneWZEZ3crWEc5UGpHN3dZK2VjUFhuRG1MK2UxLzI5L2FULzczQ0tvNm1WUjBiUUR6bWRsODltZGpydS9CUUEvOVorRHZ2cTM4KzkvYTdtREZDS1FFa3d1dHZOcE5rUFJiOTd6NmZNdnQzekIrb09MajRkK2pDdjd2L0xQeGQrMTRhNHZlclZmVDJWSzEvMXVjdERXbjJBVVQvdThTdFZ5MENTSzMxNDY5L1pEWE9VRGZDTGtTcHdTWjhoQ0o4WE9RM2V2TitUeE1XV3l6dG9odkNYRVdiZmEwL2QwekZEOTdheGxEaHcrczU2aXFTbG5jajVaUGgzakFTZnZ4b1dsV2ZBT0lBNFdhd2R3RFFzdTBYSE9hRzVLN2k5K2xyR3dTUUNLKy8yVXlTMVZqMDM1d1BSUndnL05vZjh6dm1ZODBRMzl2ak1SZDdVcURXUGV2emxvWTA2d0NpLytiTVIvVHZrNC9QRi9aQmY5Wit5T0xqV3ZjREpRSklyZlh3cFdkVzR3eDFOK3pDQldxd0NSK2hDQjl4ZnFNMzcvYzBZYkZGMDI3bW5vQjlJQzV5c3ZWNlZUa05wOGRTOUZOdXJULzM1Qm5qZFF6K21tbWRQcGxGZjZmRGp4eE5xMG9OSVA1Mzg0bDMwUDMwK2xUSEJNQ3Fmai9DWWtWbzlUbkh0eG9EU01xeGFCVThWaHNaaU5ibnF5NVo1NGFJWXZOQnRPNVpuN2MwcExrSGtKVHgreGlWZmF6Uk1nN0JvOHdscWthbm9WL2Q1aFJyL0d1cHJjZnh1cUszWWFuSnZ0dHR1Z2tmaEk5dGVxUGZVeVVMaXkyYWRqUG4wNTFXa1FPbTFwdDdvcXJ0YXN3Mk4xUkZHMkRUTmk0RWtmQlhSOU9xRGdVUTN4Yzl4bjN3ZmVjRkZEMjVhLzBFa0FpdnY5bE1FdjlzeW52Tjc2ZVNWeHFPdmMybXlLMVlXdStzejFzYTB0d0R5TDRQeGZ4M28zLy8wS3gxRy9wWTAxOWJwZHlHcFViN1ZyZngvdld2ZngxdDBKZGNoSS85ZEtDNHR6cGtKQXFMTFo1MnRVOXpOMmhqN2ZVMXEwMVd1b0hxRTh4YVhtNktMeXp6ditOcXpPR1BqcVpWN1FvZ1B2R091by9hWG00alk3OExpeGVoOVJOQUlyeitaak5KSEdJUFhma2M2eEhidmhyUzkzMWY1RFgxZXB2VnB3bUxWVU5EbW0wQVVlMEx4djc3WW9GNHNUck5mTFRocjYyMmJzT0tQZzFMemJadndYcmFOdCtQSGoyS051bExMY0xIWWVHQWtTd3NkaEswdTFtdmpReDZzdlg2bXRVbWNZTlErdGFhM05lajViRk45b21ZdHUzZ05OaS9qZFlWQ3lCdUtDWTU4V3E3ZmY1ZFNqWTBCSkFJcjcvWnpDREdEcnJIaEpEQmY5ZTB6cXpYTWl4V0RRMXB6Z0ZrMTIyQnI0ZFZJbGVubVk4Mi9MVlY1R2xZbDhPdWJGRFR2YjRLOHRaYmI1M01WUkRDUnhvZE5PNDF4NDQwWWJHVG9OMzFGWWpjays0Z0p3cXRKL2RXcDFwdnZmSW51Y1Z2dVJxVDlxY2JRQ2EvM2NEYlg0MGtUN0ZIOG5yZHpTYlNoTVdLME9wemptOXpDU0NqWDBrMGJiZlA3NWtOL3JwNm5jMnEwNFRGcXFFaHpUV0E3TG9xNStNOFZ6NzY2amJ6c1lhL3h2cnB0ejYySHJQcWR0aVZEV3E4VCs0cUNPRWpuUTRhOTFhSGova3ErdDBHWG4rem1XUkhQNVpYNjhpZGVGNjZjZXA3NjFYeHF6SlQwRDYxQWFUby9mYzVOSTdjU2VuRmZtZTBiZ0pJaE5mZmJPWW9rNFNQbHJiZmQwN0kwTGVuWnIyV1liRnFhRWh6RFNBeGl6ek9qNnJUeUVlYi9ScnJsNjkrZWoxbTFWUFZyc25vRzNOQm5qeDVFbTNjbDFDRWp6dzZjTnhiSFVMbXEvaVhxMmtidVYrMmRGU1RvT1Z6VGs3RkQvNWFmKzdKMGp5dVJVNUUxSDQ1Z0l4eS8zMHFqU2Y3Q2xWWWRIQmFOUUVrd3V0dk50TmI4VWNvcDlBNCt1ekhvQTgrMFBxeXhoQVdxNGFHdEtRQU1zcVg4UzVhcDVHUE52dTExdFprOUp0aGR5NVFJMzdXTnVYdnZQTk90SG1mZXhFKzh1bmdjYTg1aHN6V0dBRWs5OVlETjkrOVBoblhjcmtUejB2ZmV0WDM2Z2NucFpIcE5jLzlkeXIxaENJQ1NJVFgzMnltRjE4UnJlVnFXNTliVXdkOThJSFdsL1ZhaHNXcW9TRXRKWUFVZmMrY2pFNFRIMjMwYTYxZnZQeko5YmhWWjJGM0xsQXpmcjNiblAvcVY3K0tOdkZ6TGNKSFB6NkFOTWVSMlNvZVFNemJhVGFYck5lNHRGek92MGZ4ZzcrMmtidmZkbHJQY0srRVh2ZmMyN0NLTkRWYUx3RWt3dXR2TnROTHNRYTBENDJuejNGaHNBOGx0SzZzMXpJc1ZnME5hU2tCaEZ1dmpxWEcvVktuaVk4MityWFdIMy80MmZNZmZlM0Q2N0dyZG40enVwcnkrMjJEL3ZiYmJ5OW1RanJob3o4ZFFPNDF4NUhaR2l1QTVNN0xzS3lEczM0KzV6WWFmd0paL09DdmJlVHVjeldmMUo0YXZlNjU5K2NYZWU5NHZjM3EwNFRGaXREcWM0NXZ0UWFRNmo1bDFwaDhQTXcxMkFjVFdsZldheGtXcTRhR3RJUUFVc1V0Z2JPbnB2MWEyOEI3WW5lczBhKzVNcTZDWEZhdEo2Uy85OTU3MFlaK1RrWDRPSTRPSW4wUFByVVlKWUNZdHJYcit4OTJTWDRzb1g0Mk4rQVVuNE9nYmZSNTh0V2trMlJQbVY3NzNOOVBBc2ltV2dOSVZWYy9XaHBYN2hXM294L1EwZEs2c2w3THNGZzFOS1FsQkJDK2JIQUlhdHBuSFVBaVYwRnVoVjI3UUEzNnhvVDBPZCtLUmZnNG5nNGlmUTgrdFJndGdKaTJWK1EyRi8xY3pnbHBsRTlFdFoxZHozdmZaYkFHQS9uMCt1ZCtLbDNGdC9lSHhZclE2bk9PYnpVR2tPcXVmclEwdGo2UDVSM2txcTNXay9WYWhzV3FvU0hOUFlDOEdSYkhzZFN3enpxQXVMYXVndXg4SXBhcFVYL1FOdTF6L1c0UXdzY3dkQ0RwYy9DcHlkZ0JKSGRTOXNFRHRYNG1aMUxuV0xkZTlibkZncXNmRXd2L0RxbUtOTGRhTHdFa3d1dHZOcE9sNnZlVXhwZDdpK1lnODBDMG5xelhNaXhXRFExcDdnR2txcWNBenBxYTlka0hrTWhWa09qM2dwaWE5YXVxOWExWWMzc3FGdUZqT0RxUTlEbjQxR1RVQUdMYVp1NnRTWHViQ1AxOXpwV0dVUTc4MnM3enplYVNjZldqQXZwM3lBbkhCSkJOTlFhUXF1ZFRhWHk1VjRRSE9WNXJQVm12WlZpc0doclMzQU1JdDE4TlJjMzY3QU9JNi9GM1A3WGFoMDVkRGJ0NGdacjJtOTBtZmk1ZlVFajRHSllPSlBlYTQ4bHNqUjVBVE52TkNRMDdKMmJyejNQdTJ4L3RkZ3h0SzdleDRNbFhGZEMvUTg3N21RQ3lxYllBTXRyN3ZTK05NZmVEaWtIMnlldHBWcGNtTEZZTkRXbk9BWVFQbTRha1JuMFJBY1QxazI5K2RMVWZvZTZIWFl4UzgzNjMyOHpYUGgrRThERThIVXh5RHo2MW1TcUE1RDRMUHpwTy9YbnFMUXlqM0hyVjByWnliNjNnRTdFSzZOOGg1LzFNQU5sVVd3Q1o1TmlXUTJQTS9kNmlRWnBYclNmcnRReUxWVU5EbW5NQVNYNjRDaEtvVVY5TUFQbnQ5eTZ2OXFOVCs3NmM4SkpxWXo3SUJ4OThFRzMrcHk3Q1J4azZtTnhyamlscHdtSVF2Unc1anoxMWdOaTRDcUwvbjNNU0d1MmVXMjFya3FZQzZmU2ErOHFaYndYMDc1Q3ZWdmw5bkJPSWpRQ3lxYllBVXF6cEhGSVlhN0t3MkZHMG1sbWZ0elNrT1FlUTZvUHhyS2hKWDB3QWNUMTQ4ZEpxWDBKNVF2cmxzS3NYcUpIZm1BL3k4NS8vdktwSjZSNkw1NmkwNHd0RitCaUlEaVpaQjUrd0dBSzlKRG12My9xNTZmcmZPVmRRaWpaRzI3UzkzRGt1UEErK0FMMnVRNFNNZlFnZ20yb0xJTFA0UGgyTk0zZS9qcjZTcTNWa2JUTXNWZzBOYWM0QlpCYkJlRGJVb045b0cvWTN2djN4YUZNL3A0cE1TRDkwSzliR3Q2VFhFa0k4Qm8rbE96WVY0V05BT3Boa0hYekNZZ2owa3VRK2luSjE4dFYvVStlUWpIcnJsV2w3dVNkSG5uN1ZrMTY3MGlGakh3TElwcW9DU0Zpc2VocHE3dU82ajI1Z3RZNVp2NVlhMHB3RHlLam5vOFZUZzM2cmJkYjlPTnRZVXorM2V2TGFzNnY5NmRUTzd3WXhOZlkzdW8zK3c0Y1BvNkZnckNKOGpFTUhrM3ZOTVNWTldBd2RlbGx5VGladU1uTW1uby8rdUVOdE03ZWhZUDdIQVg2TlZMNWw3d1dWMzNOamhZeDlDQ0NiYWdvZ3MvbWVCWTExOUdaYTY1ajFlVXREbW0wQUNZdGhLRzdPMjBaOUtRSEU5ZkNsWjFiNzFLbHJZWmVqM09CM0czN1B1NGlGZzlKRitCaVBqaWYzbXNOS21yQVl0dWlsZWJONWhaS2tOcCtUTkNIYUxyOFRSOUxMNHU5UjhST0NIT1pxQ0JzeEJKQk5OUVdRb21NWmtzWktBTW1rSVJGQTBGQmp2c2dBNGx1eHRwNkt0ZmNMQ3MyTmZyZnhIenVFRUQ3R3BlTUpCNThCNktYSnVhcVJhcElyQzJIYnFaaUEzcUhYdzdkVDVWNUJtZ29CWkJNQnBBZU5OYmVaUG5vU3M5WXg2L09XaGpUWEFES2IzOHZaVUZPK3lBRGkrdjNyVjdibmd6d0l1NzJURy81dUFIQUlHV05PQ09GamZENmdOTWVWTkdFeFJPamw4ZTAxUTVuc1NTTmgrNms0SVlsZUIxL3R5SDEwOGRRSUlKc0lJRDFvckFTUVRCb1NBUVFOTmVXTERTQ3VYNzc2NmRXK2RlcGdVKy9HdnhzRUhBeEtoaERDeHpSOFFHbU9LMm5DWW9qUXkrUGJib1pvUWllNy8xdmI5ajdrT09rVGt2YmZWNzdtRmp4YUJKQk5CSkFlTkZZQ1NDWU5pUUNDaGhyeVJRY1FWMlEreU41SjZlWUEwQTBFcFVJSTRXTTZQcUEweDVVMFlUSHNvSmNvOXhHMk1aTk42dGEyYzI4bE84bHZRTmQrTzZnTmVjVnJDZ1NRVFFTUUhqUldBa2dtRFlrQWdvYWI4Yll4WDJvQWNma1J3KzEraHJvUlhvS2RIQVM2d1dEb0x5c2tmRXpMQjVUbXVKSW1MSVk5OURJZE13ZGdzbHV2VE52UERTQ1RqbmNLMm1lSGo1eUhEcFRnOTYxL3o5ekkrUFl2Lzd0NVhEbnZad0xJSmdKSUR4b3JBU1NUaGtRQVFVT04rRHFBK0lzSS9XM2lmL2pCWjZKTi9Kd3JNaW5kbFJKQ2JuVURna1BJMmRsWk5GRGtGT0ZqZWo2Z05NZVZOR0V4N0tHWEtmYzJwcTVKdjN4TTJ5ZUE3S0g5OWVOMHgzaXFsYmZoOTZZZjI3d1JNc0pRb3ZUM09lOW5Bc2dtQWtnUEdpc0JKSk9HUkFCQlEwMzQzYTJtZkYwT0pMNTl5ZCtyNFFZKzF0alBxYndQUC83NlI3YjNNeVdFYkh4UGlPdVlKMlFSUHVyZ0EwcHpYRWtURnNNZWVwbjhmUTk5VFhwTGs3WlBBTmxCKytwZ09YVDQ4SldVTm1UNDlyMmpHZzB0bi9OK0pvQnNJb0Qwb0xHTzNreHJIYk0rYjJsSUJCQTAxSURmMzJySWQ1YXZJTFNCSk5iZ3o2RWlUOFp5cFlTUXE2cW5uY0N3Q2hHNXQyUVJQdXJoQTBwelhFa1RGc01PZW9seXZ4azlwdGpKNWhCdnV4bENzbE1LSUVQY2R1VjF1UGtvOG0rczllYThud2tnbXdnZ1BXaXNCSkJNR2hJQkJBMDEzMWRWMTFXK0ZldU9Lam1RZUY2Rm56STF0NnNqUjRTUVM2b0huZUN3dWlYcjhlUEgwYkN4WFlTUHV2aUEwaHhYMG9URnNJTmVvaUdhVkQ5VmFaSmJzYlRkM0FCeUVpY2s3ZWN4RTg3OTcrbUc0MHBZWFRIYVJzNzdtUUN5aVFEU2c4YWFPK2VOQUVJQXdTRnF5QjFNYnFodXF4Nm96dmZWZ3hjdnplcktTTjhRWWdvTnQ3ZEN4UG5EaHcvUG56eDVFZzBlTHNKSGZYeEFhWTRyYWNKaWlORExrM3RTMldlU1c3RzBYUUxJRnUxajM2dGF2bDNyK2JDYVVXaDdPZTluQXNnbUFrZ1BIbXN6NUdSSEIzR3RZOWJuTFEySkFJSThhczR2cVh5bHhGZEp6bFRuc2ZJY0N6OU5hdzVYUlhhRWtLUlFvUEJ3VFhYV0NST3JldlRvMFNwc0VEN3E1d05LYzF4SkV4YkRGcjAwdVkxN2ltSW5uVjIwemR3SjlLY1FRTExlSTRFL0ZSNzlLcGEybVROV0FzZ21Ba2dQR212VzkrQ0V4WTZpMWN6NnZLVWhFVUJ3SERYcXZrTGlxeVBSTU9MRzNsZEZhbitpMW82blkvazJ0RXRoVjNkU2lQQXRXUnVQNm5XOS9mYmI1KysvL3o3aG8zSStvRFRIbFRSaE1YVG9aWEhUWHVMTDZDYTVGYXZaZExxdzJDSnA5L3BjL1hnbExENDZiVHZuL1V3QTJVUUE2U0dNTjlYdndtSkgwWHBtZmQ3U2tBZ2dHSTZhOVdzcVh4azVqMVh0UVdSSENQRnRaMWZETHU2bFFCRzlHdUxic2dnZjlmSUJwVG11cEFtTG9VTXZpNTlpbE1vbm5weXdNdnF0V05wbTdwT2VKbjEwY0VuYXQ1eC9XNXYwQk8zdE44TklRZ0RaUkFESnBIRk9jc3VtMXBNMUp5c3NWZzBOaVFDQzRhbGg5MjFhTjFYUnF5SzFCeEdQYjJ2TVQxV3A4MEo4TmNUZkdiTHhwS3l0SW54VXhBZVU1cmlTSml5R1FDOUp6amVmdnhtVzhYYzY1QmoxVml4dEwrdDNRa2EvVld3czJyZmNNRlo4b3ZrKzJuN09lQWtnbXdnZ21UVE8zRWVPRC9LQml0WlR6ZTlZSHhvU0FRUmx1WEZYWFppODdsdXphcDRqOHZpN245b1lieWgvVjhyQlc3Sk1JZU95ZzBZbmRCQStLdVVEU25OY1NSTVdnK2pseVAxZWlDK0VSYjFzenRPeVJyMFZTOXZLL2RSL2tZL2kxWDdsZnJvNzJhMVhyVENPVkFTUVRUVUZrRWRoc2FwcG5MbkhpcStHUlkraTljdzlnT1ErVlk4QWduN1V1UHYyckF0WFJEeFp2ZGFuWnZuYjRDT1QwNzBQMThKdUhhVEE0ZThOdVUvNHFKY1BLTTF4SlUxWURLS1hJK2Z4a3h1Zi9Pbi81emEzbzkyS3BXM2xmanEzeUpPUzlpdjNkWGd1TERvSmJmOUtNNHhrQkpCTk5RV1FXUnhyTmN6Y3VXL3JEMkdPb2ZYa3ZqZXJ1a3FyOFdUOUxnZ0JCTWRSOCs0ckloZUNpTDlMcE1hcklSNlR2d2wrZTd3cXozVkp1aHBpRGlMaGY2SXlQcUEweDVVMFliR1RwNWNpNTlZRFh5VzVjQVZEZjViNzZlRW9KMUZ2cDlsY2xzWE5BOUUrWmIwM1pOTFhRTnVmNUg3OGJWb3ZBU1RDNjI4MmsyeVFacjBVajY4WlpycXc2TkcwcXJrSGtOeGJPd2tnR0lhYWQzL2hvZWRXbkxmbHF3MjFYZzN4TFZtUnF5SEpjME5RTHg5UW11TkttckRZU2RQTDRFK2FjMDRnMGUrQzBKL25ybWUwVzdHYXpXVVo5ZnN1eHFCOXl2bDBkL0piWmpTRzNLYU1BTEtwdGdBeXlPMUtwV2g4dWJjUkRmYjZhbDI1dit2VjNDYXFzZVJlcVRRQ0NJYWo1djJ5NnNJM3J0ZDZOY1FUNTNkY0RmRWNsK1Ric2xBWEgxQ2E0MHFhc05oSjA4dVFNMzlqN3dGYmZ6L0pKTTVEdEoyczN3dFozSWtwN0ZlcXlmZmZZMmlHa3F6SW1MVmVBa2lFMTk5c0p0bnJZZEVxYVh5NXQxOE5GcWkwcnRuTnoycHBMTGtQSVRFQ0NOTDhxK2YreCtYd1B3OVM4KzR2TnR5NEd1SzVJZjZDd0ZnUW1McDJYQTF4T1V3UlJHYkdCNVRtdUpJbUxIYXk5QkxrZnZKMjhLbEkrcG1jUUdQRmJ5ZlFObktEa1ZWOXkwZ083Y3VzdnBCUjI4OGRyeEZBTnRVV1FLektXeHMxcmo2M2FRNTJmTkM2Y3JlL2VnSmhEVFNXbkxtRExRSUlEbFA0dUtVNkQvOU5taWVoeHQyUDdyMXdOZVNYcjM0NkdnS21MbCtoaVR5dXR5MkN5SXo0Z05JY1Y5S0V4VTZTZGovM251ZWt5Lzc2dWR5VGFmRmJzYlQrUHJjSlZQTXA0N0cwTDFYTXAwaWw3ZmNKakFTUVRUVUdrQ3B2YmRTNGNwdm9RVzlSMVByNkJPN0p3NXpIMEF3bEd3RUUreWx3WEEvaG82Mm5xcHZocnc5UzQrN3ZEM0VUdnk0MytyRVFVRVA1S3MyTzI3SmNEaUxYdzY2aFVqNmdOTWVWTkdHeGs2TmQ5NG1qMktOejliTzVFOUtMMzRxbGJlUmVtYkZGWEFYUmZzd3RnT1RlRG1NRWtFMDFCcERxSHNlck1mWDVjR0x3T1JoYVorNUU3c25Ebk1hUWV3VzlSUURCYmdvYVYwUGc2QWFRdGg2b2twNEVwYWI5cW1yalNWbHU4bXY5emhDWEg5bTdKNGg0WHp6cFB2bTJOSXpIQjVUbXVKSW1MSFp5dE90Rm45dXVuM2ZBcWViSktLYjE5N2xYZVJFbktPM0hiQUtJdHQzbjM4a0lJSnRxRENCVzFWVVFqYWZQZmd6K0JaMWFaKzQ0SnAxVG8rMzNPY2EzQ0NDSVU3aTRGRUxHS25EODYvLzBQMWZWL3Y5TzNWWWR2QzFMemJwdnlkcjRBc09mZlBPalZZY1ExNEVnNHZKVkVUK0tPUGtSdmlqTEI1VG11SkltTEhaU3ROdTV6V2l2RTUyV3k3Mk5wdWl0V0Y2M3FzOEpzK3FuOTZUUVB1VGViamZKSjlYYXJ2K04rbHo5TUFMSXBsb0RpTitEVmN3RjBUaWVXNDBvVDZuZnM5d1BoV3p3SUpSSzIrNTc5Y01JSUloVHFMamJDUm5uWC96Szk4Ly93My83ZitlZmUvN1ZidmhvSytkcWlMOXZ3NDM3cWp6NXU5Yko2ZDN5RTdOODY5aU95ZXB0T1l6NGxqT3VqRXpJQjVUbXVKSW1MSFl5dE11NVRiaC90dmRKVHN2bTN2WlU5RllzcmIvdlNYUDJ0MktGL2NneGVuT2piZlpwd2xvRWtFMjFCaENiL0lsWUdrUGZEeVNLTk05YWI1OHdOTW5qZUxWZDM3Ylc1N1ZyRVVCd2tjSkVPK2w4VlgvMjE2K2QvOGYvL3YvWDVURHliNjcvcjI0QWFldFdXTVZlb1VsM3c3NnF1WVFRbDYvWWVDSzlyOTUwOXlGU3ZrM0xZY3RYUi9qU3doSDVnTkljVjlLRXhVNkdkamwzc3VWUm4vNXIrZHlyTFZieTVOUzM2ZkF5c3c0aHpXNWtHYlc1MGZiNi9LNTBFVUEyMVJ4QWJOSmJzYlQ5UGs5dkt2YWFhdDArTnVVNjZnT2l2clROUHZQcHVnZ2cyS1FRc1RIcC9OLzlsMWMyd2tlM1B2OVhmOThOSDIzZFY2WGNrdVhHM0kzNnF1WVVRdHJ5VlpHSEx6Mnplc1J3ZDEvMmxLK1EzRlo1L3NnMUZjR2tBQjlRbXVOS21yRFlTZER1NW43Q05zaWpIcldlM0UrMVM5K0sxZmNxaU1jMTJTMFB4OUxZczk0YjR1Wm1sRnRsdEIzZkluYk1KNnBHQU5sVWV3Q3g1OExxUnFYdDVqNGtvMVdzY1RhdHYwOWpQK3JWSkcydjcydlhSUURCbnlnNGJFdzY5MVVPMzNZVkN4OXQvZnYvK24vUG4vM3lkN1pEeUpucVlIT3RCbnoySWFRdGh4Ri9uOGlCK1NMUkNpOEhCdUlEU25OY1NSTVdXenp0YXA5TDVvTjg0cS8xOUxucVVPeFdMSzNiNCtrN3o4RDdNZW1WRUc5ZmxmMzZlQmxWcmpHZVRqWkUrREFDeUtZNUJCRC91eGR0NnJkcGUzMGI2T0xOcXJiUjUvSFROc3JWSkcybjcvaTJFVURRVUdDNE1PbjhMLzcySDZPaFk3c2NVbnlscEYwMmxJUE1qYkQ2bmRTQVh3Z2h0VTlNVHlsUFh2L0Z5NTljQlpJRDgwWUlJQVB6QWFVNXJxUUppeTJlZGpYcmRaRkJHMCt0cjdadnl6M21kaDgzVFpQY1BxTHR0czF3OW9sVHkvUzV4OXlLN2F2V1BWVDRNQUxJcGprRWtOWllEZlF4bjk0WC8rQkIyL0FIUlgwVmZRMjEvcjVYam1NSUlHZ29MRnlZZEI0TEcvdktjMFc2NndoMThEdEQxSVJ2aEpBNVBCMHJ0M3lGNU1scno2NUN5UnZmL3ZoNlgxWDN3OHVBZ2ZpQTBoeFgwb1RGRmsyN21mdXBsUnZDd1crOTBUcXovbTJrOUsxWXgweDROdDlEUHRZdFNnNXczYXMyZlFKSW4zdk1XNE0zTjE2bmFsLzQ4Ti9saEJNQ3lLWTVCUkR6KzdISSswbnJkV04vekhoSG13K2xiZldabTlJcThUNzFjZVBRbUhJL1JDQ0E0UENrODV6eUxWbVJ4L1hlQ1p2YVNZMzRoUkFTYStTWFVMNDYwdGxYQXNqQWZFQnBqaXVMMHZzZ3FXWDdmTUpjNUw1c3JkZGp5Vlg2cVZqSFRxYjBhK3NHdFVSZzg0bC9PM2kwZXYxT2FMbGpQZ0VlcEFuVGVsS2JRYit1T2U5bkFzaW1tZ0tJZjRkVGprUCt1Y0dhYUszTDd5SC8rK1VlQTdzR21RdVhTdHM3OW1FTWczMHdvdlg0cW1ucytOUGx2ODk2andnQjVOUXBIQ1JQT2s4dDM3b1ZlVXBXU2dqWmVEcFd6ZCtZZmt3UlFNcnlBYVU1cml6S01RRWt0OEV1M2JUMHVlcFE4bVRWWjI3TUxtN3VqdzV2WGtkWTE3NXg5ZnAzMG5MSE5qZTlHMFF0NTIybkJxQlYwNmYvNXJ5ZmkvenVhcjBFa0FpdnY5bE1FdjlzenV1NCtqMVQ5V3FrdFp6ZjE4Y0dEL1B5VXp4bDZ0anptTWZ0L2U4MWRpM24xejUxREg1ZkUwQ1FUcUVnZTlKNWFuazlQVVBJeHZlRStKRzNzU1oremtVQUtjc0hsT2E0c2loOW04M2NrNElWUGRscS9mNUVNcmNwY0ROUzdGWW5yWHZJZVFqbWRmbjMwSysvdzRSUDBCZkc3ejhMZitlZjhjL20vTzcyUG5GNjJXWVZSL0UrT2t5NFViblFUT2pQMm4zejMvdm5EbjJLdW0xMXY3MytPOHByc28vV20vVStDb3NWb2RWUC9ucTB2UDVtTTBsV1k5Ri8rMXh4OUhiOGIrRGZwd3Z6TVBSbjNkODFmOEJ4N0ZYTnJxbWUwdFhuYXZFdWZqM2FZOUcrMTgrMzZ2cnFTYzZ4Y0hXRld2L05lbzhJQWVSVUtRejBublNlV2pzbXA2ZUVFRCt1OXJ5dHVUNFphMWNSUU1yeUFhVTVyaXhLOWtGU3kvaUVrbXVVKzV5MUhUY0t1VXJmaWpWMENDbXQ5NGxUeXc3WjNKU3cvdTRaL2UrYzkzT1Jaa0xySllCRWVQM05acEtzeHFML0RubkZzYlNpazdvUDBmYVBuYU5XbW9QTjZvTVYvWmNBZ2pRS0FrZFBPayt0M0JDaXB2eVN5bC9rZCs3eTkyd3NhVkk2QWFRc0gxQ2E0OHFpWkIwazlmUCtSQ3YzRStkSFlmRlJhSHQ5L3AyS25iUk02NTlUQ0RucXhLbmxjeHVHc2J3U2hyaWkvNS96ZTFLa21kQjZDU0FSWG4rem1TVHJzZWgvKzVQNDJrMGFQbG9heDVCWGM0Yms0K1Q2YW9yK053RUVoeWtBRERicFBMVjZoSkNyblNaOTllU29XRE0veHlLQWxPVURTbk5jV1pTc2c2Uit2cXA1RmpIYW5qOEp6VlgwVml6VCtoMUNjc1BiRkk0K2NXb2R4enh0cDRRTCsrUS9hLzRxU1pGbVF1c2xnRVI0L2MxbWtteU1SZisvejFYUXNWUVJQa3hqOFlkSk5YNG9zbkcrMFA4bmdHQS9OZjZEVHpwUHJVZ0kyZnVJWGpYbkc1UFMvVVYvc1laK2JrVUFLY3NIbE9hNHNpakpCMG45Yko5UEZ6YytkUjZMdHR2blUvZ3h2aGpQSi8zYWY0K09QbkZxSGQ3UFdqNWg5ZXNkbXllVDgrOVFwSm5RZWdrZ0VWNS9zNWtrRjhhaVA2c3RoTGpScnlaOHREU20ycTdNWG5pTjlHY0VFT3ltaHIvWXBQT1UyakV4ZmUrWEZhcEJ2OXMyNi81Q1AzK2ZScXlwbjFNNVNMWDdwRG80SndaNWZFQnBqaXVMa25TUTFNLzErYlRNUDEvMHFzSXUzcTZxejlXR1VhN1dhRHVlbEZuanA0ODJ5SWxUNjZraGhPd013UHE3blBkemtXWkM2eVdBUkhqOXpXYVNSTWVpUDY4bGhQZzlVUHlMQnZ2eTJGUlRYNW4xc1RENkd1blBDU0NJVTZOZmZOSjVTa1ZDaUFQUjFURE1DOVNnZXo3STA3Wmg5emVMeDVyNk9aVy9qTERkSDlXdHNLc1lpQThvelhGbFVaSU9rdnE1UHJmVXJDZjhUa0hiNzNQRnB2aXRXQzF0eDdlSzFmWTc1ZkVNK3JReXJXK0tDYTl1YVBiKy91bnZjMTU3QXNpbTZnT0k2ZSttYnE1SCs1TEJZMmljVTE2WmRVRGJlY3pSM3hGQUVLY21mN1JKNTRmS3dXZnJ5d3JQVkpmQ1VDOVFrMzY5MDdDdnZsRTgxdGpQcFFnZ1pmbUEwaHhYRnVYZ1FWSS9rL3R0NTFiRndkZmphSWFUcGZpdFdGM2FucDhxTnZYdmxyZGY4c1R0TURoV0kraDlPUmlpd3MrbEt2TDdyUFVTUUNLOC9tWXpTZmFPUlgvdjVucnNFT3pIUXhkOTdIZ0pHck92R28xMVpkYmJPUmpRL0RPcm4wNUhBRGtGYXU1SG4zUitxUHlONmQweHFmYk9oVkNqdnI0VmErNVB4U0tBbE9VRFNuTmNXWlJESisrK2o3YXM0cFlEamFQUGhIUWI1VmFzTG0zVG45WWUrcExBSVRrUXVERWJyVkhTdHR4TWxBb2lmbjhtLzd1Rm4wOUZBTmswbXdEUzBzLzVXSkQ2WlpWOStIMDd5K0RScGZFN3NQbjNzdFJ4S090MTBzOFJRTEJKamYxa2s4NFAxWi8velQ5MEE0aHJaek91UnYyeWFuMHJscHY0V0hNL2h5S0FBTXVnazVldkdQZ2tQWFN6N3RzZEhEb21EWWphdnZjdjk0dkpZdHBtcHRwNzdGRVgvYTQ0aUF3VmhOdmZ2K29tbUE5Qis5VWVoNFlJSXo3MitHcjZKUE1Dc1JCcTZDZWRkSjVTa1Nkajdac1BjcXZUdU05MlFqb0JCRmdlbmJEZE1Ma1JjTlBrcHYyZWF0L2tiamRXL2htWGwvRkpmL1FyT3FrOHRqQkdOenI3OXEzZEwvK2NmNTdRZ2FQb2Q4anZMZDkyNUZDKzczZlBEWGozUGVWbFR1cjN6L3VyOHZ1dWZhMWN1M1JmS3grN0NCMDRuaHI1S2lhZEh5b0hvbWUvL0oxdUFEazBIMlQ5QllVUFhyd1ViZkJyTHdJSUFBQUFGa2ROZkRXVHpnOVZaRDdJN2JBYkY2aGgzNWlRUHNlcklBUVFBQUFBTElvYStPb21uUitxei8vVjMzY0RpR3ZmclZqMzJ3WitqbGRCSHI3MERBRUVBQUFBeTZER3ZkcEo1NGRxNi90QkhvUmR1a0JOKzdWT0F6KzdxeUQrTHBQTytLK0YzUUlBQUFEbVJVMTc5WlBPOTFYa1ZxeWJZZGN1VU9NKzI2c2dCQkFBQUFETW5wcjFDNVBPM2RESEd2MmFLL0l0NmRFSjZXcmNaenNYaEFBQ0FBQ0EyVk9qdmpIcC9PcU4veE50OEdzdFg2bTU4cGN2ZDhPSHl3SGtjdGpGQzlTOHI1K0lOYWZ2QlNHQUFBQUFZTmJVcEc5TU92ZUU3bGlUWDJ2NVNzM1dvM2hkdnBxek0zeVltdmNiYlNQdmIwZVBOZnMxRmdFRUFBQUFzNlVtZldQUytiLzl6Lzg3MnVUWFd2NDJkTjh1MXQwSDFSM1Z6dThDYWFsNXY2UmFmenY2azllZWpUYjh0UlVCQkFBQUFMT2tKbjNXazg0LzkveXIyOEhEdFhQaWVZd2ErRHR0TS8vR3R6OGViZmhyS3dJSUFBQUFaa2VOK213bm5lK1o3N0h6dXo5MlVRTi90ZFBNbi8veGg1K05OdjAxRlFFRUFBQUFzNk5tZlphVHp2Zk05emg0eTlVdWF1TFhrOUYvK2Vxbm8wMS9UZldqcjMyNEcwRDJ6bk1CQUFBQUpxZG1mWmFUem5mTjl3aTcxWnVhK050dFF6K0gyN0Rhc2JyQ0xnQUFBQUIxVXNNK3kwbm4va2IyN3JoRDNRaTdkUlExOHJPNkRhczcxckFMQUFBQVFIM1VzTTl1MHJuSHQvWGxncTVlOHozMlVUTy92ZzJyOXFkaHRlTjBoZUVEQUFBQWRWSERQcnRKNXg1ZjVKYXJvK1o3N0tKbWZuMGIxb01YTDBVYi8xcXFIYWNyREI4QUFBQ29pNXIyV1UwNjkzeVA3bmhESFQzZll4YzE4OWZicHI3Mkx5VnN4K2tLd3djQUFBRHFvY1o5VnBQT1M4NzMyS2ZiMlAvaEI1K0pOdjgxVkhlY1llZ0FBQUJBSGRTNHoyYlMrWTc1SG1lcVFlZDc3S0tHL243YjJOZjhPTjUyaks0d2RBQUFBR0I2YnR4VnM1aDB2bU8reDMzVjRQTTlkbEZEZjZ0dDdCKys5RXkwK1orNi9JU3Vkb3l1TUhRQUFBQmdXbTdjVmJPWWRMNWp2c2Z0c0N1alVVTy9uZ2ZpYnh1UEJZQ3A2N2ZmdTl3TklQZkQwQUVBQUlCcHFZR3ZmdEs1cjhaRTVudjRpazN4K1I0eGF1Z3ZkNXI3YUFDWXVnZ2dBQUFBcUk0YStKdWRocjdLU2VkLzhiZi9PT2w4ajEzVTFEOXRHL3pmdjM0bEdnS21MQUlJQUFBQXFxSUcvbHFub2E5eTB2a1h2L0w5eWVkNzdPS212bTN3YS94Q1FnSUlBQUFBcXFFRy9yS3E2a25uZi9iWHIyMEhEOWZvOHoxMlVWTy84WVdFYnZnUDFlUHZmdXI4Rnk5LzhtQjVYc21oK3NrM1A5b05HSWVLQUFJQUFJQnBxSW12ZXRKNWJmTTlkbEZUdjM0UzFneUtBQUlBQUlCcHFKRy8wMm5zcTVwMFh1dDhqeGcxOWRlMm12eGF5M05WcXJseUJBQUFnQk9pUnI3YVNlYzF6L2VJVVZQZkRTQnU4ajBuNUZEZFVmbkt5YUh5WTM2OS9yMFZoZ0lBQUFEVVI0MTh0WlBPZDh6M3VCV0dEZ0FBQUdCTzFNeFhPZWw4ejN5UDYySG9BQUFBQU9aRXpYeVZrODUzelBmd09LdWI3d0VBQUFBZ2tScjY2aWFkZXd5UitSNytSdllxNTNzQUFBQUFTS0NHdnJwSjV4NURkMHlobU84QkFBQUF6Sm1hK3FvbW5YdStoOGZRSFpPSytSNEFBQURBM0ttcHIyclN1ZWVjTU44REFBQUFXQ0ExOVJ1VHpsMytqbzFZTUJpam1POEJBQUFBTEpnYSs0MUo1eTRIQU0rOUdQc3FDUE05QUFBQWdJVlRnKys1SHc0aDYxdXcybnIyeTk4WjVTbFllK1o3OE8zZEFBQUF3QktwMmZldFdINEsxcGxxSXd6NHkvOUtYUTNaTTkvamNoZ2FBQUFBZ0tWUzQrOGdja3UxY1VYRUlXSG9MeVRjTWQvRFYyT1k3d0VBQUFDY0VvVUFQeG5yZmdnRnF4cnlXOUUvOS95cjNkRFIxczJ3ZVFBQUFBQ25TS0hBVjBQV0llSFlFT0pidWE3ODVjdmQwT0ZpdmdjQUFBQXdWLy8wZHgrNnBycXV1dFdwbXlyL2VmYmNDb1dER3lFa0hCVkN2SXdudHJmckNjVjhEd0FBQUdCT0hDcEN3TGl2T2srb3A2bzdxdVJ2RlZkSXVLcmFDQ0U1RTlQLy9HLytnZmtlQUFBQXdKd3BRRGg0T0VqRVFrWnFuYWx1aEZYdXBiRGdFTElPRUo2WUhnc2IyOFY4RHdBQUFHREdGQmd1cVc2SEFIR2hmdnoxajV6LzlGc2ZPMy80MGpQbnYzajVrNnQ2OE9LbDFaL0ZmajZVZzhqQmVSZ0tEcjRkYXgway9PV0JzZERoWXI0SEFBQUFNSE1LQ1ZkVkQwSm9XTmRQdnZuUjg4ZmYvZFQ1SDM3d21mUHpmLzc4M25yeTJyT3JRUEtqcjMxNFl4Mmhib2RON2FRQWNic1RLS0x6UVpqdkFRQUFBTXljd29IRGgrZHZyQU9EcjNiODludVhvMEhqVVAzeGg1OWRYUjNwcmkrVTU1THNuSnVoRU9IdkNsbC9ZYUd2Y25URHg2NzVIbUZ4QUFBQUFMVlRJTGdRUGh3ZVlzRWl0M3pWeEZkUXV1dFcrU3JMdmhCeXJSc3d2dmlWNzYvQ3g0NzVIa2x6VEFBQUFBQlVRRUZnSTN6NDFxbStWejMybFcvTGFyY1JhdTlWQ3dVTFA4VnFGVEo4RmNTVDB0di9IOHJ6UGE2R0h3Y0FBQUJRTzRVQVR6aGZ6L2x3K1BqOTYxZWlBV0tJaW9TUW5VK3JVcmp3dDZWdmg0NjJQTitEUit3Q0FBQUFjNklBc1BHMHF4SlhQcmJyalc5L3ZCdEFYRHNuaml0a3JLK0NkSXI1SGdBQUFNRGN1UEh2Qm9HaDVud2NLazlPOStUMnpyYnZoeUZkb0xDeE1SZEV4WHdQQUFBQVlJN1UrSysvWk5DVHhHTmhvVlQ1U2t1NzdWQTd2N3REb2NOUHhHSytCd0FBQURCWGF2ZzNybjZNY2V2VmRtMTljZUhPMjZvVVBLNnJtTzhCQUFBQXpKVWEvcHR0OHovMjFZKzJJbGRCQ0JrQUFBREFFcW5aWHovNXl0OXdIZ3NJWTlUV1hCRG1kd0FBQUFCTDFHbjZWMThVR0FzSFk5VERsNTdwQnBEYllYZ0FBQUFBbGtLTi9yVzI2ZmNWaUZnd0dLdWV2UFpzTjREc2ZCb1dBQUFBZ0psU28zK2piZm85RVR3V0RNWXFYMzFweCtJS1F3UUFBQUN3RkdyMGI3VU4vMWpmL2JHdjJyRzR3aEFCQUFBQUxJVWFmUUlJQUFBQWdIR28wU2VBQUFBQUFCaUhHdjExQVBGVHFHS2hZTXhxeCtJS1F3UUFBQUN3RkdyMDEwL0Jtbm9TK3RhWEVaNkZJUUlBQUFCWUNqWDZWOXVtLzBkZiszQTBHSXhWdjN6MTA5MEF3bU40QVFBQWdDVlNzLyswYmZ4Ly8vcVZhRGdZbzk3NDlzZTdBZVJXR0I0QUFBQ0FKVkd6ZjdkdC9LZWFCL0xISDM1MmRRV21IWWZxYWhnZUFBQUFnQ1ZSczcvK01rS0hBSWVCV0Vnb1dWdTNYekgvQXdBQUFGZ3lOZjNyMjdER2ZoeXZBOCtQdi82UmJnRGg5aXNBQUFCZ3lkejB0d0hBVjBIKzhJUFBSTU5DaVhMZ2FiZXRjaEM2RklZRkFBQUFZSW5jOUt2T1FnZ1k3Wkc4bnZUZWJqTVVWejhBQUFDQVU2RG0vM28zRER4NDhWSTBOQXhWdnNxeU5mSDhRUmdLQUFBQWdGT2dFSENuRXdpS2hSQ0hqNTk4ODZQZDhPRmJyM2p5RlFBQUFIQnFGQVFlZElMQktvUU0rV1FzMzNhMWRlWERkU05zSGdBQUFNQXBVUmp3ZkpDTkVPS3JGYi85M3VWb29NaXByUW5uYlJFK0FBQUFnRk9tVU9BUWNyOFRFbGJscXlHNTM1YnVxeWYrbm8rdFIrMjJSZmdBQUFBQTBGQkFXRCtldDF1K0l1S3JHYjRxRXJzOXl5SEZvY09CSlhLN2xjdFAzR0xPQndBQUFJQk5EZ3FxQzFkRGVwWW5tenZVOEYwZkFBQUFBSFpUYUxpbXVxdUtCWXREUmZBQUFBQUFrTThoUW5WRDVVZjJia3hXNzVRRGg2K2FPSFJjQzRzQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZzFZYys5QytDeVlGUXNucGp4Z0FBQUFCSlJVNUVya0pnZ2c9PSc7XG4gICAgICAgICAgICB2YXIgaW1hZ2VIZWlnaHQgPSB3aWR0aCAqIDMgLyA4O1xuICAgICAgICAgICAgdmFyIG9sZEFudGlhbGlhcyA9IHRoaXMuZ2V0QW50aWFsaWFzaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnNldEFudGlhbGlhc2luZyh0cnVlKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIDgwMCwgMzAwLCB4LCB5IC0gaW1hZ2VIZWlnaHQgLSAyMCwgd2lkdGgsIGltYWdlSGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIGxvYWRpbmcgYm94XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCh4LCB5LCB3aWR0aCwgMjApO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gd2lkdGggKiAobG9hZGVkIC8gdG90YWwpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICB2YXIgbWFyZ2luID0gNTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHByb2dyZXNzIC0gbWFyZ2luICogMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAyMCAtIG1hcmdpbiAqIDI7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoeCArIG1hcmdpbiwgeSArIG1hcmdpbiwgd2lkdGggPiAwID8gd2lkdGggOiAwLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zZXRBbnRpYWxpYXNpbmcob2xkQW50aWFsaWFzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGxvYWRpbmcgc2NyZWVuIGRyYXcgZnVuY3Rpb24gaWYgeW91IHdhbnQgdG8gY3VzdG9taXplIHRoZSBkcmF3XG4gICAgICAgICAqIEBtZXRob2Qgc2V0TG9hZGluZ0RyYXdGdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0gZmNuIHtjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgbG9hZGVkOiBudW1iZXIsIHRvdGFsOiBudW1iZXIpID0+IHZvaWR9XG4gICAgICAgICAqIENhbGxiYWNrIHRvIGRyYXcgdGhlIGxvYWRpbmcgc2NyZWVuIHdoaWNoIGlzIHBhc3NlZCBhIHJlbmRlcmluZyBjb250ZXh0LCB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxvYWRlZCwgYW5kIHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgdG8gbG9hZC5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUuc2V0TG9hZGluZ0RyYXdGdW5jdGlvbiA9IGZ1bmN0aW9uIChmY24pIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ0RyYXcgPSBmY247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbm90aGVyIG9wdGlvbiBhdmFpbGFibGUgdG8geW91IHRvIGxvYWQgcmVzb3VyY2VzIGludG8gdGhlIGdhbWUuXG4gICAgICAgICAqIEltbWVkaWF0ZWx5IGFmdGVyIGNhbGxpbmcgdGhpcyB0aGUgZ2FtZSB3aWxsIHBhdXNlIGFuZCB0aGUgbG9hZGluZyBzY3JlZW5cbiAgICAgICAgICogd2lsbCBhcHBlYXIuXG4gICAgICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAgICAgKiBAcGFyYW0gbG9hZGVyIHtJTG9hZGFibGV9IFNvbWUgbG9hZGFibGUgc3VjaCBhcyBhIExvYWRlciBjb2xsZWN0aW9uLCBTb3VuZCwgb3IgVGV4dHVyZS5cbiAgICAgICAgICovXG4gICAgICAgIEVuZ2luZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBuZXcgZXguUHJvbWlzZSgpO1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbG9hZGVyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb2dyZXNzID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMudG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZygnTG9hZGluZyAnICsgKDEwMCAqIF90aGlzLnByb2dyZXNzIC8gX3RoaXMudG90YWwpLnRvRml4ZWQoMCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvYWRlci5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVuZ2luZTtcbiAgICB9KShleC5DbGFzcyk7XG4gICAgZXguRW5naW5lID0gRW5naW5lO1xuICAgIDtcbn0pKGV4IHx8IChleCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNhbGlidXItMC4yLjUuanMubWFwXG47XG4vLyBDb25jYXRlbmF0ZWQgb250byBleGNhbGlidXIgYWZ0ZXIgYnVpbGRcbi8vIEV4cG9ydHMgdGhlIGV4Y2FsaWJ1ciBtb2R1bGUgc28gaXQgY2FuIGJlIHVzZWQgd2l0aCBicm93c2VyaWZ5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL2lzc3Vlcy8zMTJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge21vZHVsZS5leHBvcnRzID0gZXg7fSIsIi8qanNsaW50IG5vZGU6dHJ1ZSxub21lbjp0cnVlKi9cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhclxuICAgICAgICBwYXJ0cyA9IG9wdHMucGFydHMsXG4gICAgICAgIGV4ID0gb3B0cy5leCxcbiAgICAgICAgZ2FtZSA9IG9wdHMuZ2FtZSxcbiAgICAgICAgY29sb3IgPSBvcHRzLmNvbG9yLFxuICAgICAgICB3ID0gZ2FtZS53aWR0aCxcbiAgICAgICAgaCA9IGdhbWUuaGVpZ2h0LFxuICAgICAgICBzaXplID0gb3B0cy5zaXplLFxuICAgICAgICBmaW5kWCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2l6ZSAqIF8ucmFuZG9tKDIsIE1hdGguZmxvb3IodyAvIHNpemUpIC0gMik7XG4gICAgICAgICAgICByZXR1cm4gXy5wbHVjayhwYXJ0cywgJ3gnKS5pbmRleE9mKHgpID09PSAtMSA/IHggOiBmaW5kWCgpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kWSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB5ID0gc2l6ZSAqIF8ucmFuZG9tKDIsIE1hdGguZmxvb3IoaCAvIHNpemUpIC0gMik7XG4gICAgICAgICAgICByZXR1cm4gXy5wbHVjayhwYXJ0cywgJ3knKS5pbmRleE9mKHkpID09PSAtMSA/IHkgOiBmaW5kWSgpO1xuICAgICAgICB9LFxuICAgICAgICBhY3RvciA9IG5ldyBleC5BY3RvcihmaW5kWCgpLCBmaW5kWSgpLCBzaXplLCBzaXplLCBjb2xvcik7XG4gICAgdGhpcy5lYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFjdG9yLmtpbGwoKTtcbiAgICB9O1xuICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcbiAgICBnYW1lLmFkZChhY3Rvcik7XG59O1xuIiwiLypqc2xpbnQgbm9kZTp0cnVlLG5vbWVuOnRydWUqL1xuLypnbG9iYWwgd2luZG93Ki9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNuYWtlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBoYW5kbGVPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgeSA9IGV2ZW50LmJldGEsXG4gICAgICAgICAgICB4ID0gZXZlbnQuZ2FtbWEsXG4gICAgICAgICAgICBtYXhYID0gMzAsXG4gICAgICAgICAgICBtYXhZID0gMjA7XG4gICAgICAgIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgICAgc25ha2UuZG93bigpO1xuICAgICAgICB9IGVsc2UgaWYgKHkgPCAtbWF4WSkge1xuICAgICAgICAgICAgc25ha2UudXAoKTtcbiAgICAgICAgfSBlbHNlIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgICAgc25ha2UucmlnaHQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh4IDwgLW1heFgpIHtcbiAgICAgICAgICAgIHNuYWtlLmxlZnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZW9yaWVudGF0aW9uJywgaGFuZGxlT3JpZW50YXRpb24pO1xufTtcbiIsIi8qanNsaW50IG5vZGU6dHJ1ZSovXG4vKmdsb2JhbCB3aW5kb3cqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBscyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UsXG4gICAgICAgIHNjb3JlID0gMCxcbiAgICAgICAgcmVjb3JkID0gbHMuZ2V0SXRlbSgncmVjb3JkJykgfHwgMDtcbiAgICB0aGlzLmluYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NvcmUgKz0gMTtcbiAgICAgICAgaWYgKHNjb3JlID4gcmVjb3JkKSB7XG4gICAgICAgICAgICByZWNvcmQgPSBzY29yZTtcbiAgICAgICAgICAgIGxzLnNldEl0ZW0oJ3JlY29yZCcsIHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSAnU2NvcmU6ICcgKyBzY29yZSArICcgUmVjb3JkOiAnICsgcmVjb3JkO1xuICAgIH07XG4gICAgZG9jdW1lbnQudGl0bGUgPSAnU2NvcmU6ICcgKyBzY29yZSArICcgUmVjb3JkOiAnICsgcmVjb3JkO1xufTsiLCIvKmpzbGludCBub2RlOnRydWUsbm9tZW46dHJ1ZSovXG52YXIgRm9vZCA9IHJlcXVpcmUoJy4vZm9vZCcpLFxuICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksXG4gICAgU2NvcmUgPSByZXF1aXJlKCcuL3Njb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICB2ID0ge30sXG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZSxcbiAgICAgICAgc3BlZWQgPSAxNTAsXG4gICAgICAgIHNjb3JlID0gbmV3IFNjb3JlKCksXG4gICAgICAgIGdhbWUgPSBvcHRzLmdhbWUsXG4gICAgICAgIHNpemUgPSBNYXRoLmZsb29yKE1hdGgubWluKGdhbWUud2lkdGgsIGdhbWUuaGVpZ2h0KSAvIDIyKSxcbiAgICAgICAgZXggPSBvcHRzLmV4LFxuICAgICAgICBjb2xvciA9IG9wdHMuY29sb3IsXG4gICAgICAgIHBhcnQgPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IpIHtcbiAgICAgICAgICAgIHZhciBhY3RvciA9IG5ldyBleC5BY3Rvcih4LCB5LCBzaXplLCBzaXplLCBjb2xvcik7XG4gICAgICAgICAgICBnYW1lLmFkZChhY3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gYWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0UGxhY2VSYW5kWCA9IF8ucmFuZG9tKDIsIE1hdGguZmxvb3IoZ2FtZS53aWR0aCAvIHNpemUpIC0gMiksXG4gICAgICAgIHN0YXJ0UGxhY2VSYW5kWSA9IF8ucmFuZG9tKDIsIE1hdGguZmxvb3IoZ2FtZS5oZWlnaHQgLyBzaXplKSAtIDIpLFxuICAgICAgICBwYXJ0cyA9IFtcbiAgICAgICAgICAgIHBhcnQoKHN0YXJ0UGxhY2VSYW5kWCArIDEpICogc2l6ZSwgc3RhcnRQbGFjZVJhbmRZICogc2l6ZSwgY29sb3IuYm9keSksXG4gICAgICAgICAgICBwYXJ0KHN0YXJ0UGxhY2VSYW5kWCAqIHNpemUsIHN0YXJ0UGxhY2VSYW5kWSAqIHNpemUsIGNvbG9yLmJvZHkpXG4gICAgICAgIF0sXG4gICAgICAgIGZvb2QgPSBuZXcgRm9vZCh7XG4gICAgICAgICAgICBleDogZXgsXG4gICAgICAgICAgICBnYW1lOiBnYW1lLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yLmZvb2QsXG4gICAgICAgICAgICBwYXJ0czogcGFydHMsXG4gICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgIH0pLFxuICAgICAgICBjdXRUYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBwYXJ0cy5wb3AoKSxcbiAgICAgICAgICAgICAgICBwcmVsYXN0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsYXN0Lm1vdmVUbyhcbiAgICAgICAgICAgICAgICBwcmVsYXN0LngsXG4gICAgICAgICAgICAgICAgcHJlbGFzdC55LFxuICAgICAgICAgICAgICAgIDIgKiBzcGVlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICB9LFxuICAgICAgICBhZGROZWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdFBhcnQgPSBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICB4ID0gZmlyc3RQYXJ0LngsXG4gICAgICAgICAgICAgICAgeSA9ICBmaXJzdFBhcnQueSxcbiAgICAgICAgICAgICAgICBuZXdQYXJ0ID0gcGFydCh4LCB5LCBjb2xvci5ib2R5KTtcbiAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQobmV3UGFydCk7XG4gICAgICAgICAgICBuZXdQYXJ0Lm1vdmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgdi54ICogc2l6ZSxcbiAgICAgICAgICAgICAgICB5ICsgdi55ICogc2l6ZSxcbiAgICAgICAgICAgICAgICBzcGVlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5ld1BhcnQub24oJ2V4aXR2aWV3cG9ydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uTG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3UGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgaGlUYWlsID0gZnVuY3Rpb24gKGFjdG9yKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDI7IGkgPCBwYXJ0cy5sZW5ndGggLSAyOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gJiYgYWN0b3Iud2l0aGluKHBhcnRzW2ldLCBzaXplIC8gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdGVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWRkTmVjaygpLmNhbGxNZXRob2QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndpdGhpbihmb29kLmFjdG9yLCBzaXplIC8gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgKz0gNTA7XG4gICAgICAgICAgICAgICAgICAgIGZvb2QuZWF0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlLmluYygpO1xuICAgICAgICAgICAgICAgICAgICBmb29kID0gbmV3IEZvb2Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXg6IGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZTogZ2FtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvci5mb29kLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IHBhcnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGlUYWlsKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25Mb3NlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0VGFpbCgpLmNhbGxNZXRob2QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5raWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIHRoaXMucmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHYueCA9IDE7XG4gICAgICAgIHYueSA9IDA7XG4gICAgfTtcbiAgICB0aGlzLmxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHYueCA9IC0xO1xuICAgICAgICB2LnkgPSAwO1xuICAgIH07XG4gICAgdGhpcy51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdi54ID0gMDtcbiAgICAgICAgdi55ID0gLTE7XG4gICAgfTtcbiAgICB0aGlzLmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHYueCA9IDA7XG4gICAgICAgIHYueSA9IDE7XG4gICAgfTtcbiAgICB0aGlzLnJ1biA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdi54ID0gb2JqLnggfHwgMDtcbiAgICAgICAgdi55ID0gb2JqLnkgfHwgMDtcbiAgICAgICAgc3RlcCgpO1xuICAgIH07XG59O1xuIiwiLyohXG4gICogZG9tcmVhZHkgKGMpIER1c3RpbiBEaWF6IDIwMTQgLSBMaWNlbnNlIE1JVFxuICAqL1xuIWZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JykgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2UgdGhpc1tuYW1lXSA9IGRlZmluaXRpb24oKVxuXG59KCdkb21yZWFkeScsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZm5zID0gW10sIGxpc3RlbmVyXG4gICAgLCBkb2MgPSBkb2N1bWVudFxuICAgICwgaGFjayA9IGRvYy5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGxcbiAgICAsIGRvbUNvbnRlbnRMb2FkZWQgPSAnRE9NQ29udGVudExvYWRlZCdcbiAgICAsIGxvYWRlZCA9IChoYWNrID8gL15sb2FkZWR8XmMvIDogL15sb2FkZWR8Xml8XmMvKS50ZXN0KGRvYy5yZWFkeVN0YXRlKVxuXG5cbiAgaWYgKCFsb2FkZWQpXG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyKVxuICAgIGxvYWRlZCA9IDFcbiAgICB3aGlsZSAobGlzdGVuZXIgPSBmbnMuc2hpZnQoKSkgbGlzdGVuZXIoKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICBsb2FkZWQgPyBmbigpIDogZm5zLnB1c2goZm4pXG4gIH1cblxufSk7XG4iLCIvKiFcbiogc2NyZWVuZnVsbFxuKiB2Mi4wLjAgLSAyMDE0LTEyLTIyXG4qIChjKSBTaW5kcmUgU29yaHVzOyBNSVQgTGljZW5zZVxuKi9cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaXNDb21tb25qcyA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzO1xuXHR2YXIga2V5Ym9hcmRBbGxvd2VkID0gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdBTExPV19LRVlCT0FSRF9JTlBVVCcgaW4gRWxlbWVudDtcblxuXHR2YXIgZm4gPSAoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWw7XG5cdFx0dmFyIHZhbExlbmd0aDtcblxuXHRcdHZhciBmbk1hcCA9IFtcblx0XHRcdFtcblx0XHRcdFx0J3JlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0J2V4aXRGdWxsc2NyZWVuJyxcblx0XHRcdFx0J2Z1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J2Z1bGxzY3JlZW5FbmFibGVkJyxcblx0XHRcdFx0J2Z1bGxzY3JlZW5jaGFuZ2UnLFxuXHRcdFx0XHQnZnVsbHNjcmVlbmVycm9yJ1xuXHRcdFx0XSxcblx0XHRcdC8vIG5ldyBXZWJLaXRcblx0XHRcdFtcblx0XHRcdFx0J3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdEV4aXRGdWxsc2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdEZ1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J3dlYmtpdEZ1bGxzY3JlZW5FbmFibGVkJyxcblx0XHRcdFx0J3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLFxuXHRcdFx0XHQnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ1xuXG5cdFx0XHRdLFxuXHRcdFx0Ly8gb2xkIFdlYktpdCAoU2FmYXJpIDUuMSlcblx0XHRcdFtcblx0XHRcdFx0J3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuXHRcdFx0XHQnd2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuXHRcdFx0XHQnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsXG5cdFx0XHRcdCd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXG5cblx0XHRcdF0sXG5cdFx0XHRbXG5cdFx0XHRcdCdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXG5cdFx0XHRcdCdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcblx0XHRcdFx0J21vekZ1bGxTY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J21vekZ1bGxTY3JlZW5FbmFibGVkJyxcblx0XHRcdFx0J21vemZ1bGxzY3JlZW5jaGFuZ2UnLFxuXHRcdFx0XHQnbW96ZnVsbHNjcmVlbmVycm9yJ1xuXHRcdFx0XSxcblx0XHRcdFtcblx0XHRcdFx0J21zUmVxdWVzdEZ1bGxzY3JlZW4nLFxuXHRcdFx0XHQnbXNFeGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdCdtc0Z1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J21zRnVsbHNjcmVlbkVuYWJsZWQnLFxuXHRcdFx0XHQnTVNGdWxsc2NyZWVuQ2hhbmdlJyxcblx0XHRcdFx0J01TRnVsbHNjcmVlbkVycm9yJ1xuXHRcdFx0XVxuXHRcdF07XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIGwgPSBmbk1hcC5sZW5ndGg7XG5cdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0Zm9yICg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhbCA9IGZuTWFwW2ldO1xuXHRcdFx0aWYgKHZhbCAmJiB2YWxbMV0gaW4gZG9jdW1lbnQpIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDsgaSA8IHZhbExlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cmV0W2ZuTWFwWzBdW2ldXSA9IHZhbFtpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKTtcblxuXHR2YXIgc2NyZWVuZnVsbCA9IHtcblx0XHRyZXF1ZXN0OiBmdW5jdGlvbiAoZWxlbSkge1xuXHRcdFx0dmFyIHJlcXVlc3QgPSBmbi5yZXF1ZXN0RnVsbHNjcmVlbjtcblxuXHRcdFx0ZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHQvLyBXb3JrIGFyb3VuZCBTYWZhcmkgNS4xIGJ1ZzogcmVwb3J0cyBzdXBwb3J0IGZvclxuXHRcdFx0Ly8ga2V5Ym9hcmQgaW4gZnVsbHNjcmVlbiBldmVuIHRob3VnaCBpdCBkb2Vzbid0LlxuXHRcdFx0Ly8gQnJvd3NlciBzbmlmZmluZywgc2luY2UgdGhlIGFsdGVybmF0aXZlIHdpdGhcblx0XHRcdC8vIHNldFRpbWVvdXQgaXMgZXZlbiB3b3JzZS5cblx0XHRcdGlmICgvNVxcLjFbXFwuXFxkXSogU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdFx0XHRcdGVsZW1bcmVxdWVzdF0oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bcmVxdWVzdF0oa2V5Ym9hcmRBbGxvd2VkICYmIEVsZW1lbnQuQUxMT1dfS0VZQk9BUkRfSU5QVVQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXhpdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0ZG9jdW1lbnRbZm4uZXhpdEZ1bGxzY3JlZW5dKCk7XG5cdFx0fSxcblx0XHR0b2dnbGU6IGZ1bmN0aW9uIChlbGVtKSB7XG5cdFx0XHRpZiAodGhpcy5pc0Z1bGxzY3JlZW4pIHtcblx0XHRcdFx0dGhpcy5leGl0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJlcXVlc3QoZWxlbSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyYXc6IGZuXG5cdH07XG5cblx0aWYgKCFmbikge1xuXHRcdGlmIChpc0NvbW1vbmpzKSB7XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2NyZWVuZnVsbCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjcmVlbmZ1bGwsIHtcblx0XHRpc0Z1bGxzY3JlZW46IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gISFkb2N1bWVudFtmbi5mdWxsc2NyZWVuRWxlbWVudF07XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbGVtZW50OiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudFtmbi5mdWxsc2NyZWVuRWxlbWVudF07XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbmFibGVkOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIENvZXJjZSB0byBib29sZWFuIGluIGNhc2Ugb2Ygb2xkIFdlYktpdFxuXHRcdFx0XHRyZXR1cm4gISFkb2N1bWVudFtmbi5mdWxsc2NyZWVuRW5hYmxlZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoaXNDb21tb25qcykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gc2NyZWVuZnVsbDtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuc2NyZWVuZnVsbCA9IHNjcmVlbmZ1bGw7XG5cdH1cbn0pKCk7XG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjcuMFxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIGNvbmNhdCAgICAgICAgICAgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZDtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuNy4wJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUNhbGxiYWNrID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIGNyZWF0ZUNhbGxiYWNrKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVzKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuICAvLyBzcGFyc2UgYXJyYXktbGlrZXMgYXMgaWYgdGhleSB3ZXJlIGRlbnNlLlxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09ICtsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gW107XG4gICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgIGN1cnJlbnRLZXk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIHZhciByZWR1Y2VFcnJvciA9ICdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJztcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaXRlcmF0ZWUgPSBjcmVhdGVDYWxsYmFjayhpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gMCwgY3VycmVudEtleTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIGlmICghbGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXgrK10gOiBpbmRleCsrXTtcbiAgICB9XG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICB2YXIga2V5cyA9IG9iai5sZW5ndGggIT09ICsgb2JqLmxlbmd0aCAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgaW5kZXggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgY3VycmVudEtleTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIGlmICghaW5kZXgpIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1stLWluZGV4XSA6IC0taW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBwcmVkaWNhdGUgPSBfLml0ZXJhdGVlKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5zb21lKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoXy5pdGVyYXRlZShwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBwcmVkaWNhdGUgPSBfLml0ZXJhdGVlKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIGluZGV4LCBjdXJyZW50S2V5O1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICBpbmRleCwgY3VycmVudEtleTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgdGFyZ2V0KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXMoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXMoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gb2JqICYmIG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmIChvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gbG93ICsgaGlnaCA+Pj4gMTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIGlmIChuIDwgMCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gIC8vIGBfLm1hcGAuXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBNYXRoLm1heChhcnJheS5sZW5ndGggLSBuLCAwKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKipcbiAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBvdXRwdXQpIHtcbiAgICBpZiAoc2hhbGxvdyAmJiBfLmV2ZXJ5KGlucHV0LCBfLmlzQXJyYXkpKSB7XG4gICAgICByZXR1cm4gY29uY2F0LmFwcGx5KG91dHB1dCwgaW5wdXQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaW5wdXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKCFfLmlzQXJyYXkodmFsdWUpICYmICFfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICBpZiAoIXN0cmljdCkgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzaGFsbG93KSB7XG4gICAgICAgIHB1c2guYXBwbHkob3V0cHV0LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QsIG91dHB1dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSwgW10pO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gdmFsdWUpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpO1xuICAgICAgICBpZiAoXy5pbmRleE9mKHNlZW4sIGNvbXB1dGVkKSA8IDApIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfLmluZGV4T2YocmVzdWx0LCB2YWx1ZSkgPCAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCBbXSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgdHJ1ZSwgdHJ1ZSwgW10pO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICB2YXIgbGVuZ3RoID0gXy5tYXgoYXJndW1lbnRzLCAnbGVuZ3RoJykubGVuZ3RoO1xuICAgIHZhciByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzW2ldID0gXy5wbHVjayhhcmd1bWVudHMsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XG4gICAgICAgIGkgPSBpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBpc1NvcnRlZCkgOiBpc1NvcnRlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb20pIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpZHggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBmcm9tID09ICdudW1iZXInKSB7XG4gICAgICBpZHggPSBmcm9tIDwgMCA/IGlkeCArIGZyb20gKyAxIDogTWF0aC5taW4oaWR4LCBmcm9tICsgMSk7XG4gICAgfVxuICAgIHdoaWxlICgtLWlkeCA+PSAwKSBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXVzYWJsZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgcHJvdG90eXBlIHNldHRpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIHZhciBhcmdzLCBib3VuZDtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgQ3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgIHZhciBzZWxmID0gbmV3IEN0b3I7XG4gICAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3Muc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmdzW2ldID09PSBfKSBhcmdzW2ldID0gYXJndW1lbnRzW3Bvc2l0aW9uKytdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPiAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBhZnRlciBiZWluZyBjYWxsZWQgTiB0aW1lcy5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYmVmb3JlIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwga2V5O1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBjcmVhdGVDYWxsYmFjayhpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShbXSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgIG9iaiA9IG5ldyBPYmplY3Qob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkgaW4gb2JqKSByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChjb25jYXQuYXBwbHkoW10sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdm9pZCAwKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cbiAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHNcbiAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoXG4gICAgICBhQ3RvciAhPT0gYkN0b3IgJiZcbiAgICAgIC8vIEhhbmRsZSBPYmplY3QuY3JlYXRlKHgpIGNhc2VzXG4gICAgICAnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiICYmXG4gICAgICAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcbiAgICB2YXIgc2l6ZSwgcmVzdWx0O1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgc2l6ZSA9IGEubGVuZ3RoO1xuICAgICAgcmVzdWx0ID0gc2l6ZSA9PT0gYi5sZW5ndGg7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBlcShhW3NpemVdLCBiW3NpemVdLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICByZXN1bHQgPSBfLmtleXMoYikubGVuZ3RoID09PSBzaXplO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgICAga2V5ID0ga2V5c1tzaXplXTtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYiwgW10sIFtdKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBhbiBJRSAxMSBidWcuXG4gIGlmICh0eXBlb2YgLy4vICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgdmFyIHBhaXJzID0gXy5wYWlycyhhdHRycyksIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgICAgb2JqID0gbmV3IE9iamVjdChvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldLCBrZXkgPSBwYWlyWzBdO1xuICAgICAgICBpZiAocGFpclsxXSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZFxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IG9iamVjdFtwcm9wZXJ0eV0oKSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiJdfQ==
